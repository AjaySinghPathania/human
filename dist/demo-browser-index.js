// dist/human.esm.js
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __markAsModule = (target) => __defProp(target, "__esModule", {value: true});
var __commonJS = (callback, module) => () => {
  if (!module) {
    module = {exports: {}};
    callback(module.exports, module);
  }
  return module.exports;
};
var __export = (target, all) => {
  __markAsModule(target);
  for (var name in all)
    __defProp(target, name, {get: all[name], enumerable: true});
};
var __exportStar = (target, module, desc) => {
  __markAsModule(target);
  if (typeof module === "object" || typeof module === "function") {
    for (let key of __getOwnPropNames(module))
      if (!__hasOwnProp.call(target, key) && key !== "default")
        __defProp(target, key, {get: () => module[key], enumerable: !(desc = __getOwnPropDesc(module, key)) || desc.enumerable});
  }
  return target;
};
var __toModule = (module) => {
  if (module && module.__esModule)
    return module;
  return __exportStar(__defProp(__create(__getProtoOf(module)), "default", {value: module, enumerable: true}), module);
};
var require_browser = __commonJS((exports, module) => {
  "use strict";
  var getGlobal2 = function() {
    if (typeof self !== "undefined") {
      return self;
    }
    if (typeof window !== "undefined") {
      return window;
    }
    if (typeof global2 !== "undefined") {
      return global2;
    }
    throw new Error("unable to locate global object");
  };
  var global2 = getGlobal2();
  module.exports = exports = global2.fetch;
  if (global2.fetch) {
    exports.default = global2.fetch.bind(global2);
  }
  exports.Headers = global2.Headers;
  exports.Request = global2.Request;
  exports.Response = global2.Response;
});
var require_safe_buffer = __commonJS((exports, module) => {
  var buffer2 = require("buffer");
  var Buffer2 = buffer2.Buffer;
  function copyProps(src, dst) {
    for (var key in src) {
      dst[key] = src[key];
    }
  }
  if (Buffer2.from && Buffer2.alloc && Buffer2.allocUnsafe && Buffer2.allocUnsafeSlow) {
    module.exports = buffer2;
  } else {
    copyProps(buffer2, exports);
    exports.Buffer = SafeBuffer;
  }
  function SafeBuffer(arg, encodingOrOffset, length) {
    return Buffer2(arg, encodingOrOffset, length);
  }
  copyProps(Buffer2, SafeBuffer);
  SafeBuffer.from = function(arg, encodingOrOffset, length) {
    if (typeof arg === "number") {
      throw new TypeError("Argument must not be a number");
    }
    return Buffer2(arg, encodingOrOffset, length);
  };
  SafeBuffer.alloc = function(size, fill2, encoding) {
    if (typeof size !== "number") {
      throw new TypeError("Argument must be a number");
    }
    var buf = Buffer2(size);
    if (fill2 !== void 0) {
      if (typeof encoding === "string") {
        buf.fill(fill2, encoding);
      } else {
        buf.fill(fill2);
      }
    } else {
      buf.fill(0);
    }
    return buf;
  };
  SafeBuffer.allocUnsafe = function(size) {
    if (typeof size !== "number") {
      throw new TypeError("Argument must be a number");
    }
    return Buffer2(size);
  };
  SafeBuffer.allocUnsafeSlow = function(size) {
    if (typeof size !== "number") {
      throw new TypeError("Argument must be a number");
    }
    return buffer2.SlowBuffer(size);
  };
});
var require_string_decoder = __commonJS((exports) => {
  "use strict";
  var Buffer2 = require_safe_buffer().Buffer;
  var isEncoding = Buffer2.isEncoding || function(encoding) {
    encoding = "" + encoding;
    switch (encoding && encoding.toLowerCase()) {
      case "hex":
      case "utf8":
      case "utf-8":
      case "ascii":
      case "binary":
      case "base64":
      case "ucs2":
      case "ucs-2":
      case "utf16le":
      case "utf-16le":
      case "raw":
        return true;
      default:
        return false;
    }
  };
  function _normalizeEncoding(enc) {
    if (!enc)
      return "utf8";
    var retried;
    while (true) {
      switch (enc) {
        case "utf8":
        case "utf-8":
          return "utf8";
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return "utf16le";
        case "latin1":
        case "binary":
          return "latin1";
        case "base64":
        case "ascii":
        case "hex":
          return enc;
        default:
          if (retried)
            return;
          enc = ("" + enc).toLowerCase();
          retried = true;
      }
    }
  }
  function normalizeEncoding(enc) {
    var nenc = _normalizeEncoding(enc);
    if (typeof nenc !== "string" && (Buffer2.isEncoding === isEncoding || !isEncoding(enc)))
      throw new Error("Unknown encoding: " + enc);
    return nenc || enc;
  }
  exports.StringDecoder = StringDecoder;
  function StringDecoder(encoding) {
    this.encoding = normalizeEncoding(encoding);
    var nb;
    switch (this.encoding) {
      case "utf16le":
        this.text = utf16Text;
        this.end = utf16End;
        nb = 4;
        break;
      case "utf8":
        this.fillLast = utf8FillLast;
        nb = 4;
        break;
      case "base64":
        this.text = base64Text;
        this.end = base64End;
        nb = 3;
        break;
      default:
        this.write = simpleWrite;
        this.end = simpleEnd;
        return;
    }
    this.lastNeed = 0;
    this.lastTotal = 0;
    this.lastChar = Buffer2.allocUnsafe(nb);
  }
  StringDecoder.prototype.write = function(buf) {
    if (buf.length === 0)
      return "";
    var r;
    var i;
    if (this.lastNeed) {
      r = this.fillLast(buf);
      if (r === void 0)
        return "";
      i = this.lastNeed;
      this.lastNeed = 0;
    } else {
      i = 0;
    }
    if (i < buf.length)
      return r ? r + this.text(buf, i) : this.text(buf, i);
    return r || "";
  };
  StringDecoder.prototype.end = utf8End;
  StringDecoder.prototype.text = utf8Text;
  StringDecoder.prototype.fillLast = function(buf) {
    if (this.lastNeed <= buf.length) {
      buf.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, this.lastNeed);
      return this.lastChar.toString(this.encoding, 0, this.lastTotal);
    }
    buf.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, buf.length);
    this.lastNeed -= buf.length;
  };
  function utf8CheckByte(byte) {
    if (byte <= 127)
      return 0;
    else if (byte >> 5 === 6)
      return 2;
    else if (byte >> 4 === 14)
      return 3;
    else if (byte >> 3 === 30)
      return 4;
    return byte >> 6 === 2 ? -1 : -2;
  }
  function utf8CheckIncomplete(self2, buf, i) {
    var j = buf.length - 1;
    if (j < i)
      return 0;
    var nb = utf8CheckByte(buf[j]);
    if (nb >= 0) {
      if (nb > 0)
        self2.lastNeed = nb - 1;
      return nb;
    }
    if (--j < i || nb === -2)
      return 0;
    nb = utf8CheckByte(buf[j]);
    if (nb >= 0) {
      if (nb > 0)
        self2.lastNeed = nb - 2;
      return nb;
    }
    if (--j < i || nb === -2)
      return 0;
    nb = utf8CheckByte(buf[j]);
    if (nb >= 0) {
      if (nb > 0) {
        if (nb === 2)
          nb = 0;
        else
          self2.lastNeed = nb - 3;
      }
      return nb;
    }
    return 0;
  }
  function utf8CheckExtraBytes(self2, buf, p) {
    if ((buf[0] & 192) !== 128) {
      self2.lastNeed = 0;
      return "\uFFFD";
    }
    if (self2.lastNeed > 1 && buf.length > 1) {
      if ((buf[1] & 192) !== 128) {
        self2.lastNeed = 1;
        return "\uFFFD";
      }
      if (self2.lastNeed > 2 && buf.length > 2) {
        if ((buf[2] & 192) !== 128) {
          self2.lastNeed = 2;
          return "\uFFFD";
        }
      }
    }
  }
  function utf8FillLast(buf) {
    var p = this.lastTotal - this.lastNeed;
    var r = utf8CheckExtraBytes(this, buf, p);
    if (r !== void 0)
      return r;
    if (this.lastNeed <= buf.length) {
      buf.copy(this.lastChar, p, 0, this.lastNeed);
      return this.lastChar.toString(this.encoding, 0, this.lastTotal);
    }
    buf.copy(this.lastChar, p, 0, buf.length);
    this.lastNeed -= buf.length;
  }
  function utf8Text(buf, i) {
    var total = utf8CheckIncomplete(this, buf, i);
    if (!this.lastNeed)
      return buf.toString("utf8", i);
    this.lastTotal = total;
    var end = buf.length - (total - this.lastNeed);
    buf.copy(this.lastChar, 0, end);
    return buf.toString("utf8", i, end);
  }
  function utf8End(buf) {
    var r = buf && buf.length ? this.write(buf) : "";
    if (this.lastNeed)
      return r + "\uFFFD";
    return r;
  }
  function utf16Text(buf, i) {
    if ((buf.length - i) % 2 === 0) {
      var r = buf.toString("utf16le", i);
      if (r) {
        var c = r.charCodeAt(r.length - 1);
        if (c >= 55296 && c <= 56319) {
          this.lastNeed = 2;
          this.lastTotal = 4;
          this.lastChar[0] = buf[buf.length - 2];
          this.lastChar[1] = buf[buf.length - 1];
          return r.slice(0, -1);
        }
      }
      return r;
    }
    this.lastNeed = 1;
    this.lastTotal = 2;
    this.lastChar[0] = buf[buf.length - 1];
    return buf.toString("utf16le", i, buf.length - 1);
  }
  function utf16End(buf) {
    var r = buf && buf.length ? this.write(buf) : "";
    if (this.lastNeed) {
      var end = this.lastTotal - this.lastNeed;
      return r + this.lastChar.toString("utf16le", 0, end);
    }
    return r;
  }
  function base64Text(buf, i) {
    var n = (buf.length - i) % 3;
    if (n === 0)
      return buf.toString("base64", i);
    this.lastNeed = 3 - n;
    this.lastTotal = 3;
    if (n === 1) {
      this.lastChar[0] = buf[buf.length - 1];
    } else {
      this.lastChar[0] = buf[buf.length - 2];
      this.lastChar[1] = buf[buf.length - 1];
    }
    return buf.toString("base64", i, buf.length - n);
  }
  function base64End(buf) {
    var r = buf && buf.length ? this.write(buf) : "";
    if (this.lastNeed)
      return r + this.lastChar.toString("base64", 0, 3 - this.lastNeed);
    return r;
  }
  function simpleWrite(buf) {
    return buf.toString(this.encoding);
  }
  function simpleEnd(buf) {
    return buf && buf.length ? this.write(buf) : "";
  }
});
var require_tf_es2017 = __commonJS((exports, module) => {
  /**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   */
  (function(global2, factory) {
    typeof exports === "object" && typeof module !== "undefined" ? factory(exports) : typeof define === "function" && define.amd ? define(["exports"], factory) : (global2 = global2 || self, factory(global2.tf = global2.tf || {}));
  })(exports, function(exports2) {
    "use strict";
    /**
     * @license
     * Copyright 2020 Google LLC. All Rights Reserved.
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     * http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     * =============================================================================
     */
    const EPSILON_FLOAT322 = 1e-7;
    const EPSILON_FLOAT162 = 1e-4;
    class DataStorage2 {
      constructor(backend3, dataMover) {
        this.backend = backend3;
        this.dataMover = dataMover;
        this.data = new WeakMap();
        this.dataIdsCount = 0;
      }
      get(dataId) {
        if (!this.data.has(dataId)) {
          this.dataMover.moveData(this.backend, dataId);
        }
        return this.data.get(dataId);
      }
      set(dataId, value) {
        this.dataIdsCount++;
        this.data.set(dataId, value);
      }
      has(dataId) {
        return this.data.has(dataId);
      }
      delete(dataId) {
        this.dataIdsCount--;
        return this.data.delete(dataId);
      }
      numDataIds() {
        return this.dataIdsCount;
      }
    }
    class KernelBackend2 {
      time(f) {
        return notYetImplemented2("time");
      }
      read(dataId) {
        return notYetImplemented2("read");
      }
      readSync(dataId) {
        return notYetImplemented2("readSync");
      }
      numDataIds() {
        return notYetImplemented2("numDataIds");
      }
      disposeData(dataId) {
        return notYetImplemented2("disposeData");
      }
      write(values, shape, dtype) {
        return notYetImplemented2("write");
      }
      move(dataId, values, shape, dtype) {
        return notYetImplemented2("move");
      }
      memory() {
        return notYetImplemented2("memory");
      }
      floatPrecision() {
        return notYetImplemented2("floatPrecision");
      }
      epsilon() {
        return this.floatPrecision() === 32 ? EPSILON_FLOAT322 : EPSILON_FLOAT162;
      }
      batchMatMul(a, b, transposeA, transposeB) {
        return notYetImplemented2("batchMatMul");
      }
      fusedBatchMatMul({a, b, transposeA, transposeB, bias, activation: activation2, preluActivationWeights}) {
        return notYetImplemented2("fusedBatchMatMul");
      }
      slice(x, begin, size) {
        return notYetImplemented2("slice");
      }
      stridedSlice(x, begin, end, strides) {
        return notYetImplemented2("stridedSlice");
      }
      unstack(x, axis) {
        return notYetImplemented2("unstack");
      }
      reverse(a, axis) {
        return notYetImplemented2("reverse");
      }
      concat(tensors, axis) {
        return notYetImplemented2("concat");
      }
      neg(a) {
        return notYetImplemented2("neg");
      }
      add(a, b) {
        return notYetImplemented2("add");
      }
      addN(tensors) {
        return notYetImplemented2("addN");
      }
      subtract(a, b) {
        return notYetImplemented2("subtract");
      }
      multiply(a, b) {
        return notYetImplemented2("multiply");
      }
      realDivide(a, b) {
        return notYetImplemented2("realDivide");
      }
      floorDiv(a, b) {
        return notYetImplemented2("floorDiv");
      }
      sum(x, axes) {
        return notYetImplemented2("sum");
      }
      prod(x, axes) {
        return notYetImplemented2("prod");
      }
      unsortedSegmentSum(x, segmentIds, numSegments) {
        return notYetImplemented2("unsortedSegmentSum");
      }
      argMin(x, axis) {
        return notYetImplemented2("argMin");
      }
      argMax(x, axis) {
        return notYetImplemented2("argMax");
      }
      equal(a, b) {
        return notYetImplemented2("equal");
      }
      notEqual(a, b) {
        return notYetImplemented2("notEqual");
      }
      less(a, b) {
        return notYetImplemented2("less");
      }
      lessEqual(a, b) {
        return notYetImplemented2("lessEqual");
      }
      greater(a, b) {
        return notYetImplemented2("greater");
      }
      greaterEqual(a, b) {
        return notYetImplemented2("greaterEqual");
      }
      logicalNot(a) {
        return notYetImplemented2("logicalNot");
      }
      logicalAnd(a, b) {
        return notYetImplemented2("logicalAnd");
      }
      logicalOr(a, b) {
        return notYetImplemented2("logicalOr");
      }
      where(condition) {
        return notYetImplemented2("where");
      }
      select(condition, a, b) {
        return notYetImplemented2("select");
      }
      topk(x, k, sorted) {
        return notYetImplemented2("topk");
      }
      min(x, axes) {
        return notYetImplemented2("min");
      }
      minimum(a, b) {
        return notYetImplemented2("minimum");
      }
      mod(a, b) {
        return notYetImplemented2("mod");
      }
      max(x, axes) {
        return notYetImplemented2("max");
      }
      maximum(a, b) {
        return notYetImplemented2("maximum");
      }
      all(x, axes) {
        return notYetImplemented2("all");
      }
      any(x, axes) {
        return notYetImplemented2("any");
      }
      squaredDifference(a, b) {
        return notYetImplemented2("squaredDifference");
      }
      ceil(x) {
        return notYetImplemented2("ceil");
      }
      floor(x) {
        return notYetImplemented2("floor");
      }
      round(x) {
        return notYetImplemented2("round");
      }
      sign(x) {
        return notYetImplemented2("sign");
      }
      isNaN(x) {
        return notYetImplemented2("isNaN");
      }
      isInf(x) {
        return notYetImplemented2("isInf");
      }
      isFinite(x) {
        return notYetImplemented2("isFinite");
      }
      pow(a, b) {
        return notYetImplemented2("pow");
      }
      exp(x) {
        return notYetImplemented2("exp");
      }
      expm1(x) {
        return notYetImplemented2("expm1");
      }
      softmax(x, dim) {
        return notYetImplemented2("softmax");
      }
      log(x) {
        return notYetImplemented2("log");
      }
      log1p(x) {
        return notYetImplemented2("log1p");
      }
      sqrt(x) {
        return notYetImplemented2("sqrt");
      }
      rsqrt(x) {
        return notYetImplemented2("rsqrt");
      }
      square(x) {
        return notYetImplemented2("square");
      }
      reciprocal(x) {
        return notYetImplemented2("reciprocal");
      }
      relu(x) {
        return notYetImplemented2("relu");
      }
      relu6(x) {
        return notYetImplemented2("relu6");
      }
      prelu(x, a) {
        return notYetImplemented2("prelu");
      }
      elu(x) {
        return notYetImplemented2("elu");
      }
      eluDer(dy, y) {
        return notYetImplemented2("eluDer");
      }
      selu(x) {
        return notYetImplemented2("selu");
      }
      int(x) {
        return notYetImplemented2("int");
      }
      clip(x, min3, max3) {
        return notYetImplemented2("clip");
      }
      abs(x) {
        return notYetImplemented2("abs");
      }
      complexAbs(x) {
        return notYetImplemented2("complexAbs");
      }
      sigmoid(x) {
        return notYetImplemented2("sigmoid");
      }
      softplus(x) {
        return notYetImplemented2("softplus");
      }
      sin(x) {
        return notYetImplemented2("sin");
      }
      cos(x) {
        return notYetImplemented2("cos");
      }
      tan(x) {
        return notYetImplemented2("tan");
      }
      asin(x) {
        return notYetImplemented2("asin");
      }
      acos(x) {
        return notYetImplemented2("acos");
      }
      atan(x) {
        return notYetImplemented2("atan");
      }
      atan2(a, b) {
        return notYetImplemented2("atan2");
      }
      sinh(x) {
        return notYetImplemented2("sinh");
      }
      cosh(x) {
        return notYetImplemented2("cosh");
      }
      tanh(x) {
        return notYetImplemented2("tanh");
      }
      asinh(x) {
        return notYetImplemented2("asinh");
      }
      acosh(x) {
        return notYetImplemented2("acosh");
      }
      atanh(x) {
        return notYetImplemented2("atanh");
      }
      erf(x) {
        return notYetImplemented2("erf");
      }
      step(x, alpha) {
        return notYetImplemented2("step");
      }
      fusedConv2d({input: input2, filter, convInfo, bias, activation: activation2, preluActivationWeights}) {
        return notYetImplemented2("fusedConv2d");
      }
      conv2d(x, filter, convInfo) {
        return notYetImplemented2("conv2d");
      }
      conv2dDerInput(dy, filter, convInfo) {
        return notYetImplemented2("conv2dDerInput");
      }
      conv2dDerFilter(x, dY, convInfo) {
        return notYetImplemented2("conv2dDerFilter");
      }
      fusedDepthwiseConv2D({input: input2, filter, convInfo, bias, activation: activation2, preluActivationWeights}) {
        return notYetImplemented2("fusedDepthwiseConv2D");
      }
      depthwiseConv2D(input2, filter, convInfo) {
        return notYetImplemented2("depthwiseConv2D");
      }
      depthwiseConv2DDerInput(dy, filter, convInfo) {
        return notYetImplemented2("depthwiseConv2DDerInput");
      }
      depthwiseConv2DDerFilter(x, dY, convInfo) {
        return notYetImplemented2("depthwiseConv2DDerFilter");
      }
      conv3d(x, filter, convInfo) {
        return notYetImplemented2("conv3d");
      }
      conv3dDerInput(dy, filter, convInfo) {
        return notYetImplemented2("conv3dDerInput");
      }
      conv3dDerFilter(x, dY, convInfo) {
        return notYetImplemented2("conv3dDerFilter");
      }
      maxPool(x, convInfo) {
        return notYetImplemented2("maxPool");
      }
      maxPoolBackprop(dy, x, y, convInfo) {
        return notYetImplemented2("maxPoolBackprop");
      }
      avgPool(x, convInfo) {
        return notYetImplemented2("avgPool");
      }
      avgPoolBackprop(dy, x, convInfo) {
        return notYetImplemented2("avgPoolBackprop");
      }
      avgPool3d(x, convInfo) {
        return notYetImplemented2("avgPool3d");
      }
      avgPool3dBackprop(dy, x, convInfo) {
        return notYetImplemented2("avgPool3dBackprop");
      }
      maxPool3d(x, convInfo) {
        return notYetImplemented2("maxPool3d");
      }
      maxPool3dBackprop(dy, x, y, convInfo) {
        return notYetImplemented2("maxPool3dBackprop");
      }
      reshape(x, shape) {
        return notYetImplemented2("reshape");
      }
      cast(x, dtype) {
        return notYetImplemented2("cast");
      }
      tile(x, reps) {
        return notYetImplemented2("tile");
      }
      pad(x, paddings, constantValue) {
        return notYetImplemented2("pad");
      }
      transpose(x, perm) {
        return notYetImplemented2("transpose");
      }
      gather(x, indices, axis) {
        return notYetImplemented2("gather");
      }
      gatherND(x, indices) {
        return notYetImplemented2("gatherND");
      }
      scatterND(indices, updates, shape) {
        return notYetImplemented2("scatterND");
      }
      batchToSpaceND(x, blockShape, crops) {
        return notYetImplemented2("batchToSpaceND");
      }
      spaceToBatchND(x, blockShape, paddings) {
        return notYetImplemented2("spaceToBatchND");
      }
      resizeBilinear(x, newHeight, newWidth, alignCorners) {
        return notYetImplemented2("resizeBilinear");
      }
      resizeBilinearBackprop(dy, x, alignCorners) {
        return notYetImplemented2("resizeBilinearBackprop");
      }
      resizeNearestNeighbor(x, newHEight, newWidth, alignCorners) {
        return notYetImplemented2("resizeNearestNeighbor");
      }
      resizeNearestNeighborBackprop(dy, x, alignCorners) {
        return notYetImplemented2("resizeNearestNeighborBackprop");
      }
      batchNorm(x, mean2, variance2, offset, scale2, varianceEpsilon) {
        return notYetImplemented2("batchNorm");
      }
      localResponseNormalization4D(x, radius, bias, alpha, beta) {
        return notYetImplemented2("localResponseNormalization4D");
      }
      LRNGrad(dy, inputImage, outputImage, radius, bias, alpha, beta) {
        return notYetImplemented2("LRNGrad");
      }
      multinomial(logits, normalized, numSamples, seed) {
        return notYetImplemented2("multinomial");
      }
      oneHot(indices, depth, onValue, offValue) {
        return notYetImplemented2("oneHot");
      }
      cumsum(x, axis, exclusive, reverse3) {
        return notYetImplemented2("cumsum");
      }
      nonMaxSuppression(boxes, scores, maxOutputSize, iouThreshold, scoreThreshold) {
        return notYetImplemented2("nonMaxSuppression");
      }
      fft(x) {
        return notYetImplemented2("fft");
      }
      ifft(x) {
        return notYetImplemented2("ifft");
      }
      complex(real2, imag2) {
        return notYetImplemented2("complex");
      }
      real(input2) {
        return notYetImplemented2("real");
      }
      imag(input2) {
        return notYetImplemented2("imag");
      }
      cropAndResize(image3, boxes, boxIndex, cropSize, method, extrapolationValue) {
        return notYetImplemented2("cropAndResize");
      }
      depthToSpace(x, blockSize, dataFormat) {
        return notYetImplemented2("depthToSpace");
      }
      split(value, sizeSplits, axis) {
        return notYetImplemented2("split");
      }
      sparseToDense(sparseIndices, sparseValues, outputShape, defaultValue) {
        return notYetImplemented2("sparseToDense");
      }
      diag(x) {
        return notYetImplemented2("diag");
      }
      fill(shape, value, dtype) {
        return notYetImplemented2("fill");
      }
      onesLike(x) {
        return notYetImplemented2("onesLike");
      }
      zerosLike(x) {
        return notYetImplemented2("zerosLike");
      }
      linspace(start, stop, num) {
        return notYetImplemented2("linspace");
      }
      dispose() {
        return notYetImplemented2("dispose");
      }
    }
    function notYetImplemented2(kernelName) {
      throw new Error(`'${kernelName}' not yet implemented or not found in the registry. This kernel may not be supported by the tfjs backend you have chosen`);
    }
    /**
     * @license
     * Copyright 2020 Google LLC. All Rights Reserved.
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     * http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     * =============================================================================
     */
    function shuffle2(array2) {
      let counter = array2.length;
      let temp = 0;
      let index2 = 0;
      while (counter > 0) {
        index2 = Math.random() * counter | 0;
        counter--;
        temp = array2[counter];
        array2[counter] = array2[index2];
        array2[index2] = temp;
      }
    }
    function clamp2(min3, x, max3) {
      return Math.max(min3, Math.min(x, max3));
    }
    function nearestLargerEven2(val) {
      return val % 2 === 0 ? val : val + 1;
    }
    function sum5(arr) {
      let sum6 = 0;
      for (let i = 0; i < arr.length; i++) {
        sum6 += arr[i];
      }
      return sum6;
    }
    function randUniform2(a, b) {
      const r = Math.random();
      return b * r + (1 - r) * a;
    }
    function distSquared2(a, b) {
      let result = 0;
      for (let i = 0; i < a.length; i++) {
        const diff = Number(a[i]) - Number(b[i]);
        result += diff * diff;
      }
      return result;
    }
    function assert2(expr, msg) {
      if (!expr) {
        throw new Error(typeof msg === "string" ? msg : msg());
      }
    }
    function assertShapesMatch2(shapeA, shapeB, errorMessagePrefix = "") {
      assert2(arraysEqual2(shapeA, shapeB), () => errorMessagePrefix + ` Shapes ${shapeA} and ${shapeB} must match`);
    }
    function assertNonNull2(a) {
      assert2(a != null, () => `The input to the tensor constructor must be a non-null value.`);
    }
    function flatten2(arr, result = [], skipTypedArray = false) {
      if (result == null) {
        result = [];
      }
      if (Array.isArray(arr) || isTypedArray2(arr) && !skipTypedArray) {
        for (let i = 0; i < arr.length; ++i) {
          flatten2(arr[i], result, skipTypedArray);
        }
      } else {
        result.push(arr);
      }
      return result;
    }
    function sizeFromShape2(shape) {
      if (shape.length === 0) {
        return 1;
      }
      let size = shape[0];
      for (let i = 1; i < shape.length; i++) {
        size *= shape[i];
      }
      return size;
    }
    function isScalarShape2(shape) {
      return shape.length === 0;
    }
    function arraysEqual2(n1, n2) {
      if (n1 === n2) {
        return true;
      }
      if (n1 == null || n2 == null) {
        return false;
      }
      if (n1.length !== n2.length) {
        return false;
      }
      for (let i = 0; i < n1.length; i++) {
        if (n1[i] !== n2[i]) {
          return false;
        }
      }
      return true;
    }
    function isInt2(a) {
      return a % 1 === 0;
    }
    function tanh2(x) {
      if (Math.tanh != null) {
        return Math.tanh(x);
      }
      if (x === Infinity) {
        return 1;
      } else if (x === -Infinity) {
        return -1;
      } else {
        const e2x = Math.exp(2 * x);
        return (e2x - 1) / (e2x + 1);
      }
    }
    function sizeToSquarishShape2(size) {
      const width = Math.ceil(Math.sqrt(size));
      return [width, Math.ceil(size / width)];
    }
    function createShuffledIndices2(n) {
      const shuffledIndices = new Uint32Array(n);
      for (let i = 0; i < n; ++i) {
        shuffledIndices[i] = i;
      }
      shuffle2(shuffledIndices);
      return shuffledIndices;
    }
    function rightPad2(a, size) {
      if (size <= a.length) {
        return a;
      }
      return a + " ".repeat(size - a.length);
    }
    function repeatedTry2(checkFn, delayFn = (counter) => 0, maxCounter) {
      return new Promise((resolve, reject) => {
        let tryCount = 0;
        const tryFn = () => {
          if (checkFn()) {
            resolve();
            return;
          }
          tryCount++;
          const nextBackoff = delayFn(tryCount);
          if (maxCounter != null && tryCount >= maxCounter) {
            reject();
            return;
          }
          setTimeout(tryFn, nextBackoff);
        };
        tryFn();
      });
    }
    function inferFromImplicitShape2(shape, size) {
      let shapeProd = 1;
      let implicitIdx = -1;
      for (let i = 0; i < shape.length; ++i) {
        if (shape[i] >= 0) {
          shapeProd *= shape[i];
        } else if (shape[i] === -1) {
          if (implicitIdx !== -1) {
            throw Error(`Shapes can only have 1 implicit size. Found -1 at dim ${implicitIdx} and dim ${i}`);
          }
          implicitIdx = i;
        } else if (shape[i] < 0) {
          throw Error(`Shapes can not be < 0. Found ${shape[i]} at dim ${i}`);
        }
      }
      if (implicitIdx === -1) {
        if (size > 0 && size !== shapeProd) {
          throw Error(`Size(${size}) must match the product of shape ${shape}`);
        }
        return shape;
      }
      if (shapeProd === 0) {
        throw Error(`Cannot infer the missing size in [${shape}] when there are 0 elements`);
      }
      if (size % shapeProd !== 0) {
        throw Error(`The implicit shape can't be a fractional number. Got ${size} / ${shapeProd}`);
      }
      const newShape = shape.slice();
      newShape[implicitIdx] = size / shapeProd;
      return newShape;
    }
    function parseAxisParam2(axis, shape) {
      const rank = shape.length;
      axis = axis == null ? shape.map((s, i) => i) : [].concat(axis);
      assert2(axis.every((ax) => ax >= -rank && ax < rank), () => `All values in axis param must be in range [-${rank}, ${rank}) but got axis ${axis}`);
      assert2(axis.every((ax) => isInt2(ax)), () => `All values in axis param must be integers but got axis ${axis}`);
      return axis.map((a) => a < 0 ? rank + a : a);
    }
    function squeezeShape2(shape, axis) {
      const newShape = [];
      const keptDims = [];
      const isEmptyArray = axis != null && Array.isArray(axis) && axis.length === 0;
      const axes = axis == null || isEmptyArray ? null : parseAxisParam2(axis, shape).sort();
      let j = 0;
      for (let i = 0; i < shape.length; ++i) {
        if (axes != null) {
          if (axes[j] === i && shape[i] !== 1) {
            throw new Error(`Can't squeeze axis ${i} since its dim '${shape[i]}' is not 1`);
          }
          if ((axes[j] == null || axes[j] > i) && shape[i] === 1) {
            newShape.push(shape[i]);
            keptDims.push(i);
          }
          if (axes[j] <= i) {
            j++;
          }
        }
        if (shape[i] !== 1) {
          newShape.push(shape[i]);
          keptDims.push(i);
        }
      }
      return {newShape, keptDims};
    }
    function getTypedArrayFromDType2(dtype, size) {
      let values = null;
      if (dtype == null || dtype === "float32") {
        values = new Float32Array(size);
      } else if (dtype === "int32") {
        values = new Int32Array(size);
      } else if (dtype === "bool") {
        values = new Uint8Array(size);
      } else {
        throw new Error(`Unknown data type ${dtype}`);
      }
      return values;
    }
    function getArrayFromDType2(dtype, size) {
      let values = null;
      if (dtype == null || dtype === "float32") {
        values = new Float32Array(size);
      } else if (dtype === "int32") {
        values = new Int32Array(size);
      } else if (dtype === "bool") {
        values = new Uint8Array(size);
      } else if (dtype === "string") {
        values = new Array(size);
      } else {
        throw new Error(`Unknown data type ${dtype}`);
      }
      return values;
    }
    function checkConversionForErrors2(vals, dtype) {
      for (let i = 0; i < vals.length; i++) {
        const num = vals[i];
        if (isNaN(num) || !isFinite(num)) {
          throw Error(`A tensor of type ${dtype} being uploaded contains ${num}.`);
        }
      }
    }
    function isValidDtype2(dtype) {
      return dtype === "bool" || dtype === "complex64" || dtype === "float32" || dtype === "int32" || dtype === "string";
    }
    function hasEncodingLoss2(oldType, newType) {
      if (newType === "complex64") {
        return false;
      }
      if (newType === "float32" && oldType !== "complex64") {
        return false;
      }
      if (newType === "int32" && oldType !== "float32" && oldType !== "complex64") {
        return false;
      }
      if (newType === "bool" && oldType === "bool") {
        return false;
      }
      return true;
    }
    function isTypedArray2(a) {
      return a instanceof Float32Array || a instanceof Int32Array || a instanceof Uint8Array;
    }
    function bytesPerElement2(dtype) {
      if (dtype === "float32" || dtype === "int32") {
        return 4;
      } else if (dtype === "complex64") {
        return 8;
      } else if (dtype === "bool") {
        return 1;
      } else {
        throw new Error(`Unknown dtype ${dtype}`);
      }
    }
    function bytesFromStringArray2(arr) {
      if (arr == null) {
        return 0;
      }
      let bytes = 0;
      arr.forEach((x) => bytes += x.length);
      return bytes;
    }
    function isString2(value) {
      return typeof value === "string" || value instanceof String;
    }
    function isBoolean2(value) {
      return typeof value === "boolean";
    }
    function isNumber2(value) {
      return typeof value === "number";
    }
    function inferDtype2(values) {
      if (Array.isArray(values)) {
        return inferDtype2(values[0]);
      }
      if (values instanceof Float32Array) {
        return "float32";
      } else if (values instanceof Int32Array || values instanceof Uint8Array) {
        return "int32";
      } else if (isNumber2(values)) {
        return "float32";
      } else if (isString2(values)) {
        return "string";
      } else if (isBoolean2(values)) {
        return "bool";
      }
      return "float32";
    }
    function isFunction2(f) {
      return !!(f && f.constructor && f.call && f.apply);
    }
    function nearestDivisor2(size, start) {
      for (let i = start; i < size; ++i) {
        if (size % i === 0) {
          return i;
        }
      }
      return size;
    }
    function computeStrides2(shape) {
      const rank = shape.length;
      if (rank < 2) {
        return [];
      }
      const strides = new Array(rank - 1);
      strides[rank - 2] = shape[rank - 1];
      for (let i = rank - 3; i >= 0; --i) {
        strides[i] = strides[i + 1] * shape[i + 1];
      }
      return strides;
    }
    function createNestedArray2(offset, shape, a) {
      const ret = new Array();
      if (shape.length === 1) {
        const d = shape[0];
        for (let i = 0; i < d; i++) {
          ret[i] = a[offset + i];
        }
      } else {
        const d = shape[0];
        const rest = shape.slice(1);
        const len = rest.reduce((acc, c) => acc * c);
        for (let i = 0; i < d; i++) {
          ret[i] = createNestedArray2(offset + i * len, rest, a);
        }
      }
      return ret;
    }
    function toNestedArray2(shape, a) {
      if (shape.length === 0) {
        return a[0];
      }
      const size = shape.reduce((acc, c) => acc * c);
      if (size === 0) {
        return [];
      }
      if (size !== a.length) {
        throw new Error(`[${shape}] does not match the input size ${a.length}.`);
      }
      return createNestedArray2(0, shape, a);
    }
    function makeOnesTypedArray2(size, dtype) {
      const array2 = makeZerosTypedArray2(size, dtype);
      for (let i = 0; i < array2.length; i++) {
        array2[i] = 1;
      }
      return array2;
    }
    function makeZerosTypedArray2(size, dtype) {
      if (dtype == null || dtype === "float32" || dtype === "complex64") {
        return new Float32Array(size);
      } else if (dtype === "int32") {
        return new Int32Array(size);
      } else if (dtype === "bool") {
        return new Uint8Array(size);
      } else {
        throw new Error(`Unknown data type ${dtype}`);
      }
    }
    function makeZerosNestedTypedArray2(shape, dtype) {
      const size = shape.reduce((prev, curr) => prev * curr, 1);
      if (dtype == null || dtype === "float32") {
        return toNestedArray2(shape, new Float32Array(size));
      } else if (dtype === "int32") {
        return toNestedArray2(shape, new Int32Array(size));
      } else if (dtype === "bool") {
        return toNestedArray2(shape, new Uint8Array(size));
      } else {
        throw new Error(`Unknown data type ${dtype}`);
      }
    }
    function assertNonNegativeIntegerDimensions2(shape) {
      shape.forEach((dimSize) => {
        assert2(Number.isInteger(dimSize) && dimSize >= 0, () => `Tensor must have a shape comprised of positive integers but got shape [${shape}].`);
      });
    }
    function locToIndex2(locs, rank, strides) {
      if (rank === 0) {
        return 0;
      } else if (rank === 1) {
        return locs[0];
      }
      let index2 = locs[locs.length - 1];
      for (let i = 0; i < locs.length - 1; ++i) {
        index2 += strides[i] * locs[i];
      }
      return index2;
    }
    function indexToLoc2(index2, rank, strides) {
      if (rank === 0) {
        return [];
      } else if (rank === 1) {
        return [index2];
      }
      const locs = new Array(rank);
      for (let i = 0; i < locs.length - 1; ++i) {
        locs[i] = Math.floor(index2 / strides[i]);
        index2 -= locs[i] * strides[i];
      }
      locs[locs.length - 1] = index2;
      return locs;
    }
    function isPromise2(object) {
      return object && object.then && typeof object.then === "function";
    }
    /**
     * @license
     * Copyright 2017 Google LLC. All Rights Reserved.
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     * http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     * =============================================================================
     */
    const TENSORFLOWJS_FLAGS_PREFIX2 = "tfjsflags";
    class Environment2 {
      constructor(global2) {
        this.global = global2;
        this.flags = {};
        this.flagRegistry = {};
        this.urlFlags = {};
        this.populateURLFlags();
      }
      setPlatform(platformName, platform) {
        if (this.platform != null) {
          console.warn(`Platform ${this.platformName} has already been set. Overwriting the platform with ${platform}.`);
        }
        this.platformName = platformName;
        this.platform = platform;
      }
      registerFlag(flagName, evaluationFn, setHook) {
        this.flagRegistry[flagName] = {evaluationFn, setHook};
        if (this.urlFlags[flagName] != null) {
          const flagValue = this.urlFlags[flagName];
          console.warn(`Setting feature override from URL ${flagName}: ${flagValue}.`);
          this.set(flagName, flagValue);
        }
      }
      async getAsync(flagName) {
        if (flagName in this.flags) {
          return this.flags[flagName];
        }
        this.flags[flagName] = await this.evaluateFlag(flagName);
        return this.flags[flagName];
      }
      get(flagName) {
        if (flagName in this.flags) {
          return this.flags[flagName];
        }
        const flagValue = this.evaluateFlag(flagName);
        if (isPromise2(flagValue)) {
          throw new Error(`Flag ${flagName} cannot be synchronously evaluated. Please use getAsync() instead.`);
        }
        this.flags[flagName] = flagValue;
        return this.flags[flagName];
      }
      getNumber(flagName) {
        return this.get(flagName);
      }
      getBool(flagName) {
        return this.get(flagName);
      }
      getFlags() {
        return this.flags;
      }
      get features() {
        return this.flags;
      }
      set(flagName, value) {
        if (this.flagRegistry[flagName] == null) {
          throw new Error(`Cannot set flag ${flagName} as it has not been registered.`);
        }
        this.flags[flagName] = value;
        if (this.flagRegistry[flagName].setHook != null) {
          this.flagRegistry[flagName].setHook(value);
        }
      }
      evaluateFlag(flagName) {
        if (this.flagRegistry[flagName] == null) {
          throw new Error(`Cannot evaluate flag '${flagName}': no evaluation function found.`);
        }
        return this.flagRegistry[flagName].evaluationFn();
      }
      setFlags(flags) {
        this.flags = Object.assign({}, flags);
      }
      reset() {
        this.flags = {};
        this.urlFlags = {};
        this.populateURLFlags();
      }
      populateURLFlags() {
        if (typeof this.global === "undefined" || typeof this.global.location === "undefined" || typeof this.global.location.search === "undefined") {
          return;
        }
        const urlParams = getQueryParams2(this.global.location.search);
        if (TENSORFLOWJS_FLAGS_PREFIX2 in urlParams) {
          const keyValues = urlParams[TENSORFLOWJS_FLAGS_PREFIX2].split(",");
          keyValues.forEach((keyValue) => {
            const [key, value] = keyValue.split(":");
            this.urlFlags[key] = parseValue2(key, value);
          });
        }
      }
    }
    function getQueryParams2(queryString) {
      const params = {};
      queryString.replace(/[?&]([^=?&]+)(?:=([^&]*))?/g, (s, ...t) => {
        decodeParam2(params, t[0], t[1]);
        return t.join("=");
      });
      return params;
    }
    function decodeParam2(params, name, value) {
      params[decodeURIComponent(name)] = decodeURIComponent(value || "");
    }
    function parseValue2(flagName, value) {
      value = value.toLowerCase();
      if (value === "true" || value === "false") {
        return value === "true";
      } else if (`${+value}` === value) {
        return +value;
      }
      throw new Error(`Could not parse value flag value ${value} for flag ${flagName}.`);
    }
    function env2() {
      return exports2.ENV;
    }
    exports2.ENV = null;
    function setEnvironmentGlobal2(environment6) {
      exports2.ENV = environment6;
    }
    /**
     * @license
     * Copyright 2020 Google LLC. All Rights Reserved.
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     * http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     * =============================================================================
     */
    let globalNameSpace2;
    function getGlobalNamespace2() {
      if (globalNameSpace2 == null) {
        let ns;
        if (typeof window !== "undefined") {
          ns = window;
        } else if (typeof global !== "undefined") {
          ns = global;
        } else if (typeof process !== "undefined") {
          ns = process;
        } else if (typeof self !== "undefined") {
          ns = self;
        } else {
          throw new Error("Could not find a global object");
        }
        globalNameSpace2 = ns;
      }
      return globalNameSpace2;
    }
    function getGlobalMap2() {
      const ns = getGlobalNamespace2();
      if (ns._tfGlobals == null) {
        ns._tfGlobals = new Map();
      }
      return ns._tfGlobals;
    }
    function getGlobal2(key, init2) {
      const globalMap = getGlobalMap2();
      if (globalMap.has(key)) {
        return globalMap.get(key);
      } else {
        const singleton = init2();
        globalMap.set(key, singleton);
        return globalMap.get(key);
      }
    }
    const Abs3 = "Abs";
    const Acos = "Acos";
    const Acosh = "Acosh";
    const Add3 = "Add";
    const AddN3 = "AddN";
    const All = "All";
    const Any = "Any";
    const ArgMax3 = "ArgMax";
    const ArgMin = "ArgMin";
    const Asin = "Asin";
    const Asinh = "Asinh";
    const Atan = "Atan";
    const Atanh = "Atanh";
    const Atan2 = "Atan2";
    const AvgPool3 = "AvgPool";
    const AvgPoolBackprop = "AvgPoolBackprop";
    const AvgPool3D = "AvgPool3D";
    const AvgPool3DBackprop = "AvgPool3DBackprop";
    const BatchMatMul3 = "BatchMatMul";
    const BatchToSpaceND = "BatchToSpaceND";
    const BroadcastTo = "BroadcastTo";
    const Cast5 = "Cast";
    const Ceil = "Ceil";
    const ClipByValue3 = "ClipByValue";
    const Complex2 = "Complex";
    const Concat3 = "Concat";
    const Conv2D3 = "Conv2D";
    const Conv2DBackpropFilter = "Conv2DBackpropFilter";
    const Conv2DBackpropInput3 = "Conv2DBackpropInput";
    const Conv3D = "Conv3D";
    const Conv3DBackpropFilterV2 = "Conv3DBackpropFilterV2";
    const Conv3DBackpropInputV2 = "Conv3DBackpropInputV2";
    const Cos3 = "Cos";
    const Cosh = "Cosh";
    const Cumsum3 = "Cumsum";
    const CropAndResize3 = "CropAndResize";
    const DepthToSpace3 = "DepthToSpace";
    const DepthwiseConv2dNative3 = "DepthwiseConv2dNative";
    const DepthwiseConv2dNativeBackpropFilter = "DepthwiseConv2dNativeBackpropFilter";
    const DepthwiseConv2dNativeBackpropInput = "DepthwiseConv2dNativeBackpropInput";
    const Diag = "Diag";
    const Dilation2D = "Dilation2D";
    const Dilation2DBackpropInput = "Dilation2DBackpropInput";
    const Dilation2DBackpropFilter = "Dilation2DBackpropFilter";
    const Div3 = "Div";
    const Elu2 = "Elu";
    const EluGrad = "EluGrad";
    const Erf = "Erf";
    const Equal3 = "Equal";
    const Exp3 = "Exp";
    const Expm1 = "Expm1";
    const FFT = "FFT";
    const Fill3 = "Fill";
    const FlipLeftRight3 = "FlipLeftRight";
    const Floor = "Floor";
    const FloorDiv3 = "FloorDiv";
    const FusedBatchNorm3 = "FusedBatchNorm";
    const GatherV23 = "GatherV2";
    const GatherNd3 = "GatherNd";
    const Greater3 = "Greater";
    const GreaterEqual3 = "GreaterEqual";
    const Identity5 = "Identity";
    const IFFT = "IFFT";
    const Imag = "Imag";
    const IsFinite = "IsFinite";
    const IsInf = "IsInf";
    const IsNan = "IsNan";
    const Less3 = "Less";
    const LessEqual3 = "LessEqual";
    const LinSpace = "LinSpace";
    const Log3 = "Log";
    const Log1p = "Log1p";
    const LogicalAnd3 = "LogicalAnd";
    const LogicalNot = "LogicalNot";
    const LogicalOr = "LogicalOr";
    const LogSoftmax = "LogSoftmax";
    const LRN = "LRN";
    const LRNBackprop = "LRNBackprop";
    const Max3 = "Max";
    const Maximum3 = "Maximum";
    const MaxPool3 = "MaxPool";
    const MaxPoolBackprop = "MaxPoolBackprop";
    const MaxPool3D = "MaxPool3D";
    const MaxPool3DBackprop = "MaxPool3DBackprop";
    const MaxPoolWithArgmax = "MaxPoolWithArgmax";
    const Mean = "Mean";
    const Min3 = "Min";
    const Minimum3 = "Minimum";
    const MirrorPad = "MirrorPad";
    const Mod = "Mod";
    const Multiply3 = "Multiply";
    const Negate3 = "Negate";
    const NotEqual3 = "NotEqual";
    const NonMaxSuppressionV33 = "NonMaxSuppressionV3";
    const NonMaxSuppressionV43 = "NonMaxSuppressionV4";
    const NonMaxSuppressionV53 = "NonMaxSuppressionV5";
    const OnesLike3 = "OnesLike";
    const OneHot3 = "OneHot";
    const PadV23 = "PadV2";
    const Pool = "Pool";
    const Pow3 = "Pow";
    const Prelu3 = "Prelu";
    const Prod = "Prod";
    const Range = "Range";
    const Real = "Real";
    const Reciprocal = "Reciprocal";
    const Relu3 = "Relu";
    const Reshape6 = "Reshape";
    const ResizeNearestNeighbor = "ResizeNearestNeighbor";
    const ResizeNearestNeighborGrad = "ResizeNearestNeighborGrad";
    const ResizeBilinear3 = "ResizeBilinear";
    const ResizeBilinearGrad = "ResizeBilinearGrad";
    const Relu63 = "Relu6";
    const Reverse3 = "Reverse";
    const Round = "Round";
    const Rsqrt3 = "Rsqrt";
    const ScatterNd3 = "ScatterNd";
    const SelectV23 = "SelectV2";
    const Selu = "Selu";
    const Slice6 = "Slice";
    const Sin3 = "Sin";
    const Sinh = "Sinh";
    const Sign = "Sign";
    const Sigmoid3 = "Sigmoid";
    const Softplus = "Softplus";
    const Sqrt3 = "Sqrt";
    const Sum3 = "Sum";
    const SpaceToBatchND = "SpaceToBatchND";
    const SplitV2 = "SplitV";
    const Softmax3 = "Softmax";
    const SquaredDifference3 = "SquaredDifference";
    const Square3 = "Square";
    const Sub3 = "Sub";
    const SparseToDense = "SparseToDense";
    const StridedSlice3 = "StridedSlice";
    const Tan = "Tan";
    const Tanh3 = "Tanh";
    const Tile3 = "Tile";
    const TopK = "TopK";
    const Transpose5 = "Transpose";
    const Unique = "Unique";
    const Unpack3 = "Unpack";
    const UnsortedSegmentSum = "UnsortedSegmentSum";
    const ZerosLike3 = "ZerosLike";
    const Step2 = "Step";
    const FromPixels = "FromPixels";
    const RotateWithOffset3 = "RotateWithOffset";
    const _FusedMatMul2 = "_FusedMatMul";
    const FusedConv2D3 = "FusedConv2D";
    const FusedDepthwiseConv2D3 = "FusedDepthwiseConv2D";
    /**
     * @license
     * Copyright 2019 Google LLC. All Rights Reserved.
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     * http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     * =============================================================================
     */
    const kernelRegistry2 = getGlobal2("kernelRegistry", () => new Map());
    const gradRegistry2 = getGlobal2("gradRegistry", () => new Map());
    function getKernel2(kernelName, backendName) {
      const key = makeKey2(kernelName, backendName);
      return kernelRegistry2.get(key);
    }
    function getGradient2(kernelName) {
      return gradRegistry2.get(kernelName);
    }
    function getKernelsForBackend2(backendName) {
      const it = kernelRegistry2.entries();
      const result = [];
      while (true) {
        const {done, value} = it.next();
        if (done) {
          break;
        }
        const [key, config2] = value;
        const [backend3] = key.split("_");
        if (backend3 === backendName) {
          result.push(config2);
        }
      }
      return result;
    }
    function registerKernel2(config2) {
      const {kernelName, backendName} = config2;
      const key = makeKey2(kernelName, backendName);
      if (kernelRegistry2.has(key)) {
        console.warn(`The kernel '${kernelName}' for backend '${backendName}' is already registered`);
      }
      kernelRegistry2.set(key, config2);
    }
    function registerGradient(config2) {
      const {kernelName} = config2;
      if (gradRegistry2.has(kernelName)) {
        if (env2().getBool("DEBUG")) {
          console.warn(`Overriding the gradient for '${kernelName}'`);
        }
      }
      gradRegistry2.set(kernelName, config2);
    }
    function unregisterKernel(kernelName, backendName) {
      const key = makeKey2(kernelName, backendName);
      if (!kernelRegistry2.has(key)) {
        throw new Error(`The kernel '${kernelName}' for backend '${backendName}' is not registered`);
      }
      kernelRegistry2.delete(key);
    }
    function unregisterGradient(kernelName) {
      if (!gradRegistry2.has(kernelName)) {
        throw new Error(`The gradient '${kernelName}' for backend is not registered`);
      }
      gradRegistry2.delete(kernelName);
    }
    function copyRegisteredKernels(registeredBackendName, newBackendName) {
      const kernels = getKernelsForBackend2(registeredBackendName);
      kernels.forEach((kernelConfig) => {
        const newKernelConfig = Object.assign({}, kernelConfig, {backendName: newBackendName});
        registerKernel2(newKernelConfig);
      });
    }
    function makeKey2(kernelName, backendName) {
      return `${backendName}_${kernelName}`;
    }
    /**
     * @license
     * Copyright 2017 Google LLC. All Rights Reserved.
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     * http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     * =============================================================================
     */
    function createScalarValue2(value, dtype) {
      if (dtype === "string") {
        return encodeString2(value);
      }
      return toTypedArray2([value], dtype);
    }
    function noConversionNeeded2(a, dtype) {
      return a instanceof Float32Array && dtype === "float32" || a instanceof Int32Array && dtype === "int32" || a instanceof Uint8Array && dtype === "bool";
    }
    function toTypedArray2(a, dtype) {
      if (dtype === "string") {
        throw new Error("Cannot convert a string[] to a TypedArray");
      }
      if (Array.isArray(a)) {
        a = flatten2(a);
      }
      if (env2().getBool("DEBUG")) {
        checkConversionForErrors2(a, dtype);
      }
      if (noConversionNeeded2(a, dtype)) {
        return a;
      }
      if (dtype == null || dtype === "float32" || dtype === "complex64") {
        return new Float32Array(a);
      } else if (dtype === "int32") {
        return new Int32Array(a);
      } else if (dtype === "bool") {
        const bool = new Uint8Array(a.length);
        for (let i = 0; i < bool.length; ++i) {
          if (Math.round(a[i]) !== 0) {
            bool[i] = 1;
          }
        }
        return bool;
      } else {
        throw new Error(`Unknown data type ${dtype}`);
      }
    }
    function now3() {
      return env2().platform.now();
    }
    function fetch$1(path, requestInits) {
      return env2().platform.fetch(path, requestInits);
    }
    function encodeString2(s, encoding = "utf-8") {
      encoding = encoding || "utf-8";
      return env2().platform.encode(s, encoding);
    }
    function decodeString2(bytes, encoding = "utf-8") {
      encoding = encoding || "utf-8";
      return env2().platform.decode(bytes, encoding);
    }
    var util30 = /* @__PURE__ */ Object.freeze({
      __proto__: null,
      createScalarValue: createScalarValue2,
      toTypedArray: toTypedArray2,
      now: now3,
      fetch: fetch$1,
      encodeString: encodeString2,
      decodeString: decodeString2,
      shuffle: shuffle2,
      clamp: clamp2,
      nearestLargerEven: nearestLargerEven2,
      sum: sum5,
      randUniform: randUniform2,
      distSquared: distSquared2,
      assert: assert2,
      assertShapesMatch: assertShapesMatch2,
      assertNonNull: assertNonNull2,
      flatten: flatten2,
      sizeFromShape: sizeFromShape2,
      isScalarShape: isScalarShape2,
      arraysEqual: arraysEqual2,
      isInt: isInt2,
      tanh: tanh2,
      sizeToSquarishShape: sizeToSquarishShape2,
      createShuffledIndices: createShuffledIndices2,
      rightPad: rightPad2,
      repeatedTry: repeatedTry2,
      inferFromImplicitShape: inferFromImplicitShape2,
      parseAxisParam: parseAxisParam2,
      squeezeShape: squeezeShape2,
      getTypedArrayFromDType: getTypedArrayFromDType2,
      getArrayFromDType: getArrayFromDType2,
      checkConversionForErrors: checkConversionForErrors2,
      isValidDtype: isValidDtype2,
      hasEncodingLoss: hasEncodingLoss2,
      isTypedArray: isTypedArray2,
      bytesPerElement: bytesPerElement2,
      bytesFromStringArray: bytesFromStringArray2,
      isString: isString2,
      isBoolean: isBoolean2,
      isNumber: isNumber2,
      inferDtype: inferDtype2,
      isFunction: isFunction2,
      nearestDivisor: nearestDivisor2,
      computeStrides: computeStrides2,
      toNestedArray: toNestedArray2,
      makeOnesTypedArray: makeOnesTypedArray2,
      makeZerosTypedArray: makeZerosTypedArray2,
      makeZerosNestedTypedArray: makeZerosNestedTypedArray2,
      assertNonNegativeIntegerDimensions: assertNonNegativeIntegerDimensions2,
      locToIndex: locToIndex2,
      indexToLoc: indexToLoc2,
      isPromise: isPromise2
    });
    /**
     * @license
     * Copyright 2018 Google LLC. All Rights Reserved.
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     * http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     * =============================================================================
     */
    class Profiler2 {
      constructor(backendTimer, logger) {
        this.backendTimer = backendTimer;
        this.logger = logger;
        if (logger == null) {
          this.logger = new Logger2();
        }
      }
      profileKernel(kernelName, inputs, f) {
        let outputs;
        const holdResultWrapperFn = () => {
          outputs = f();
        };
        const timer = this.backendTimer.time(holdResultWrapperFn);
        for (let i = 0; i < outputs.length; i++) {
          const output = outputs[i];
          output.data().then((tensorVals) => {
            checkComputationForErrors2(tensorVals, output.dtype, kernelName);
          });
        }
        const kernelProfile = {
          kernelName,
          outputs,
          inputs,
          timeMs: timer.then((timing) => timing.kernelMs),
          extraInfo: timer.then((timing) => timing.getExtraProfileInfo != null ? timing.getExtraProfileInfo() : "")
        };
        return kernelProfile;
      }
      logKernelProfile(kernelProfile) {
        const {kernelName, outputs, timeMs, inputs, extraInfo} = kernelProfile;
        outputs.forEach((result) => {
          Promise.all([result.data(), timeMs, extraInfo]).then((valueContainer) => {
            this.logger.logKernelProfile(kernelName, result, valueContainer[0], valueContainer[1], inputs, valueContainer[2]);
          });
        });
      }
    }
    function checkComputationForErrors2(vals, dtype, kernelName) {
      if (dtype !== "float32") {
        return false;
      }
      for (let i = 0; i < vals.length; i++) {
        const num = vals[i];
        if (isNaN(num) || !isFinite(num)) {
          console.warn(`Found ${num} in the result of '${kernelName}'`);
          return true;
        }
      }
      return false;
    }
    class Logger2 {
      logKernelProfile(name, result, vals, timeMs, inputs, extraInfo) {
        const time2 = typeof timeMs === "number" ? rightPad2(`${timeMs}ms`, 9) : timeMs["error"];
        const paddedName = rightPad2(name, 25);
        const rank = result.rank;
        const size = result.size;
        const shape = rightPad2(result.shape.toString(), 14);
        let inputShapesDescription = "";
        for (const name2 in inputs) {
          const input2 = inputs[name2];
          if (input2 != null) {
            const inputShape = input2.shape || result.shape;
            const inputRank = inputShape.length;
            inputShapesDescription += `${name2}: ${inputRank}D ${inputRank > 0 ? inputShape : ""} `;
          }
        }
        console.log(`%c${paddedName}	%c${time2}	%c${rank}D ${shape}	%c${size}	%c${inputShapesDescription}	%c${extraInfo}`, "font-weight:bold", "color:red", "color:blue", "color: orange", "color: green", "color: steelblue");
      }
    }
    /**
     * @license
     * Copyright 2017 Google LLC. All Rights Reserved.
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     * http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     * =============================================================================
     */
    function getFilteredNodesXToY2(tape2, xs, y) {
      const tensorsFromX = {};
      const nodesFromX = {};
      for (let i = 0; i < xs.length; i++) {
        tensorsFromX[xs[i].id] = true;
      }
      for (let i = 0; i < tape2.length; i++) {
        const node = tape2[i];
        const nodeInputs = node.inputs;
        for (const inputName in nodeInputs) {
          const input2 = nodeInputs[inputName];
          let anyInputFromX = false;
          for (let j = 0; j < xs.length; j++) {
            if (tensorsFromX[input2.id]) {
              node.outputs.forEach((output) => tensorsFromX[output.id] = true);
              anyInputFromX = true;
              nodesFromX[node.id] = true;
              break;
            }
          }
          if (anyInputFromX) {
            break;
          }
        }
      }
      const tensorsLeadToY = {};
      tensorsLeadToY[y.id] = true;
      const nodesToY = {};
      for (let i = tape2.length - 1; i >= 0; i--) {
        const node = tape2[i];
        const nodeInputs = node.inputs;
        for (let j = 0; j < node.outputs.length; j++) {
          if (tensorsLeadToY[node.outputs[j].id]) {
            for (const inputName in nodeInputs) {
              tensorsLeadToY[nodeInputs[inputName].id] = true;
              nodesToY[node.id] = true;
            }
            break;
          }
        }
      }
      const filteredTape = [];
      for (let i = 0; i < tape2.length; i++) {
        const node = tape2[i];
        if (nodesFromX[node.id] && nodesToY[node.id]) {
          const prunedInputs = {};
          for (const inputName in node.inputs) {
            const nodeInput = node.inputs[inputName];
            if (tensorsFromX[nodeInput.id]) {
              prunedInputs[inputName] = nodeInput;
            }
          }
          const prunedNode = Object.assign({}, node);
          prunedNode.inputs = prunedInputs;
          prunedNode.outputs = node.outputs;
          filteredTape.push(prunedNode);
        }
      }
      return filteredTape;
    }
    function backpropagateGradients2(tensorAccumulatedGradientMap, filteredTape, tidy2, add3) {
      for (let i = filteredTape.length - 1; i >= 0; i--) {
        const node = filteredTape[i];
        const dys = [];
        node.outputs.forEach((o) => {
          const gradTensor = tensorAccumulatedGradientMap[o.id];
          if (gradTensor != null) {
            dys.push(gradTensor);
          } else {
            dys.push(null);
          }
        });
        if (node.gradient == null) {
          throw new Error(`Cannot compute gradient: gradient function not found for ${node.kernelName}.`);
        }
        const inputGradients = node.gradient(dys);
        for (const inputName in node.inputs) {
          if (!(inputName in inputGradients)) {
            throw new Error(`Cannot backprop through input ${inputName}. Available gradients found: ${Object.keys(inputGradients)}.`);
          }
          const dx = tidy2(() => inputGradients[inputName]());
          if (dx.dtype !== "float32") {
            throw new Error(`Error in gradient for op ${node.kernelName}. The gradient of input ${inputName} must have 'float32' dtype, but has '${dx.dtype}'`);
          }
          const x = node.inputs[inputName];
          if (!arraysEqual2(dx.shape, x.shape)) {
            throw new Error(`Error in gradient for op ${node.kernelName}. The gradient of input '${inputName}' has shape '${dx.shape}', which does not match the shape of the input '${x.shape}'`);
          }
          if (tensorAccumulatedGradientMap[x.id] == null) {
            tensorAccumulatedGradientMap[x.id] = dx;
          } else {
            const curGradient = tensorAccumulatedGradientMap[x.id];
            tensorAccumulatedGradientMap[x.id] = add3(curGradient, dx);
            curGradient.dispose();
          }
        }
      }
    }
    /**
     * @license
     * Copyright 2018 Google LLC. All Rights Reserved.
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     * http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     * =============================================================================
     */
    const FORMAT_LIMIT_NUM_VALS2 = 20;
    const FORMAT_NUM_FIRST_LAST_VALS2 = 3;
    const FORMAT_NUM_SIG_DIGITS2 = 7;
    function tensorToString2(vals, shape, dtype, verbose) {
      const strides = computeStrides2(shape);
      const padPerCol = computeMaxSizePerColumn2(vals, shape, dtype, strides);
      const rank = shape.length;
      const valsLines = subTensorToString2(vals, shape, dtype, strides, padPerCol);
      const lines = ["Tensor"];
      if (verbose) {
        lines.push(`  dtype: ${dtype}`);
        lines.push(`  rank: ${rank}`);
        lines.push(`  shape: [${shape}]`);
        lines.push(`  values:`);
      }
      lines.push(valsLines.map((l) => "    " + l).join("\n"));
      return lines.join("\n");
    }
    function computeMaxSizePerColumn2(vals, shape, dtype, strides) {
      const n = sizeFromShape2(shape);
      const numCols = strides[strides.length - 1];
      const padPerCol = new Array(numCols).fill(0);
      const rank = shape.length;
      const valuesOrTuples = dtype === "complex64" ? createComplexTuples2(vals) : vals;
      if (rank > 1) {
        for (let row = 0; row < n / numCols; row++) {
          const offset = row * numCols;
          for (let j = 0; j < numCols; j++) {
            padPerCol[j] = Math.max(padPerCol[j], valToString2(valuesOrTuples[offset + j], 0, dtype).length);
          }
        }
      }
      return padPerCol;
    }
    function valToString2(val, pad3, dtype) {
      let valStr;
      if (Array.isArray(val)) {
        valStr = `${parseFloat(val[0].toFixed(FORMAT_NUM_SIG_DIGITS2))} + ${parseFloat(val[1].toFixed(FORMAT_NUM_SIG_DIGITS2))}j`;
      } else if (isString2(val)) {
        valStr = `'${val}'`;
      } else if (dtype === "bool") {
        valStr = boolNumToString2(val);
      } else {
        valStr = parseFloat(val.toFixed(FORMAT_NUM_SIG_DIGITS2)).toString();
      }
      return rightPad2(valStr, pad3);
    }
    function boolNumToString2(v) {
      return v === 0 ? "false" : "true";
    }
    function subTensorToString2(vals, shape, dtype, strides, padPerCol, isLast = true) {
      const storagePerElement = dtype === "complex64" ? 2 : 1;
      const size = shape[0];
      const rank = shape.length;
      if (rank === 0) {
        if (dtype === "complex64") {
          const complexTuple = createComplexTuples2(vals);
          return [valToString2(complexTuple[0], 0, dtype)];
        }
        if (dtype === "bool") {
          return [boolNumToString2(vals[0])];
        }
        return [vals[0].toString()];
      }
      if (rank === 1) {
        if (size > FORMAT_LIMIT_NUM_VALS2) {
          const firstValsSize = FORMAT_NUM_FIRST_LAST_VALS2 * storagePerElement;
          let firstVals = Array.from(vals.slice(0, firstValsSize));
          let lastVals = Array.from(vals.slice((size - FORMAT_NUM_FIRST_LAST_VALS2) * storagePerElement, size * storagePerElement));
          if (dtype === "complex64") {
            firstVals = createComplexTuples2(firstVals);
            lastVals = createComplexTuples2(lastVals);
          }
          return [
            "[" + firstVals.map((x, i) => valToString2(x, padPerCol[i], dtype)).join(", ") + ", ..., " + lastVals.map((x, i) => valToString2(x, padPerCol[size - FORMAT_NUM_FIRST_LAST_VALS2 + i], dtype)).join(", ") + "]"
          ];
        }
        const displayVals = dtype === "complex64" ? createComplexTuples2(vals) : Array.from(vals);
        return [
          "[" + displayVals.map((x, i) => valToString2(x, padPerCol[i], dtype)).join(", ") + "]"
        ];
      }
      const subshape = shape.slice(1);
      const substrides = strides.slice(1);
      const stride = strides[0] * storagePerElement;
      const lines = [];
      if (size > FORMAT_LIMIT_NUM_VALS2) {
        for (let i = 0; i < FORMAT_NUM_FIRST_LAST_VALS2; i++) {
          const start = i * stride;
          const end = start + stride;
          lines.push(...subTensorToString2(vals.slice(start, end), subshape, dtype, substrides, padPerCol, false));
        }
        lines.push("...");
        for (let i = size - FORMAT_NUM_FIRST_LAST_VALS2; i < size; i++) {
          const start = i * stride;
          const end = start + stride;
          lines.push(...subTensorToString2(vals.slice(start, end), subshape, dtype, substrides, padPerCol, i === size - 1));
        }
      } else {
        for (let i = 0; i < size; i++) {
          const start = i * stride;
          const end = start + stride;
          lines.push(...subTensorToString2(vals.slice(start, end), subshape, dtype, substrides, padPerCol, i === size - 1));
        }
      }
      const sep = rank === 2 ? "," : "";
      lines[0] = "[" + lines[0] + sep;
      for (let i = 1; i < lines.length - 1; i++) {
        lines[i] = " " + lines[i] + sep;
      }
      let newLineSep = ",\n";
      for (let i = 2; i < rank; i++) {
        newLineSep += "\n";
      }
      lines[lines.length - 1] = " " + lines[lines.length - 1] + "]" + (isLast ? "" : newLineSep);
      return lines;
    }
    function createComplexTuples2(vals) {
      const complexTuples = [];
      for (let i = 0; i < vals.length; i += 2) {
        complexTuples.push([vals[i], vals[i + 1]]);
      }
      return complexTuples;
    }
    /**
     * @license
     * Copyright 2017 Google LLC. All Rights Reserved.
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     * http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     * =============================================================================
     */
    class TensorBuffer2 {
      constructor(shape, dtype, values) {
        this.dtype = dtype;
        this.shape = shape.slice();
        this.size = sizeFromShape2(shape);
        if (values != null) {
          const n = values.length;
          assert2(n === this.size, () => `Length of values '${n}' does not match the size inferred by the shape '${this.size}'.`);
        }
        if (dtype === "complex64") {
          throw new Error(`complex64 dtype TensorBuffers are not supported. Please create a TensorBuffer for the real and imaginary parts separately and call tf.complex(real, imag).`);
        }
        this.values = values || getArrayFromDType2(dtype, this.size);
        this.strides = computeStrides2(shape);
      }
      set(value, ...locs) {
        if (locs.length === 0) {
          locs = [0];
        }
        assert2(locs.length === this.rank, () => `The number of provided coordinates (${locs.length}) must match the rank (${this.rank})`);
        const index2 = this.locToIndex(locs);
        this.values[index2] = value;
      }
      get(...locs) {
        if (locs.length === 0) {
          locs = [0];
        }
        let i = 0;
        for (const loc of locs) {
          if (loc < 0 || loc >= this.shape[i]) {
            const msg = `Requested out of range element at ${locs}.   Buffer shape=${this.shape}`;
            throw new Error(msg);
          }
          i++;
        }
        let index2 = locs[locs.length - 1];
        for (let i2 = 0; i2 < locs.length - 1; ++i2) {
          index2 += this.strides[i2] * locs[i2];
        }
        return this.values[index2];
      }
      locToIndex(locs) {
        if (this.rank === 0) {
          return 0;
        } else if (this.rank === 1) {
          return locs[0];
        }
        let index2 = locs[locs.length - 1];
        for (let i = 0; i < locs.length - 1; ++i) {
          index2 += this.strides[i] * locs[i];
        }
        return index2;
      }
      indexToLoc(index2) {
        if (this.rank === 0) {
          return [];
        } else if (this.rank === 1) {
          return [index2];
        }
        const locs = new Array(this.shape.length);
        for (let i = 0; i < locs.length - 1; ++i) {
          locs[i] = Math.floor(index2 / this.strides[i]);
          index2 -= locs[i] * this.strides[i];
        }
        locs[locs.length - 1] = index2;
        return locs;
      }
      get rank() {
        return this.shape.length;
      }
      toTensor() {
        return trackerFn2().makeTensor(this.values, this.shape, this.dtype);
      }
    }
    let trackerFn2 = null;
    let opHandler2 = null;
    let deprecationWarningFn2 = null;
    [deprecationWarningFn2];
    function setTensorTracker2(fn) {
      trackerFn2 = fn;
    }
    function setOpHandler(handler) {
      opHandler2 = handler;
    }
    function setDeprecationWarningFn2(fn) {
      deprecationWarningFn2 = fn;
    }
    class Tensor2 {
      constructor(shape, dtype, dataId, id) {
        this.kept = false;
        this.isDisposedInternal = false;
        this.shape = shape.slice();
        this.dtype = dtype || "float32";
        this.size = sizeFromShape2(shape);
        this.strides = computeStrides2(shape);
        this.dataId = dataId;
        this.id = id;
        this.rankType = this.rank < 5 ? this.rank.toString() : "higher";
      }
      get rank() {
        return this.shape.length;
      }
      async buffer() {
        const vals = await this.data();
        return opHandler2.buffer(this.shape, this.dtype, vals);
      }
      bufferSync() {
        return opHandler2.buffer(this.shape, this.dtype, this.dataSync());
      }
      async array() {
        const vals = await this.data();
        return toNestedArray2(this.shape, vals);
      }
      arraySync() {
        return toNestedArray2(this.shape, this.dataSync());
      }
      async data() {
        this.throwIfDisposed();
        const data2 = trackerFn2().read(this.dataId);
        if (this.dtype === "string") {
          const bytes = await data2;
          try {
            return bytes.map((b) => decodeString2(b));
          } catch (_a) {
            throw new Error("Failed to decode the string bytes into utf-8. To get the original bytes, call tensor.bytes().");
          }
        }
        return data2;
      }
      dataSync() {
        this.throwIfDisposed();
        const data2 = trackerFn2().readSync(this.dataId);
        if (this.dtype === "string") {
          try {
            return data2.map((b) => decodeString2(b));
          } catch (_a) {
            throw new Error("Failed to decode the string bytes into utf-8. To get the original bytes, call tensor.bytes().");
          }
        }
        return data2;
      }
      async bytes() {
        this.throwIfDisposed();
        const data2 = await trackerFn2().read(this.dataId);
        if (this.dtype === "string") {
          return data2;
        } else {
          return new Uint8Array(data2.buffer);
        }
      }
      dispose() {
        if (this.isDisposed) {
          return;
        }
        trackerFn2().disposeTensor(this);
        this.isDisposedInternal = true;
      }
      get isDisposed() {
        return this.isDisposedInternal;
      }
      throwIfDisposed() {
        if (this.isDisposed) {
          throw new Error(`Tensor is disposed.`);
        }
      }
      print(verbose = false) {
        return opHandler2.print(this, verbose);
      }
      clone() {
        this.throwIfDisposed();
        return opHandler2.clone(this);
      }
      toString(verbose = false) {
        const vals = this.dataSync();
        return tensorToString2(vals, this.shape, this.dtype, verbose);
      }
      cast(dtype) {
        this.throwIfDisposed();
        return opHandler2.cast(this, dtype);
      }
      variable(trainable = true, name, dtype) {
        this.throwIfDisposed();
        return trackerFn2().makeVariable(this, trainable, name, dtype);
      }
    }
    Object.defineProperty(Tensor2, Symbol.hasInstance, {
      value: (instance2) => {
        return !!instance2 && instance2.data != null && instance2.dataSync != null && instance2.throwIfDisposed != null;
      }
    });
    class Variable2 extends Tensor2 {
      constructor(initialValue, trainable, name, tensorId) {
        super(initialValue.shape, initialValue.dtype, initialValue.dataId, tensorId);
        this.trainable = trainable;
        this.name = name;
      }
      assign(newValue) {
        if (newValue.dtype !== this.dtype) {
          throw new Error(`dtype of the new value (${newValue.dtype}) and previous value (${this.dtype}) must match`);
        }
        if (!arraysEqual2(newValue.shape, this.shape)) {
          throw new Error(`shape of the new value (${newValue.shape}) and previous value (${this.shape}) must match`);
        }
        trackerFn2().disposeTensor(this);
        this.dataId = newValue.dataId;
        trackerFn2().incRef(this, null);
      }
      dispose() {
        trackerFn2().disposeVariable(this);
        this.isDisposedInternal = true;
      }
    }
    Object.defineProperty(Variable2, Symbol.hasInstance, {
      value: (instance2) => {
        return instance2 instanceof Tensor2 && instance2.assign != null && instance2.assign instanceof Function;
      }
    });
    /**
     * @license
     * Copyright 2017 Google LLC. All Rights Reserved.
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     * http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     * =============================================================================
     */
    (function(Rank2) {
      Rank2["R0"] = "R0";
      Rank2["R1"] = "R1";
      Rank2["R2"] = "R2";
      Rank2["R3"] = "R3";
      Rank2["R4"] = "R4";
      Rank2["R5"] = "R5";
      Rank2["R6"] = "R6";
    })(exports2.Rank || (exports2.Rank = {}));
    var UpcastInt32AndMap2;
    (function(UpcastInt32AndMap3) {
      UpcastInt32AndMap3["float32"] = "float32";
      UpcastInt32AndMap3["int32"] = "int32";
      UpcastInt32AndMap3["bool"] = "int32";
      UpcastInt32AndMap3["complex64"] = "complex64";
    })(UpcastInt32AndMap2 || (UpcastInt32AndMap2 = {}));
    var UpcastBoolAndMap2;
    (function(UpcastBoolAndMap3) {
      UpcastBoolAndMap3["float32"] = "float32";
      UpcastBoolAndMap3["int32"] = "int32";
      UpcastBoolAndMap3["bool"] = "bool";
      UpcastBoolAndMap3["complex64"] = "complex64";
    })(UpcastBoolAndMap2 || (UpcastBoolAndMap2 = {}));
    var UpcastFloat32AndMap2;
    (function(UpcastFloat32AndMap3) {
      UpcastFloat32AndMap3["float32"] = "float32";
      UpcastFloat32AndMap3["int32"] = "float32";
      UpcastFloat32AndMap3["bool"] = "float32";
      UpcastFloat32AndMap3["complex64"] = "complex64";
    })(UpcastFloat32AndMap2 || (UpcastFloat32AndMap2 = {}));
    var UpcastComplex64AndMap2;
    (function(UpcastComplex64AndMap3) {
      UpcastComplex64AndMap3["float32"] = "complex64";
      UpcastComplex64AndMap3["int32"] = "complex64";
      UpcastComplex64AndMap3["bool"] = "complex64";
      UpcastComplex64AndMap3["complex64"] = "complex64";
    })(UpcastComplex64AndMap2 || (UpcastComplex64AndMap2 = {}));
    const upcastTypeMap2 = {
      float32: UpcastFloat32AndMap2,
      int32: UpcastInt32AndMap2,
      bool: UpcastBoolAndMap2,
      complex64: UpcastComplex64AndMap2
    };
    function upcastType2(typeA, typeB) {
      if (typeA === "string" || typeB === "string") {
        if (typeA === "string" && typeB === "string") {
          return "string";
        }
        throw new Error(`Can not upcast ${typeA} with ${typeB}`);
      }
      return upcastTypeMap2[typeA][typeB];
    }
    function sumOutType(type) {
      return upcastType2(type, "int32");
    }
    /**
     * @license
     * Copyright 2018 Google LLC. All Rights Reserved.
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     * http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     * =============================================================================
     */
    function makeTypesMatch2(a, b) {
      if (a.dtype === b.dtype) {
        return [a, b];
      }
      const dtype = upcastType2(a.dtype, b.dtype);
      return [a.cast(dtype), b.cast(dtype)];
    }
    function assertTypesMatch(a, b) {
      assert2(a.dtype === b.dtype, () => `The dtypes of the first(${a.dtype}) and second(${b.dtype}) input must match`);
    }
    function isTensorInList(tensor7, tensorList) {
      return tensorList.some((x) => x.id === tensor7.id);
    }
    function getTensorsInContainer2(result) {
      const list = [];
      const seen = new Set();
      walkTensorContainer2(result, list, seen);
      return list;
    }
    function walkTensorContainer2(container, list, seen) {
      if (container == null) {
        return;
      }
      if (container instanceof Tensor2) {
        list.push(container);
        return;
      }
      if (!isIterable2(container)) {
        return;
      }
      const iterable = container;
      for (const k in iterable) {
        const val = iterable[k];
        if (!seen.has(val)) {
          seen.add(val);
          walkTensorContainer2(val, list, seen);
        }
      }
    }
    function isIterable2(obj) {
      return Array.isArray(obj) || typeof obj === "object";
    }
    var tensor_util3 = /* @__PURE__ */ Object.freeze({
      __proto__: null,
      makeTypesMatch: makeTypesMatch2,
      assertTypesMatch,
      isTensorInList,
      getTensorsInContainer: getTensorsInContainer2
    });
    /**
     * @license
     * Copyright 2018 Google LLC. All Rights Reserved.
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     * http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     * =============================================================================
     */
    class EngineState2 {
      constructor() {
        this.registeredVariables = {};
        this.nextTapeNodeId = 0;
        this.numBytes = 0;
        this.numTensors = 0;
        this.numStringTensors = 0;
        this.numDataBuffers = 0;
        this.gradientDepth = 0;
        this.kernelDepth = 0;
        this.scopeStack = [];
        this.numDataMovesStack = [];
        this.nextScopeId = 0;
        this.tensorInfo = new WeakMap();
        this.profiling = false;
        this.activeProfile = {newBytes: 0, newTensors: 0, peakBytes: 0, kernels: [], result: null};
      }
      dispose() {
        for (const variableName in this.registeredVariables) {
          this.registeredVariables[variableName].dispose();
        }
      }
    }
    class Engine2 {
      constructor(ENV4) {
        this.ENV = ENV4;
        this.registry = {};
        this.registryFactory = {};
        this.pendingBackendInitId = 0;
        this.state = new EngineState2();
      }
      async ready() {
        if (this.pendingBackendInit != null) {
          return this.pendingBackendInit.then(() => {
          });
        }
        if (this.backendInstance != null) {
          return;
        }
        const sortedBackends = this.getSortedBackends();
        for (let i = 0; i < sortedBackends.length; i++) {
          const backendName = sortedBackends[i];
          const success = await this.initializeBackend(backendName).success;
          if (success) {
            await this.setBackend(backendName);
            return;
          }
        }
        throw new Error(`Could not initialize any backends, all backend initializations failed.`);
      }
      get backend() {
        if (this.pendingBackendInit != null) {
          throw new Error(`Backend '${this.backendName}' has not yet been initialized. Make sure to await tf.ready() or await tf.setBackend() before calling other methods`);
        }
        if (this.backendInstance == null) {
          const {name, asyncInit} = this.initializeBackendsAndReturnBest();
          if (asyncInit) {
            throw new Error(`The highest priority backend '${name}' has not yet been initialized. Make sure to await tf.ready() or await tf.setBackend() before calling other methods`);
          }
          this.setBackend(name);
        }
        return this.backendInstance;
      }
      backendNames() {
        return Object.keys(this.registryFactory);
      }
      findBackend(backendName) {
        if (!(backendName in this.registry)) {
          if (backendName in this.registryFactory) {
            const {asyncInit} = this.initializeBackend(backendName);
            if (asyncInit) {
              return null;
            }
          } else {
            return null;
          }
        }
        return this.registry[backendName];
      }
      findBackendFactory(backendName) {
        if (!(backendName in this.registryFactory)) {
          return null;
        }
        return this.registryFactory[backendName].factory;
      }
      registerBackend(backendName, factory, priority = 1) {
        if (backendName in this.registryFactory) {
          console.warn(`${backendName} backend was already registered. Reusing existing backend factory.`);
          return false;
        }
        this.registryFactory[backendName] = {factory, priority};
        return true;
      }
      async setBackend(backendName) {
        if (this.registryFactory[backendName] == null) {
          throw new Error(`Backend name '${backendName}' not found in registry`);
        }
        this.backendName = backendName;
        if (this.registry[backendName] == null) {
          this.backendInstance = null;
          const {success, asyncInit} = this.initializeBackend(backendName);
          const result = asyncInit ? await success : success;
          if (!result) {
            return false;
          }
        }
        this.backendInstance = this.registry[backendName];
        this.setupRegisteredKernels();
        this.profiler = new Profiler2(this.backendInstance);
        return true;
      }
      setupRegisteredKernels() {
        const kernels = getKernelsForBackend2(this.backendName);
        kernels.forEach((kernel) => {
          if (kernel.setupFunc != null) {
            kernel.setupFunc(this.backendInstance);
          }
        });
      }
      disposeRegisteredKernels(backendName) {
        const kernels = getKernelsForBackend2(backendName);
        kernels.forEach((kernel) => {
          if (kernel.disposeFunc != null) {
            kernel.disposeFunc(this.registry[backendName]);
          }
        });
      }
      initializeBackend(backendName) {
        const registryFactoryEntry = this.registryFactory[backendName];
        if (registryFactoryEntry == null) {
          throw new Error(`Cannot initialize backend ${backendName}, no registration found.`);
        }
        try {
          const backend3 = registryFactoryEntry.factory();
          if (backend3 && !(backend3 instanceof KernelBackend2) && typeof backend3.then === "function") {
            const promiseId = ++this.pendingBackendInitId;
            const success = backend3.then((backendInstance) => {
              if (promiseId < this.pendingBackendInitId) {
                return false;
              }
              this.registry[backendName] = backendInstance;
              this.pendingBackendInit = null;
              return true;
            }).catch((err) => {
              if (promiseId < this.pendingBackendInitId) {
                return false;
              }
              this.pendingBackendInit = null;
              console.warn(`Initialization of backend ${backendName} failed`);
              console.warn(err.stack || err.message);
              return false;
            });
            this.pendingBackendInit = success;
            return {success, asyncInit: true};
          } else {
            this.registry[backendName] = backend3;
            return {success: true, asyncInit: false};
          }
        } catch (err) {
          console.warn(`Initialization of backend ${backendName} failed`);
          console.warn(err.stack || err.message);
          return {success: false, asyncInit: false};
        }
      }
      removeBackend(backendName) {
        if (!(backendName in this.registryFactory)) {
          throw new Error(`${backendName} backend not found in registry`);
        }
        if (this.backendName === backendName && this.pendingBackendInit != null) {
          this.pendingBackendInitId++;
        }
        if (backendName in this.registry) {
          this.disposeRegisteredKernels(backendName);
          this.registry[backendName].dispose();
          delete this.registry[backendName];
        }
        delete this.registryFactory[backendName];
        if (this.backendName === backendName) {
          this.pendingBackendInit = null;
          this.backendName = null;
          this.backendInstance = null;
        }
      }
      getSortedBackends() {
        if (Object.keys(this.registryFactory).length === 0) {
          throw new Error("No backend found in registry.");
        }
        return Object.keys(this.registryFactory).sort((a, b) => {
          return this.registryFactory[b].priority - this.registryFactory[a].priority;
        });
      }
      initializeBackendsAndReturnBest() {
        const sortedBackends = this.getSortedBackends();
        for (let i = 0; i < sortedBackends.length; i++) {
          const backendName = sortedBackends[i];
          const {success, asyncInit} = this.initializeBackend(backendName);
          if (asyncInit || success) {
            return {name: backendName, asyncInit};
          }
        }
        throw new Error(`Could not initialize any backends, all backend initializations failed.`);
      }
      moveData(backend3, dataId) {
        const info = this.state.tensorInfo.get(dataId);
        const srcBackend = info.backend;
        const values = this.readSync(dataId);
        srcBackend.disposeData(dataId);
        info.backend = backend3;
        backend3.move(dataId, values, info.shape, info.dtype);
        if (this.shouldCheckForMemLeaks()) {
          this.state.numDataMovesStack[this.state.numDataMovesStack.length - 1]++;
        }
      }
      tidy(nameOrFn, fn) {
        let name = null;
        if (fn == null) {
          if (typeof nameOrFn !== "function") {
            throw new Error("Please provide a function to tidy()");
          }
          fn = nameOrFn;
        } else {
          if (typeof nameOrFn !== "string" && !(nameOrFn instanceof String)) {
            throw new Error("When calling with two arguments, the first argument to tidy() must be a string");
          }
          if (typeof fn !== "function") {
            throw new Error("When calling with two arguments, the 2nd argument to tidy() must be a function");
          }
          name = nameOrFn;
        }
        let result;
        return this.scopedRun(() => this.startScope(name), () => this.endScope(result), () => {
          result = fn();
          if (result instanceof Promise) {
            console.error("Cannot return a Promise inside of tidy.");
          }
          return result;
        });
      }
      scopedRun(start, end, f) {
        start();
        try {
          const res = f();
          end();
          return res;
        } catch (ex) {
          end();
          throw ex;
        }
      }
      nextTensorId() {
        return Engine2.nextTensorId++;
      }
      nextVariableId() {
        return Engine2.nextVariableId++;
      }
      clone(x) {
        const y = this.makeTensorFromDataId(x.dataId, x.shape, x.dtype);
        const inputs = {x};
        const grad2 = (dy) => ({
          x: () => {
            const dtype = "float32";
            const gradInputs = {x: dy};
            const attrs = {dtype};
            return ENGINE2.runKernelFunc((backend3) => backend3.cast(dy, dtype), gradInputs, null, Cast5, attrs);
          }
        });
        const saved = [];
        this.addTapeNode(this.state.activeScope.name, inputs, [y], grad2, saved, {});
        return y;
      }
      runKernel(kernelName, inputs, attrs, inputsToSave, outputsToSave) {
        const forwardFunc = null;
        const backwardsFunc = null;
        return this.runKernelFunc(forwardFunc, inputs, backwardsFunc, kernelName, attrs, inputsToSave, outputsToSave);
      }
      shouldCheckForMemLeaks() {
        return this.ENV.getBool("IS_TEST");
      }
      checkKernelForMemLeak(kernelName, numDataIdsBefore, outInfos) {
        const numDataIdsAfter = this.backend.numDataIds();
        let numOutputDataIds = 0;
        outInfos.forEach((info) => {
          numOutputDataIds += info.dtype === "complex64" ? 3 : 1;
        });
        const numMoves = this.state.numDataMovesStack[this.state.numDataMovesStack.length - 1];
        const dataIdsLeaked = numDataIdsAfter - numDataIdsBefore - numOutputDataIds - numMoves;
        if (dataIdsLeaked > 0) {
          throw new Error(`Backend '${this.backendName}' has an internal memory leak (${dataIdsLeaked} data ids) after running '${kernelName}'`);
        }
      }
      runKernelFunc(forwardFunc, inputs, backwardsFunc, kernelName, attrs, inputsToSave, outputsToSave) {
        let outputs;
        let saved = [];
        const isTapeOn = this.isTapeOn();
        if (kernelName == null) {
          kernelName = this.state.activeScope != null ? this.state.activeScope.name : "";
        }
        const startingBytecount = this.state.numBytes;
        const startingNumTensors = this.state.numTensors;
        if (this.shouldCheckForMemLeaks()) {
          this.state.numDataMovesStack.push(0);
        }
        let kernelFunc3;
        const kernel = getKernel2(kernelName, this.backendName);
        let out;
        if (kernel != null) {
          kernelFunc3 = () => {
            const numDataIdsBefore = this.backend.numDataIds();
            out = kernel.kernelFunc({inputs, attrs, backend: this.backend});
            const outInfos = Array.isArray(out) ? out : [out];
            if (this.shouldCheckForMemLeaks()) {
              this.checkKernelForMemLeak(kernelName, numDataIdsBefore, outInfos);
            }
            const outTensors = outInfos.map(({dataId, shape, dtype}) => this.makeTensorFromDataId(dataId, shape, dtype));
            if (isTapeOn) {
              let tensorsToSave = this.getTensorsForGradient(kernelName, inputs, outTensors);
              if (tensorsToSave == null) {
                if (outputsToSave == null) {
                  outputsToSave = [];
                }
                const outsToSave = outTensors.filter((_, i) => outputsToSave[i]);
                tensorsToSave = (inputsToSave || []).slice().concat(outsToSave);
              }
              saved = this.saveTensorsForBackwardMode(tensorsToSave);
            }
            return outTensors;
          };
        } else {
          const saveFunc = (tensors) => {
            if (!isTapeOn) {
              return;
            }
            saved = tensors.map((tensor7) => this.keep(this.clone(tensor7)));
          };
          kernelFunc3 = () => {
            const numDataIdsBefore = this.backend.numDataIds();
            out = this.tidy(() => forwardFunc(this.backend, saveFunc));
            const outs = Array.isArray(out) ? out : [out];
            if (this.shouldCheckForMemLeaks()) {
              this.checkKernelForMemLeak(kernelName, numDataIdsBefore, outs);
            }
            return outs;
          };
        }
        let kernelProfile;
        this.scopedRun(() => this.state.kernelDepth++, () => this.state.kernelDepth--, () => {
          if (!this.ENV.getBool("DEBUG") && !this.state.profiling) {
            outputs = kernelFunc3();
          } else {
            kernelProfile = this.profiler.profileKernel(kernelName, inputs, () => kernelFunc3());
            if (this.ENV.getBool("DEBUG")) {
              this.profiler.logKernelProfile(kernelProfile);
            }
            outputs = kernelProfile.outputs;
          }
        });
        if (isTapeOn) {
          this.addTapeNode(kernelName, inputs, outputs, backwardsFunc, saved, attrs);
        }
        if (this.state.profiling) {
          this.state.activeProfile.kernels.push({
            name: kernelName,
            bytesAdded: this.state.numBytes - startingBytecount,
            totalBytesSnapshot: this.state.numBytes,
            tensorsAdded: this.state.numTensors - startingNumTensors,
            totalTensorsSnapshot: this.state.numTensors,
            inputShapes: Object.keys(inputs).map((key) => inputs[key] != null ? inputs[key].shape : null),
            outputShapes: outputs.map((item) => item.shape),
            kernelTimeMs: kernelProfile.timeMs,
            extraInfo: kernelProfile.extraInfo
          });
        }
        return Array.isArray(out) ? outputs : outputs[0];
      }
      saveTensorsForBackwardMode(tensors) {
        const saved = tensors.map((tensor7) => this.keep(this.clone(tensor7)));
        return saved;
      }
      getTensorsForGradient(kernelName, inputs, outputs) {
        const gradConfig = getGradient2(kernelName);
        if (gradConfig != null) {
          const inputsToSave = gradConfig.inputsToSave || [];
          const outputsToSave = gradConfig.outputsToSave || [];
          let inputTensorsToSave;
          if (gradConfig.saveAllInputs) {
            assert2(Array.isArray(inputs), () => "saveAllInputs is true, expected inputs to be an array.");
            inputTensorsToSave = Object.keys(inputs).map((key) => inputs[key]);
          } else {
            inputTensorsToSave = inputsToSave.map((inputName) => inputs[inputName]);
          }
          const outputTensorsToSave = outputs.filter((_, i) => outputsToSave[i]);
          return inputTensorsToSave.concat(outputTensorsToSave);
        }
        return null;
      }
      makeTensor(values, shape, dtype, backend3) {
        if (values == null) {
          throw new Error("Values passed to engine.makeTensor() are null");
        }
        dtype = dtype || "float32";
        backend3 = backend3 || this.backend;
        let backendVals = values;
        if (dtype === "string" && isString2(values[0])) {
          backendVals = values.map((d) => encodeString2(d));
        }
        const dataId = backend3.write(backendVals, shape, dtype);
        const t = new Tensor2(shape, dtype, dataId, this.nextTensorId());
        this.incRef(t, backend3);
        if (dtype === "string") {
          const info = this.state.tensorInfo.get(dataId);
          const newBytes = bytesFromStringArray2(backendVals);
          this.state.numBytes += newBytes - info.bytes;
          info.bytes = newBytes;
        }
        return t;
      }
      makeTensorFromDataId(dataId, shape, dtype, backend3) {
        dtype = dtype || "float32";
        const t = new Tensor2(shape, dtype, dataId, this.nextTensorId());
        this.incRef(t, backend3);
        return t;
      }
      makeVariable(initialValue, trainable = true, name, dtype) {
        name = name || this.nextVariableId().toString();
        if (dtype != null && dtype !== initialValue.dtype) {
          initialValue = initialValue.cast(dtype);
        }
        const v = new Variable2(initialValue, trainable, name, this.nextTensorId());
        if (this.state.registeredVariables[v.name] != null) {
          throw new Error(`Variable with name ${v.name} was already registered`);
        }
        this.state.registeredVariables[v.name] = v;
        this.incRef(v, this.backend);
        return v;
      }
      incRef(a, backend3) {
        const refCount = this.state.tensorInfo.has(a.dataId) ? this.state.tensorInfo.get(a.dataId).refCount : 0;
        this.state.numTensors++;
        if (a.dtype === "string") {
          this.state.numStringTensors++;
        }
        if (refCount === 0) {
          this.state.numDataBuffers++;
          let bytes = 0;
          if (a.dtype !== "complex64" && a.dtype !== "string") {
            bytes = a.size * bytesPerElement2(a.dtype);
          }
          this.state.tensorInfo.set(a.dataId, {
            backend: backend3 || this.backend,
            dtype: a.dtype,
            shape: a.shape,
            bytes,
            refCount: 0
          });
          this.state.numBytes += bytes;
        }
        this.state.tensorInfo.get(a.dataId).refCount++;
        if (!(a instanceof Variable2)) {
          this.track(a);
        }
      }
      disposeTensor(a) {
        if (!this.state.tensorInfo.has(a.dataId)) {
          return;
        }
        this.state.numTensors--;
        if (a.dtype === "string") {
          this.state.numStringTensors--;
        }
        const info = this.state.tensorInfo.get(a.dataId);
        const refCount = info.refCount;
        if (refCount <= 1) {
          if (a.dtype !== "complex64") {
            this.state.numBytes -= info.bytes;
          }
          this.state.numDataBuffers--;
          info.backend.disposeData(a.dataId);
          this.state.tensorInfo.delete(a.dataId);
        } else {
          this.state.tensorInfo.get(a.dataId).refCount--;
        }
      }
      disposeVariables() {
        for (const varName in this.state.registeredVariables) {
          const v = this.state.registeredVariables[varName];
          this.disposeVariable(v);
        }
      }
      disposeVariable(v) {
        this.disposeTensor(v);
        if (this.state.registeredVariables[v.name] != null) {
          delete this.state.registeredVariables[v.name];
        }
      }
      memory() {
        const info = this.backend.memory();
        info.numTensors = this.state.numTensors;
        info.numDataBuffers = this.state.numDataBuffers;
        info.numBytes = this.state.numBytes;
        if (this.state.numStringTensors > 0) {
          info.unreliable = true;
          if (info.reasons == null) {
            info.reasons = [];
          }
          info.reasons.push("Memory usage by string tensors is approximate (2 bytes per character)");
        }
        return info;
      }
      async profile(query) {
        this.state.profiling = true;
        const startBytes = this.state.numBytes;
        const startNumTensors = this.state.numTensors;
        this.state.activeProfile.kernels = [];
        this.state.activeProfile.result = await query();
        this.state.profiling = false;
        this.state.activeProfile.peakBytes = Math.max(...this.state.activeProfile.kernels.map((d) => d.totalBytesSnapshot));
        this.state.activeProfile.newBytes = this.state.numBytes - startBytes;
        this.state.activeProfile.newTensors = this.state.numTensors - startNumTensors;
        for (const kernel of this.state.activeProfile.kernels) {
          kernel.kernelTimeMs = await kernel.kernelTimeMs;
          kernel.extraInfo = await kernel.extraInfo;
        }
        return this.state.activeProfile;
      }
      isTapeOn() {
        return this.state.gradientDepth > 0 && this.state.kernelDepth === 0;
      }
      addTapeNode(kernelName, inputs, outputs, gradientsFunc, saved, attrs) {
        const tapeNode = {id: this.state.nextTapeNodeId++, kernelName, inputs, outputs, saved};
        const gradConfig = getGradient2(kernelName);
        if (gradConfig != null) {
          gradientsFunc = gradConfig.gradFunc;
        }
        if (gradientsFunc != null) {
          tapeNode.gradient = (dys) => {
            dys = dys.map((dy, i) => {
              if (dy == null) {
                const output = outputs[i];
                const vals = makeZerosTypedArray2(output.size, output.dtype);
                return this.makeTensor(vals, output.shape, output.dtype);
              }
              return dy;
            });
            return gradientsFunc(dys.length > 1 ? dys : dys[0], saved, attrs);
          };
        }
        this.state.activeTape.push(tapeNode);
      }
      keep(result) {
        result.kept = true;
        return result;
      }
      startTape() {
        if (this.state.gradientDepth === 0) {
          this.state.activeTape = [];
        }
        this.state.gradientDepth++;
      }
      endTape() {
        this.state.gradientDepth--;
      }
      startScope(name) {
        const scopeInfo = {
          track: [],
          name: "unnamed scope",
          id: this.state.nextScopeId++
        };
        if (name) {
          scopeInfo.name = name;
        }
        this.state.scopeStack.push(scopeInfo);
        this.state.activeScope = scopeInfo;
      }
      endScope(result) {
        const tensorsToTrackInParent = getTensorsInContainer2(result);
        const tensorsToTrackInParentSet = new Set(tensorsToTrackInParent.map((t) => t.id));
        for (let i = 0; i < this.state.activeScope.track.length; i++) {
          const tensor7 = this.state.activeScope.track[i];
          if (!tensor7.kept && !tensorsToTrackInParentSet.has(tensor7.id)) {
            tensor7.dispose();
          }
        }
        const oldScope = this.state.scopeStack.pop();
        this.state.activeScope = this.state.scopeStack.length === 0 ? null : this.state.scopeStack[this.state.scopeStack.length - 1];
        tensorsToTrackInParent.forEach((tensor7) => {
          if (!tensor7.kept && tensor7.scopeId === oldScope.id) {
            this.track(tensor7);
          }
        });
      }
      gradients(f, xs, dy, allowNoGradients = false) {
        assert2(xs.length > 0, () => "gradients() received an empty list of xs.");
        if (dy != null && dy.dtype !== "float32") {
          throw new Error(`dy must have 'float32' dtype, but has '${dy.dtype}'`);
        }
        const y = this.scopedRun(() => this.startTape(), () => this.endTape(), () => this.tidy("forward", f));
        assert2(y instanceof Tensor2, () => "The result y returned by f() must be a tensor.");
        const filteredTape = getFilteredNodesXToY2(this.state.activeTape, xs, y);
        if (!allowNoGradients && filteredTape.length === 0 && xs.length > 0) {
          throw new Error("Cannot compute gradient of y=f(x) with respect to x. Make sure that the f you passed encloses all operations that lead from x to y.");
        }
        return this.tidy("backward", () => {
          const accumulatedGradientMap = {};
          accumulatedGradientMap[y.id] = dy == null ? ones2(y.shape) : dy;
          backpropagateGradients2(accumulatedGradientMap, filteredTape, (f2) => this.tidy(f2), add2);
          const grads2 = xs.map((x) => accumulatedGradientMap[x.id]);
          if (this.state.gradientDepth === 0) {
            this.state.activeTape.forEach((node) => {
              for (const tensor7 of node.saved) {
                tensor7.dispose();
              }
            });
            this.state.activeTape = null;
          }
          return {value: y, grads: grads2};
        });
      }
      customGrad(f) {
        assert2(isFunction2(f), () => "The f passed in customGrad(f) must be a function.");
        return (...inputs) => {
          assert2(inputs.every((t) => t instanceof Tensor2), () => "The args passed in customGrad(f)(x1, x2,...) must all be tensors");
          let res;
          const inputMap = {};
          inputs.forEach((input2, i) => {
            inputMap[i] = input2;
          });
          return this.runKernelFunc((_, save) => {
            res = f(...[...inputs, save]);
            assert2(res.value instanceof Tensor2, () => "The function f passed in customGrad(f) must return an object where `obj.value` is a tensor");
            assert2(isFunction2(res.gradFunc), () => "The function f passed in customGrad(f) must return an object where `obj.gradFunc` is a function.");
            return res.value;
          }, inputMap, (dy, saved) => {
            const gradRes = res.gradFunc(dy, saved);
            const grads2 = Array.isArray(gradRes) ? gradRes : [gradRes];
            assert2(grads2.length === inputs.length, () => "The function f passed in customGrad(f) must return an object where `obj.gradFunc` is a function that returns the same number of tensors as inputs passed to f(...).");
            assert2(grads2.every((t) => t instanceof Tensor2), () => "The function f passed in customGrad(f) must return an object where `obj.gradFunc` is a function that returns a list of only tensors.");
            const gradMap = {};
            grads2.forEach((grad2, i) => {
              gradMap[i] = () => grad2;
            });
            return gradMap;
          });
        };
      }
      readSync(dataId) {
        const info = this.state.tensorInfo.get(dataId);
        return info.backend.readSync(dataId);
      }
      read(dataId) {
        const info = this.state.tensorInfo.get(dataId);
        return info.backend.read(dataId);
      }
      async time(query) {
        const start = now3();
        const timingInfo = await this.backend.time(query);
        timingInfo.wallMs = now3() - start;
        return timingInfo;
      }
      track(result) {
        if (this.state.activeScope != null) {
          result.scopeId = this.state.activeScope.id;
          this.state.activeScope.track.push(result);
        }
        return result;
      }
      get registeredVariables() {
        return this.state.registeredVariables;
      }
      reset() {
        this.pendingBackendInitId++;
        this.state.dispose();
        this.ENV.reset();
        this.state = new EngineState2();
        for (const backendName in this.registry) {
          this.disposeRegisteredKernels(backendName);
          this.registry[backendName].dispose();
          delete this.registry[backendName];
        }
        this.backendName = null;
        this.backendInstance = null;
        this.pendingBackendInit = null;
      }
    }
    Engine2.nextTensorId = 0;
    Engine2.nextVariableId = 0;
    function ones2(shape) {
      const values = makeOnesTypedArray2(sizeFromShape2(shape), "float32");
      return ENGINE2.makeTensor(values, shape, "float32");
    }
    function getOrMakeEngine2() {
      const ns = getGlobalNamespace2();
      if (ns._tfengine == null) {
        const environment6 = new Environment2(ns);
        ns._tfengine = new Engine2(environment6);
      }
      setEnvironmentGlobal2(ns._tfengine.ENV);
      setTensorTracker2(() => ns._tfengine);
      return ns._tfengine;
    }
    const ENGINE2 = getOrMakeEngine2();
    function add2(a, b) {
      const inputs = {a, b};
      return ENGINE2.runKernelFunc((backend3, save) => {
        const res = backend3.add(a, b);
        save([a, b]);
        return res;
      }, inputs, null, Add3);
    }
    /**
     * @license
     * Copyright 2017 Google LLC. All Rights Reserved.
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     * http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     * =============================================================================
     */
    function _isNavigatorDefined() {
      return typeof navigator !== "undefined" && navigator != null;
    }
    function isMobile() {
      if (_isNavigatorDefined()) {
        const a = navigator.userAgent || navigator.vendor || window.opera;
        return /(android|bb\d+|meego).+mobile|avantgo|bada\/|blackberry|blazer|compal|elaine|fennec|hiptop|iemobile|ip(hone|od)|iris|kindle|lge |maemo|midp|mmp|mobile.+firefox|netfront|opera m(ob|in)i|palm( os)?|phone|p(ixi|re)\/|plucker|pocket|psp|series(4|6)0|symbian|treo|up\.(browser|link)|vodafone|wap|windows ce|xda|xiino/i.test(a) || /1207|6310|6590|3gso|4thp|50[1-6]i|770s|802s|a wa|abac|ac(er|oo|s\-)|ai(ko|rn)|al(av|ca|co)|amoi|an(ex|ny|yw)|aptu|ar(ch|go)|as(te|us)|attw|au(di|\-m|r |s )|avan|be(ck|ll|nq)|bi(lb|rd)|bl(ac|az)|br(e|v)w|bumb|bw\-(n|u)|c55\/|capi|ccwa|cdm\-|cell|chtm|cldc|cmd\-|co(mp|nd)|craw|da(it|ll|ng)|dbte|dc\-s|devi|dica|dmob|do(c|p)o|ds(12|\-d)|el(49|ai)|em(l2|ul)|er(ic|k0)|esl8|ez([4-7]0|os|wa|ze)|fetc|fly(\-|_)|g1 u|g560|gene|gf\-5|g\-mo|go(\.w|od)|gr(ad|un)|haie|hcit|hd\-(m|p|t)|hei\-|hi(pt|ta)|hp( i|ip)|hs\-c|ht(c(\-| |_|a|g|p|s|t)|tp)|hu(aw|tc)|i\-(20|go|ma)|i230|iac( |\-|\/)|ibro|idea|ig01|ikom|im1k|inno|ipaq|iris|ja(t|v)a|jbro|jemu|jigs|kddi|keji|kgt( |\/)|klon|kpt |kwc\-|kyo(c|k)|le(no|xi)|lg( g|\/(k|l|u)|50|54|\-[a-w])|libw|lynx|m1\-w|m3ga|m50\/|ma(te|ui|xo)|mc(01|21|ca)|m\-cr|me(rc|ri)|mi(o8|oa|ts)|mmef|mo(01|02|bi|de|do|t(\-| |o|v)|zz)|mt(50|p1|v )|mwbp|mywa|n10[0-2]|n20[2-3]|n30(0|2)|n50(0|2|5)|n7(0(0|1)|10)|ne((c|m)\-|on|tf|wf|wg|wt)|nok(6|i)|nzph|o2im|op(ti|wv)|oran|owg1|p800|pan(a|d|t)|pdxg|pg(13|\-([1-8]|c))|phil|pire|pl(ay|uc)|pn\-2|po(ck|rt|se)|prox|psio|pt\-g|qa\-a|qc(07|12|21|32|60|\-[2-7]|i\-)|qtek|r380|r600|raks|rim9|ro(ve|zo)|s55\/|sa(ge|ma|mm|ms|ny|va)|sc(01|h\-|oo|p\-)|sdk\/|se(c(\-|0|1)|47|mc|nd|ri)|sgh\-|shar|sie(\-|m)|sk\-0|sl(45|id)|sm(al|ar|b3|it|t5)|so(ft|ny)|sp(01|h\-|v\-|v )|sy(01|mb)|t2(18|50)|t6(00|10|18)|ta(gt|lk)|tcl\-|tdg\-|tel(i|m)|tim\-|t\-mo|to(pl|sh)|ts(70|m\-|m3|m5)|tx\-9|up(\.b|g1|si)|utst|v400|v750|veri|vi(rg|te)|vk(40|5[0-3]|\-v)|vm40|voda|vulc|vx(52|53|60|61|70|80|81|83|85|98)|w3c(\-| )|webc|whit|wi(g |nc|nw)|wmlb|wonu|x700|yas\-|your|zeto|zte\-/i.test(a.substr(0, 4));
      }
      return false;
    }
    function isBrowser() {
      return typeof window !== "undefined" && window.document != null || typeof WorkerGlobalScope !== "undefined";
    }
    var device_util = /* @__PURE__ */ Object.freeze({
      __proto__: null,
      isMobile,
      isBrowser
    });
    /**
     * @license
     * Copyright 2019 Google LLC. All Rights Reserved.
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     * http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     * =============================================================================
     */
    const ENV3 = env2();
    ENV3.registerFlag("DEBUG", () => false, (debugValue) => {
      if (debugValue) {
        console.warn("Debugging mode is ON. The output of every math call will be downloaded to CPU and checked for NaNs. This significantly impacts performance.");
      }
    });
    ENV3.registerFlag("IS_BROWSER", () => isBrowser());
    ENV3.registerFlag("IS_NODE", () => typeof process !== "undefined" && typeof process.versions !== "undefined" && typeof process.versions.node !== "undefined");
    ENV3.registerFlag("IS_CHROME", () => typeof navigator !== "undefined" && navigator != null && navigator.userAgent != null && /Chrome/.test(navigator.userAgent) && /Google Inc/.test(navigator.vendor));
    ENV3.registerFlag("PROD", () => false);
    ENV3.registerFlag("TENSORLIKE_CHECK_SHAPE_CONSISTENCY", () => ENV3.getBool("DEBUG"));
    ENV3.registerFlag("DEPRECATION_WARNINGS_ENABLED", () => true);
    ENV3.registerFlag("IS_TEST", () => false);
    /**
     * @license
     * Copyright 2018 Google LLC. All Rights Reserved.
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     * http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     * =============================================================================
     */
    function inferShape2(val, dtype) {
      let firstElem = val;
      if (isTypedArray2(val)) {
        return dtype === "string" ? [] : [val.length];
      }
      if (!Array.isArray(val)) {
        return [];
      }
      const shape = [];
      while (Array.isArray(firstElem) || isTypedArray2(firstElem) && dtype !== "string") {
        shape.push(firstElem.length);
        firstElem = firstElem[0];
      }
      if (Array.isArray(val) && env2().getBool("TENSORLIKE_CHECK_SHAPE_CONSISTENCY")) {
        deepAssertShapeConsistency2(val, shape, []);
      }
      return shape;
    }
    function deepAssertShapeConsistency2(val, shape, indices) {
      indices = indices || [];
      if (!Array.isArray(val) && !isTypedArray2(val)) {
        assert2(shape.length === 0, () => `Element arr[${indices.join("][")}] is a primitive, but should be an array/TypedArray of ${shape[0]} elements`);
        return;
      }
      assert2(shape.length > 0, () => `Element arr[${indices.join("][")}] should be a primitive, but is an array of ${val.length} elements`);
      assert2(val.length === shape[0], () => `Element arr[${indices.join("][")}] should have ${shape[0]} elements, but has ${val.length} elements`);
      const subShape = shape.slice(1);
      for (let i = 0; i < val.length; ++i) {
        deepAssertShapeConsistency2(val[i], subShape, indices.concat(i));
      }
    }
    function assertDtype2(expectedDtype, actualDType, argName, functionName) {
      if (expectedDtype == null) {
        return;
      }
      if (expectedDtype !== "numeric" && expectedDtype !== actualDType || expectedDtype === "numeric" && actualDType === "string") {
        throw new Error(`Argument '${argName}' passed to '${functionName}' must be ${expectedDtype} tensor, but got ${actualDType} tensor`);
      }
    }
    function convertToTensor2(x, argName, functionName, parseAsDtype = "numeric") {
      if (x instanceof Tensor2) {
        assertDtype2(parseAsDtype, x.dtype, argName, functionName);
        return x;
      }
      let inferredDtype = inferDtype2(x);
      if (inferredDtype !== "string" && ["bool", "int32", "float32"].indexOf(parseAsDtype) >= 0) {
        inferredDtype = parseAsDtype;
      }
      assertDtype2(parseAsDtype, inferredDtype, argName, functionName);
      if (x == null || !isTypedArray2(x) && !Array.isArray(x) && typeof x !== "number" && typeof x !== "boolean" && typeof x !== "string") {
        const type = x == null ? "null" : x.constructor.name;
        throw new Error(`Argument '${argName}' passed to '${functionName}' must be a Tensor or TensorLike, but got '${type}'`);
      }
      const inferredShape = inferShape2(x, inferredDtype);
      if (!isTypedArray2(x) && !Array.isArray(x)) {
        x = [x];
      }
      const skipTypedArray = true;
      const values = inferredDtype !== "string" ? toTypedArray2(x, inferredDtype) : flatten2(x, [], skipTypedArray);
      return ENGINE2.makeTensor(values, inferredShape, inferredDtype);
    }
    function convertToTensorArray(arg, argName, functionName, parseAsDtype = "numeric") {
      if (!Array.isArray(arg)) {
        throw new Error(`Argument ${argName} passed to ${functionName} must be a \`Tensor[]\` or \`TensorLike[]\``);
      }
      const tensors = arg;
      return tensors.map((t, i) => convertToTensor2(t, `${argName}[${i}]`, functionName), parseAsDtype);
    }
    /**
     * @license
     * Copyright 2018 Google LLC. All Rights Reserved.
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     * http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     * =============================================================================
     */
    const OP_SCOPE_SUFFIX2 = "__op";
    function op2(f) {
      const keys = Object.keys(f);
      if (keys.length !== 1) {
        throw new Error(`Please provide an object with a single key (operation name) mapping to a function. Got an object with ${keys.length} keys.`);
      }
      let opName = keys[0];
      const fn = f[opName];
      if (opName.endsWith("_")) {
        opName = opName.substring(0, opName.length - 1);
      }
      opName = opName + OP_SCOPE_SUFFIX2;
      const f2 = (...args) => {
        ENGINE2.startScope(opName);
        try {
          const result = fn(...args);
          if (isPromise2(result)) {
            console.error("Cannot return a Promise inside of tidy.");
          }
          ENGINE2.endScope(result);
          return result;
        } catch (ex) {
          ENGINE2.endScope(null);
          throw ex;
        }
      };
      Object.defineProperty(f2, "name", {value: opName, configurable: true});
      return f2;
    }
    /**
     * @license
     * Copyright 2020 Google LLC. All Rights Reserved.
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     * http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     * =============================================================================
     */
    function complex_2(real2, imag2) {
      const $real = convertToTensor2(real2, "real", "complex");
      const $imag = convertToTensor2(imag2, "imag", "complex");
      assertShapesMatch2($real.shape, $imag.shape, `real and imag shapes, ${$real.shape} and ${$imag.shape}, must match in call to tf.complex().`);
      const forward = (backend3) => {
        return backend3.complex($real, $imag);
      };
      const inputs = {real: $real, imag: $imag};
      return ENGINE2.runKernelFunc(forward, inputs, null, Complex2);
    }
    const complex3 = op2({complex_: complex_2});
    /**
     * @license
     * Copyright 2018 Google LLC. All Rights Reserved.
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     * http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     * =============================================================================
     */
    function makeTensor2(values, shape, inferredShape, dtype) {
      if (dtype == null) {
        dtype = inferDtype2(values);
      }
      if (dtype === "complex64") {
        throw new Error(`Cannot construct a complex64 tensor directly. Please use tf.complex(real, imag).`);
      }
      if (!isTypedArray2(values) && !Array.isArray(values) && typeof values !== "number" && typeof values !== "boolean" && typeof values !== "string") {
        throw new Error("values passed to tensor(values) must be a number/boolean/string or an array of numbers/booleans/strings, or a TypedArray");
      }
      if (shape != null) {
        assertNonNegativeIntegerDimensions2(shape);
        const providedSize = sizeFromShape2(shape);
        const inferredSize = sizeFromShape2(inferredShape);
        assert2(providedSize === inferredSize, () => `Based on the provided shape, [${shape}], the tensor should have ${providedSize} values but has ${inferredSize}`);
        for (let i = 0; i < inferredShape.length; ++i) {
          const inferred = inferredShape[i];
          const flatDimsDontMatch = i === inferredShape.length - 1 ? inferred !== sizeFromShape2(shape.slice(i)) : true;
          assert2(inferredShape[i] === shape[i] || !flatDimsDontMatch, () => `Error creating a new Tensor. Inferred shape (${inferredShape}) does not match the provided shape (${shape}). `);
        }
      }
      if (!isTypedArray2(values) && !Array.isArray(values)) {
        values = [values];
      }
      shape = shape || inferredShape;
      values = dtype !== "string" ? toTypedArray2(values, dtype) : flatten2(values, [], true);
      return ENGINE2.makeTensor(values, shape, dtype);
    }
    /**
     * @license
     * Copyright 2018 Google LLC. All Rights Reserved.
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     * http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     * =============================================================================
     */
    function tensor6(values, shape, dtype) {
      const inferredShape = inferShape2(values, dtype);
      return makeTensor2(values, shape, inferredShape, dtype);
    }
    /**
     * @license
     * Copyright 2018 Google LLC. All Rights Reserved.
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     * http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     * =============================================================================
     */
    const DTYPE_VALUE_SIZE_MAP = {
      float32: 4,
      float16: 2,
      int32: 4,
      uint16: 2,
      uint8: 1,
      bool: 1,
      complex64: 8
    };
    /**
     * @license
     * Copyright 2018 Google LLC. All Rights Reserved.
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     * http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     * =============================================================================
     */
    const NUM_BYTES_STRING_LENGTH = 4;
    async function encodeWeights(tensors, group) {
      const specs = [];
      const dataPromises = [];
      const names = Array.isArray(tensors) ? tensors.map((tensor7) => tensor7.name) : Object.keys(tensors);
      for (let i = 0; i < names.length; ++i) {
        const name = names[i];
        const t = Array.isArray(tensors) ? tensors[i].tensor : tensors[name];
        if (t.dtype !== "float32" && t.dtype !== "int32" && t.dtype !== "bool" && t.dtype !== "string" && t.dtype !== "complex64") {
          throw new Error(`Unsupported dtype in weight '${name}': ${t.dtype}`);
        }
        const spec = {name, shape: t.shape, dtype: t.dtype};
        if (t.dtype === "string") {
          const utf8bytes = new Promise(async (resolve) => {
            const vals = await t.bytes();
            const totalNumBytes = vals.reduce((p2, c) => p2 + c.length, 0) + NUM_BYTES_STRING_LENGTH * vals.length;
            const bytes = new Uint8Array(totalNumBytes);
            let offset = 0;
            for (let i2 = 0; i2 < vals.length; i2++) {
              const val = vals[i2];
              const bytesOfLength = new Uint8Array(new Uint32Array([val.length]).buffer);
              bytes.set(bytesOfLength, offset);
              offset += NUM_BYTES_STRING_LENGTH;
              bytes.set(val, offset);
              offset += val.length;
            }
            resolve(bytes);
          });
          dataPromises.push(utf8bytes);
        } else {
          dataPromises.push(t.data());
        }
        if (group != null) {
          spec.group = group;
        }
        specs.push(spec);
      }
      const tensorValues = await Promise.all(dataPromises);
      return {data: concatenateTypedArrays(tensorValues), specs};
    }
    function decodeWeights(buffer3, specs) {
      const out = {};
      let float16Decode;
      let offset = 0;
      for (const spec of specs) {
        const name = spec.name;
        const dtype = spec.dtype;
        const shape = spec.shape;
        const size = sizeFromShape2(shape);
        let values;
        if ("quantization" in spec) {
          const quantization = spec.quantization;
          if (quantization.dtype === "uint8" || quantization.dtype === "uint16") {
            if (!("min" in quantization && "scale" in quantization)) {
              throw new Error(`Weight ${spec.name} with quantization ${quantization.dtype} doesn't have corresponding metadata min and scale.`);
            }
          } else if (quantization.dtype === "float16") {
            if (dtype !== "float32") {
              throw new Error(`Weight ${spec.name} is quantized with ${quantization.dtype} which only supports weights of type float32 not ${dtype}.`);
            }
          } else {
            throw new Error(`Weight ${spec.name} has unknown quantization dtype ${quantization.dtype}. Supported quantization dtypes are: 'uint8', 'uint16', and 'float16'.`);
          }
          const quantizationSizeFactor = DTYPE_VALUE_SIZE_MAP[quantization.dtype];
          const byteBuffer = buffer3.slice(offset, offset + size * quantizationSizeFactor);
          const quantizedArray = quantization.dtype === "uint8" ? new Uint8Array(byteBuffer) : new Uint16Array(byteBuffer);
          if (dtype === "float32") {
            if (quantization.dtype === "uint8" || quantization.dtype === "uint16") {
              values = new Float32Array(quantizedArray.length);
              for (let i = 0; i < quantizedArray.length; i++) {
                const v = quantizedArray[i];
                values[i] = v * quantization.scale + quantization.min;
              }
            } else if (quantization.dtype === "float16") {
              if (float16Decode === void 0) {
                float16Decode = getFloat16Decoder();
              }
              values = float16Decode(quantizedArray);
            } else {
              throw new Error(`Unsupported quantization type ${quantization.dtype} for weight type float32.`);
            }
          } else if (dtype === "int32") {
            if (quantization.dtype !== "uint8" && quantization.dtype !== "uint16") {
              throw new Error(`Unsupported quantization type ${quantization.dtype} for weight type int32.`);
            }
            values = new Int32Array(quantizedArray.length);
            for (let i = 0; i < quantizedArray.length; i++) {
              const v = quantizedArray[i];
              values[i] = Math.round(v * quantization.scale + quantization.min);
            }
          } else {
            throw new Error(`Unsupported dtype in weight '${name}': ${dtype}`);
          }
          offset += size * quantizationSizeFactor;
        } else if (dtype === "string") {
          const size2 = sizeFromShape2(spec.shape);
          values = [];
          for (let i = 0; i < size2; i++) {
            const byteLength = new Uint32Array(buffer3.slice(offset, offset + NUM_BYTES_STRING_LENGTH))[0];
            offset += NUM_BYTES_STRING_LENGTH;
            const bytes = new Uint8Array(buffer3.slice(offset, offset + byteLength));
            values.push(bytes);
            offset += byteLength;
          }
        } else {
          const dtypeFactor = DTYPE_VALUE_SIZE_MAP[dtype];
          const byteBuffer = buffer3.slice(offset, offset + size * dtypeFactor);
          if (dtype === "float32") {
            values = new Float32Array(byteBuffer);
          } else if (dtype === "int32") {
            values = new Int32Array(byteBuffer);
          } else if (dtype === "bool") {
            values = new Uint8Array(byteBuffer);
          } else if (dtype === "complex64") {
            values = new Float32Array(byteBuffer);
            const real2 = new Float32Array(values.length / 2);
            const image3 = new Float32Array(values.length / 2);
            for (let i = 0; i < real2.length; i++) {
              real2[i] = values[i * 2];
              image3[i] = values[i * 2 + 1];
            }
            const realTensor = tensor6(real2, shape, "float32");
            const imageTensor = tensor6(image3, shape, "float32");
            out[name] = complex3(realTensor, imageTensor);
            realTensor.dispose();
            imageTensor.dispose();
          } else {
            throw new Error(`Unsupported dtype in weight '${name}': ${dtype}`);
          }
          offset += size * dtypeFactor;
        }
        if (dtype !== "complex64") {
          out[name] = tensor6(values, shape, dtype);
        }
      }
      return out;
    }
    function concatenateTypedArrays(xs) {
      if (xs === null) {
        throw new Error(`Invalid input value: ${JSON.stringify(xs)}`);
      }
      let totalByteLength = 0;
      const normalizedXs = [];
      xs.forEach((x) => {
        totalByteLength += x.byteLength;
        normalizedXs.push(x.byteLength === x.buffer.byteLength ? x : new x.constructor(x));
        if (!(x instanceof Float32Array || x instanceof Int32Array || x instanceof Uint8Array)) {
          throw new Error(`Unsupported TypedArray subtype: ${x.constructor.name}`);
        }
      });
      const y = new Uint8Array(totalByteLength);
      let offset = 0;
      normalizedXs.forEach((x) => {
        y.set(new Uint8Array(x.buffer), offset);
        offset += x.byteLength;
      });
      return y.buffer;
    }
    const useNodeBuffer = typeof Buffer !== "undefined" && (typeof Blob === "undefined" || typeof atob === "undefined" || typeof btoa === "undefined");
    function stringByteLength(str2) {
      if (useNodeBuffer) {
        return Buffer.byteLength(str2);
      }
      return new Blob([str2]).size;
    }
    function arrayBufferToBase64String(buffer3) {
      if (useNodeBuffer) {
        return Buffer.from(buffer3).toString("base64");
      }
      const buf = new Uint8Array(buffer3);
      let s = "";
      for (let i = 0, l = buf.length; i < l; i++) {
        s += String.fromCharCode(buf[i]);
      }
      return btoa(s);
    }
    function base64StringToArrayBuffer(str2) {
      if (useNodeBuffer) {
        const buf = Buffer.from(str2, "base64");
        return buf.buffer.slice(buf.byteOffset, buf.byteOffset + buf.byteLength);
      }
      const s = atob(str2);
      const buffer3 = new Uint8Array(s.length);
      for (let i = 0; i < s.length; ++i) {
        buffer3.set([s.charCodeAt(i)], i);
      }
      return buffer3.buffer;
    }
    function concatenateArrayBuffers(buffers) {
      if (buffers.length === 1) {
        return buffers[0];
      }
      let totalByteLength = 0;
      buffers.forEach((buffer3) => {
        totalByteLength += buffer3.byteLength;
      });
      const temp = new Uint8Array(totalByteLength);
      let offset = 0;
      buffers.forEach((buffer3) => {
        temp.set(new Uint8Array(buffer3), offset);
        offset += buffer3.byteLength;
      });
      return temp.buffer;
    }
    function basename(path) {
      const SEPARATOR = "/";
      path = path.trim();
      while (path.endsWith(SEPARATOR)) {
        path = path.slice(0, path.length - 1);
      }
      const items = path.split(SEPARATOR);
      return items[items.length - 1];
    }
    function getModelArtifactsInfoForJSON(modelArtifacts) {
      if (modelArtifacts.modelTopology instanceof ArrayBuffer) {
        throw new Error("Expected JSON model topology, received ArrayBuffer.");
      }
      return {
        dateSaved: new Date(),
        modelTopologyType: "JSON",
        modelTopologyBytes: modelArtifacts.modelTopology == null ? 0 : stringByteLength(JSON.stringify(modelArtifacts.modelTopology)),
        weightSpecsBytes: modelArtifacts.weightSpecs == null ? 0 : stringByteLength(JSON.stringify(modelArtifacts.weightSpecs)),
        weightDataBytes: modelArtifacts.weightData == null ? 0 : modelArtifacts.weightData.byteLength
      };
    }
    function computeFloat16MantisaTable() {
      const convertMantissa = (i) => {
        let m = i << 13;
        let e = 0;
        while ((m & 8388608) === 0) {
          e -= 8388608;
          m <<= 1;
        }
        m &= ~8388608;
        e += 947912704;
        return m | e;
      };
      const mantisaTable = new Uint32Array(2048);
      mantisaTable[0] = 0;
      for (let i = 1; i < 1024; i++) {
        mantisaTable[i] = convertMantissa(i);
      }
      for (let i = 1024; i < 2048; i++) {
        mantisaTable[i] = 939524096 + (i - 1024 << 13);
      }
      return mantisaTable;
    }
    function computeFloat16ExponentTable() {
      const exponentTable = new Uint32Array(64);
      exponentTable[0] = 0;
      exponentTable[31] = 1199570944;
      exponentTable[32] = 2147483648;
      exponentTable[63] = 3347054592;
      for (let i = 1; i < 31; i++) {
        exponentTable[i] = i << 23;
      }
      for (let i = 33; i < 63; i++) {
        exponentTable[i] = 2147483648 + (i - 32 << 23);
      }
      return exponentTable;
    }
    function computeFloat16OffsetTable() {
      const offsetTable = new Uint32Array(64);
      for (let i = 0; i < 64; i++) {
        offsetTable[i] = 1024;
      }
      offsetTable[0] = offsetTable[32] = 0;
      return offsetTable;
    }
    function getFloat16Decoder() {
      const mantisaTable = computeFloat16MantisaTable();
      const exponentTable = computeFloat16ExponentTable();
      const offsetTable = computeFloat16OffsetTable();
      return (quantizedArray) => {
        const buffer3 = new ArrayBuffer(4 * quantizedArray.length);
        const bufferUint32View = new Uint32Array(buffer3);
        for (let index2 = 0; index2 < quantizedArray.length; index2++) {
          const float16Bits = quantizedArray[index2];
          const float32Bits = mantisaTable[offsetTable[float16Bits >> 10] + (float16Bits & 1023)] + exponentTable[float16Bits >> 10];
          bufferUint32View[index2] = float32Bits;
        }
        return new Float32Array(buffer3);
      };
    }
    /**
     * @license
     * Copyright 2018 Google LLC. All Rights Reserved.
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     * http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     * =============================================================================
     */
    class IORouterRegistry {
      constructor() {
        this.saveRouters = [];
        this.loadRouters = [];
      }
      static getInstance() {
        if (IORouterRegistry.instance == null) {
          IORouterRegistry.instance = new IORouterRegistry();
        }
        return IORouterRegistry.instance;
      }
      static registerSaveRouter(saveRouter) {
        IORouterRegistry.getInstance().saveRouters.push(saveRouter);
      }
      static registerLoadRouter(loadRouter) {
        IORouterRegistry.getInstance().loadRouters.push(loadRouter);
      }
      static getSaveHandlers(url) {
        return IORouterRegistry.getHandlers(url, "save");
      }
      static getLoadHandlers(url, loadOptions) {
        return IORouterRegistry.getHandlers(url, "load", loadOptions);
      }
      static getHandlers(url, handlerType, loadOptions) {
        const validHandlers = [];
        const routers = handlerType === "load" ? IORouterRegistry.getInstance().loadRouters : IORouterRegistry.getInstance().saveRouters;
        routers.forEach((router) => {
          const handler = router(url, loadOptions);
          if (handler !== null) {
            validHandlers.push(handler);
          }
        });
        return validHandlers;
      }
    }
    const registerSaveRouter = (loudRouter) => IORouterRegistry.registerSaveRouter(loudRouter);
    const registerLoadRouter = (loudRouter) => IORouterRegistry.registerLoadRouter(loudRouter);
    const getSaveHandlers = (url) => IORouterRegistry.getSaveHandlers(url);
    const getLoadHandlers = (url, loadOptions) => IORouterRegistry.getLoadHandlers(url, loadOptions);
    /**
     * @license
     * Copyright 2018 Google LLC. All Rights Reserved.
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     * http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     * =============================================================================
     */
    const DATABASE_NAME = "tensorflowjs";
    const DATABASE_VERSION = 1;
    const MODEL_STORE_NAME = "models_store";
    const INFO_STORE_NAME = "model_info_store";
    async function deleteDatabase() {
      const idbFactory = getIndexedDBFactory();
      return new Promise((resolve, reject) => {
        const deleteRequest = idbFactory.deleteDatabase(DATABASE_NAME);
        deleteRequest.onsuccess = () => resolve();
        deleteRequest.onerror = (error) => reject(error);
      });
    }
    function getIndexedDBFactory() {
      if (!env2().getBool("IS_BROWSER")) {
        throw new Error("Failed to obtain IndexedDB factory because the current environmentis not a web browser.");
      }
      const theWindow = typeof window === "undefined" ? self : window;
      const factory = theWindow.indexedDB || theWindow.mozIndexedDB || theWindow.webkitIndexedDB || theWindow.msIndexedDB || theWindow.shimIndexedDB;
      if (factory == null) {
        throw new Error("The current browser does not appear to support IndexedDB.");
      }
      return factory;
    }
    function setUpDatabase(openRequest) {
      const db = openRequest.result;
      db.createObjectStore(MODEL_STORE_NAME, {keyPath: "modelPath"});
      db.createObjectStore(INFO_STORE_NAME, {keyPath: "modelPath"});
    }
    class BrowserIndexedDB {
      constructor(modelPath) {
        this.indexedDB = getIndexedDBFactory();
        if (modelPath == null || !modelPath) {
          throw new Error("For IndexedDB, modelPath must not be null, undefined or empty.");
        }
        this.modelPath = modelPath;
      }
      async save(modelArtifacts) {
        if (modelArtifacts.modelTopology instanceof ArrayBuffer) {
          throw new Error("BrowserLocalStorage.save() does not support saving model topology in binary formats yet.");
        }
        return this.databaseAction(this.modelPath, modelArtifacts);
      }
      async load() {
        return this.databaseAction(this.modelPath);
      }
      databaseAction(modelPath, modelArtifacts) {
        return new Promise((resolve, reject) => {
          const openRequest = this.indexedDB.open(DATABASE_NAME, DATABASE_VERSION);
          openRequest.onupgradeneeded = () => setUpDatabase(openRequest);
          openRequest.onsuccess = () => {
            const db = openRequest.result;
            if (modelArtifacts == null) {
              const modelTx = db.transaction(MODEL_STORE_NAME, "readonly");
              const modelStore = modelTx.objectStore(MODEL_STORE_NAME);
              const getRequest = modelStore.get(this.modelPath);
              getRequest.onsuccess = () => {
                if (getRequest.result == null) {
                  db.close();
                  return reject(new Error(`Cannot find model with path '${this.modelPath}' in IndexedDB.`));
                } else {
                  resolve(getRequest.result.modelArtifacts);
                }
              };
              getRequest.onerror = (error) => {
                db.close();
                return reject(getRequest.error);
              };
              modelTx.oncomplete = () => db.close();
            } else {
              const modelArtifactsInfo = getModelArtifactsInfoForJSON(modelArtifacts);
              const infoTx = db.transaction(INFO_STORE_NAME, "readwrite");
              let infoStore = infoTx.objectStore(INFO_STORE_NAME);
              const putInfoRequest = infoStore.put({modelPath: this.modelPath, modelArtifactsInfo});
              let modelTx;
              putInfoRequest.onsuccess = () => {
                modelTx = db.transaction(MODEL_STORE_NAME, "readwrite");
                const modelStore = modelTx.objectStore(MODEL_STORE_NAME);
                const putModelRequest = modelStore.put({
                  modelPath: this.modelPath,
                  modelArtifacts,
                  modelArtifactsInfo
                });
                putModelRequest.onsuccess = () => resolve({modelArtifactsInfo});
                putModelRequest.onerror = (error) => {
                  infoStore = infoTx.objectStore(INFO_STORE_NAME);
                  const deleteInfoRequest = infoStore.delete(this.modelPath);
                  deleteInfoRequest.onsuccess = () => {
                    db.close();
                    return reject(putModelRequest.error);
                  };
                  deleteInfoRequest.onerror = (error2) => {
                    db.close();
                    return reject(putModelRequest.error);
                  };
                };
              };
              putInfoRequest.onerror = (error) => {
                db.close();
                return reject(putInfoRequest.error);
              };
              infoTx.oncomplete = () => {
                if (modelTx == null) {
                  db.close();
                } else {
                  modelTx.oncomplete = () => db.close();
                }
              };
            }
          };
          openRequest.onerror = (error) => reject(openRequest.error);
        });
      }
    }
    BrowserIndexedDB.URL_SCHEME = "indexeddb://";
    const indexedDBRouter = (url) => {
      if (!env2().getBool("IS_BROWSER")) {
        return null;
      } else {
        if (!Array.isArray(url) && url.startsWith(BrowserIndexedDB.URL_SCHEME)) {
          return browserIndexedDB(url.slice(BrowserIndexedDB.URL_SCHEME.length));
        } else {
          return null;
        }
      }
    };
    IORouterRegistry.registerSaveRouter(indexedDBRouter);
    IORouterRegistry.registerLoadRouter(indexedDBRouter);
    function browserIndexedDB(modelPath) {
      return new BrowserIndexedDB(modelPath);
    }
    function maybeStripScheme(key) {
      return key.startsWith(BrowserIndexedDB.URL_SCHEME) ? key.slice(BrowserIndexedDB.URL_SCHEME.length) : key;
    }
    class BrowserIndexedDBManager {
      constructor() {
        this.indexedDB = getIndexedDBFactory();
      }
      async listModels() {
        return new Promise((resolve, reject) => {
          const openRequest = this.indexedDB.open(DATABASE_NAME, DATABASE_VERSION);
          openRequest.onupgradeneeded = () => setUpDatabase(openRequest);
          openRequest.onsuccess = () => {
            const db = openRequest.result;
            const tx = db.transaction(INFO_STORE_NAME, "readonly");
            const store = tx.objectStore(INFO_STORE_NAME);
            const getAllInfoRequest = store.getAll();
            getAllInfoRequest.onsuccess = () => {
              const out = {};
              for (const item of getAllInfoRequest.result) {
                out[item.modelPath] = item.modelArtifactsInfo;
              }
              resolve(out);
            };
            getAllInfoRequest.onerror = (error) => {
              db.close();
              return reject(getAllInfoRequest.error);
            };
            tx.oncomplete = () => db.close();
          };
          openRequest.onerror = (error) => reject(openRequest.error);
        });
      }
      async removeModel(path) {
        path = maybeStripScheme(path);
        return new Promise((resolve, reject) => {
          const openRequest = this.indexedDB.open(DATABASE_NAME, DATABASE_VERSION);
          openRequest.onupgradeneeded = () => setUpDatabase(openRequest);
          openRequest.onsuccess = () => {
            const db = openRequest.result;
            const infoTx = db.transaction(INFO_STORE_NAME, "readwrite");
            const infoStore = infoTx.objectStore(INFO_STORE_NAME);
            const getInfoRequest = infoStore.get(path);
            let modelTx;
            getInfoRequest.onsuccess = () => {
              if (getInfoRequest.result == null) {
                db.close();
                return reject(new Error(`Cannot find model with path '${path}' in IndexedDB.`));
              } else {
                const deleteInfoRequest = infoStore.delete(path);
                const deleteModelData = () => {
                  modelTx = db.transaction(MODEL_STORE_NAME, "readwrite");
                  const modelStore = modelTx.objectStore(MODEL_STORE_NAME);
                  const deleteModelRequest = modelStore.delete(path);
                  deleteModelRequest.onsuccess = () => resolve(getInfoRequest.result.modelArtifactsInfo);
                  deleteModelRequest.onerror = (error) => reject(getInfoRequest.error);
                };
                deleteInfoRequest.onsuccess = deleteModelData;
                deleteInfoRequest.onerror = (error) => {
                  deleteModelData();
                  db.close();
                  return reject(getInfoRequest.error);
                };
              }
            };
            getInfoRequest.onerror = (error) => {
              db.close();
              return reject(getInfoRequest.error);
            };
            infoTx.oncomplete = () => {
              if (modelTx == null) {
                db.close();
              } else {
                modelTx.oncomplete = () => db.close();
              }
            };
          };
          openRequest.onerror = (error) => reject(openRequest.error);
        });
      }
    }
    /**
     * @license
     * Copyright 2018 Google LLC. All Rights Reserved.
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     * http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     * =============================================================================
     */
    const PATH_SEPARATOR = "/";
    const PATH_PREFIX = "tensorflowjs_models";
    const INFO_SUFFIX = "info";
    const MODEL_TOPOLOGY_SUFFIX = "model_topology";
    const WEIGHT_SPECS_SUFFIX = "weight_specs";
    const WEIGHT_DATA_SUFFIX = "weight_data";
    const MODEL_METADATA_SUFFIX = "model_metadata";
    function purgeLocalStorageArtifacts() {
      if (!env2().getBool("IS_BROWSER") || typeof window === "undefined" || typeof window.localStorage === "undefined") {
        throw new Error("purgeLocalStorageModels() cannot proceed because local storage is unavailable in the current environment.");
      }
      const LS = window.localStorage;
      const purgedModelPaths = [];
      for (let i = 0; i < LS.length; ++i) {
        const key = LS.key(i);
        const prefix = PATH_PREFIX + PATH_SEPARATOR;
        if (key.startsWith(prefix) && key.length > prefix.length) {
          LS.removeItem(key);
          const modelName = getModelPathFromKey(key);
          if (purgedModelPaths.indexOf(modelName) === -1) {
            purgedModelPaths.push(modelName);
          }
        }
      }
      return purgedModelPaths;
    }
    function getModelKeys(path) {
      return {
        info: [PATH_PREFIX, path, INFO_SUFFIX].join(PATH_SEPARATOR),
        topology: [PATH_PREFIX, path, MODEL_TOPOLOGY_SUFFIX].join(PATH_SEPARATOR),
        weightSpecs: [PATH_PREFIX, path, WEIGHT_SPECS_SUFFIX].join(PATH_SEPARATOR),
        weightData: [PATH_PREFIX, path, WEIGHT_DATA_SUFFIX].join(PATH_SEPARATOR),
        modelMetadata: [PATH_PREFIX, path, MODEL_METADATA_SUFFIX].join(PATH_SEPARATOR)
      };
    }
    function getModelPathFromKey(key) {
      const items = key.split(PATH_SEPARATOR);
      if (items.length < 3) {
        throw new Error(`Invalid key format: ${key}`);
      }
      return items.slice(1, items.length - 1).join(PATH_SEPARATOR);
    }
    function maybeStripScheme$1(key) {
      return key.startsWith(BrowserLocalStorage.URL_SCHEME) ? key.slice(BrowserLocalStorage.URL_SCHEME.length) : key;
    }
    class BrowserLocalStorage {
      constructor(modelPath) {
        if (!env2().getBool("IS_BROWSER") || typeof window === "undefined" || typeof window.localStorage === "undefined") {
          throw new Error("The current environment does not support local storage.");
        }
        this.LS = window.localStorage;
        if (modelPath == null || !modelPath) {
          throw new Error("For local storage, modelPath must not be null, undefined or empty.");
        }
        this.modelPath = modelPath;
        this.keys = getModelKeys(this.modelPath);
      }
      async save(modelArtifacts) {
        if (modelArtifacts.modelTopology instanceof ArrayBuffer) {
          throw new Error("BrowserLocalStorage.save() does not support saving model topology in binary formats yet.");
        } else {
          const topology = JSON.stringify(modelArtifacts.modelTopology);
          const weightSpecs = JSON.stringify(modelArtifacts.weightSpecs);
          const modelArtifactsInfo = getModelArtifactsInfoForJSON(modelArtifacts);
          try {
            this.LS.setItem(this.keys.info, JSON.stringify(modelArtifactsInfo));
            this.LS.setItem(this.keys.topology, topology);
            this.LS.setItem(this.keys.weightSpecs, weightSpecs);
            this.LS.setItem(this.keys.weightData, arrayBufferToBase64String(modelArtifacts.weightData));
            this.LS.setItem(this.keys.modelMetadata, JSON.stringify({
              format: modelArtifacts.format,
              generatedBy: modelArtifacts.generatedBy,
              convertedBy: modelArtifacts.convertedBy,
              userDefinedMetadata: modelArtifacts.userDefinedMetadata
            }));
            return {modelArtifactsInfo};
          } catch (err) {
            this.LS.removeItem(this.keys.info);
            this.LS.removeItem(this.keys.topology);
            this.LS.removeItem(this.keys.weightSpecs);
            this.LS.removeItem(this.keys.weightData);
            this.LS.removeItem(this.keys.modelMetadata);
            throw new Error(`Failed to save model '${this.modelPath}' to local storage: size quota being exceeded is a possible cause of this failure: modelTopologyBytes=${modelArtifactsInfo.modelTopologyBytes}, weightSpecsBytes=${modelArtifactsInfo.weightSpecsBytes}, weightDataBytes=${modelArtifactsInfo.weightDataBytes}.`);
          }
        }
      }
      async load() {
        const info = JSON.parse(this.LS.getItem(this.keys.info));
        if (info == null) {
          throw new Error(`In local storage, there is no model with name '${this.modelPath}'`);
        }
        if (info.modelTopologyType !== "JSON") {
          throw new Error("BrowserLocalStorage does not support loading non-JSON model topology yet.");
        }
        const out = {};
        const topology = JSON.parse(this.LS.getItem(this.keys.topology));
        if (topology == null) {
          throw new Error(`In local storage, the topology of model '${this.modelPath}' is missing.`);
        }
        out.modelTopology = topology;
        const weightSpecs = JSON.parse(this.LS.getItem(this.keys.weightSpecs));
        if (weightSpecs == null) {
          throw new Error(`In local storage, the weight specs of model '${this.modelPath}' are missing.`);
        }
        out.weightSpecs = weightSpecs;
        const metadataString = this.LS.getItem(this.keys.modelMetadata);
        if (metadataString != null) {
          const metadata = JSON.parse(metadataString);
          out.format = metadata["format"];
          out.generatedBy = metadata["generatedBy"];
          out.convertedBy = metadata["convertedBy"];
          out.userDefinedMetadata = metadata["userDefinedMetadata"];
        }
        const weightDataBase64 = this.LS.getItem(this.keys.weightData);
        if (weightDataBase64 == null) {
          throw new Error(`In local storage, the binary weight values of model '${this.modelPath}' are missing.`);
        }
        out.weightData = base64StringToArrayBuffer(weightDataBase64);
        return out;
      }
    }
    BrowserLocalStorage.URL_SCHEME = "localstorage://";
    const localStorageRouter = (url) => {
      if (!env2().getBool("IS_BROWSER")) {
        return null;
      } else {
        if (!Array.isArray(url) && url.startsWith(BrowserLocalStorage.URL_SCHEME)) {
          return browserLocalStorage(url.slice(BrowserLocalStorage.URL_SCHEME.length));
        } else {
          return null;
        }
      }
    };
    IORouterRegistry.registerSaveRouter(localStorageRouter);
    IORouterRegistry.registerLoadRouter(localStorageRouter);
    function browserLocalStorage(modelPath) {
      return new BrowserLocalStorage(modelPath);
    }
    class BrowserLocalStorageManager {
      constructor() {
        assert2(env2().getBool("IS_BROWSER"), () => "Current environment is not a web browser");
        assert2(typeof window === "undefined" || typeof window.localStorage !== "undefined", () => "Current browser does not appear to support localStorage");
        this.LS = window.localStorage;
      }
      async listModels() {
        const out = {};
        const prefix = PATH_PREFIX + PATH_SEPARATOR;
        const suffix = PATH_SEPARATOR + INFO_SUFFIX;
        for (let i = 0; i < this.LS.length; ++i) {
          const key = this.LS.key(i);
          if (key.startsWith(prefix) && key.endsWith(suffix)) {
            const modelPath = getModelPathFromKey(key);
            out[modelPath] = JSON.parse(this.LS.getItem(key));
          }
        }
        return out;
      }
      async removeModel(path) {
        path = maybeStripScheme$1(path);
        const keys = getModelKeys(path);
        if (this.LS.getItem(keys.info) == null) {
          throw new Error(`Cannot find model at path '${path}'`);
        }
        const info = JSON.parse(this.LS.getItem(keys.info));
        this.LS.removeItem(keys.info);
        this.LS.removeItem(keys.topology);
        this.LS.removeItem(keys.weightSpecs);
        this.LS.removeItem(keys.weightData);
        return info;
      }
    }
    /**
     * @license
     * Copyright 2018 Google LLC. All Rights Reserved.
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     * http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     * =============================================================================
     */
    const URL_SCHEME_SUFFIX = "://";
    class ModelStoreManagerRegistry {
      constructor() {
        this.managers = {};
      }
      static getInstance() {
        if (ModelStoreManagerRegistry.instance == null) {
          ModelStoreManagerRegistry.instance = new ModelStoreManagerRegistry();
        }
        return ModelStoreManagerRegistry.instance;
      }
      static registerManager(scheme, manager) {
        assert2(scheme != null, () => "scheme must not be undefined or null.");
        if (scheme.endsWith(URL_SCHEME_SUFFIX)) {
          scheme = scheme.slice(0, scheme.indexOf(URL_SCHEME_SUFFIX));
        }
        assert2(scheme.length > 0, () => "scheme must not be an empty string.");
        const registry = ModelStoreManagerRegistry.getInstance();
        assert2(registry.managers[scheme] == null, () => `A model store manager is already registered for scheme '${scheme}'.`);
        registry.managers[scheme] = manager;
      }
      static getManager(scheme) {
        const manager = this.getInstance().managers[scheme];
        if (manager == null) {
          throw new Error(`Cannot find model manager for scheme '${scheme}'`);
        }
        return manager;
      }
      static getSchemes() {
        return Object.keys(this.getInstance().managers);
      }
    }
    function parseURL(url) {
      if (url.indexOf(URL_SCHEME_SUFFIX) === -1) {
        throw new Error(`The url string provided does not contain a scheme. Supported schemes are: ${ModelStoreManagerRegistry.getSchemes().join(",")}`);
      }
      return {
        scheme: url.split(URL_SCHEME_SUFFIX)[0],
        path: url.split(URL_SCHEME_SUFFIX)[1]
      };
    }
    async function cloneModelInternal(sourceURL, destURL, deleteSource = false) {
      assert2(sourceURL !== destURL, () => `Old path and new path are the same: '${sourceURL}'`);
      const loadHandlers = IORouterRegistry.getLoadHandlers(sourceURL);
      assert2(loadHandlers.length > 0, () => `Copying failed because no load handler is found for source URL ${sourceURL}.`);
      assert2(loadHandlers.length < 2, () => `Copying failed because more than one (${loadHandlers.length}) load handlers for source URL ${sourceURL}.`);
      const loadHandler = loadHandlers[0];
      const saveHandlers = IORouterRegistry.getSaveHandlers(destURL);
      assert2(saveHandlers.length > 0, () => `Copying failed because no save handler is found for destination URL ${destURL}.`);
      assert2(saveHandlers.length < 2, () => `Copying failed because more than one (${loadHandlers.length}) save handlers for destination URL ${destURL}.`);
      const saveHandler = saveHandlers[0];
      const sourceScheme = parseURL(sourceURL).scheme;
      const sourcePath = parseURL(sourceURL).path;
      const sameMedium = sourceScheme === parseURL(sourceURL).scheme;
      const modelArtifacts = await loadHandler.load();
      if (deleteSource && sameMedium) {
        await ModelStoreManagerRegistry.getManager(sourceScheme).removeModel(sourcePath);
      }
      const saveResult = await saveHandler.save(modelArtifacts);
      if (deleteSource && !sameMedium) {
        await ModelStoreManagerRegistry.getManager(sourceScheme).removeModel(sourcePath);
      }
      return saveResult.modelArtifactsInfo;
    }
    async function listModels() {
      const schemes = ModelStoreManagerRegistry.getSchemes();
      const out = {};
      for (const scheme of schemes) {
        const schemeOut = await ModelStoreManagerRegistry.getManager(scheme).listModels();
        for (const path in schemeOut) {
          const url = scheme + URL_SCHEME_SUFFIX + path;
          out[url] = schemeOut[path];
        }
      }
      return out;
    }
    async function removeModel(url) {
      const schemeAndPath = parseURL(url);
      const manager = ModelStoreManagerRegistry.getManager(schemeAndPath.scheme);
      return manager.removeModel(schemeAndPath.path);
    }
    async function copyModel(sourceURL, destURL) {
      const deleteSource = false;
      return cloneModelInternal(sourceURL, destURL, deleteSource);
    }
    async function moveModel(sourceURL, destURL) {
      const deleteSource = true;
      return cloneModelInternal(sourceURL, destURL, deleteSource);
    }
    /**
     * @license
     * Copyright 2019 Google LLC. All Rights Reserved.
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     * http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     * =============================================================================
     */
    class PlatformBrowser {
      fetch(path, init2) {
        return fetch(path, init2);
      }
      now() {
        return performance.now();
      }
      encode(text, encoding) {
        if (encoding !== "utf-8" && encoding !== "utf8") {
          throw new Error(`Browser's encoder only supports utf-8, but got ${encoding}`);
        }
        if (this.textEncoder == null) {
          this.textEncoder = new TextEncoder();
        }
        return this.textEncoder.encode(text);
      }
      decode(bytes, encoding) {
        return new TextDecoder(encoding).decode(bytes);
      }
    }
    if (env2().get("IS_BROWSER")) {
      env2().setPlatform("browser", new PlatformBrowser());
      try {
        ModelStoreManagerRegistry.registerManager(BrowserLocalStorage.URL_SCHEME, new BrowserLocalStorageManager());
      } catch (err) {
      }
      try {
        ModelStoreManagerRegistry.registerManager(BrowserIndexedDB.URL_SCHEME, new BrowserIndexedDBManager());
      } catch (err) {
      }
    }
    /**
     * @license
     * Copyright 2019 Google LLC. All Rights Reserved.
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     * http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     * =============================================================================
     */
    const getNodeFetch = {
      importFetch: () => require_browser()
    };
    let systemFetch;
    function resetSystemFetch() {
      systemFetch = null;
    }
    function setSystemFetch(fetchFn) {
      systemFetch = fetchFn;
    }
    function getSystemFetch() {
      return systemFetch;
    }
    class PlatformNode {
      constructor() {
        this.util = require("util");
        this.textEncoder = new this.util.TextEncoder();
      }
      fetch(path, requestInits) {
        if (env2().global.fetch != null) {
          return env2().global.fetch(path, requestInits);
        }
        if (systemFetch == null) {
          systemFetch = getNodeFetch.importFetch();
        }
        return systemFetch(path, requestInits);
      }
      now() {
        const time2 = process.hrtime();
        return time2[0] * 1e3 + time2[1] / 1e6;
      }
      encode(text, encoding) {
        if (encoding !== "utf-8" && encoding !== "utf8") {
          throw new Error(`Node built-in encoder only supports utf-8, but got ${encoding}`);
        }
        return this.textEncoder.encode(text);
      }
      decode(bytes, encoding) {
        if (bytes.length === 0) {
          return "";
        }
        return new this.util.TextDecoder(encoding).decode(bytes);
      }
    }
    if (env2().get("IS_NODE")) {
      env2().setPlatform("node", new PlatformNode());
    }
    /**
     * @license
     * Copyright 2020 Google Inc. All Rights Reserved.
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     * http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     * =============================================================================
     */
    function buffer2(shape, dtype = "float32", values) {
      dtype = dtype || "float32";
      assertNonNegativeIntegerDimensions2(shape);
      return new TensorBuffer2(shape, dtype, values);
    }
    /**
     * @license
     * Copyright 2020 Google Inc. All Rights Reserved.
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     * http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     * =============================================================================
     */
    function cast_2(x, dtype) {
      const $x = convertToTensor2(x, "x", "cast");
      if (!isValidDtype2(dtype)) {
        throw new Error(`Failed to cast to unknown dtype ${dtype}`);
      }
      if (dtype === "string" && $x.dtype !== "string" || dtype !== "string" && $x.dtype === "string") {
        throw new Error("Only strings can be casted to strings");
      }
      const inputs = {x: $x};
      const attrs = {dtype};
      return ENGINE2.runKernelFunc((backend3) => backend3.cast($x, dtype), inputs, null, Cast5, attrs);
    }
    const cast7 = op2({cast_: cast_2});
    /**
     * @license
     * Copyright 2020 Google LLC. All Rights Reserved.
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     * http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     * =============================================================================
     */
    function clone_(x) {
      const $x = convertToTensor2(x, "x", "clone", null);
      const forward = () => ENGINE2.makeTensorFromDataId($x.dataId, $x.shape, $x.dtype);
      const inputs = {x: $x};
      return ENGINE2.runKernelFunc(forward, inputs, null, Identity5);
    }
    const clone = op2({clone_});
    /**
     * @license
     * Copyright 2020 Google Inc. All Rights Reserved.
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     * http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     * =============================================================================
     */
    function print2(x, verbose = false) {
      console.log(x.toString(verbose));
    }
    /**
     * @license
     * Copyright 2020 Google Inc. All Rights Reserved.
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     * http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     * =============================================================================
     */
    getOrMakeEngine2();
    const opHandler$1 = {
      buffer: buffer2,
      cast: cast7,
      clone,
      print: print2
    };
    setOpHandler(opHandler$1);
    /**
     * @license
     * Copyright 2018 Google LLC. All Rights Reserved.
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     * http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     * =============================================================================
     */
    const DEFAULT_FILE_NAME_PREFIX = "model";
    const DEFAULT_JSON_EXTENSION_NAME = ".json";
    const DEFAULT_WEIGHT_DATA_EXTENSION_NAME = ".weights.bin";
    function defer(f) {
      return new Promise((resolve) => setTimeout(resolve)).then(f);
    }
    class BrowserDownloads {
      constructor(fileNamePrefix) {
        if (!env2().getBool("IS_BROWSER")) {
          throw new Error("browserDownloads() cannot proceed because the current environment is not a browser.");
        }
        if (fileNamePrefix.startsWith(BrowserDownloads.URL_SCHEME)) {
          fileNamePrefix = fileNamePrefix.slice(BrowserDownloads.URL_SCHEME.length);
        }
        if (fileNamePrefix == null || fileNamePrefix.length === 0) {
          fileNamePrefix = DEFAULT_FILE_NAME_PREFIX;
        }
        this.modelTopologyFileName = fileNamePrefix + DEFAULT_JSON_EXTENSION_NAME;
        this.weightDataFileName = fileNamePrefix + DEFAULT_WEIGHT_DATA_EXTENSION_NAME;
      }
      async save(modelArtifacts) {
        if (typeof document === "undefined") {
          throw new Error("Browser downloads are not supported in this environment since `document` is not present");
        }
        const weightsURL = window.URL.createObjectURL(new Blob([modelArtifacts.weightData], {type: "application/octet-stream"}));
        if (modelArtifacts.modelTopology instanceof ArrayBuffer) {
          throw new Error("BrowserDownloads.save() does not support saving model topology in binary formats yet.");
        } else {
          const weightsManifest = [{
            paths: ["./" + this.weightDataFileName],
            weights: modelArtifacts.weightSpecs
          }];
          const modelTopologyAndWeightManifest = {
            modelTopology: modelArtifacts.modelTopology,
            format: modelArtifacts.format,
            generatedBy: modelArtifacts.generatedBy,
            convertedBy: modelArtifacts.convertedBy,
            weightsManifest
          };
          const modelTopologyAndWeightManifestURL = window.URL.createObjectURL(new Blob([JSON.stringify(modelTopologyAndWeightManifest)], {type: "application/json"}));
          const jsonAnchor = this.jsonAnchor == null ? document.createElement("a") : this.jsonAnchor;
          jsonAnchor.download = this.modelTopologyFileName;
          jsonAnchor.href = modelTopologyAndWeightManifestURL;
          await defer(() => jsonAnchor.dispatchEvent(new MouseEvent("click")));
          if (modelArtifacts.weightData != null) {
            const weightDataAnchor = this.weightDataAnchor == null ? document.createElement("a") : this.weightDataAnchor;
            weightDataAnchor.download = this.weightDataFileName;
            weightDataAnchor.href = weightsURL;
            await defer(() => weightDataAnchor.dispatchEvent(new MouseEvent("click")));
          }
          return {modelArtifactsInfo: getModelArtifactsInfoForJSON(modelArtifacts)};
        }
      }
    }
    BrowserDownloads.URL_SCHEME = "downloads://";
    class BrowserFiles {
      constructor(files) {
        if (files == null || files.length < 1) {
          throw new Error(`When calling browserFiles, at least 1 file is required, but received ${files}`);
        }
        this.files = files;
      }
      async load() {
        const jsonFile = this.files[0];
        const weightFiles = this.files.slice(1);
        return new Promise((resolve, reject) => {
          const jsonReader = new FileReader();
          jsonReader.onload = (event) => {
            const modelJSON = JSON.parse(event.target.result);
            const modelTopology = modelJSON.modelTopology;
            if (modelTopology == null) {
              reject(new Error(`modelTopology field is missing from file ${jsonFile.name}`));
              return;
            }
            if (weightFiles.length === 0) {
              resolve({modelTopology});
            }
            const weightsManifest = modelJSON.weightsManifest;
            if (weightsManifest == null) {
              reject(new Error(`weightManifest field is missing from file ${jsonFile.name}`));
              return;
            }
            let pathToFile;
            try {
              pathToFile = this.checkManifestAndWeightFiles(weightsManifest, weightFiles);
            } catch (err) {
              reject(err);
              return;
            }
            const weightSpecs = [];
            const paths = [];
            const perFileBuffers = [];
            weightsManifest.forEach((weightsGroup) => {
              weightsGroup.paths.forEach((path) => {
                paths.push(path);
                perFileBuffers.push(null);
              });
              weightSpecs.push(...weightsGroup.weights);
            });
            weightsManifest.forEach((weightsGroup) => {
              weightsGroup.paths.forEach((path) => {
                const weightFileReader = new FileReader();
                weightFileReader.onload = (event2) => {
                  const weightData = event2.target.result;
                  const index2 = paths.indexOf(path);
                  perFileBuffers[index2] = weightData;
                  if (perFileBuffers.indexOf(null) === -1) {
                    resolve({
                      modelTopology,
                      weightSpecs,
                      weightData: concatenateArrayBuffers(perFileBuffers),
                      format: modelJSON.format,
                      generatedBy: modelJSON.generatedBy,
                      convertedBy: modelJSON.convertedBy,
                      userDefinedMetadata: modelJSON.userDefinedMetadata
                    });
                  }
                };
                weightFileReader.onerror = (error) => reject(`Failed to weights data from file of path '${path}'.`);
                weightFileReader.readAsArrayBuffer(pathToFile[path]);
              });
            });
          };
          jsonReader.onerror = (error) => reject(`Failed to read model topology and weights manifest JSON from file '${jsonFile.name}'. BrowserFiles supports loading Keras-style tf.Model artifacts only.`);
          jsonReader.readAsText(jsonFile);
        });
      }
      checkManifestAndWeightFiles(manifest, files) {
        const basenames = [];
        const fileNames = files.map((file) => basename(file.name));
        const pathToFile = {};
        for (const group of manifest) {
          group.paths.forEach((path) => {
            const pathBasename = basename(path);
            if (basenames.indexOf(pathBasename) !== -1) {
              throw new Error(`Duplicate file basename found in weights manifest: '${pathBasename}'`);
            }
            basenames.push(pathBasename);
            if (fileNames.indexOf(pathBasename) === -1) {
              throw new Error(`Weight file with basename '${pathBasename}' is not provided.`);
            } else {
              pathToFile[path] = files[fileNames.indexOf(pathBasename)];
            }
          });
        }
        if (basenames.length !== files.length) {
          throw new Error(`Mismatch in the number of files in weights manifest (${basenames.length}) and the number of weight files provided (${files.length}).`);
        }
        return pathToFile;
      }
    }
    const browserDownloadsRouter = (url) => {
      if (!env2().getBool("IS_BROWSER")) {
        return null;
      } else {
        if (!Array.isArray(url) && url.startsWith(BrowserDownloads.URL_SCHEME)) {
          return browserDownloads(url.slice(BrowserDownloads.URL_SCHEME.length));
        } else {
          return null;
        }
      }
    };
    IORouterRegistry.registerSaveRouter(browserDownloadsRouter);
    function browserDownloads(fileNamePrefix = "model") {
      return new BrowserDownloads(fileNamePrefix);
    }
    function browserFiles(files) {
      return new BrowserFiles(files);
    }
    /**
     * @license
     * Copyright 2019 Google LLC. All Rights Reserved.
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     * http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     * =============================================================================
     */
    function monitorPromisesProgress(promises, onProgress, startFraction, endFraction) {
      checkPromises(promises);
      startFraction = startFraction == null ? 0 : startFraction;
      endFraction = endFraction == null ? 1 : endFraction;
      checkFraction(startFraction, endFraction);
      let resolvedPromise = 0;
      const registerMonitor = (promise) => {
        promise.then((value) => {
          const fraction = startFraction + ++resolvedPromise / promises.length * (endFraction - startFraction);
          onProgress(fraction);
          return value;
        });
        return promise;
      };
      function checkPromises(promises2) {
        assert2(promises2 != null && Array.isArray(promises2) && promises2.length > 0, () => "promises must be a none empty array");
      }
      function checkFraction(startFraction2, endFraction2) {
        assert2(startFraction2 >= 0 && startFraction2 <= 1, () => `Progress fraction must be in range [0, 1], but got startFraction ${startFraction2}`);
        assert2(endFraction2 >= 0 && endFraction2 <= 1, () => `Progress fraction must be in range [0, 1], but got endFraction ${endFraction2}`);
        assert2(endFraction2 >= startFraction2, () => `startFraction must be no more than endFraction, but got startFraction ${startFraction2} and endFraction ${endFraction2}`);
      }
      return Promise.all(promises.map(registerMonitor));
    }
    /**
     * @license
     * Copyright 2018 Google LLC. All Rights Reserved.
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     * http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     * =============================================================================
     */
    async function loadWeightsAsArrayBuffer(fetchURLs, loadOptions) {
      if (loadOptions == null) {
        loadOptions = {};
      }
      const fetchFunc = loadOptions.fetchFunc == null ? env2().platform.fetch : loadOptions.fetchFunc;
      const requests = fetchURLs.map((fetchURL) => fetchFunc(fetchURL, loadOptions.requestInit, {isBinary: true}));
      const fetchStartFraction = 0;
      const fetchEndFraction = 0.5;
      const responses = loadOptions.onProgress == null ? await Promise.all(requests) : await monitorPromisesProgress(requests, loadOptions.onProgress, fetchStartFraction, fetchEndFraction);
      const bufferPromises = responses.map((response) => response.arrayBuffer());
      const bufferStartFraction = 0.5;
      const bufferEndFraction = 1;
      const buffers = loadOptions.onProgress == null ? await Promise.all(bufferPromises) : await monitorPromisesProgress(bufferPromises, loadOptions.onProgress, bufferStartFraction, bufferEndFraction);
      return buffers;
    }
    async function loadWeights(manifest, filePathPrefix = "", weightNames, requestInit) {
      const fetchWeights = (fetchUrls) => loadWeightsAsArrayBuffer(fetchUrls, {requestInit});
      const loadWeights2 = weightsLoaderFactory(fetchWeights);
      return loadWeights2(manifest, filePathPrefix, weightNames);
    }
    function weightsLoaderFactory(fetchWeightsFunction) {
      return async (manifest, filePathPrefix = "", weightNames) => {
        const groupIndicesToFetchMap = manifest.map(() => false);
        const groupWeightsToFetch = {};
        const weightsFound = weightNames != null ? weightNames.map(() => false) : [];
        const allManifestWeightNames = [];
        manifest.forEach((manifestGroupConfig, groupIndex) => {
          let groupOffset = 0;
          manifestGroupConfig.weights.forEach((weightsEntry) => {
            const rawDtype = "quantization" in weightsEntry ? weightsEntry.quantization.dtype : weightsEntry.dtype;
            const weightsBytes = DTYPE_VALUE_SIZE_MAP[rawDtype] * sizeFromShape2(weightsEntry.shape);
            const enqueueWeightsForFetchingFn = () => {
              groupIndicesToFetchMap[groupIndex] = true;
              if (groupWeightsToFetch[groupIndex] == null) {
                groupWeightsToFetch[groupIndex] = [];
              }
              groupWeightsToFetch[groupIndex].push({
                manifestEntry: weightsEntry,
                groupOffset,
                sizeBytes: weightsBytes
              });
            };
            if (weightNames != null) {
              weightNames.forEach((weightName, weightIndex) => {
                if (weightName === weightsEntry.name) {
                  enqueueWeightsForFetchingFn();
                  weightsFound[weightIndex] = true;
                }
              });
            } else {
              enqueueWeightsForFetchingFn();
            }
            allManifestWeightNames.push(weightsEntry.name);
            groupOffset += weightsBytes;
          });
        });
        if (!weightsFound.every((found) => found)) {
          const weightsNotFound = weightNames.filter((_, i) => !weightsFound[i]);
          throw new Error(`Could not find weights in manifest with names: ${weightsNotFound.join(", ")}. 
Manifest JSON has weights with names: ${allManifestWeightNames.join(", ")}.`);
        }
        const groupIndicesToFetch = groupIndicesToFetchMap.reduce((accumulator, shouldFetch, i) => {
          if (shouldFetch) {
            accumulator.push(i);
          }
          return accumulator;
        }, []);
        const fetchUrls = [];
        groupIndicesToFetch.forEach((i) => {
          manifest[i].paths.forEach((filepath) => {
            const fetchUrl = filePathPrefix + (!filePathPrefix.endsWith("/") ? "/" : "") + filepath;
            fetchUrls.push(fetchUrl);
          });
        });
        const buffers = await fetchWeightsFunction(fetchUrls);
        const weightsTensorMap = {};
        let bufferIndexOffset = 0;
        groupIndicesToFetch.forEach((i) => {
          const numBuffers = manifest[i].paths.length;
          let groupBytes = 0;
          for (let i2 = 0; i2 < numBuffers; i2++) {
            groupBytes += buffers[bufferIndexOffset + i2].byteLength;
          }
          const groupBuffer = new ArrayBuffer(groupBytes);
          const groupByteBuffer = new Uint8Array(groupBuffer);
          let groupBufferOffset = 0;
          for (let i2 = 0; i2 < numBuffers; i2++) {
            const buffer3 = new Uint8Array(buffers[bufferIndexOffset + i2]);
            groupByteBuffer.set(buffer3, groupBufferOffset);
            groupBufferOffset += buffer3.byteLength;
          }
          const weightsEntries = groupWeightsToFetch[i];
          weightsEntries.forEach((weightsEntry) => {
            const byteBuffer = groupBuffer.slice(weightsEntry.groupOffset, weightsEntry.groupOffset + weightsEntry.sizeBytes);
            const nameToTensorMap = decodeWeights(byteBuffer, [weightsEntry.manifestEntry]);
            for (const name in nameToTensorMap) {
              weightsTensorMap[name] = nameToTensorMap[name];
            }
          });
          bufferIndexOffset += numBuffers;
        });
        return weightsTensorMap;
      };
    }
    /**
     * @license
     * Copyright 2018 Google LLC. All Rights Reserved.
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     * http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     * =============================================================================
     */
    const OCTET_STREAM_MIME_TYPE = "application/octet-stream";
    const JSON_TYPE = "application/json";
    class HTTPRequest {
      constructor(path, loadOptions) {
        this.DEFAULT_METHOD = "POST";
        if (loadOptions == null) {
          loadOptions = {};
        }
        this.weightPathPrefix = loadOptions.weightPathPrefix;
        this.onProgress = loadOptions.onProgress;
        this.weightUrlConverter = loadOptions.weightUrlConverter;
        if (loadOptions.fetchFunc != null) {
          assert2(typeof loadOptions.fetchFunc === "function", () => "Must pass a function that matches the signature of `fetch` (see https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API)");
          this.fetch = loadOptions.fetchFunc;
        } else {
          this.fetch = env2().platform.fetch;
        }
        assert2(path != null && path.length > 0, () => "URL path for http must not be null, undefined or empty.");
        if (Array.isArray(path)) {
          assert2(path.length === 2, () => `URL paths for http must have a length of 2, (actual length is ${path.length}).`);
        }
        this.path = path;
        if (loadOptions.requestInit != null && loadOptions.requestInit.body != null) {
          throw new Error("requestInit is expected to have no pre-existing body, but has one.");
        }
        this.requestInit = loadOptions.requestInit || {};
      }
      async save(modelArtifacts) {
        if (modelArtifacts.modelTopology instanceof ArrayBuffer) {
          throw new Error("BrowserHTTPRequest.save() does not support saving model topology in binary formats yet.");
        }
        const init2 = Object.assign({method: this.DEFAULT_METHOD}, this.requestInit);
        init2.body = new FormData();
        const weightsManifest = [{
          paths: ["./model.weights.bin"],
          weights: modelArtifacts.weightSpecs
        }];
        const modelTopologyAndWeightManifest = {
          modelTopology: modelArtifacts.modelTopology,
          format: modelArtifacts.format,
          generatedBy: modelArtifacts.generatedBy,
          convertedBy: modelArtifacts.convertedBy,
          userDefinedMetadata: modelArtifacts.userDefinedMetadata,
          weightsManifest
        };
        init2.body.append("model.json", new Blob([JSON.stringify(modelTopologyAndWeightManifest)], {type: JSON_TYPE}), "model.json");
        if (modelArtifacts.weightData != null) {
          init2.body.append("model.weights.bin", new Blob([modelArtifacts.weightData], {type: OCTET_STREAM_MIME_TYPE}), "model.weights.bin");
        }
        const response = await this.fetch(this.path, init2);
        if (response.ok) {
          return {
            modelArtifactsInfo: getModelArtifactsInfoForJSON(modelArtifacts),
            responses: [response]
          };
        } else {
          throw new Error(`BrowserHTTPRequest.save() failed due to HTTP response status ${response.status}.`);
        }
      }
      async load() {
        const modelConfigRequest = await this.fetch(this.path, this.requestInit);
        if (!modelConfigRequest.ok) {
          throw new Error(`Request to ${this.path} failed with status code ${modelConfigRequest.status}. Please verify this URL points to the model JSON of the model to load.`);
        }
        let modelConfig;
        try {
          modelConfig = await modelConfigRequest.json();
        } catch (e) {
          let message = `Failed to parse model JSON of response from ${this.path}.`;
          if (this.path.endsWith(".pb")) {
            message += " Your path contains a .pb file extension. Support for .pb models have been removed in TensorFlow.js 1.0 in favor of .json models. You can re-convert your Python TensorFlow model using the TensorFlow.js 1.0 conversion scripts or you can convert your.pb models with the 'pb2json'NPM script in the tensorflow/tfjs-converter repository.";
          } else {
            message += " Please make sure the server is serving valid JSON for this request.";
          }
          throw new Error(message);
        }
        const modelTopology = modelConfig.modelTopology;
        const weightsManifest = modelConfig.weightsManifest;
        const generatedBy = modelConfig.generatedBy;
        const convertedBy = modelConfig.convertedBy;
        const format = modelConfig.format;
        const userDefinedMetadata = modelConfig.userDefinedMetadata;
        if (modelTopology == null && weightsManifest == null) {
          throw new Error(`The JSON from HTTP path ${this.path} contains neither model topology or manifest for weights.`);
        }
        let weightSpecs;
        let weightData;
        if (weightsManifest != null) {
          const results = await this.loadWeights(weightsManifest);
          [weightSpecs, weightData] = results;
        }
        const artifacts = {
          modelTopology,
          weightSpecs,
          weightData,
          userDefinedMetadata,
          generatedBy,
          convertedBy,
          format
        };
        const initializer = modelConfig.modelInitializer;
        if (initializer) {
          artifacts.modelInitializer = initializer;
        }
        return artifacts;
      }
      async loadWeights(weightsManifest) {
        const weightPath = Array.isArray(this.path) ? this.path[1] : this.path;
        const [prefix, suffix] = parseUrl(weightPath);
        const pathPrefix = this.weightPathPrefix || prefix;
        const weightSpecs = [];
        for (const entry of weightsManifest) {
          weightSpecs.push(...entry.weights);
        }
        const fetchURLs = [];
        const urlPromises = [];
        for (const weightsGroup of weightsManifest) {
          for (const path of weightsGroup.paths) {
            if (this.weightUrlConverter != null) {
              urlPromises.push(this.weightUrlConverter(path));
            } else {
              fetchURLs.push(pathPrefix + path + suffix);
            }
          }
        }
        if (this.weightUrlConverter) {
          fetchURLs.push(...await Promise.all(urlPromises));
        }
        const buffers = await loadWeightsAsArrayBuffer(fetchURLs, {
          requestInit: this.requestInit,
          fetchFunc: this.fetch,
          onProgress: this.onProgress
        });
        return [weightSpecs, concatenateArrayBuffers(buffers)];
      }
    }
    HTTPRequest.URL_SCHEME_REGEX = /^https?:\/\//;
    function parseUrl(url) {
      const lastSlash = url.lastIndexOf("/");
      const lastSearchParam = url.lastIndexOf("?");
      const prefix = url.substring(0, lastSlash);
      const suffix = lastSearchParam > lastSlash ? url.substring(lastSearchParam) : "";
      return [prefix + "/", suffix];
    }
    function isHTTPScheme(url) {
      return url.match(HTTPRequest.URL_SCHEME_REGEX) != null;
    }
    const httpRouter = (url, loadOptions) => {
      if (typeof fetch === "undefined" && (loadOptions == null || loadOptions.fetchFunc == null)) {
        return null;
      } else {
        let isHTTP = true;
        if (Array.isArray(url)) {
          isHTTP = url.every((urlItem) => isHTTPScheme(urlItem));
        } else {
          isHTTP = isHTTPScheme(url);
        }
        if (isHTTP) {
          return http(url, loadOptions);
        }
      }
      return null;
    };
    IORouterRegistry.registerSaveRouter(httpRouter);
    IORouterRegistry.registerLoadRouter(httpRouter);
    function http(path, loadOptions) {
      return new HTTPRequest(path, loadOptions);
    }
    function browserHTTPRequest(path, loadOptions) {
      return http(path, loadOptions);
    }
    /**
     * @license
     * Copyright 2018 Google LLC. All Rights Reserved.
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     * http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     * =============================================================================
     */
    class PassthroughLoader {
      constructor(modelArtifacts) {
        this.modelArtifacts = modelArtifacts;
      }
      async load() {
        return this.modelArtifacts;
      }
    }
    class PassthroughSaver {
      constructor(saveHandler) {
        this.saveHandler = saveHandler;
      }
      async save(modelArtifacts) {
        return this.saveHandler(modelArtifacts);
      }
    }
    function fromMemory(modelArtifacts, weightSpecs, weightData, trainingConfig) {
      if (arguments.length === 1) {
        const isModelArtifacts = modelArtifacts.modelTopology != null || modelArtifacts.weightSpecs != null;
        if (isModelArtifacts) {
          return new PassthroughLoader(modelArtifacts);
        } else {
          console.warn("Please call tf.io.fromMemory() with only one argument. The argument should be of type ModelArtifacts. The multi-argument signature of tf.io.fromMemory() has been deprecated and will be removed in a future release.");
          return new PassthroughLoader({modelTopology: modelArtifacts});
        }
      } else {
        console.warn("Please call tf.io.fromMemory() with only one argument. The argument should be of type ModelArtifacts. The multi-argument signature of tf.io.fromMemory() has been deprecated and will be removed in a future release.");
        return new PassthroughLoader({
          modelTopology: modelArtifacts,
          weightSpecs,
          weightData,
          trainingConfig
        });
      }
    }
    function withSaveHandler(saveHandler) {
      return new PassthroughSaver(saveHandler);
    }
    /**
     * @license
     * Copyright 2018 Google LLC. All Rights Reserved.
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     * http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     * =============================================================================
     */
    var io = /* @__PURE__ */ Object.freeze({
      __proto__: null,
      browserFiles,
      browserHTTPRequest,
      concatenateArrayBuffers,
      decodeWeights,
      encodeWeights,
      fromMemory,
      getLoadHandlers,
      getModelArtifactsInfoForJSON,
      getSaveHandlers,
      http,
      isHTTPScheme,
      loadWeights,
      registerLoadRouter,
      registerSaveRouter,
      weightsLoaderFactory,
      withSaveHandler,
      copyModel,
      listModels,
      moveModel,
      removeModel
    });
    /**
     * @license
     * Copyright 2020 Google LLC. All Rights Reserved.
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     * http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     * =============================================================================
     */
    function reshape_2(x, shape) {
      const $x = convertToTensor2(x, "x", "reshape", null);
      const inputs = {x: $x};
      const attrs = {shape};
      const forward = (backend3, save) => {
        shape = inferFromImplicitShape2(shape, $x.size);
        assert2($x.size === sizeFromShape2(shape), () => "new shape and old shape must have the same number of elements.");
        save([$x]);
        return backend3.reshape($x, shape);
      };
      return ENGINE2.runKernelFunc(forward, inputs, null, Reshape6, attrs);
    }
    const reshape5 = op2({reshape_: reshape_2});
    /**
     * @license
     * Copyright 2020 Google LLC. All Rights Reserved.
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     * http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     * =============================================================================
     */
    function matMul_(a, b, transposeA = false, transposeB = false) {
      let $a = convertToTensor2(a, "a", "matMul");
      let $b = convertToTensor2(b, "b", "matMul");
      [$a, $b] = makeTypesMatch2($a, $b);
      const forward = (backend3, save) => {
        save([$a, $b]);
        const innerShapeA = transposeA ? $a.shape[$a.rank - 2] : $a.shape[$a.rank - 1];
        const innerShapeB = transposeB ? $b.shape[$b.rank - 1] : $b.shape[$b.rank - 2];
        const outerShapeA = transposeA ? $a.shape[$a.rank - 1] : $a.shape[$a.rank - 2];
        const outerShapeB = transposeB ? $b.shape[$b.rank - 2] : $b.shape[$b.rank - 1];
        const outerDimsA = $a.shape.slice(0, -2);
        const outerDimsB = $b.shape.slice(0, -2);
        const batchDimA = sizeFromShape2(outerDimsA);
        const batchDimB = sizeFromShape2(outerDimsB);
        const batchDimsCompatible = batchDimA === batchDimB || batchDimA === 1 || batchDimB === 1;
        assert2($a.rank >= 2 && $b.rank >= 2 && batchDimsCompatible, () => `Error in matMul: the input batch dimensions must either be the same or at least one input batch dimension must be 1. Got input batch dimensions of (${outerDimsA}) and (${outerDimsB}).`);
        assert2(innerShapeA === innerShapeB, () => `Error in matMul: inner shapes (${innerShapeA}) and (${innerShapeB}) of Tensors with shapes ${$a.shape} and ${$b.shape} and transposeA=${transposeA} and transposeB=${transposeB} must match.`);
        const outShapeOuterDims = batchDimA > batchDimB ? outerDimsA : outerDimsB;
        const outShape = outShapeOuterDims.concat([outerShapeA, outerShapeB]);
        const a3D = transposeA ? reshape5($a, [batchDimA, innerShapeA, outerShapeA]) : reshape5($a, [batchDimA, outerShapeA, innerShapeA]);
        const b3D = transposeB ? reshape5($b, [batchDimB, outerShapeB, innerShapeB]) : reshape5($b, [batchDimB, innerShapeB, outerShapeB]);
        const res3d = backend3.batchMatMul(a3D, b3D, transposeA, transposeB);
        return reshape5(res3d, outShape);
      };
      const inputs = {a: $a, b: $b};
      const attrs = {transposeA, transposeB};
      return ENGINE2.runKernelFunc(forward, inputs, null, BatchMatMul3, attrs);
    }
    const matMul = op2({matMul_});
    /**
     * @license
     * Copyright 2020 Google LLC. All Rights Reserved.
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     * http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     * =============================================================================
     */
    function oneHot_(indices, depth, onValue = 1, offValue = 0) {
      if (depth < 2) {
        throw new Error(`Error in oneHot: depth must be >=2, but it is ${depth}`);
      }
      const $indices = convertToTensor2(indices, "indices", "oneHot", "int32");
      const outShape = [...$indices.shape, depth];
      const forward = (backend3, save) => {
        save([$indices]);
        return reshape5(backend3.oneHot(reshape5($indices, [$indices.size]), depth, onValue, offValue), outShape);
      };
      const inputs = {indices: $indices};
      const attrs = {depth, onValue, offValue};
      return ENGINE2.runKernelFunc(forward, inputs, null, OneHot3, attrs);
    }
    const oneHot2 = op2({oneHot_});
    /**
     * @license
     * Copyright 2018 Google LLC. All Rights Reserved.
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     * http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     * =============================================================================
     */
    function transpose_2(x, perm) {
      const $x = convertToTensor2(x, "x", "transpose");
      if (perm == null) {
        perm = $x.shape.map((s, i) => i).reverse();
      }
      assert2($x.rank === perm.length, () => `Error in transpose: rank of input ${$x.rank} must match length of perm ${perm}.`);
      perm.forEach((axis) => {
        assert2(axis >= 0 && axis < $x.rank, () => `All entries in 'perm' must be between 0 and ${$x.rank - 1} but got ${perm}`);
      });
      if ($x.rank <= 1) {
        return $x.clone();
      }
      const inputs = {x: $x};
      const attrs = {perm};
      return ENGINE2.runKernelFunc((backend3) => backend3.transpose($x, perm), inputs, null, Transpose5, attrs);
    }
    const transpose4 = op2({transpose_: transpose_2});
    /**
     * @license
     * Copyright 2018 Google LLC. All Rights Reserved.
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     * http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     * =============================================================================
     */
    function confusionMatrix_(labels, predictions, numClasses) {
      const $labels = convertToTensor2(labels, "labels", "confusionMatrix");
      const $predictions = convertToTensor2(predictions, "predictions", "confusionMatrix");
      assert2(numClasses == null || numClasses > 0 && Number.isInteger(numClasses), () => `If provided, numClasses must be a positive integer, but got ${numClasses}`);
      assert2($labels.rank === 1, () => `Expected the rank of labels to be 1, but got ${$labels.rank}`);
      assert2($predictions.rank === 1, () => `Expected the rank of predictions to be 1, but got ${$predictions.rank}`);
      assert2($labels.shape[0] === $predictions.shape[0], () => `Mismatch in the number of examples: ${$labels.shape[0]} vs. ${$predictions.shape[0]}. Labels and predictions should have the same number of elements.`);
      assert2(numClasses > 0 && Number.isInteger(numClasses), () => `numClasses is required to be a positive integer, but got ${numClasses}`);
      const oneHotLabels = oneHot2(cast7($labels, "int32"), numClasses);
      const oneHotPredictions = oneHot2(cast7($predictions, "int32"), numClasses);
      const oneHotLabelsT = transpose4(oneHotLabels);
      const product = matMul(oneHotLabelsT, oneHotPredictions);
      return cast7(product, "int32");
    }
    const confusionMatrix = op2({confusionMatrix_});
    /**
     * @license
     * Copyright 2018 Google LLC. All Rights Reserved.
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     * http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     * =============================================================================
     */
    var math = /* @__PURE__ */ Object.freeze({
      __proto__: null,
      confusionMatrix
    });
    /**
     * @license
     * Copyright 2018 Google LLC. All Rights Reserved.
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     * http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     * =============================================================================
     */
    function tensor3d(values, shape, dtype) {
      assertNonNull2(values);
      if (shape != null && shape.length !== 3) {
        throw new Error("tensor3d() requires shape to have three numbers");
      }
      const inferredShape = inferShape2(values, dtype);
      if (inferredShape.length !== 3 && inferredShape.length !== 1) {
        throw new Error("tensor3d() requires values to be number[][][] or flat/TypedArray");
      }
      if (inferredShape.length === 1 && shape == null) {
        throw new Error("tensor3d() requires shape to be provided when `values` are a flat array");
      }
      return makeTensor2(values, shape, inferredShape, dtype);
    }
    /**
     * @license
     * Copyright 2019 Google LLC. All Rights Reserved.
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     * http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     * =============================================================================
     */
    let fromPixels2DContext;
    function fromPixels_(pixels, numChannels = 3) {
      if (numChannels > 4) {
        throw new Error("Cannot construct Tensor with more than 4 channels from pixels.");
      }
      if (pixels == null) {
        throw new Error("pixels passed to tf.browser.fromPixels() can not be null");
      }
      let isPixelData = false;
      let isImageData = false;
      let isVideo = false;
      let isImage = false;
      let isCanvasLike = false;
      if (pixels.data instanceof Uint8Array) {
        isPixelData = true;
      } else if (typeof ImageData !== "undefined" && pixels instanceof ImageData) {
        isImageData = true;
      } else if (typeof HTMLVideoElement !== "undefined" && pixels instanceof HTMLVideoElement) {
        isVideo = true;
      } else if (typeof HTMLImageElement !== "undefined" && pixels instanceof HTMLImageElement) {
        isImage = true;
      } else if (pixels.getContext != null) {
        isCanvasLike = true;
      } else {
        throw new Error(`pixels passed to tf.browser.fromPixels() must be either an HTMLVideoElement, HTMLImageElement, HTMLCanvasElement, ImageData in browser, or OffscreenCanvas, ImageData in webworker or {data: Uint32Array, width: number, height: number}, but was ${pixels.constructor.name}`);
      }
      if (isVideo) {
        const HAVE_CURRENT_DATA_READY_STATE = 2;
        if (isVideo && pixels.readyState < HAVE_CURRENT_DATA_READY_STATE) {
          throw new Error("The video element has not loaded data yet. Please wait for `loadeddata` event on the <video> element.");
        }
      }
      const kernel = getKernel2(FromPixels, ENGINE2.backendName);
      if (kernel != null) {
        const inputs = {pixels};
        const attrs = {numChannels};
        return ENGINE2.runKernel(FromPixels, inputs, attrs);
      }
      const [width, height] = isVideo ? [
        pixels.videoWidth,
        pixels.videoHeight
      ] : [pixels.width, pixels.height];
      let vals;
      if (isCanvasLike) {
        vals = pixels.getContext("2d").getImageData(0, 0, width, height).data;
      } else if (isImageData || isPixelData) {
        vals = pixels.data;
      } else if (isImage || isVideo) {
        if (fromPixels2DContext == null) {
          fromPixels2DContext = document.createElement("canvas").getContext("2d");
        }
        fromPixels2DContext.canvas.width = width;
        fromPixels2DContext.canvas.height = height;
        fromPixels2DContext.drawImage(pixels, 0, 0, width, height);
        vals = fromPixels2DContext.getImageData(0, 0, width, height).data;
      }
      let values;
      if (numChannels === 4) {
        values = new Int32Array(vals);
      } else {
        const numPixels = width * height;
        values = new Int32Array(numPixels * numChannels);
        for (let i = 0; i < numPixels; i++) {
          for (let channel = 0; channel < numChannels; ++channel) {
            values[i * numChannels + channel] = vals[i * 4 + channel];
          }
        }
      }
      const outShape = [height, width, numChannels];
      return tensor3d(values, outShape, "int32");
    }
    async function toPixels(img, canvas) {
      let $img = convertToTensor2(img, "img", "toPixels");
      if (!(img instanceof Tensor2)) {
        const originalImgTensor = $img;
        $img = cast7(originalImgTensor, "int32");
        originalImgTensor.dispose();
      }
      if ($img.rank !== 2 && $img.rank !== 3) {
        throw new Error(`toPixels only supports rank 2 or 3 tensors, got rank ${$img.rank}.`);
      }
      const [height, width] = $img.shape.slice(0, 2);
      const depth = $img.rank === 2 ? 1 : $img.shape[2];
      if (depth > 4 || depth === 2) {
        throw new Error(`toPixels only supports depth of size 1, 3 or 4 but got ${depth}`);
      }
      if ($img.dtype !== "float32" && $img.dtype !== "int32") {
        throw new Error(`Unsupported type for toPixels: ${$img.dtype}. Please use float32 or int32 tensors.`);
      }
      const data2 = await $img.data();
      const multiplier = $img.dtype === "float32" ? 255 : 1;
      const bytes = new Uint8ClampedArray(width * height * 4);
      for (let i = 0; i < height * width; ++i) {
        const rgba = [0, 0, 0, 255];
        for (let d = 0; d < depth; d++) {
          const value = data2[i * depth + d];
          if ($img.dtype === "float32") {
            if (value < 0 || value > 1) {
              throw new Error(`Tensor values for a float32 Tensor must be in the range [0 - 1] but encountered ${value}.`);
            }
          } else if ($img.dtype === "int32") {
            if (value < 0 || value > 255) {
              throw new Error(`Tensor values for a int32 Tensor must be in the range [0 - 255] but encountered ${value}.`);
            }
          }
          if (depth === 1) {
            rgba[0] = value * multiplier;
            rgba[1] = value * multiplier;
            rgba[2] = value * multiplier;
          } else {
            rgba[d] = value * multiplier;
          }
        }
        const j = i * 4;
        bytes[j + 0] = Math.round(rgba[0]);
        bytes[j + 1] = Math.round(rgba[1]);
        bytes[j + 2] = Math.round(rgba[2]);
        bytes[j + 3] = Math.round(rgba[3]);
      }
      if (canvas != null) {
        canvas.width = width;
        canvas.height = height;
        const ctx = canvas.getContext("2d");
        const imageData = new ImageData(bytes, width, height);
        ctx.putImageData(imageData, 0, 0);
      }
      if ($img !== img) {
        $img.dispose();
      }
      return bytes;
    }
    const fromPixels = op2({fromPixels_});
    var browser = /* @__PURE__ */ Object.freeze({
      __proto__: null,
      toPixels,
      fromPixels
    });
    function prepareAndValidate2(tensor7, indices) {
      if (tensor7.rank < 1) {
        throw new Error(`tf.gatherND() expects the input to be rank 1 or higher, but the rank was ${tensor7.rank}.`);
      }
      if (indices.rank < 1) {
        throw new Error(`tf.gatherND() expects the indices to be rank 1 or higher, but the rank was ${indices.rank}.`);
      }
      if (indices.dtype !== "int32") {
        throw new Error(`tf.gatherND() expects the indices to be int32 type, but the dtype was ${indices.dtype}.`);
      }
      if (indices.shape[indices.rank - 1] > tensor7.rank) {
        throw new Error(`index innermost dimension length must be <= tensor rank; saw: ${indices.shape[indices.rank - 1]} vs. ${tensor7.rank}`);
      }
      if (tensor7.size === 0) {
        throw new Error(`Requested more than 0 entries, but input is empty. Input shape: ${tensor7.shape}.`);
      }
      const indicesShape = indices.shape;
      const sliceRank = indicesShape[indicesShape.length - 1];
      let nResult = 1;
      for (let i = 0; i < indicesShape.length - 1; ++i) {
        nResult *= indicesShape[i];
      }
      const inputShape = tensor7.shape;
      const resultShape = indicesShape.slice();
      resultShape.pop();
      let sliceSize = 1;
      for (let i = sliceRank; i < tensor7.rank; ++i) {
        sliceSize *= inputShape[i];
        resultShape.push(inputShape[i]);
      }
      const strides = [
        ...computeStrides2(tensor7.shape).map((stride) => stride / sliceSize),
        1
      ].slice(0, sliceRank);
      return [resultShape, nResult, sliceSize, strides];
    }
    var gather_nd_util = /* @__PURE__ */ Object.freeze({
      __proto__: null,
      prepareAndValidate: prepareAndValidate2
    });
    function validateUpdateShape2(shape, indices, updates) {
      const sliceDim = indices.rank > 1 ? indices.shape[indices.rank - 1] : 1;
      const batchDim = indices.rank > 1 ? indices.rank - 1 : 1;
      const shapeError = `Must have updates.shape = indices.shape[:batchDim] + shape[sliceDim:], got updates.shape: ${updates.shape}, indices.shape: ${indices.shape}, shape: ${shape}, sliceDim: ${sliceDim}, and batchDim: ${batchDim}.`;
      if (updates.rank < batchDim) {
        throw new Error(shapeError + ` update.rank < ${batchDim}. `);
      }
      if (shape.length < sliceDim + (updates.rank - batchDim)) {
        throw new Error(shapeError + ` Output shape length < ${sliceDim + (updates.rank - batchDim)}`);
      }
      if (updates.rank !== batchDim + shape.length - sliceDim) {
        throw new Error(shapeError + ` update.rank != ${batchDim + shape.length - sliceDim}`);
      }
      for (let d = 0; d < batchDim; ++d) {
        if (updates.shape[d] !== indices.shape[d]) {
          throw new Error(shapeError + ` updates.shape[${d}] (${updates.shape[d]}) != indices.shape[${d}] (${indices.shape[d]}).`);
        }
      }
      for (let d = 0; d < updates.rank - batchDim; ++d) {
        if (updates.shape[d + batchDim] !== shape[d + sliceDim]) {
          throw new Error(shapeError + ` updates.shape[${d + batchDim}] (${updates.shape[d + batchDim]}) != shape[${d + batchDim}] (${shape[d + batchDim]})`);
        }
      }
    }
    function validateInput2(updates, indices, shape) {
      if (indices.rank < 1) {
        throw new Error(`tf.scatterND() expects the indices to be rank 1 or higher, but the rank was ${indices.rank}.`);
      }
      if (updates.rank < 1) {
        throw new Error(`tf.scatterND() expects the updates to be rank 1 or higher, but the rank was ${updates.rank}.`);
      }
      if (indices.dtype !== "int32") {
        throw new Error(`The dtype of 'indices' should be int32, but got dtype: ${indices.dtype}`);
      }
      if (shape.length < 1) {
        throw new Error(`Output rank must be greater or equal to 1, but got shape: ${shape}`);
      }
      if (shape.length === 0) {
        if (indices.size === 0) {
          throw new Error(`Indices specified for empty output. indices shape: ${indices.shape}`);
        }
        if (updates.size === 0) {
          throw new Error(`Updates specified for empty output. updates shape: ${updates.shape}`);
        }
      }
      validateUpdateShape2(shape, indices, updates);
    }
    function calculateShapes2(updates, indices, shape) {
      const indicesRank = indices.shape.length;
      const sliceRank = indicesRank > 1 ? indices.shape[indicesRank - 1] : 1;
      const totalNd = shape.length;
      let sliceSize = 1;
      for (let i = sliceRank; i < totalNd; ++i) {
        sliceSize *= shape[i];
      }
      const safeSliceDim = sliceRank < 1 ? 1 : sliceRank;
      const numUpdates = sizeFromShape2(indices.shape) / safeSliceDim;
      const strides = [...computeStrides2(shape.slice(0, sliceRank)), 1];
      const outputSize = sizeFromShape2(shape);
      return {sliceRank, numUpdates, sliceSize, strides, outputSize};
    }
    var scatter_nd_util = /* @__PURE__ */ Object.freeze({
      __proto__: null,
      validateUpdateShape: validateUpdateShape2,
      validateInput: validateInput2,
      calculateShapes: calculateShapes2
    });
    /**
     * @license
     * Copyright 2017 Google LLC. All Rights Reserved.
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     * http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     * =============================================================================
     */
    function assertParamsValid2(input2, begin, size) {
      const inputRank = input2.shape.length;
      assert2(inputRank === begin.length, () => `Error in slice${inputRank}D: Length of begin ${begin} must match the rank of the array (${inputRank}).`);
      assert2(inputRank === size.length, () => `Error in slice${inputRank}D: Length of size ${size} must match the rank of the array (${inputRank}).`);
      for (let i = 0; i < inputRank; ++i) {
        assert2(begin[i] + size[i] <= input2.shape[i], () => `Error in slice${inputRank}D: begin[${i}] + size[${i}] (${begin[i] + size[i]}) would overflow input.shape[${i}] (${input2.shape[i]})`);
      }
    }
    function maskToAxes2(mask) {
      const axes = [];
      let axis = 0;
      while (mask > 0) {
        if (mask & 1) {
          axes.push(axis);
        }
        mask /= 2;
        axis++;
      }
      return axes;
    }
    function computeOutShape5(begin, end, strides) {
      const size = [];
      for (let axis = 0; axis < begin.length; axis++) {
        size[axis] = Math.ceil((end[axis] - begin[axis]) / strides[axis]);
      }
      return size;
    }
    function stridesWithElidedDims2(strides, ellipsisInsertionIndex, numElidedAxes, inputShape) {
      const newStrides = [...strides];
      for (let i = newStrides.length; i < inputShape.length; i++) {
        newStrides.push(1);
      }
      for (let i = 0; i < numElidedAxes; i++) {
        if (i === 0) {
          newStrides[ellipsisInsertionIndex] = 1;
        } else {
          newStrides.splice(ellipsisInsertionIndex, 0, 1);
          newStrides.pop();
        }
      }
      return newStrides;
    }
    function unnormalizeAxis2(ellipsisInsertionIndex, numElidedAxes, normalizedAxis) {
      if (normalizedAxis <= ellipsisInsertionIndex) {
        return normalizedAxis;
      }
      return normalizedAxis - (numElidedAxes - 1);
    }
    function getElidedAxes2(numElidedAxes, ellipsisInsertionIndex) {
      const elidedAxes = [];
      for (let i = 0; i < numElidedAxes; i++) {
        elidedAxes.push(ellipsisInsertionIndex + i);
      }
      return elidedAxes;
    }
    function getNormalizedAxes2(inputShape, ellipsisAxes, numInterpolatedAxes, begin, end, strides, beginMask, endMask, ellipsisMask) {
      const inputRank = inputShape.length;
      let normalizedBegin = new Array(inputRank), normalizedEnd = new Array(inputRank), normalizedStrides = new Array(inputRank);
      if (ellipsisAxes.length && numInterpolatedAxes > 0) {
        const fullIndex = ellipsisAxes[0];
        const numElidedAxes = numInterpolatedAxes + 1;
        normalizedBegin = startIndicesWithElidedDims2(beginMask, fullIndex, numElidedAxes, begin, inputShape);
        normalizedEnd = stopIndicesWithElidedDims2(endMask, fullIndex, numElidedAxes, end, inputShape);
        normalizedStrides = stridesWithElidedDims2(strides, fullIndex, numElidedAxes, inputShape);
      } else {
        for (let axis = 0; axis < inputRank; axis++) {
          normalizedBegin[axis] = startForAxis2(beginMask, begin, strides, inputShape, axis, ellipsisMask);
          normalizedEnd[axis] = stopForAxis2(endMask, end, strides, inputShape, axis, ellipsisMask);
          normalizedStrides[axis] = stridesForAxis2(strides, axis, ellipsisMask);
        }
      }
      return {
        begin: normalizedBegin,
        end: normalizedEnd,
        strides: normalizedStrides
      };
    }
    function startIndicesWithElidedDims2(beginMask, ellipsisInsertionIndex, numElidedAxes, originalBegin, inputShape) {
      const newIndices = [...inputShape];
      const elidedAxes = getElidedAxes2(numElidedAxes, ellipsisInsertionIndex);
      for (let axis = 0; axis < newIndices.length; axis++) {
        if (elidedAxes.indexOf(axis) > -1) {
          newIndices[axis] = 0;
        } else {
          const originalAxis = unnormalizeAxis2(ellipsisInsertionIndex, numElidedAxes, axis);
          let originalValue = originalBegin[originalAxis];
          if (beginMask & 1 << originalAxis) {
            originalValue = 0;
          }
          newIndices[axis] = originalValue;
        }
      }
      return newIndices;
    }
    function stopIndicesWithElidedDims2(endMask, ellipsisInsertionIndex, numElidedAxes, originalEnd, inputShape) {
      const newIndices = [...inputShape];
      const elidedAxes = getElidedAxes2(numElidedAxes, ellipsisInsertionIndex);
      for (let axis = 0; axis < newIndices.length; axis++) {
        if (elidedAxes.indexOf(axis) > -1) {
          newIndices[axis] = Number.MAX_SAFE_INTEGER;
        } else {
          const originalAxis = unnormalizeAxis2(ellipsisInsertionIndex, numElidedAxes, axis);
          let originalValue = originalEnd[originalAxis];
          if (endMask & 1 << originalAxis) {
            originalValue = Number.MAX_SAFE_INTEGER;
          }
          newIndices[axis] = originalValue;
        }
      }
      for (let i = 0; i < newIndices.length; i++) {
        const axisSize = inputShape[i];
        if (newIndices[i] < 0) {
          newIndices[i] += axisSize;
        }
        newIndices[i] = clamp2(0, newIndices[i], inputShape[i]);
      }
      return newIndices;
    }
    function stridesForAxis2(strides, axis, ellipsisMask) {
      let stride = strides[axis];
      if (ellipsisMask & 1 << axis || stride == null) {
        stride = 1;
      }
      return stride;
    }
    function startForAxis2(beginMask, startIndices, strides, inputShape, axis, ellipsisMask) {
      let start = startIndices[axis];
      const stride = strides[axis] || 1;
      if (beginMask & 1 << axis || ellipsisMask & 1 << axis || start == null) {
        if (stride > 0) {
          start = Number.MIN_SAFE_INTEGER;
        } else {
          start = Number.MAX_SAFE_INTEGER;
        }
      }
      const axisSize = inputShape[axis];
      if (start < 0) {
        start += axisSize;
      }
      start = clamp2(0, start, axisSize - 1);
      return start;
    }
    function stopForAxis2(endMask, stopIndices, strides, inputShape, axis, ellipsisMask) {
      let stop = stopIndices[axis];
      const stride = strides[axis] || 1;
      if (endMask & 1 << axis || ellipsisMask & 1 << axis || stop == null) {
        if (stride > 0) {
          stop = Number.MAX_SAFE_INTEGER;
        } else {
          stop = Number.MIN_SAFE_INTEGER;
        }
      }
      const axisSize = inputShape[axis];
      if (stop < 0) {
        stop += axisSize;
      }
      if (stride > 0) {
        stop = clamp2(0, stop, axisSize);
      } else {
        stop = clamp2(-1, stop, axisSize - 1);
      }
      return stop;
    }
    function isSliceContinous2(shape, begin, size) {
      let firstNonOneAxis = size.length;
      for (let i = 0; i < size.length; i++) {
        if (size[i] > 1) {
          firstNonOneAxis = i;
          break;
        }
      }
      for (let i = firstNonOneAxis + 1; i < size.length; i++) {
        if (begin[i] > 0 || size[i] !== shape[i]) {
          return false;
        }
      }
      return true;
    }
    function computeFlatOffset2(begin, strides) {
      let flatOffset = begin.length > 0 ? begin[begin.length - 1] : 1;
      for (let i = 0; i < begin.length - 1; i++) {
        flatOffset += begin[i] * strides[i];
      }
      return flatOffset;
    }
    function parseSliceParams2(x, begin, size) {
      let begin_;
      const xRank = x.shape.length;
      if (typeof begin === "number") {
        begin_ = [begin, ...new Array(xRank - 1).fill(0)];
      } else if (begin.length < xRank) {
        begin_ = begin.concat(new Array(xRank - begin.length).fill(0));
      } else {
        begin_ = begin.slice();
      }
      begin_.forEach((d) => {
        assert2(d !== -1, () => "slice() does not support negative begin indexing.");
      });
      let size_;
      if (size == null) {
        size_ = new Array(xRank).fill(-1);
      } else if (typeof size === "number") {
        size_ = [size, ...new Array(xRank - 1).fill(-1)];
      } else if (size.length < xRank) {
        size_ = size.concat(new Array(xRank - size.length).fill(-1));
      } else {
        size_ = size;
      }
      size_ = size_.map((d, i) => {
        if (d >= 0) {
          return d;
        } else {
          assert2(d === -1, () => `Negative size values should be exactly -1 but got ${d} for the slice() size at index ${i}.`);
          return x.shape[i] - begin_[i];
        }
      });
      return [begin_, size_];
    }
    var slice_util = /* @__PURE__ */ Object.freeze({
      __proto__: null,
      assertParamsValid: assertParamsValid2,
      maskToAxes: maskToAxes2,
      computeOutShape: computeOutShape5,
      stridesWithElidedDims: stridesWithElidedDims2,
      getNormalizedAxes: getNormalizedAxes2,
      startIndicesWithElidedDims: startIndicesWithElidedDims2,
      stopIndicesWithElidedDims: stopIndicesWithElidedDims2,
      stridesForAxis: stridesForAxis2,
      startForAxis: startForAxis2,
      stopForAxis: stopForAxis2,
      isSliceContinous: isSliceContinous2,
      computeFlatOffset: computeFlatOffset2,
      parseSliceParams: parseSliceParams2
    });
    /**
     * @license
     * Copyright 2018 Google LLC. All Rights Reserved.
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     * http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     * =============================================================================
     */
    class Serializable {
      getClassName() {
        return this.constructor.className;
      }
      static fromConfig(cls, config2) {
        return new cls(config2);
      }
    }
    class SerializationMap {
      constructor() {
        this.classNameMap = {};
      }
      static getMap() {
        if (SerializationMap.instance == null) {
          SerializationMap.instance = new SerializationMap();
        }
        return SerializationMap.instance;
      }
      static register(cls) {
        SerializationMap.getMap().classNameMap[cls.className] = [cls, cls.fromConfig];
      }
    }
    function registerClass(cls) {
      assert2(cls.className != null, () => `Class being registered does not have the static className property defined.`);
      assert2(typeof cls.className === "string", () => `className is required to be a string, but got type ` + typeof cls.className);
      assert2(cls.className.length > 0, () => `Class being registered has an empty-string as its className, which is disallowed.`);
      SerializationMap.register(cls);
    }
    var serialization = /* @__PURE__ */ Object.freeze({
      __proto__: null,
      Serializable,
      SerializationMap,
      registerClass
    });
    /**
     * @license
     * Copyright 2017 Google LLC. All Rights Reserved.
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     * http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     * =============================================================================
     */
    const TEST_EPSILON_FLOAT32 = 1e-3;
    const TEST_EPSILON_FLOAT16 = 0.1;
    function expectArraysClose(actual, expected, epsilon2) {
      if (epsilon2 == null) {
        epsilon2 = testEpsilon();
      }
      return expectArraysPredicate(actual, expected, (a, b) => areClose(a, b, epsilon2));
    }
    function testEpsilon() {
      return ENGINE2.backend.floatPrecision() === 32 ? TEST_EPSILON_FLOAT32 : TEST_EPSILON_FLOAT16;
    }
    function expectArraysPredicate(actual, expected, predicate) {
      let checkClassType = true;
      if (isTypedArray2(actual) || isTypedArray2(expected)) {
        checkClassType = false;
      }
      if (isTypedArray2(actual) && isTypedArray2(expected)) {
        checkClassType = true;
      }
      if (checkClassType) {
        const aType = actual.constructor.name;
        const bType = expected.constructor.name;
        if (aType !== bType) {
          throw new Error(`Arrays are of different type. Actual: ${aType}. Expected: ${bType}`);
        }
      }
      if (Array.isArray(actual) && Array.isArray(expected)) {
        const actualShape = inferShape2(actual);
        const expectedShape = inferShape2(expected);
        if (!arraysEqual2(actualShape, expectedShape)) {
          throw new Error(`Arrays have different shapes. Actual: [${actualShape}]. Expected: [${expectedShape}]`);
        }
      }
      const actualFlat = isTypedArray2(actual) ? actual : flatten2(actual);
      const expectedFlat = isTypedArray2(expected) ? expected : flatten2(expected);
      if (actualFlat.length !== expectedFlat.length) {
        throw new Error(`Arrays have different lengths actual: ${actualFlat.length} vs expected: ${expectedFlat.length}.
Actual:   ${actualFlat}.
Expected: ${expectedFlat}.`);
      }
      for (let i = 0; i < expectedFlat.length; ++i) {
        const a = actualFlat[i];
        const e = expectedFlat[i];
        if (!predicate(a, e)) {
          throw new Error(`Arrays differ: actual[${i}] = ${a}, expected[${i}] = ${e}.
Actual:   ${actualFlat}.
Expected: ${expectedFlat}.`);
        }
      }
    }
    function expectPromiseToFail(fn, done) {
      fn().then(() => done.fail(), () => done());
    }
    function expectArraysEqual(actual, expected) {
      const exp2 = typeof expected === "string" || typeof expected === "number" || typeof expected === "boolean" ? [expected] : expected;
      if (isString2(actual) || isString2(actual[0]) || isString2(expected) || isString2(expected[0])) {
        return expectArraysPredicate(actual, exp2, (a, b) => a == b);
      }
      return expectArraysPredicate(actual, expected, (a, b) => areClose(a, b, 0));
    }
    function expectNumbersClose(a, e, epsilon2) {
      if (epsilon2 == null) {
        epsilon2 = testEpsilon();
      }
      if (!areClose(a, e, epsilon2)) {
        throw new Error(`Numbers differ: actual === ${a}, expected === ${e}`);
      }
    }
    function areClose(a, e, epsilon2) {
      if (!isFinite(a) && !isFinite(e)) {
        return true;
      }
      if (isNaN(a) || isNaN(e) || Math.abs(a - e) > epsilon2) {
        return false;
      }
      return true;
    }
    function expectValuesInRange(actual, low, high) {
      for (let i = 0; i < actual.length; i++) {
        if (actual[i] < low || actual[i] > high) {
          throw new Error(`Value out of range:${actual[i]} low: ${low}, high: ${high}`);
        }
      }
    }
    function expectArrayBuffersEqual(actual, expected) {
      expect(new Float32Array(actual)).toEqual(new Float32Array(expected));
    }
    var test_util = /* @__PURE__ */ Object.freeze({
      __proto__: null,
      TEST_EPSILON_FLOAT16,
      expectArraysClose,
      testEpsilon,
      expectPromiseToFail,
      expectArraysEqual,
      expectNumbersClose,
      expectValuesInRange,
      expectArrayBuffersEqual
    });
    /** @license See the LICENSE file. */
    const version4 = "2.7.0";
    /**
     * @license
     * Copyright 2018 Google LLC. All Rights Reserved.
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     * http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     * =============================================================================
     */
    function enableProdMode() {
      env2().set("PROD", true);
    }
    function enableDebugMode() {
      env2().set("DEBUG", true);
    }
    function disableDeprecationWarnings() {
      env2().set("DEPRECATION_WARNINGS_ENABLED", false);
      console.warn(`TensorFlow.js deprecation warnings have been disabled.`);
    }
    function deprecationWarn2(msg) {
      if (env2().getBool("DEPRECATION_WARNINGS_ENABLED")) {
        console.warn(msg + " You can disable deprecation warnings with tf.disableDeprecationWarnings().");
      }
    }
    setDeprecationWarningFn2(deprecationWarn2);
    function disposeVariables() {
      ENGINE2.disposeVariables();
    }
    function engine19() {
      return ENGINE2;
    }
    function memory() {
      return ENGINE2.memory();
    }
    function profile2(f) {
      return ENGINE2.profile(f);
    }
    function tidy(nameOrFn, fn) {
      return ENGINE2.tidy(nameOrFn, fn);
    }
    function dispose(container) {
      const tensors = getTensorsInContainer2(container);
      tensors.forEach((tensor7) => tensor7.dispose());
    }
    function keep(result) {
      return ENGINE2.keep(result);
    }
    function time(f) {
      return ENGINE2.time(f);
    }
    function setBackend(backendName) {
      return ENGINE2.setBackend(backendName);
    }
    function ready() {
      return ENGINE2.ready();
    }
    function getBackend() {
      return ENGINE2.backendName;
    }
    function removeBackend(name) {
      ENGINE2.removeBackend(name);
    }
    function findBackend(name) {
      return ENGINE2.findBackend(name);
    }
    function findBackendFactory(name) {
      return ENGINE2.findBackendFactory(name);
    }
    function registerBackend2(name, factory, priority = 1) {
      return ENGINE2.registerBackend(name, factory, priority);
    }
    function backend2() {
      return ENGINE2.backend;
    }
    function setPlatform(platformName, platform) {
      env2().setPlatform(platformName, platform);
    }
    /**
     * @license
     * Copyright 2020 Google LLC. All Rights Reserved.
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     * http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     * =============================================================================
     */
    function add_(a, b) {
      let $a = convertToTensor2(a, "a", "add");
      let $b = convertToTensor2(b, "b", "add");
      [$a, $b] = makeTypesMatch2($a, $b);
      const forward = (backend3, save) => {
        const res = backend3.add($a, $b);
        save([$a, $b]);
        return res;
      };
      const inputs = {a: $a, b: $b};
      return ENGINE2.runKernelFunc(forward, inputs, null, Add3);
    }
    const add$1 = op2({add_});
    /**
     * @license
     * Copyright 2020 Google LLC. All Rights Reserved.
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     * http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     * =============================================================================
     */
    function floorDiv_(a, b) {
      let $a = convertToTensor2(a, "a", "floorDiv");
      let $b = convertToTensor2(b, "b", "floorDiv");
      [$a, $b] = makeTypesMatch2($a, $b);
      const forward = (backend3, save) => {
        const res = backend3.floorDiv($a, $b);
        save([$a, $b]);
        return res;
      };
      const inputs = {a: $a, b: $b};
      return ENGINE2.runKernelFunc(forward, inputs, null, FloorDiv3);
    }
    const floorDiv = op2({floorDiv_});
    /**
     * @license
     * Copyright 2020 Google LLC. All Rights Reserved.
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     * http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     * =============================================================================
     */
    function div_(a, b) {
      let $a = convertToTensor2(a, "a", "div");
      let $b = convertToTensor2(b, "b", "div");
      [$a, $b] = makeTypesMatch2($a, $b);
      if ($a.dtype === "int32" && $b.dtype === "int32") {
        return floorDiv($a, $b);
      }
      const forward = (backend3, save) => {
        const res = backend3.realDivide($a, $b);
        save([$a, $b]);
        return res;
      };
      const inputs = {a: $a, b: $b};
      const attrs = {};
      return ENGINE2.runKernelFunc(forward, inputs, null, Div3, attrs);
    }
    const div = op2({div_});
    /**
     * @license
     * Copyright 2020 Google LLC. All Rights Reserved.
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     * http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     * =============================================================================
     */
    function mul_2(a, b) {
      let $a = convertToTensor2(a, "a", "mul");
      let $b = convertToTensor2(b, "b", "mul");
      [$a, $b] = makeTypesMatch2($a, $b);
      const forward = (backend3, save) => {
        const res = backend3.multiply($a, $b);
        save([$a, $b]);
        return res;
      };
      const inputs = {a: $a, b: $b};
      return ENGINE2.runKernelFunc(forward, inputs, null, Multiply3);
    }
    const mul3 = op2({mul_: mul_2});
    /**
     * @license
     * Copyright 2018 Google LLC. All Rights Reserved.
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     * http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     * =============================================================================
     */
    function abs_(x) {
      const $x = convertToTensor2(x, "x", "abs");
      const inputs = {x: $x};
      return ENGINE2.runKernelFunc((backend3, save) => {
        save([$x]);
        if ($x.dtype === "complex64") {
          return backend3.complexAbs($x);
        }
        return backend3.abs($x);
      }, inputs, null, Abs3);
    }
    const abs = op2({abs_});
    /**
     * @license
     * Copyright 2018 Google LLC. All Rights Reserved.
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     * http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     * =============================================================================
     */
    function acos_(x) {
      const $x = convertToTensor2(x, "x", "acos");
      const inputs = {x: $x};
      return ENGINE2.runKernelFunc((backend3, save) => {
        const res = backend3.acos($x);
        save([$x]);
        return res;
      }, inputs, null, Acos);
    }
    const acos = op2({acos_});
    /**
     * @license
     * Copyright 2018 Google LLC. All Rights Reserved.
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     * http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     * =============================================================================
     */
    function acosh_(x) {
      const $x = convertToTensor2(x, "x", "acosh");
      const inputs = {x: $x};
      return ENGINE2.runKernelFunc((backend3, save) => {
        const res = backend3.acosh($x);
        save([$x]);
        return res;
      }, inputs, null, Acosh);
    }
    const acosh = op2({acosh_});
    /**
     * @license
     * Copyright 2020 Google LLC. All Rights Reserved.
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     * http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     * =============================================================================
     */
    function addN_(tensors) {
      assert2(Array.isArray(tensors), () => "The argument passed to tf.addN() must be a list of tensors");
      assert2(tensors.length >= 1, () => `Must pass at least one tensor to tf.addN(), but got ${tensors.length}`);
      const $tensors = tensors.map((t, i) => convertToTensor2(t, `tensors${i}`, "addN"));
      const firstTensor = $tensors[0];
      $tensors.forEach((t) => {
        if (t.dtype !== firstTensor.dtype) {
          throw new Error("All tensors passed to tf.addN() must have the same dtype");
        }
      });
      $tensors.forEach((t) => {
        if (!arraysEqual2(t.shape, firstTensor.shape)) {
          throw new Error("All tensors passed to tf.addN() must have the same shape");
        }
      });
      const forward = (backend3, save) => {
        const res = backend3.addN($tensors);
        save($tensors);
        return res;
      };
      const inputs = $tensors;
      return ENGINE2.runKernelFunc(forward, inputs, null, AddN3);
    }
    const addN = op2({addN_});
    /**
     * @license
     * Copyright 2017 Google LLC. All Rights Reserved.
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     * http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     * =============================================================================
     */
    function axesAreInnerMostDims2(axes, rank) {
      for (let i = 0; i < axes.length; ++i) {
        if (axes[axes.length - i - 1] !== rank - 1 - i) {
          return false;
        }
      }
      return true;
    }
    function combineLocations2(outputLoc, reduceLoc, axes) {
      const rank = outputLoc.length + reduceLoc.length;
      const loc = [];
      let outIdx = 0;
      let reduceIdx = 0;
      for (let dim = 0; dim < rank; dim++) {
        if (axes.indexOf(dim) === -1) {
          loc.push(outputLoc[outIdx++]);
        } else {
          loc.push(reduceLoc[reduceIdx++]);
        }
      }
      return loc;
    }
    function computeOutAndReduceShapes2(aShape, axes) {
      const outShape = [];
      const rank = aShape.length;
      for (let dim = 0; dim < rank; dim++) {
        if (axes.indexOf(dim) === -1) {
          outShape.push(aShape[dim]);
        }
      }
      const reduceShape = axes.map((dim) => aShape[dim]);
      return [outShape, reduceShape];
    }
    function expandShapeToKeepDim2(shape, axes) {
      const reduceSubShape = axes.map((x) => 1);
      return combineLocations2(shape, reduceSubShape, axes);
    }
    function assertAxesAreInnerMostDims2(msg, axes, rank) {
      assert2(axesAreInnerMostDims2(axes, rank), () => `${msg} supports only inner-most axes for now. Got axes ${axes} and rank-${rank} input.`);
    }
    function getAxesPermutation2(axes, rank) {
      if (axesAreInnerMostDims2(axes, rank)) {
        return null;
      }
      const result = [];
      for (let i = 0; i < rank; ++i) {
        if (axes.indexOf(i) === -1) {
          result.push(i);
        }
      }
      axes.forEach((axis) => result.push(axis));
      return result;
    }
    function getUndoAxesPermutation2(axes) {
      return axes.map((axis, i) => [i, axis]).sort((a, b) => a[1] - b[1]).map((x) => x[0]);
    }
    function getInnerMostAxes2(numAxes, rank) {
      const res = [];
      for (let i = rank - numAxes; i < rank; ++i) {
        res.push(i);
      }
      return res;
    }
    /**
     * @license
     * Copyright 2020 Google LLC. All Rights Reserved.
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     * http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     * =============================================================================
     */
    function all_(x, axis = null, keepDims = false) {
      let $x = convertToTensor2(x, "x", "all", "bool");
      const forward = (backend3) => {
        const origAxes = parseAxisParam2(axis, $x.shape);
        let axes = origAxes;
        const permutedAxes = getAxesPermutation2(axes, $x.rank);
        if (permutedAxes != null) {
          $x = transpose4($x, permutedAxes);
          axes = getInnerMostAxes2(axes.length, $x.rank);
        }
        const res = backend3.all($x, axes);
        if (keepDims) {
          const newShape = expandShapeToKeepDim2(res.shape, origAxes);
          return reshape5(res, newShape);
        }
        return res;
      };
      const inputs = {x: $x};
      const attrs = {axis, keepDims};
      return ENGINE2.runKernelFunc(forward, inputs, null, All, attrs);
    }
    const all = op2({all_});
    /**
     * @license
     * Copyright 2020 Google LLC. All Rights Reserved.
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     * http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     * =============================================================================
     */
    function any_(x, axis = null, keepDims = false) {
      let $x = convertToTensor2(x, "x", "any", "bool");
      const forward = (backend3) => {
        const origAxes = parseAxisParam2(axis, $x.shape);
        let axes = origAxes;
        const permutedAxes = getAxesPermutation2(axes, $x.rank);
        if (permutedAxes != null) {
          $x = transpose4($x, permutedAxes);
          axes = getInnerMostAxes2(axes.length, $x.rank);
        }
        const res = backend3.any($x, axes);
        if (keepDims) {
          const newShape = expandShapeToKeepDim2(res.shape, origAxes);
          return reshape5(res, newShape);
        }
        return res;
      };
      const inputs = {x: $x};
      const attrs = {axis, keepDims};
      return ENGINE2.runKernelFunc(forward, inputs, null, Any, attrs);
    }
    const any = op2({any_});
    /**
     * @license
     * Copyright 2020 Google Inc. All Rights Reserved.
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     * http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     * =============================================================================
     */
    function argMax_(x, axis = 0) {
      let $x = convertToTensor2(x, "x", "argMax");
      const forward = (backend3, save) => {
        save([$x]);
        let axes = parseAxisParam2(axis, $x.shape);
        const permutedAxes = getAxesPermutation2(axes, $x.rank);
        if (permutedAxes != null) {
          $x = transpose4($x, permutedAxes);
          axes = getInnerMostAxes2(axes.length, $x.rank);
        }
        return backend3.argMax($x, axes[0]);
      };
      const inputs = {x: $x};
      const attrs = {axis};
      return ENGINE2.runKernelFunc(forward, inputs, null, ArgMax3, attrs);
    }
    const argMax = op2({argMax_});
    /**
     * @license
     * Copyright 2020 Google Inc. All Rights Reserved.
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     * http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     * =============================================================================
     */
    function argMin_(x, axis = 0) {
      let $x = convertToTensor2(x, "x", "argMin");
      const forward = (backend3, save) => {
        save([$x]);
        if (axis == null) {
          axis = 0;
        }
        let axes = parseAxisParam2(axis, $x.shape);
        const permutedAxes = getAxesPermutation2(axes, $x.rank);
        if (permutedAxes != null) {
          $x = transpose4($x, permutedAxes);
          axes = getInnerMostAxes2(axes.length, $x.rank);
        }
        return backend3.argMin($x, axes[0]);
      };
      const inputs = {x: $x};
      const attrs = {axis};
      return ENGINE2.runKernelFunc(forward, inputs, null, ArgMin, attrs);
    }
    const argMin = op2({argMin_});
    /**
     * @license
     * Copyright 2018 Google LLC. All Rights Reserved.
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     * http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     * =============================================================================
     */
    function asin_(x) {
      const $x = convertToTensor2(x, "x", "asin");
      const inputs = {x: $x};
      return ENGINE2.runKernelFunc((backend3, save) => {
        const res = backend3.asin($x);
        save([$x]);
        return res;
      }, inputs, null, Asin);
    }
    const asin = op2({asin_});
    /**
     * @license
     * Copyright 2018 Google LLC. All Rights Reserved.
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     * http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     * =============================================================================
     */
    function asinh_(x) {
      const $x = convertToTensor2(x, "x", "asinh");
      const inputs = {x: $x};
      return ENGINE2.runKernelFunc((backend3, save) => {
        const res = backend3.asinh($x);
        save([$x]);
        return res;
      }, inputs, null, Asinh);
    }
    const asinh = op2({asinh_});
    /**
     * @license
     * Copyright 2018 Google LLC. All Rights Reserved.
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     * http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     * =============================================================================
     */
    function atan_(x) {
      const $x = convertToTensor2(x, "x", "atan");
      const inputs = {x: $x};
      return ENGINE2.runKernelFunc((backend3, save) => {
        const res = backend3.atan($x);
        save([$x]);
        return res;
      }, inputs, null, Atan);
    }
    const atan = op2({atan_});
    /**
     * @license
     * Copyright 2020 Google LLC. All Rights Reserved.
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     * http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     * =============================================================================
     */
    function atan2_(a, b) {
      let $a = convertToTensor2(a, "a", "atan2");
      let $b = convertToTensor2(b, "b", "atan2");
      [$a, $b] = makeTypesMatch2($a, $b);
      const forward = (backend3, save) => {
        const res = backend3.atan2($a, $b);
        save([$a, $b]);
        return res;
      };
      const inputs = {a: $a, b: $b};
      return ENGINE2.runKernelFunc(forward, inputs, null, Atan2);
    }
    const atan2 = op2({atan2_});
    /**
     * @license
     * Copyright 2018 Google LLC. All Rights Reserved.
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     * http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     * =============================================================================
     */
    function atanh_(x) {
      const $x = convertToTensor2(x, "x", "atanh");
      const inputs = {x: $x};
      return ENGINE2.runKernelFunc((backend3, save) => {
        const res = backend3.atanh($x);
        save([$x]);
        return res;
      }, inputs, null, Atanh);
    }
    const atanh = op2({atanh_});
    /**
     * @license
     * Copyright 2020 Google LLC. All Rights Reserved.
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     * http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     * =============================================================================
     */
    function computeDilation2DInfo2(inputShape, filterShape, strides, pad3, dataFormat = "NHWC", dilations) {
      const inputChannels = inputShape[3];
      const $filterShape = [...filterShape, inputChannels];
      const $dataFormat = convertConv2DDataFormat2(dataFormat);
      return computeConv2DInfo2(inputShape, $filterShape, strides, dilations, pad3, null, null, $dataFormat);
    }
    function computePool2DInfo2(inShape, filterSize, strides, dilations, pad3, roundingMode, dataFormat = "channelsLast") {
      const [filterHeight, filterWidth] = parseTupleParam2(filterSize);
      let filterShape;
      if (dataFormat === "channelsLast") {
        filterShape = [filterHeight, filterWidth, inShape[3], inShape[3]];
      } else if (dataFormat === "channelsFirst") {
        filterShape = [filterHeight, filterWidth, inShape[1], inShape[1]];
      } else {
        throw new Error(`Unknown dataFormat ${dataFormat}`);
      }
      return computeConv2DInfo2(inShape, filterShape, strides, dilations, pad3, roundingMode, false, dataFormat);
    }
    function computePool3DInfo2(inShape, filterSize, strides, dilations, pad3, roundingMode, dataFormat = "NDHWC") {
      const [filterDepth, filterHeight, filterWidth] = parse3TupleParam2(filterSize);
      let filterShape;
      let $dataFormat;
      if (dataFormat === "NDHWC") {
        $dataFormat = "channelsLast";
        filterShape = [filterDepth, filterHeight, filterWidth, inShape[4], inShape[4]];
      } else if (dataFormat === "NCDHW") {
        $dataFormat = "channelsFirst";
        filterShape = [filterDepth, filterHeight, filterWidth, inShape[1], inShape[1]];
      } else {
        throw new Error(`Unknown dataFormat ${dataFormat}`);
      }
      return computeConv3DInfo2(inShape, filterShape, strides, dilations, pad3, false, $dataFormat, roundingMode);
    }
    function computeConv2DInfo2(inShape, filterShape, strides, dilations, pad3, roundingMode, depthwise = false, dataFormat = "channelsLast") {
      let [batchSize, inHeight, inWidth, inChannels] = [-1, -1, -1, -1];
      if (dataFormat === "channelsLast") {
        [batchSize, inHeight, inWidth, inChannels] = inShape;
      } else if (dataFormat === "channelsFirst") {
        [batchSize, inChannels, inHeight, inWidth] = inShape;
      } else {
        throw new Error(`Unknown dataFormat ${dataFormat}`);
      }
      const [filterHeight, filterWidth, , filterChannels] = filterShape;
      const [strideHeight, strideWidth] = parseTupleParam2(strides);
      const [dilationHeight, dilationWidth] = parseTupleParam2(dilations);
      const effectiveFilterHeight = getEffectiveFilterSize2(filterHeight, dilationHeight);
      const effectiveFilterWidth = getEffectiveFilterSize2(filterWidth, dilationWidth);
      const {padInfo, outHeight, outWidth} = getPadAndOutInfo2(pad3, inHeight, inWidth, strideHeight, strideWidth, effectiveFilterHeight, effectiveFilterWidth, roundingMode, dataFormat);
      const outChannels = depthwise ? filterChannels * inChannels : filterChannels;
      let outShape;
      if (dataFormat === "channelsFirst") {
        outShape = [batchSize, outChannels, outHeight, outWidth];
      } else if (dataFormat === "channelsLast") {
        outShape = [batchSize, outHeight, outWidth, outChannels];
      }
      return {
        batchSize,
        dataFormat,
        inHeight,
        inWidth,
        inChannels,
        outHeight,
        outWidth,
        outChannels,
        padInfo,
        strideHeight,
        strideWidth,
        filterHeight,
        filterWidth,
        effectiveFilterHeight,
        effectiveFilterWidth,
        dilationHeight,
        dilationWidth,
        inShape,
        outShape,
        filterShape
      };
    }
    function computeConv3DInfo2(inShape, filterShape, strides, dilations, pad3, depthwise = false, dataFormat = "channelsLast", roundingMode) {
      let [batchSize, inDepth, inHeight, inWidth, inChannels] = [-1, -1, -1, -1, -1];
      if (dataFormat === "channelsLast") {
        [batchSize, inDepth, inHeight, inWidth, inChannels] = inShape;
      } else if (dataFormat === "channelsFirst") {
        [batchSize, inChannels, inDepth, inHeight, inWidth] = inShape;
      } else {
        throw new Error(`Unknown dataFormat ${dataFormat}`);
      }
      const [filterDepth, filterHeight, filterWidth, , filterChannels] = filterShape;
      const [strideDepth, strideHeight, strideWidth] = parse3TupleParam2(strides);
      const [dilationDepth, dilationHeight, dilationWidth] = parse3TupleParam2(dilations);
      const effectiveFilterDepth = getEffectiveFilterSize2(filterDepth, dilationDepth);
      const effectiveFilterHeight = getEffectiveFilterSize2(filterHeight, dilationHeight);
      const effectiveFilterWidth = getEffectiveFilterSize2(filterWidth, dilationWidth);
      const {padInfo, outDepth, outHeight, outWidth} = get3DPadAndOutInfo2(pad3, inDepth, inHeight, inWidth, strideDepth, strideHeight, strideWidth, effectiveFilterDepth, effectiveFilterHeight, effectiveFilterWidth, roundingMode);
      const outChannels = depthwise ? filterChannels * inChannels : filterChannels;
      let outShape;
      if (dataFormat === "channelsFirst") {
        outShape = [batchSize, outChannels, outDepth, outHeight, outWidth];
      } else if (dataFormat === "channelsLast") {
        outShape = [batchSize, outDepth, outHeight, outWidth, outChannels];
      }
      return {
        batchSize,
        dataFormat,
        inDepth,
        inHeight,
        inWidth,
        inChannels,
        outDepth,
        outHeight,
        outWidth,
        outChannels,
        padInfo,
        strideDepth,
        strideHeight,
        strideWidth,
        filterDepth,
        filterHeight,
        filterWidth,
        effectiveFilterDepth,
        effectiveFilterHeight,
        effectiveFilterWidth,
        dilationDepth,
        dilationHeight,
        dilationWidth,
        inShape,
        outShape,
        filterShape
      };
    }
    function computeOutputShape2D2(inShape, fieldSize, stride, zeroPad, roundingMode) {
      if (zeroPad == null) {
        zeroPad = computeDefaultPad2(inShape, fieldSize, stride);
      }
      const inputRows = inShape[0];
      const inputCols = inShape[1];
      const outputRows = conditionalRound2((inputRows - fieldSize + 2 * zeroPad) / stride + 1, roundingMode);
      assert2(isInt2(outputRows), () => `The output # of rows (${outputRows}) must be an integer. Change the stride and/or zero pad parameters`);
      const outputCols = conditionalRound2((inputCols - fieldSize + 2 * zeroPad) / stride + 1, roundingMode);
      assert2(isInt2(outputCols), () => `The output # of columns (${outputCols}) must be an integer. Change the stride and/or zero pad parameters`);
      return [outputRows, outputCols];
    }
    function computeOutputShape4D2(inShape, fieldSize, outChannels, stride, zeroPad, roundingMode) {
      if (zeroPad == null) {
        zeroPad = computeDefaultPad2(inShape, fieldSize, stride);
      }
      const inputDepth = inShape[0];
      const inputRows = inShape[1];
      const inputCols = inShape[2];
      const outputDepths = conditionalRound2((inputDepth - fieldSize + 2 * zeroPad) / stride + 1, roundingMode);
      assert2(isInt2(outputDepths), () => `The output # of depths (${outputDepths}) must be an integer. Change the stride and/or zero pad parameters`);
      const outputRows = conditionalRound2((inputRows - fieldSize + 2 * zeroPad) / stride + 1, roundingMode);
      assert2(isInt2(outputRows), () => `The output # of rows (${outputRows}) must be an integer. Change the stride and/or zero pad parameters`);
      const outputCols = conditionalRound2((inputCols - fieldSize + 2 * zeroPad) / stride + 1, roundingMode);
      assert2(isInt2(outputCols), () => `The output # of columns (${outputCols}) must be an integer. Change the stride and/or zero pad parameters`);
      return [outputDepths, outputRows, outputCols, outChannels];
    }
    function computeDefaultPad2(inputShape, fieldSize, stride, dilation = 1) {
      const effectiveFieldSize = getEffectiveFilterSize2(fieldSize, dilation);
      return Math.floor((inputShape[0] * (stride - 1) - stride + effectiveFieldSize) / 2);
    }
    function parseTupleParam2(param) {
      if (typeof param === "number") {
        return [param, param, param];
      }
      if (param.length === 2) {
        return [param[0], param[1], 1];
      }
      return param;
    }
    function parse3TupleParam2(param) {
      return typeof param === "number" ? [param, param, param] : param;
    }
    function getEffectiveFilterSize2(filterSize, dilation) {
      if (dilation <= 1) {
        return filterSize;
      }
      return filterSize + (filterSize - 1) * (dilation - 1);
    }
    function getPadAndOutInfo2(pad3, inHeight, inWidth, strideHeight, strideWidth, filterHeight, filterWidth, roundingMode, dataFormat) {
      let padInfo;
      let outHeight;
      let outWidth;
      if (typeof pad3 === "number") {
        const padType = pad3 === 0 ? "VALID" : "NUMBER";
        padInfo = {top: pad3, bottom: pad3, left: pad3, right: pad3, type: padType};
        const outShape = computeOutputShape2D2([inHeight, inWidth], filterHeight, strideHeight, pad3, roundingMode);
        outHeight = outShape[0];
        outWidth = outShape[1];
      } else if (pad3 === "same") {
        outHeight = Math.ceil(inHeight / strideHeight);
        outWidth = Math.ceil(inWidth / strideWidth);
        const padAlongHeight = Math.max(0, (outHeight - 1) * strideHeight + filterHeight - inHeight);
        const padAlongWidth = Math.max(0, (outWidth - 1) * strideWidth + filterWidth - inWidth);
        const top = Math.floor(padAlongHeight / 2);
        const bottom = padAlongHeight - top;
        const left = Math.floor(padAlongWidth / 2);
        const right = padAlongWidth - left;
        padInfo = {top, bottom, left, right, type: "SAME"};
      } else if (pad3 === "valid") {
        padInfo = {top: 0, bottom: 0, left: 0, right: 0, type: "VALID"};
        outHeight = Math.ceil((inHeight - filterHeight + 1) / strideHeight);
        outWidth = Math.ceil((inWidth - filterWidth + 1) / strideWidth);
      } else if (typeof pad3 === "object") {
        const top = dataFormat === "channelsLast" ? pad3[1][0] : pad3[2][0];
        const bottom = dataFormat === "channelsLast" ? pad3[1][1] : pad3[2][1];
        const left = dataFormat === "channelsLast" ? pad3[2][0] : pad3[3][0];
        const right = dataFormat === "channelsLast" ? pad3[2][1] : pad3[3][1];
        const padType = top === 0 && bottom === 0 && left === 0 && right === 0 ? "VALID" : "EXPLICIT";
        padInfo = {top, bottom, left, right, type: padType};
        outHeight = conditionalRound2((inHeight - filterHeight + top + bottom) / strideHeight + 1, roundingMode);
        outWidth = conditionalRound2((inWidth - filterWidth + left + right) / strideWidth + 1, roundingMode);
      } else {
        throw Error(`Unknown padding parameter: ${pad3}`);
      }
      return {padInfo, outHeight, outWidth};
    }
    function get3DPadAndOutInfo2(pad3, inDepth, inHeight, inWidth, strideDepth, strideHeight, strideWidth, filterDepth, filterHeight, filterWidth, roundingMode) {
      let padInfo;
      let outDepth;
      let outHeight;
      let outWidth;
      if (typeof pad3 === "number") {
        const padType = pad3 === 0 ? "VALID" : "NUMBER";
        padInfo = {
          top: pad3,
          bottom: pad3,
          left: pad3,
          right: pad3,
          front: pad3,
          back: pad3,
          type: padType
        };
        const outShape = computeOutputShape4D2([inDepth, inHeight, inWidth, 1], filterDepth, 1, strideDepth, pad3, roundingMode);
        outDepth = outShape[0];
        outHeight = outShape[1];
        outWidth = outShape[2];
      } else if (pad3 === "same") {
        outDepth = Math.ceil(inDepth / strideDepth);
        outHeight = Math.ceil(inHeight / strideHeight);
        outWidth = Math.ceil(inWidth / strideWidth);
        const padAlongDepth = (outDepth - 1) * strideDepth + filterDepth - inDepth;
        const padAlongHeight = (outHeight - 1) * strideHeight + filterHeight - inHeight;
        const padAlongWidth = (outWidth - 1) * strideWidth + filterWidth - inWidth;
        const front = Math.floor(padAlongDepth / 2);
        const back = padAlongDepth - front;
        const top = Math.floor(padAlongHeight / 2);
        const bottom = padAlongHeight - top;
        const left = Math.floor(padAlongWidth / 2);
        const right = padAlongWidth - left;
        padInfo = {top, bottom, left, right, front, back, type: "SAME"};
      } else if (pad3 === "valid") {
        padInfo = {
          top: 0,
          bottom: 0,
          left: 0,
          right: 0,
          front: 0,
          back: 0,
          type: "VALID"
        };
        outDepth = Math.ceil((inDepth - filterDepth + 1) / strideDepth);
        outHeight = Math.ceil((inHeight - filterHeight + 1) / strideHeight);
        outWidth = Math.ceil((inWidth - filterWidth + 1) / strideWidth);
      } else {
        throw Error(`Unknown padding parameter: ${pad3}`);
      }
      return {padInfo, outDepth, outHeight, outWidth};
    }
    function conditionalRound2(value, roundingMode) {
      if (!roundingMode) {
        return value;
      }
      switch (roundingMode) {
        case "round":
          return Math.round(value);
        case "ceil":
          return Math.ceil(value);
        case "floor":
          return Math.floor(value);
        default:
          throw new Error(`Unknown roundingMode ${roundingMode}`);
      }
    }
    function tupleValuesAreOne2(param) {
      const [dimA, dimB, dimC] = parseTupleParam2(param);
      return dimA === 1 && dimB === 1 && dimC === 1;
    }
    function eitherStridesOrDilationsAreOne2(strides, dilations) {
      return tupleValuesAreOne2(strides) || tupleValuesAreOne2(dilations);
    }
    function convertConv2DDataFormat2(dataFormat) {
      if (dataFormat === "NHWC") {
        return "channelsLast";
      } else if (dataFormat === "NCHW") {
        return "channelsFirst";
      } else {
        throw new Error(`Unknown dataFormat ${dataFormat}`);
      }
    }
    /**
     * @license
     * Copyright 2020 Google LLC. All Rights Reserved.
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     * http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     * =============================================================================
     */
    function avgPool_(x, filterSize, strides, pad3, dimRoundingMode) {
      const $x = convertToTensor2(x, "x", "avgPool", "float32");
      const dilations = 1;
      assert2(eitherStridesOrDilationsAreOne2(strides, dilations), () => `Error in avgPool: Either strides or dilations must be 1. Got strides ${strides} and dilations '${dilations}'`);
      let x4D = $x;
      let reshapedTo4D = false;
      if ($x.rank === 3) {
        reshapedTo4D = true;
        x4D = reshape5($x, [1, $x.shape[0], $x.shape[1], $x.shape[2]]);
      }
      assert2(x4D.rank === 4, () => `Error in avgPool: x must be rank 4 but got rank ${x4D.rank}.`);
      if (dimRoundingMode != null) {
        assert2(isInt2(pad3), () => `Error in avgPool: pad must be an integer when using, dimRoundingMode ${dimRoundingMode} but got pad ${pad3}.`);
      }
      const forward = (backend3, save) => {
        const convInfo = computePool2DInfo2(x4D.shape, filterSize, strides, 1, pad3, dimRoundingMode);
        save([x4D]);
        if (convInfo.filterWidth === 1 && convInfo.filterHeight === 1 && arraysEqual2(convInfo.inShape, convInfo.outShape)) {
          return x4D.clone();
        }
        return backend3.avgPool(x4D, convInfo);
      };
      const inputs = {x: x4D};
      const attrs = {filterSize, strides, pad: pad3, dimRoundingMode};
      let res = ENGINE2.runKernelFunc(forward, inputs, null, AvgPool3, attrs);
      res = cast7(res, $x.dtype);
      if (reshapedTo4D) {
        return reshape5(res, [res.shape[1], res.shape[2], res.shape[3]]);
      }
      return res;
    }
    const avgPool2 = op2({avgPool_});
    /**
     * @license
     * Copyright 2020 Google LLC. All Rights Reserved.
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     * http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     * =============================================================================
     */
    function avgPool3d_(x, filterSize, strides, pad3, dimRoundingMode, dataFormat = "NDHWC", dilations) {
      if (dilations == null) {
        dilations = [1, 1, 1];
      } else {
        deprecationWarn2("dilations is deprecated, this field will be gone in v3.0.0.");
      }
      const $x = convertToTensor2(x, "x", "avgPool3d", "float32");
      let x5D = $x;
      let reshapedTo5D = false;
      if ($x.rank === 4) {
        reshapedTo5D = true;
        x5D = reshape5($x, [1, $x.shape[0], $x.shape[1], $x.shape[2], $x.shape[3]]);
      }
      assert2(x5D.rank === 5, () => `Error in avgPool3d: x must be rank 5 but got rank ${x5D.rank}.`);
      assert2(dataFormat === "NDHWC", () => `Error in avgPool3d: Only NDHWC is currently supported, but got dataFormat of ${dataFormat}`);
      assert2(eitherStridesOrDilationsAreOne2(strides, dilations), () => `Error in avgPool3d: Either strides or dilations must be 1. Got strides ${strides} and dilations '${dilations}'`);
      if (dimRoundingMode != null) {
        assert2(isInt2(pad3), () => `Error in avgPool3d: pad must be an integer when using, dimRoundingMode ${dimRoundingMode} but got pad ${pad3}.`);
      }
      const forward = (backend3, save) => {
        if (dilations == null) {
          dilations = [1, 1, 1];
        }
        const convInfo = computePool3DInfo2(x5D.shape, filterSize, strides, dilations, pad3, dimRoundingMode, dataFormat);
        save([x5D]);
        return backend3.avgPool3d(x5D, convInfo);
      };
      const inputs = {x: x5D};
      const attrs = {filterSize, strides, pad: pad3, dimRoundingMode, dataFormat, dilations};
      let res = ENGINE2.runKernelFunc(forward, inputs, null, AvgPool3D, attrs);
      res = cast7(res, x5D.dtype);
      if (reshapedTo5D) {
        return reshape5(res, [res.shape[1], res.shape[2], res.shape[3], res.shape[4]]);
      }
      return res;
    }
    const avgPool3d = op2({avgPool3d_});
    /**
     * @license
     * Copyright 2017 Google LLC. All Rights Reserved.
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     * http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     * =============================================================================
     */
    function assertParamsConsistent2(shapes, axis) {
      const rank = shapes[0].length;
      shapes.forEach((shape, i) => {
        assert2(shape.length === rank, () => `Error in concat${rank}D: rank of tensors[${i}] must be the same as the rank of the rest (${rank})`);
      });
      assert2(axis >= 0 && axis < rank, () => `Error in concat${rank}D: axis must be between 0 and ${rank - 1}.`);
      const firstShape = shapes[0];
      shapes.forEach((shape, i) => {
        for (let r = 0; r < rank; r++) {
          assert2(r === axis || shape[r] === firstShape[r], () => `Error in concat${rank}D: Shape of tensors[${i}] (${shape}) does not match the shape of the rest (${firstShape}) along the non-concatenated axis ${i}.`);
        }
      });
    }
    function computeOutShape$1(shapes, axis) {
      const outputShape = shapes[0].slice();
      for (let i = 1; i < shapes.length; i++) {
        outputShape[axis] += shapes[i][axis];
      }
      return outputShape;
    }
    /**
     * @license
     * Copyright 2020 Google LLC. All Rights Reserved.
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     * http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     * =============================================================================
     */
    function concat_(tensors, axis = 0) {
      assert2(tensors.length >= 1, () => "Pass at least one tensor to concat");
      let $tensors = convertToTensorArray(tensors, "tensors", "concat");
      if ($tensors[0].dtype === "complex64") {
        $tensors.forEach((tensor7) => {
          if (tensor7.dtype !== "complex64") {
            throw new Error(`Cannot concatenate complex64 tensors with a tensor
          with dtype ${tensor7.dtype}. `);
          }
        });
      }
      const forward = (backend3, save) => {
        const $axis = parseAxisParam2(axis, $tensors[0].shape)[0];
        const outShape = computeOutShape$1($tensors.map((t) => t.shape), $axis);
        if (sizeFromShape2(outShape) === 0) {
          return tensor6([], outShape);
        }
        $tensors = $tensors.filter((t) => t.size > 0);
        if ($tensors.length === 1) {
          return $tensors[0];
        }
        const shapes = $tensors.map((t) => t.shape);
        assertParamsConsistent2(shapes, $axis);
        const res = backend3.concat($tensors, $axis);
        save($tensors);
        return res;
      };
      const inputs = $tensors;
      const attr = {axis};
      return ENGINE2.runKernelFunc(forward, inputs, null, Concat3, attr);
    }
    const concat2 = op2({concat_});
    /**
     * @license
     * Copyright 2018 Google LLC. All Rights Reserved.
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     * http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     * =============================================================================
     */
    function sigmoid_(x) {
      const $x = convertToTensor2(x, "x", "sigmoid");
      const inputs = {x: $x};
      return ENGINE2.runKernelFunc((backend3, save) => {
        const res = backend3.sigmoid($x);
        save([res]);
        return res;
      }, inputs, null, Sigmoid3);
    }
    const sigmoid2 = op2({sigmoid_});
    /**
     * @license
     * Copyright 2018 Google LLC. All Rights Reserved.
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     * http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     * =============================================================================
     */
    function slice_(x, begin, size) {
      const $x = convertToTensor2(x, "x", "slice");
      if ($x.rank === 0) {
        throw new Error("Slicing scalar is not possible");
      }
      const forward = (backend3, save) => {
        const [begin_, size_] = parseSliceParams2($x, begin, size);
        assertParamsValid2($x, begin_, size_);
        save([$x]);
        return backend3.slice($x, begin_, size_);
      };
      const inputs = {x: $x};
      const attrs = {begin, size};
      return ENGINE2.runKernelFunc(forward, inputs, null, Slice6, attrs);
    }
    const slice2 = op2({slice_});
    /**
     * @license
     * Copyright 2018 Google LLC. All Rights Reserved.
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     * http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     * =============================================================================
     */
    function tanh_(x) {
      const $x = convertToTensor2(x, "x", "tanh");
      const inputs = {x: $x};
      return ENGINE2.runKernelFunc((backend3, save) => {
        const y = backend3.tanh($x);
        save([y]);
        return y;
      }, inputs, null, Tanh3);
    }
    const tanh$1 = op2({tanh_});
    /**
     * @license
     * Copyright 2020 Google LLC. All Rights Reserved.
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     * http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     * =============================================================================
     */
    function basicLSTMCell_(forgetBias, lstmKernel, lstmBias, data2, c, h) {
      const $forgetBias = convertToTensor2(forgetBias, "forgetBias", "basicLSTMCell");
      const $lstmKernel = convertToTensor2(lstmKernel, "lstmKernel", "basicLSTMCell");
      const $lstmBias = convertToTensor2(lstmBias, "lstmBias", "basicLSTMCell");
      const $data = convertToTensor2(data2, "data", "basicLSTMCell");
      const $c = convertToTensor2(c, "c", "basicLSTMCell");
      const $h = convertToTensor2(h, "h", "basicLSTMCell");
      const combined = concat2([$data, $h], 1);
      const weighted = matMul(combined, $lstmKernel);
      const res = add$1(weighted, $lstmBias);
      const batchSize = res.shape[0];
      const sliceCols = res.shape[1] / 4;
      const sliceSize = [batchSize, sliceCols];
      const i = slice2(res, [0, 0], sliceSize);
      const j = slice2(res, [0, sliceCols], sliceSize);
      const f = slice2(res, [0, sliceCols * 2], sliceSize);
      const o = slice2(res, [0, sliceCols * 3], sliceSize);
      const newC = add$1(mul3(sigmoid2(i), tanh$1(j)), mul3($c, sigmoid2(add$1($forgetBias, f))));
      const newH = mul3(tanh$1(newC), sigmoid2(o));
      return [newC, newH];
    }
    const basicLSTMCell = op2({basicLSTMCell_});
    /**
     * @license
     * Copyright 2020 Google LLC. All Rights Reserved.
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     * http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     * =============================================================================
     */
    function batchToSpaceND_(x, blockShape, crops) {
      const $x = convertToTensor2(x, "x", "batchToSpaceND");
      const prod2 = blockShape.reduce((a, b) => a * b);
      assert2($x.rank >= 1 + blockShape.length, () => `input rank is ${$x.rank} but should be > than blockShape.length ${blockShape.length}`);
      assert2(crops.length === blockShape.length, () => `crops.length is ${crops.length} but should be equal to blockShape.length  ${blockShape.length}`);
      assert2($x.shape[0] % prod2 === 0, () => `input tensor batch is ${$x.shape[0]} but is not divisible by the product of the elements of blockShape ${blockShape.join(" * ")} === ${prod2}`);
      const forward = (backend3) => {
        return backend3.batchToSpaceND($x, blockShape, crops);
      };
      const inputs = {x: $x};
      const attrs = {blockShape, crops};
      return ENGINE2.runKernelFunc(forward, inputs, null, BatchToSpaceND, attrs);
    }
    const batchToSpaceND = op2({batchToSpaceND_});
    function xAs4D(x) {
      let x4D;
      if (x.rank === 0 || x.rank === 1) {
        x4D = reshape5(x, [1, 1, 1, x.size]);
      } else if (x.rank === 2) {
        x4D = reshape5(x, [1, 1, x.shape[0], x.shape[1]]);
      } else if (x.rank === 3) {
        x4D = reshape5(x, [1, x.shape[0], x.shape[1], x.shape[2]]);
      } else {
        x4D = x;
      }
      return x4D;
    }
    /**
     * @license
     * Copyright 2020 Google LLC. All Rights Reserved.
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     * http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     * =============================================================================
     */
    function batchNorm_(x, mean2, variance2, offset, scale2, varianceEpsilon) {
      if (varianceEpsilon == null) {
        varianceEpsilon = 1e-3;
      }
      const $x = convertToTensor2(x, "x", "batchNorm");
      const $mean = convertToTensor2(mean2, "mean", "batchNorm");
      const $variance = convertToTensor2(variance2, "variance", "batchNorm");
      let $scale;
      if (scale2 != null) {
        $scale = convertToTensor2(scale2, "scale", "batchNorm");
      }
      let $offset;
      if (offset != null) {
        $offset = convertToTensor2(offset, "offset", "batchNorm");
      }
      assert2($mean.rank === $variance.rank, () => "Batch normalization gradient requires mean and variance to have equal ranks.");
      assert2($offset == null || $mean.rank === $offset.rank, () => "Batch normalization gradient requires mean and offset to have equal ranks.");
      assert2($scale == null || $mean.rank === $scale.rank, () => "Batch normalization gradient requires mean and scale to have equal ranks.");
      const x4D = xAs4D($x);
      const forward = (backend3, save) => {
        save([x4D, $mean, $variance, $scale]);
        return backend3.batchNorm(x4D, as1DOr4D($mean), as1DOr4D($variance), as1DOr4D($offset), as1DOr4D($scale), varianceEpsilon);
      };
      const inputs = {
        x: x4D,
        scale: $scale,
        offset: $offset,
        mean: $mean,
        variance: $variance
      };
      const attrs = {varianceEpsilon};
      const res = ENGINE2.runKernelFunc(forward, inputs, null, FusedBatchNorm3, attrs);
      return reshape5(res, $x.shape);
    }
    function as1DOr4D(x) {
      if (x == null) {
        return null;
      }
      if (x.rank === 0) {
        return reshape5(x, [x.size]);
      } else if (x.rank === 1) {
        return x;
      } else if (x.rank === 2) {
        return reshape5(x, [1, 1, x.shape[0], x.shape[1]]);
      } else if (x.rank === 3) {
        return reshape5(x, [1, x.shape[0], x.shape[1], x.shape[2]]);
      }
      return x;
    }
    const batchNorm = op2({batchNorm_});
    function batchNorm2d_(x, mean2, variance2, offset, scale2, varianceEpsilon) {
      const $x = convertToTensor2(x, "x", "batchNorm");
      const $mean = convertToTensor2(mean2, "mean", "batchNorm");
      const $variance = convertToTensor2(variance2, "variance", "batchNorm");
      let $scale;
      if (scale2 != null) {
        $scale = convertToTensor2(scale2, "scale", "batchNorm");
      }
      let $offset;
      if (offset != null) {
        $offset = convertToTensor2(offset, "offset", "batchNorm");
      }
      assert2($x.rank === 2, () => `Error in batchNorm2D: x must be rank 2 but got rank ${$x.rank}.`);
      assert2($mean.rank === 2 || $mean.rank === 1, () => `Error in batchNorm2D: mean must be rank 2 or rank 1 but got rank ${$mean.rank}.`);
      assert2($variance.rank === 2 || $variance.rank === 1, () => `Error in batchNorm2D: variance must be rank 2 or rank 1 but got rank ${$variance.rank}.`);
      if ($scale != null) {
        assert2($scale.rank === 2 || $scale.rank === 1, () => `Error in batchNorm2D: scale must be rank 2 or rank 1 but got rank ${$scale.rank}.`);
      }
      if ($offset != null) {
        assert2($offset.rank === 2 || $offset.rank === 1, () => `Error in batchNorm2D: offset must be rank 2 or rank 1 but got rank ${$offset.rank}.`);
      }
      return batchNorm($x, $mean, $variance, $offset, $scale, varianceEpsilon);
    }
    const batchNorm2d = op2({batchNorm2d_});
    function batchNorm3d_(x, mean2, variance2, offset, scale2, varianceEpsilon) {
      const $x = convertToTensor2(x, "x", "batchNorm");
      const $mean = convertToTensor2(mean2, "mean", "batchNorm");
      const $variance = convertToTensor2(variance2, "variance", "batchNorm");
      let $scale;
      if (scale2 != null) {
        $scale = convertToTensor2(scale2, "scale", "batchNorm");
      }
      let $offset;
      if (offset != null) {
        $offset = convertToTensor2(offset, "offset", "batchNorm");
      }
      assert2($x.rank === 3, () => `Error in batchNorm3D: x must be rank 3 but got rank ${$x.rank}.`);
      assert2($mean.rank === 3 || $mean.rank === 1, () => `Error in batchNorm3D: mean must be rank 3 or rank 1 but got rank ${$mean.rank}.`);
      assert2($variance.rank === 3 || $variance.rank === 1, () => `Error in batchNorm3D: variance must be rank 3 or rank 1 but got rank ${$variance.rank}.`);
      if ($scale != null) {
        assert2($scale.rank === 3 || $scale.rank === 1, () => `Error in batchNorm3D: scale must be rank 3 or rank 1 but got rank ${$scale.rank}.`);
      }
      if ($offset != null) {
        assert2($offset.rank === 3 || $offset.rank === 1, () => `Error in batchNorm3D: offset must be rank 3 or rank 1 but got rank ${$offset.rank}.`);
      }
      return batchNorm($x, $mean, $variance, $offset, $scale, varianceEpsilon);
    }
    const batchNorm3d = op2({batchNorm3d_});
    function batchNorm4d_(x, mean2, variance2, offset, scale2, varianceEpsilon) {
      const $x = convertToTensor2(x, "x", "batchNorm");
      const $mean = convertToTensor2(mean2, "mean", "batchNorm");
      const $variance = convertToTensor2(variance2, "variance", "batchNorm");
      let $scale;
      if (scale2 != null) {
        $scale = convertToTensor2(scale2, "scale", "batchNorm");
      }
      let $offset;
      if (offset != null) {
        $offset = convertToTensor2(offset, "offset", "batchNorm");
      }
      assert2($x.rank === 4, () => `Error in batchNorm4D: x must be rank 4 but got rank ${$x.rank}.`);
      assert2($mean.rank === 4 || $mean.rank === 1, () => `Error in batchNorm4D: mean must be rank 4 or rank 1 but got rank ${$mean.rank}.`);
      assert2($variance.rank === 4 || $variance.rank === 1, () => `Error in batchNorm4D: variance must be rank 4 or rank 1 but got rank ${$variance.rank}.`);
      if ($scale != null) {
        assert2($scale.rank === 4 || $scale.rank === 1, () => `Error in batchNorm4D: scale must be rank 4 or rank 1 but got rank ${$scale.rank}.`);
      }
      if ($offset != null) {
        assert2($offset.rank === 4 || $offset.rank === 1, () => `Error in batchNorm4D: offset must be rank 4 or rank 1 but got rank ${$offset.rank}.`);
      }
      return batchNorm($x, $mean, $variance, $offset, $scale, varianceEpsilon);
    }
    const batchNorm4d = op2({batchNorm4d_});
    /**
     * @license
     * Copyright 2020 Google LLC. All Rights Reserved.
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     * http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     * =============================================================================
     */
    function broadcastTo_(x, shape) {
      let input2 = convertToTensor2(x, "broadcastTo", "x");
      const xShape = input2.shape;
      if (shape.some((d) => !(d > 0) || d % 1 !== 0)) {
        throw new Error(`broadcastTo(): Invalid broadcast shape [${shape}].`);
      }
      if (shape.length < input2.rank) {
        throw new Error(`broadcastTo(): shape.length=${shape.length} < input.rank=${input2.rank}.`);
      }
      if (shape.length > input2.rank) {
        const newShape = input2.shape.slice();
        while (newShape.length < shape.length) {
          newShape.unshift(1);
        }
        input2 = reshape5(input2, newShape);
      }
      const inputShape = input2.shape;
      const reps = Array.from(shape);
      for (let i = shape.length - 1; i >= 0; i--) {
        if (inputShape[i] === shape[i]) {
          reps[i] = 1;
        } else if (input2.shape[i] !== 1) {
          throw new Error(`broadcastTo(): [${xShape}] cannot be broadcast to [${shape}].`);
        }
      }
      const axes = reps.map((n, i) => n > 1 ? i : -1).filter((i) => i >= 0);
      if (axes.length === 0) {
        return clone(input2);
      }
      const forward = (backend3) => backend3.tile(input2, reps);
      const inputs = {x: input2};
      const attrs = {shape, inputShape};
      return ENGINE2.runKernelFunc(forward, inputs, null, BroadcastTo, attrs);
    }
    const broadcastTo = op2({broadcastTo_});
    /**
     * @license
     * Copyright 2018 Google LLC. All Rights Reserved.
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     * http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     * =============================================================================
     */
    function ceil_(x) {
      const $x = convertToTensor2(x, "x", "ceil");
      const inputs = {x: $x};
      return ENGINE2.runKernelFunc((backend3) => backend3.ceil($x), inputs, null, Ceil);
    }
    const ceil = op2({ceil_});
    /**
     * @license
     * Copyright 2018 Google LLC. All Rights Reserved.
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     * http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     * =============================================================================
     */
    function clipByValue_(x, clipValueMin, clipValueMax) {
      const $x = convertToTensor2(x, "x", "clipByValue");
      assert2(clipValueMin <= clipValueMax, () => `Error in clip: min (${clipValueMin}) must be less than or equal to max (${clipValueMax}).`);
      const inputs = {x: $x};
      const attrs = {clipValueMin, clipValueMax};
      return ENGINE2.runKernelFunc((backend3, save) => {
        const res = backend3.clip($x, clipValueMin, clipValueMax);
        save([$x]);
        return res;
      }, inputs, null, ClipByValue3, attrs);
    }
    const clipByValue = op2({clipByValue_});
    function concat1d_(tensors) {
      return concat2(tensors, 0);
    }
    const concat1d = op2({concat1d_});
    function concat2d_(tensors, axis) {
      return concat2(tensors, axis);
    }
    const concat2d = op2({concat2d_});
    function concat3d_(tensors, axis) {
      return concat2(tensors, axis);
    }
    const concat3d = op2({concat3d_});
    function concat4d_(tensors, axis) {
      return concat2(tensors, axis);
    }
    const concat4d = op2({concat4d_});
    /**
     * @license
     * Copyright 2020 Google LLC. All Rights Reserved.
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     * http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     * =============================================================================
     */
    function conv2d_(x, filter, strides, pad3, dataFormat = "NHWC", dilations = [1, 1], dimRoundingMode) {
      const $x = convertToTensor2(x, "x", "conv2d");
      const $filter = convertToTensor2(filter, "filter", "conv2d");
      let x4D = $x;
      let reshapedTo4D = false;
      if ($x.rank === 3) {
        reshapedTo4D = true;
        x4D = reshape5($x, [1, $x.shape[0], $x.shape[1], $x.shape[2]]);
      }
      assert2(x4D.rank === 4, () => `Error in conv2d: input must be rank 4, but got rank ${x4D.rank}.`);
      assert2($filter.rank === 4, () => `Error in conv2d: filter must be rank 4, but got rank ${$filter.rank}.`);
      if (dimRoundingMode != null) {
        assert2(isInt2(pad3), () => `Error in conv2d: pad must be an integer when using, dimRoundingMode ${dimRoundingMode} but got pad ${pad3}.`);
      }
      const inDepth = dataFormat === "NHWC" ? x4D.shape[3] : x4D.shape[1];
      assert2(inDepth === $filter.shape[2], () => `Error in conv2d: depth of input (${inDepth}) must match input depth for filter ${$filter.shape[2]}.`);
      assert2(eitherStridesOrDilationsAreOne2(strides, dilations), () => `Error in conv2D: Either strides or dilations must be 1. Got strides ${strides} and dilations '${dilations}'`);
      const forward = (backend3, save) => {
        const $dataFormat = convertConv2DDataFormat2(dataFormat);
        const convInfo = computeConv2DInfo2(x4D.shape, $filter.shape, strides, dilations, pad3, dimRoundingMode, false, $dataFormat);
        const res2 = backend3.conv2d(x4D, $filter, convInfo);
        save([x4D, $filter]);
        return res2;
      };
      const inputs = {x: x4D, filter: $filter};
      const attrs = {strides, pad: pad3, dataFormat, dilations, dimRoundingMode};
      const res = ENGINE2.runKernelFunc(forward, inputs, null, Conv2D3, attrs);
      if (reshapedTo4D) {
        return reshape5(res, [res.shape[1], res.shape[2], res.shape[3]]);
      }
      return res;
    }
    const conv2d2 = op2({conv2d_});
    function conv1d_(x, filter, stride, pad3, dataFormat = "NWC", dilation = 1, dimRoundingMode) {
      const $x = convertToTensor2(x, "x", "conv1d");
      const $filter = convertToTensor2(filter, "filter", "conv1d");
      let x3D = $x;
      let reshapedTo3D = false;
      if ($x.rank === 2) {
        reshapedTo3D = true;
        x3D = reshape5($x, [1, $x.shape[0], $x.shape[1]]);
      }
      assert2(x3D.rank === 3, () => `Error in conv1d: input must be rank 3, but got rank ${x3D.rank}.`);
      assert2($filter.rank === 3, () => `Error in conv1d: filter must be rank 3, but got rank ${$filter.rank}.`);
      if (dimRoundingMode != null) {
        assert2(isInt2(pad3), () => `Error in conv1d: pad must be an integer when using, dimRoundingMode ${dimRoundingMode} but got pad ${pad3}.`);
      }
      assert2(x3D.shape[2] === $filter.shape[1], () => `Error in conv1d: depth of input (${x3D.shape[2]}) must match input depth for filter ${$filter.shape[1]}.`);
      assert2(eitherStridesOrDilationsAreOne2(stride, dilation), () => `Error in conv1D: Either stride or dilation must be 1. Got stride ${stride} and dilation '${dilation}'`);
      assert2(dataFormat === "NWC", () => `Error in conv1d: got dataFormat of ${dataFormat} but only NWC is currently supported.`);
      const filter4D = reshape5($filter, [1, $filter.shape[0], $filter.shape[1], $filter.shape[2]]);
      const input4D = reshape5(x3D, [x3D.shape[0], 1, x3D.shape[1], x3D.shape[2]]);
      const strides = [1, stride];
      const dilations = [1, dilation];
      const conv2dDataFormat = "NHWC";
      const res = conv2d2(input4D, filter4D, strides, pad3, conv2dDataFormat, dilations, dimRoundingMode);
      if (reshapedTo3D) {
        return reshape5(res, [res.shape[2], res.shape[3]]);
      }
      return reshape5(res, [res.shape[0], res.shape[2], res.shape[3]]);
    }
    const conv1d = op2({conv1d_});
    /**
     * @license
     * Copyright 2020 Google LLC. All Rights Reserved.
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     * http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     * =============================================================================
     */
    function conv2DBackpropInput_(xShape, dy, filter, strides, pad3, dataFormat = "NHWC", dimRoundingMode) {
      assert2(xShape.length === dy.rank, () => `Length of inShape (${xShape.length}) and rank of dy (${dy.rank}) must match`);
      let xShape4D = xShape;
      let dy4D = dy;
      let reshapedTo4D = false;
      if (dy.rank === 3) {
        reshapedTo4D = true;
        dy4D = reshape5(dy, [1, dy.shape[0], dy.shape[1], dy.shape[2]]);
        xShape4D = [1, xShape[0], xShape[1], xShape[2]];
      }
      assert2(xShape4D.length === 4, () => `Error in conv2dDerInput: inShape must be length 4, but got length ${xShape4D.length}.`);
      assert2(dy4D.rank === 4, () => `Error in conv2dDerInput: dy must be rank 4, but got rank ${dy4D.rank}`);
      assert2(filter.rank === 4, () => `Error in conv2dDerInput: filter must be rank 4, but got rank ${filter.rank}`);
      const inDepth = dataFormat === "NHWC" ? xShape4D[3] : xShape4D[1];
      const outDepth = dataFormat === "NHWC" ? dy4D.shape[3] : dy4D.shape[1];
      assert2(inDepth === filter.shape[2], () => `Error in conv2dDerInput: depth of input (${inDepth}) must match input depth for filter ${filter.shape[2]}.`);
      assert2(outDepth === filter.shape[3], () => `Error in conv2dDerInput: depth of output (${outDepth}) must match output depth for filter ${filter.shape[3]}.`);
      if (dimRoundingMode != null) {
        assert2(isInt2(pad3), () => `Error in conv2dDerInput: pad must be an integer when using, dimRoundingMode ${dimRoundingMode} but got pad ${pad3}.`);
      }
      const forward = (backend3, save) => {
        const dilations = 1;
        const $dataFormat = convertConv2DDataFormat2(dataFormat);
        const convInfo = computeConv2DInfo2(xShape4D, filter.shape, strides, dilations, pad3, dimRoundingMode, false, $dataFormat);
        const res2 = backend3.conv2dDerInput(dy4D, filter, convInfo);
        save([dy4D, filter]);
        return res2;
      };
      const inputs = {dy: dy4D, filter};
      const attrs = {strides, pad: pad3, dataFormat, dimRoundingMode, inputShape: xShape4D};
      const res = ENGINE2.runKernelFunc(forward, inputs, null, Conv2DBackpropInput3, attrs);
      if (reshapedTo4D) {
        return reshape5(res, [res.shape[1], res.shape[2], res.shape[3]]);
      }
      return res;
    }
    const conv2DBackpropInput2 = op2({conv2DBackpropInput_});
    function conv2dTranspose_(x, filter, outputShape, strides, pad3, dimRoundingMode) {
      const $x = convertToTensor2(x, "x", "conv2dTranspose");
      const $filter = convertToTensor2(filter, "filter", "conv2dTranspose");
      return conv2DBackpropInput2(outputShape, $x, $filter, strides, pad3, "NHWC", dimRoundingMode);
    }
    const conv2dTranspose = op2({conv2dTranspose_});
    /**
     * @license
     * Copyright 2020 Google LLC. All Rights Reserved.
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     * http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     * =============================================================================
     */
    function conv3d_(x, filter, strides, pad3, dataFormat = "NDHWC", dilations = [1, 1, 1]) {
      const $x = convertToTensor2(x, "x", "conv3d");
      const $filter = convertToTensor2(filter, "filter", "conv3d");
      let x5D = $x;
      let reshapedTo5D = false;
      if ($x.rank === 4) {
        reshapedTo5D = true;
        x5D = reshape5($x, [1, $x.shape[0], $x.shape[1], $x.shape[2], $x.shape[3]]);
      }
      assert2(x5D.rank === 5, () => `Error in conv3d: input must be rank 5, but got rank ${x5D.rank}.`);
      assert2($filter.rank === 5, () => `Error in conv3d: filter must be rank 5, but got rank ${$filter.rank}.`);
      assert2(x5D.shape[4] === $filter.shape[3], () => `Error in conv3d: depth of input (${x5D.shape[4]}) must match input depth for filter ${$filter.shape[3]}.`);
      assert2(eitherStridesOrDilationsAreOne2(strides, dilations), () => `Error in conv3D: Either strides or dilations must be 1. Got strides ${strides} and dilations '${dilations}'`);
      assert2(dataFormat === "NDHWC", () => `Error in conv3d: got dataFormat of ${dataFormat} but only NDHWC is currently supported.`);
      const forward = (backend3, save) => {
        const convInfo = computeConv3DInfo2(x5D.shape, $filter.shape, strides, dilations, pad3);
        const res2 = backend3.conv3d(x5D, $filter, convInfo);
        save([x5D, $filter]);
        return res2;
      };
      const inputs = {x: x5D, filter: $filter};
      const attrs = {strides, pad: pad3, dataFormat, dilations};
      const res = ENGINE2.runKernelFunc(forward, inputs, null, Conv3D, attrs);
      if (reshapedTo5D) {
        return reshape5(res, [res.shape[1], res.shape[2], res.shape[3], res.shape[4]]);
      }
      return res;
    }
    const conv3d = op2({conv3d_});
    /**
     * @license
     * Copyright 2020 Google LLC. All Rights Reserved.
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     * http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     * =============================================================================
     */
    function conv3DBackpropInput_(xShape, dy, filter, strides, pad3) {
      assert2(xShape.length === dy.rank, () => `Length of inShape (${xShape.length}) and rank of dy (${dy.rank}) must match`);
      let xShape5D = xShape;
      let dy5D = dy;
      let reshapedTo5D = false;
      if (dy.rank === 4) {
        reshapedTo5D = true;
        dy5D = reshape5(dy, [1, dy.shape[0], dy.shape[1], dy.shape[2], dy.shape[3]]);
        xShape5D = [1, xShape[0], xShape[1], xShape[2], xShape[3]];
      }
      const inDepth = xShape5D[4];
      const outDepth = dy5D.shape[4];
      assert2(xShape5D.length === 5, () => `Error in conv3dDerInput: inShape must be length 5, but got length ${xShape5D.length}.`);
      assert2(dy5D.rank === 5, () => `Error in conv3dDerInput: dy must be rank 5, but got rank ${dy5D.rank}`);
      assert2(filter.rank === 5, () => `Error in conv3dDerInput: filter must be rank 5, but got rank ${filter.rank}`);
      assert2(inDepth === filter.shape[3], () => `Error in conv3dDerInput: depth of input (${inDepth}) must match input depth for filter ${filter.shape[3]}.`);
      assert2(outDepth === filter.shape[4], () => `Error in conv3dDerInput: depth of output (${outDepth}) must match output depth for filter ${filter.shape[4]}.`);
      const forward = (backend3) => {
        const dilations = 1;
        const convInfo = computeConv3DInfo2(xShape5D, filter.shape, strides, dilations, pad3);
        return backend3.conv3dDerInput(dy5D, filter, convInfo);
      };
      const inputs = {dy: dy5D, filter};
      const attrs = {pad: pad3, strides, inputShape: xShape5D};
      const res = ENGINE2.runKernelFunc(forward, inputs, null, Conv3DBackpropInputV2, attrs);
      if (reshapedTo5D) {
        return reshape5(res, [res.shape[1], res.shape[2], res.shape[3], res.shape[4]]);
      }
      return res;
    }
    const conv3DBackpropInput = op2({conv3DBackpropInput_});
    function conv3dTranspose_(x, filter, outputShape, strides, pad3) {
      const $x = convertToTensor2(x, "x", "conv3dTranspose");
      const $filter = convertToTensor2(filter, "filter", "conv3dTranspose");
      return conv3DBackpropInput(outputShape, $x, $filter, strides, pad3);
    }
    const conv3dTranspose = op2({conv3dTranspose_});
    /**
     * @license
     * Copyright 2018 Google LLC. All Rights Reserved.
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     * http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     * =============================================================================
     */
    function cos_(x) {
      const $x = convertToTensor2(x, "x", "cos");
      const inputs = {x: $x};
      return ENGINE2.runKernelFunc((backend3, save) => {
        const res = backend3.cos($x);
        save([$x]);
        return res;
      }, inputs, null, Cos3);
    }
    const cos = op2({cos_});
    /**
     * @license
     * Copyright 2018 Google LLC. All Rights Reserved.
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     * http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     * =============================================================================
     */
    function cosh_(x) {
      const $x = convertToTensor2(x, "x", "cosh");
      const inputs = {x: $x};
      return ENGINE2.runKernelFunc((backend3, save) => {
        const res = backend3.cosh($x);
        save([$x]);
        return res;
      }, inputs, null, Cosh);
    }
    const cosh = op2({cosh_});
    /**
     * @license
     * Copyright 2018 Google LLC. All Rights Reserved.
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     * http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     * =============================================================================
     */
    function cumsum_(x, axis = 0, exclusive = false, reverse3 = false) {
      const $x = convertToTensor2(x, "x", "cumsum");
      const forward = (backend3, save) => {
        const permutation = getAxesPermutation2([axis], $x.rank);
        let permutedX = $x;
        if (permutation != null) {
          permutedX = transpose4($x, permutation);
        }
        const permutedAxis = getInnerMostAxes2(1, $x.rank)[0];
        let value = backend3.cumsum(permutedX, permutedAxis, exclusive, reverse3);
        save([$x]);
        if (permutation != null) {
          const reversePermutation = getUndoAxesPermutation2(permutation);
          value = transpose4(value, reversePermutation);
        }
        return value;
      };
      const inputs = {x: $x};
      const attrs = {axis, exclusive, reverse: reverse3};
      return ENGINE2.runKernelFunc(forward, inputs, null, Cumsum3, attrs);
    }
    const cumsum2 = op2({cumsum_});
    /**
     * @license
     * Copyright 2020 Google LLC. All Rights Reserved.
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     * http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     * =============================================================================
     */
    function depthToSpace_(x, blockSize, dataFormat = "NHWC") {
      const $x = convertToTensor2(x, "x", "depthToSpace");
      const inputHeight = dataFormat === "NHWC" ? $x.shape[1] : $x.shape[2];
      const inputWidth = dataFormat === "NHWC" ? $x.shape[2] : $x.shape[3];
      const inputDepth = dataFormat === "NHWC" ? $x.shape[3] : $x.shape[1];
      assert2(inputHeight * blockSize >= 0, () => `Negative dimension size caused by overflow when multiplying
    ${inputHeight} and ${blockSize}  for depthToSpace with input shape
    ${$x.shape}`);
      assert2(inputWidth * blockSize >= 0, () => `Negative dimension size caused by overflow when multiplying
    ${inputWidth} and ${blockSize} for depthToSpace with input shape
        ${$x.shape}`);
      assert2(inputDepth % (blockSize * blockSize) === 0, () => `Dimension size must be evenly divisible by ${blockSize * blockSize} but is ${inputDepth} for depthToSpace with input shape ${$x.shape}`);
      const forward = (backend3) => backend3.depthToSpace($x, blockSize, dataFormat);
      const inputs = {x: $x};
      const attrs = {blockSize, dataFormat};
      return ENGINE2.runKernelFunc(forward, inputs, null, DepthToSpace3, attrs);
    }
    const depthToSpace2 = op2({depthToSpace_});
    /**
     * @license
     * Copyright 2020 Google LLC. All Rights Reserved.
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     * http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     * =============================================================================
     */
    function depthwiseConv2d_(x, filter, strides, pad3, dataFormat = "NHWC", dilations = [1, 1], dimRoundingMode) {
      const $x = convertToTensor2(x, "x", "depthwiseConv2d");
      const $filter = convertToTensor2(filter, "filter", "depthwiseConv2d");
      let x4D = $x;
      let reshapedTo4D = false;
      if ($x.rank === 3) {
        reshapedTo4D = true;
        x4D = reshape5($x, [1, $x.shape[0], $x.shape[1], $x.shape[2]]);
      }
      assert2(x4D.rank === 4, () => `Error in depthwiseConv2d: input must be rank 4, but got rank ${x4D.rank}.`);
      assert2($filter.rank === 4, () => `Error in depthwiseConv2d: filter must be rank 4, but got rank ${$filter.rank}.`);
      assert2(x4D.shape[3] === $filter.shape[2], () => `Error in depthwiseConv2d: number of input channels (${x4D.shape[3]}) must match the inChannels dimension in filter ${$filter.shape[2]}.`);
      if (dimRoundingMode != null) {
        assert2(isInt2(pad3), () => `Error in depthwiseConv2d: pad must be an integer when using, dimRoundingMode ${dimRoundingMode} but got pad ${pad3}.`);
      }
      const forward = (backend3, save) => {
        if (dilations == null) {
          dilations = [1, 1];
        }
        assert2(eitherStridesOrDilationsAreOne2(strides, dilations), () => `Error in depthwiseConv2d: Either strides or dilations must be 1. Got strides ${strides} and dilations '${dilations}'`);
        const convInfo = computeConv2DInfo2(x4D.shape, $filter.shape, strides, dilations, pad3, dimRoundingMode, true);
        const res2 = backend3.depthwiseConv2D(x4D, $filter, convInfo);
        save([x4D, $filter]);
        return res2;
      };
      const inputs = {x: x4D, filter: $filter};
      const attrs = {strides, pad: pad3, dataFormat, dilations, dimRoundingMode};
      const res = ENGINE2.runKernelFunc(forward, inputs, null, DepthwiseConv2dNative3, attrs);
      if (reshapedTo4D) {
        return reshape5(res, [res.shape[1], res.shape[2], res.shape[3]]);
      }
      return res;
    }
    const depthwiseConv2d2 = op2({depthwiseConv2d_});
    /**
     * @license
     * Copyright 2020 Google LLC. All Rights Reserved.
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     * http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     * =============================================================================
     */
    function diag_(x) {
      const $x = convertToTensor2(x, "x", "diag");
      const forward = (backend3) => {
        const flat = reshape5($x, [$x.size]);
        const result = backend3.diag(flat);
        const outShape = [...x.shape, ...x.shape];
        return reshape5(result, outShape);
      };
      const inputs = {x: $x};
      return ENGINE2.runKernelFunc(forward, inputs, null, Diag);
    }
    const diag = op2({diag_});
    /**
     * @license
     * Copyright 2020 Google LLC. All Rights Reserved.
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     * http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     * =============================================================================
     */
    function dilation2d_(x, filter, strides, pad3, dilations = [1, 1], dataFormat = "NHWC") {
      const $x = convertToTensor2(x, "x", "dilation2d");
      const $filter = convertToTensor2(filter, "filter", "dilation2d");
      assert2($x.rank === 3 || $x.rank === 4, () => `Error in dilation2d: input must be rank 3 or 4, but got rank ${$x.rank}.`);
      assert2($filter.rank === 3, () => `Error in dilation2d: filter must be rank 3, but got rank ${$filter.rank}.`);
      assert2(dataFormat === "NHWC", () => `Error in dilation2d: Only NHWC is currently supported, but got dataFormat of ${dataFormat}`);
      let x4D = $x;
      let reshapedTo4D = false;
      if ($x.rank === 3) {
        x4D = reshape5($x, [1, $x.shape[0], $x.shape[1], $x.shape[2]]);
        reshapedTo4D = true;
      }
      const inputs = {x: x4D, filter: $filter};
      const attrs = {strides, pad: pad3, dilations};
      const res = ENGINE2.runKernel(Dilation2D, inputs, attrs);
      if (reshapedTo4D) {
        return reshape5(res, [res.shape[1], res.shape[2], res.shape[3]]);
      }
      return res;
    }
    const dilation2d = op2({dilation2d_});
    /**
     * @license
     * Copyright 2017 Google LLC. All Rights Reserved.
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     * http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     * =============================================================================
     */
    function getBroadcastDims2(inShape, outShape) {
      const inRank = inShape.length;
      const dims = [];
      for (let i = 0; i < inRank; i++) {
        const dim = inRank - 1 - i;
        const a = inShape[dim] || 1;
        const b = outShape[outShape.length - 1 - i] || 1;
        if (b > 1 && a === 1) {
          dims.unshift(dim);
        }
      }
      return dims;
    }
    function getReductionAxes2(inShape, outShape) {
      const result = [];
      for (let i = 0; i < outShape.length; i++) {
        const inDim = inShape[inShape.length - i - 1];
        const outAxis = outShape.length - i - 1;
        const outDim = outShape[outAxis];
        if (inDim == null || inDim === 1 && outDim > 1) {
          result.unshift(outAxis);
        }
      }
      return result;
    }
    function assertAndGetBroadcastShape2(shapeA, shapeB) {
      const result = [];
      const l = Math.max(shapeA.length, shapeB.length);
      for (let i = 0; i < l; i++) {
        let a = shapeA[shapeA.length - i - 1];
        if (a == null) {
          a = 1;
        }
        let b = shapeB[shapeB.length - i - 1];
        if (b == null) {
          b = 1;
        }
        if (a === 1) {
          result.unshift(b);
        } else if (b === 1) {
          result.unshift(a);
        } else if (a !== b) {
          const errMsg = `Operands could not be broadcast together with shapes ${shapeA} and ${shapeB}.`;
          throw Error(errMsg);
        } else {
          result.unshift(a);
        }
      }
      return result;
    }
    /**
     * @license
     * Copyright 2020 Google LLC. All Rights Reserved.
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     * http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     * =============================================================================
     */
    function equal_(a, b) {
      let $a = convertToTensor2(a, "a", "equal");
      let $b = convertToTensor2(b, "b", "equal");
      [$a, $b] = makeTypesMatch2($a, $b);
      assertAndGetBroadcastShape2($a.shape, $b.shape);
      const forward = (backend3) => backend3.equal($a, $b);
      const inputs = {a: $a, b: $b};
      return ENGINE2.runKernelFunc(forward, inputs, null, Equal3);
    }
    const equal = op2({equal_});
    /**
     * @license
     * Copyright 2020 Google LLC. All Rights Reserved.
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     * http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     * =============================================================================
     */
    function where_(condition, a, b) {
      const $a = convertToTensor2(a, "a", "where");
      const $b = convertToTensor2(b, "b", "where");
      const $condition = convertToTensor2(condition, "condition", "where", "bool");
      const broadcastShape = assertAndGetBroadcastShape2($a.shape, $b.shape);
      const $broadcastedA = broadcastTo($a, broadcastShape);
      const $broadcastedB = broadcastTo($b, broadcastShape);
      if ($condition.rank === 1) {
        assert2($condition.shape[0] === $a.shape[0], () => "The first dimension of `a` must match the size of `condition`.");
      }
      if ($condition.rank !== 1) {
        assertShapesMatch2($condition.shape, $broadcastedB.shape, "Error in where: ");
      }
      const forward = (backend3, save) => {
        const res = backend3.select($condition, $broadcastedA, $broadcastedB);
        save([$condition]);
        return res;
      };
      const inputs = {
        condition: $condition,
        t: $broadcastedA,
        e: $broadcastedB
      };
      return ENGINE2.runKernelFunc(forward, inputs, null, SelectV23);
    }
    const where = op2({where_});
    /**
     * @license
     * Copyright 2018 Google LLC. All Rights Reserved.
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     * http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     * =============================================================================
     */
    function zerosLike_(x) {
      const $x = convertToTensor2(x, "x", "zerosLike");
      const inputs = {x: $x};
      return ENGINE2.runKernelFunc((backend3) => backend3.zerosLike($x), inputs, null, ZerosLike3);
    }
    const zerosLike2 = op2({zerosLike_});
    /**
     * @license
     * Copyright 2020 Google LLC. All Rights Reserved.
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     * http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     * =============================================================================
     */
    function divNoNan_(a, b) {
      let $a = convertToTensor2(a, "a", "div");
      let $b = convertToTensor2(b, "b", "div");
      [$a, $b] = makeTypesMatch2($a, $b);
      const divResult = div($a, $b);
      const zeros4 = zerosLike2(divResult);
      const bEqualsZero = equal($b, zeros4);
      return where(bEqualsZero, zeros4, divResult);
    }
    const divNoNan = op2({divNoNan_});
    /**
     * @license
     * Copyright 2020 Google LLC. All Rights Reserved.
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     * http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     * =============================================================================
     */
    function dot_(t1, t2) {
      const $t1 = convertToTensor2(t1, "t1", "dot");
      const $t2 = convertToTensor2(t2, "t2", "dot");
      assert2(($t1.rank === 1 || $t1.rank === 2) && ($t2.rank === 1 || $t2.rank === 2), () => `Error in dot: inputs must all be rank 1 or 2, but got ranks ${$t1.rank} and ${$t2.rank}.`);
      const t1Inner = $t1.rank === 1 ? $t1.size : $t1.shape[1];
      const t2Inner = $t2.rank === 1 ? $t2.size : $t2.shape[0];
      assert2(t1Inner === t2Inner, () => `Error in dot: inner dimensions of inputs must match, but got ${t1Inner} and ${t2Inner}.`);
      if ($t1.rank === 1 && $t2.rank === 1) {
        const t12D = reshape5($t1, [1, -1]);
        const t22D = reshape5($t2, [-1, 1]);
        const t1t2 = matMul(t12D, t22D);
        return reshape5(t1t2, []);
      } else if ($t1.rank === 1 && $t2.rank === 2) {
        const t12D = reshape5($t1, [1, -1]);
        const t22D = reshape5($t2, [$t2.shape[0], $t2.shape[1]]);
        const t1t2 = matMul(t12D, t22D);
        return reshape5(t1t2, [t1t2.size]);
      } else if ($t1.rank === 2 && $t2.rank === 1) {
        const t22D = reshape5($t2, [-1, 1]);
        const t1t2 = matMul($t1, t22D);
        return reshape5(t1t2, [t1t2.size]);
      } else {
        const t22D = reshape5($t2, [$t2.shape[0], $t2.shape[1]]);
        const t1t2 = matMul($t1, t22D);
        return t1t2;
      }
    }
    const dot2 = op2({dot_});
    /**
     * @license
     * Copyright 2020 Google LLC. All Rights Reserved.
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     * http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     * =============================================================================
     */
    function elu_2(x) {
      const $x = convertToTensor2(x, "x", "elu");
      const forward = (backend3, save) => {
        const y = backend3.elu($x);
        save([y]);
        return y;
      };
      const inputs = {x: $x};
      return ENGINE2.runKernelFunc(forward, inputs, null, Elu2);
    }
    const elu3 = op2({elu_: elu_2});
    /**
     * @license
     * Copyright 2018 Google LLC. All Rights Reserved.
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     * http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     * =============================================================================
     */
    function erf_(x) {
      let $x = convertToTensor2(x, "x", "erf");
      assert2($x.dtype === "int32" || $x.dtype === "float32", () => "Input dtype must be `int32` or `float32`.");
      if ($x.dtype === "int32") {
        $x = cast7($x, "float32");
      }
      const inputs = {x: $x};
      return ENGINE2.runKernelFunc((backend3, save) => {
        const res = backend3.erf($x);
        save([$x]);
        return res;
      }, inputs, null, Erf);
    }
    const erf = op2({erf_});
    /**
     * @license
     * Copyright 2018 Google LLC. All Rights Reserved.
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     * http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     * =============================================================================
     */
    function exp_(x) {
      const $x = convertToTensor2(x, "x", "exp");
      const inputs = {x: $x};
      return ENGINE2.runKernelFunc((backend3, save) => {
        const res = backend3.exp($x);
        save([res]);
        return res;
      }, inputs, null, Exp3);
    }
    const exp = op2({exp_});
    /**
     * @license
     * Copyright 2020 Google LLC. All Rights Reserved.
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     * http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     * =============================================================================
     */
    function expandDims_(x, axis = 0) {
      const parseAs = null;
      const $x = convertToTensor2(x, "x", "expandDims", parseAs);
      assert2(axis <= $x.rank, () => "Axis must be <= rank of the tensor");
      const newShape = $x.shape.slice();
      if (axis < 0) {
        assert2(-($x.rank + 1) <= axis, () => `Axis must be in the interval [${-($x.rank + 1)}, ${$x.rank}]`);
        axis = $x.rank + axis + 1;
      }
      newShape.splice(axis, 0, 1);
      return reshape5($x, newShape);
    }
    const expandDims = op2({expandDims_});
    /**
     * @license
     * Copyright 2018 Google LLC. All Rights Reserved.
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     * http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     * =============================================================================
     */
    function expm1_(x) {
      const $x = convertToTensor2(x, "x", "expm1");
      const inputs = {x: $x};
      return ENGINE2.runKernelFunc((backend3, save) => {
        const res = backend3.expm1($x);
        save([$x]);
        return res;
      }, inputs, null, Expm1);
    }
    const expm1 = op2({expm1_});
    /**
     * @license
     * Copyright 2020 Google LLC. All Rights Reserved.
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     * http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     * =============================================================================
     */
    function tile_(x, reps) {
      const parseAs = null;
      const $x = convertToTensor2(x, "x", "tile", parseAs);
      assert2($x.rank === reps.length, () => `Error in transpose: rank of input ${$x.rank} must match length of reps ${reps}.`);
      const forward = (backend3, save) => {
        const res = backend3.tile($x, reps);
        save([$x]);
        return res;
      };
      const inputsToSave = [$x];
      const inputs = {x: $x};
      const attrs = {reps};
      return ENGINE2.runKernelFunc(forward, inputs, null, Tile3, attrs, inputsToSave);
    }
    const tile2 = op2({tile_});
    /**
     * @license
     * Copyright 2020 Google LLC. All Rights Reserved.
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     * http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     * =============================================================================
     */
    function eye_(numRows, numColumns, batchShape, dtype = "float32") {
      if (numColumns == null) {
        numColumns = numRows;
      }
      const buff = buffer2([numRows, numColumns], dtype);
      const n = numRows <= numColumns ? numRows : numColumns;
      for (let i = 0; i < n; ++i) {
        buff.set(1, i, i);
      }
      const out = reshape5(buff.toTensor(), [numRows, numColumns]);
      if (batchShape == null) {
        return out;
      } else {
        if (batchShape.length === 1) {
          return tile2(expandDims(out, 0), [batchShape[0], 1, 1]);
        } else if (batchShape.length === 2) {
          return tile2(expandDims(expandDims(out, 0), 0), [batchShape[0], batchShape[1], 1, 1]);
        } else if (batchShape.length === 3) {
          return tile2(expandDims(expandDims(expandDims(out, 0), 0), 0), [
            batchShape[0],
            batchShape[1],
            batchShape[2],
            1,
            1
          ]);
        } else {
          throw new Error(`eye() currently supports only 1D and 2D batchShapes, but received ${batchShape.length}D.`);
        }
      }
    }
    const eye = op2({eye_});
    /**
     * @license
     * Copyright 2020 Google LLC. All Rights Reserved.
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     * http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     * =============================================================================
     */
    function fill2(shape, value, dtype) {
      const attrs = {shape, value, dtype};
      return ENGINE2.runKernelFunc((backend3) => backend3.fill(shape, value, dtype), {}, null, Fill3, attrs);
    }
    /**
     * @license
     * Copyright 2018 Google LLC. All Rights Reserved.
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     * http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     * =============================================================================
     */
    function floor_(x) {
      const $x = convertToTensor2(x, "x", "floor");
      const inputs = {x: $x};
      return ENGINE2.runKernelFunc((backend3) => backend3.floor($x), inputs, null, Floor);
    }
    const floor = op2({floor_});
    /**
     * @license
     * Copyright 2017 Google LLC. All Rights Reserved.
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     * http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     * =============================================================================
     */
    const PARALLELIZE_THRESHOLD2 = 30;
    function computeOptimalWindowSize2(inSize) {
      if (inSize <= PARALLELIZE_THRESHOLD2) {
        return inSize;
      }
      return nearestDivisor2(inSize, Math.floor(Math.sqrt(inSize)));
    }
    /**
     * @license
     * Copyright 2018 Google LLC. All Rights Reserved.
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     * http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     * =============================================================================
     */
    function segOpComputeOptimalWindowSize2(inSize, numSegments) {
      let done = false;
      let res;
      if (inSize <= PARALLELIZE_THRESHOLD2) {
        res = inSize;
        done = true;
      } else {
        res = nearestDivisor2(inSize, Math.floor(Math.sqrt(inSize)));
      }
      while (!done) {
        if (res > numSegments || res === inSize) {
          done = true;
        } else {
          res = nearestDivisor2(inSize, res + 1);
        }
      }
      return res;
    }
    function computeOutShape$2(aShape, axis, numSegments) {
      const outShape = [];
      const rank = aShape.length;
      for (let dim = 0; dim < rank; dim++) {
        if (dim !== axis) {
          outShape.push(aShape[dim]);
        } else {
          outShape.push(numSegments);
        }
      }
      return outShape;
    }
    function collectGatherOpShapeInfo2(x, indices, axis) {
      const dimSize = x.shape[axis];
      const outputShape = [];
      let batchSize = 1;
      let sliceSize = 1;
      for (let i = 0; i < axis; i++) {
        outputShape.push(x.shape[i]);
        batchSize *= x.shape[i];
      }
      for (let i = 0; i < indices.rank; i++) {
        outputShape.push(indices.shape[i]);
      }
      for (let i = axis + 1; i < x.rank; i++) {
        outputShape.push(x.shape[i]);
        sliceSize *= x.shape[i];
      }
      return {batchSize, sliceSize, dimSize, outputShape};
    }
    var segment_util = /* @__PURE__ */ Object.freeze({
      __proto__: null,
      segOpComputeOptimalWindowSize: segOpComputeOptimalWindowSize2,
      computeOutShape: computeOutShape$2,
      collectGatherOpShapeInfo: collectGatherOpShapeInfo2
    });
    /**
     * @license
     * Copyright 2018 Google LLC. All Rights Reserved.
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     * http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     * =============================================================================
     */
    function gather_(x, indices, axis = 0) {
      const $x = convertToTensor2(x, "x", "gather");
      const $indices = convertToTensor2(indices, "indices", "gather", "int32");
      const inputs = {x: $x, indices: $indices};
      const attrs = {axis};
      const forward = (backend3, save) => {
        const parsedAxis = parseAxisParam2(axis, $x.shape)[0];
        const shapeInfo = collectGatherOpShapeInfo2($x, $indices, parsedAxis);
        const res = backend3.gather($x, reshape5($indices, [$indices.size]), parsedAxis);
        save([$x, $indices]);
        return reshape5(res, shapeInfo.outputShape);
      };
      return ENGINE2.runKernelFunc(forward, inputs, null, GatherV23, attrs);
    }
    const gather = op2({gather_});
    /**
     * @license
     * Copyright 2020 Google LLC. All Rights Reserved.
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     * http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     * =============================================================================
     */
    function greater_(a, b) {
      let $a = convertToTensor2(a, "a", "greater");
      let $b = convertToTensor2(b, "b", "greater");
      [$a, $b] = makeTypesMatch2($a, $b);
      assertAndGetBroadcastShape2($a.shape, $b.shape);
      const forward = (backend3) => backend3.greater($a, $b);
      const inputs = {a: $a, b: $b};
      return ENGINE2.runKernelFunc(forward, inputs, null, Greater3);
    }
    const greater = op2({greater_});
    /**
     * @license
     * Copyright 2020 Google LLC. All Rights Reserved.
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     * http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     * =============================================================================
     */
    function greaterEqual_(a, b) {
      let $a = convertToTensor2(a, "a", "greaterEqual");
      let $b = convertToTensor2(b, "b", "greaterEqual");
      [$a, $b] = makeTypesMatch2($a, $b);
      assertAndGetBroadcastShape2($a.shape, $b.shape);
      const forward = (backend3, save) => {
        const res = backend3.greaterEqual($a, $b);
        save([$a, $b]);
        return res;
      };
      const inputs = {a: $a, b: $b};
      return ENGINE2.runKernelFunc(forward, inputs, null, GreaterEqual3);
    }
    const greaterEqual = op2({greaterEqual_});
    /**
     * @license
     * Copyright 2020 Google LLC. All Rights Reserved.
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     * http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     * =============================================================================
     */
    function imag_(input2) {
      const $input = convertToTensor2(input2, "input", "imag");
      const forward = (backend3) => {
        return backend3.imag($input);
      };
      const inputs = {input: $input};
      return ENGINE2.runKernelFunc(forward, inputs, null, Imag);
    }
    const imag = op2({imag_});
    /**
     * @license
     * Copyright 2018 Google LLC. All Rights Reserved.
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     * http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     * =============================================================================
     */
    function isFinite_(x) {
      const $x = convertToTensor2(x, "x", "isFinite");
      const inputs = {x: $x};
      return ENGINE2.runKernelFunc((backend3) => backend3.isFinite($x), inputs, null, IsFinite);
    }
    const isFinite$1 = op2({isFinite_});
    /**
     * @license
     * Copyright 2018 Google LLC. All Rights Reserved.
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     * http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     * =============================================================================
     */
    function isInf_(x) {
      const $x = convertToTensor2(x, "x", "isInf");
      const inputs = {x: $x};
      return ENGINE2.runKernelFunc((backend3) => backend3.isInf($x), inputs, null, IsInf);
    }
    const isInf = op2({isInf_});
    /**
     * @license
     * Copyright 2018 Google LLC. All Rights Reserved.
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     * http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     * =============================================================================
     */
    function isNaN_(x) {
      const $x = convertToTensor2(x, "x", "isNaN");
      const inputs = {x: $x};
      return ENGINE2.runKernelFunc((backend3) => backend3.isNaN($x), inputs, null, IsNan);
    }
    const isNaN$1 = op2({isNaN_});
    /**
     * @license
     * Copyright 2020 Google LLC. All Rights Reserved.
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     * http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     * =============================================================================
     */
    function maximum_(a, b) {
      let $a = convertToTensor2(a, "a", "maximum");
      let $b = convertToTensor2(b, "b", "maximum");
      [$a, $b] = makeTypesMatch2($a, $b);
      if ($a.dtype === "bool") {
        $a = cast7($a, "int32");
        $b = cast7($b, "int32");
      }
      assertAndGetBroadcastShape2($a.shape, $b.shape);
      const forward = (backend3, save) => {
        const res = backend3.maximum($a, $b);
        save([$a, $b]);
        return res;
      };
      const inputs = {a: $a, b: $b};
      return ENGINE2.runKernelFunc(forward, inputs, null, Maximum3);
    }
    const maximum = op2({maximum_});
    /**
     * @license
     * Copyright 2018 Google LLC. All Rights Reserved.
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     * http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     * =============================================================================
     */
    function scalar3(value, dtype) {
      if ((isTypedArray2(value) && dtype !== "string" || Array.isArray(value)) && dtype !== "complex64") {
        throw new Error("Error creating a new Scalar: value must be a primitive (number|boolean|string)");
      }
      if (dtype === "string" && isTypedArray2(value) && !(value instanceof Uint8Array)) {
        throw new Error("When making a scalar from encoded string, the value must be `Uint8Array`.");
      }
      const shape = [];
      const inferredShape = [];
      return makeTensor2(value, shape, inferredShape, dtype);
    }
    /**
     * @license
     * Copyright 2020 Google LLC. All Rights Reserved.
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     * http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     * =============================================================================
     */
    function leakyRelu_(x, alpha = 0.2) {
      const $x = convertToTensor2(x, "x", "leakyRelu");
      return maximum(mul3(scalar3(alpha), $x), $x);
    }
    const leakyRelu = op2({leakyRelu_});
    /**
     * @license
     * Copyright 2020 Google LLC. All Rights Reserved.
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     * http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     * =============================================================================
     */
    function less_(a, b) {
      let $a = convertToTensor2(a, "a", "less");
      let $b = convertToTensor2(b, "b", "less");
      [$a, $b] = makeTypesMatch2($a, $b);
      assertAndGetBroadcastShape2($a.shape, $b.shape);
      const forward = (backend3) => backend3.less($a, $b);
      const inputs = {a: $a, b: $b};
      return ENGINE2.runKernelFunc(forward, inputs, null, Less3);
    }
    const less = op2({less_});
    /**
     * @license
     * Copyright 2020 Google LLC. All Rights Reserved.
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     * http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     * =============================================================================
     */
    function lessEqual_(a, b) {
      let $a = convertToTensor2(a, "a", "lessEqual");
      let $b = convertToTensor2(b, "b", "lessEqual");
      [$a, $b] = makeTypesMatch2($a, $b);
      assertAndGetBroadcastShape2($a.shape, $b.shape);
      const forward = (backend3, save) => {
        const res = backend3.lessEqual($a, $b);
        save([$a, $b]);
        return res;
      };
      const inputs = {a: $a, b: $b};
      return ENGINE2.runKernelFunc(forward, inputs, null, LessEqual3);
    }
    const lessEqual = op2({lessEqual_});
    /**
     * @license
     * Copyright 2018 Google LLC. All Rights Reserved.
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     * http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     * =============================================================================
     */
    function linspace(start, stop, num) {
      if (num <= 0) {
        throw new Error("The number of values should be positive.");
      }
      const attrs = {start, stop, num};
      return ENGINE2.runKernelFunc((backend3) => backend3.linspace(start, stop, num), {}, null, LinSpace, attrs);
    }
    /**
     * @license
     * Copyright 2020 Google LLC. All Rights Reserved.
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     * http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     * =============================================================================
     */
    function localResponseNormalization_(x, depthRadius = 5, bias = 1, alpha = 1, beta = 0.5) {
      const $x = convertToTensor2(x, "x", "localResponseNormalization");
      assert2($x.rank === 4 || $x.rank === 3, () => `Error in localResponseNormalization: x must be rank 3 or 4 but got
               rank ${$x.rank}.`);
      assert2(isInt2(depthRadius), () => `Error in localResponseNormalization: depthRadius must be an integer but got depthRadius ${depthRadius}.`);
      let x4D = $x;
      let reshapedTo4D = false;
      if ($x.rank === 3) {
        reshapedTo4D = true;
        x4D = reshape5($x, [1, $x.shape[0], $x.shape[1], $x.shape[2]]);
      }
      const forward = (backend3, save) => {
        const y = backend3.localResponseNormalization4D(x4D, depthRadius, bias, alpha, beta);
        save([x4D, y]);
        return y;
      };
      const inputs = {x: x4D};
      const attrs = {depthRadius, bias, alpha, beta};
      const res = ENGINE2.runKernelFunc(forward, inputs, null, LRN, attrs);
      if (reshapedTo4D) {
        return reshape5(res, [res.shape[1], res.shape[2], res.shape[3]]);
      } else {
        return res;
      }
    }
    const localResponseNormalization = op2({localResponseNormalization_});
    /**
     * @license
     * Copyright 2018 Google LLC. All Rights Reserved.
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     * http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     * =============================================================================
     */
    function log_(x) {
      const $x = convertToTensor2(x, "x", "log");
      const inputs = {x: $x};
      return ENGINE2.runKernelFunc((backend3, save) => {
        const res = backend3.log($x);
        save([$x]);
        return res;
      }, inputs, null, Log3);
    }
    const log22 = op2({log_});
    /**
     * @license
     * Copyright 2018 Google LLC. All Rights Reserved.
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     * http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     * =============================================================================
     */
    function log1p_(x) {
      const $x = convertToTensor2(x, "x", "log1p");
      const inputs = {x: $x};
      return ENGINE2.runKernelFunc((backend3, save) => {
        const res = backend3.log1p($x);
        save([$x]);
        return res;
      }, inputs, null, Log1p);
    }
    const log1p = op2({log1p_});
    /**
     * @license
     * Copyright 2018 Google LLC. All Rights Reserved.
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     * http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     * =============================================================================
     */
    function grad(f) {
      assert2(isFunction2(f), () => "The f passed in grad(f) must be a function");
      return (x, dy) => {
        const $x = convertToTensor2(x, "x", "tf.grad", null);
        const $dy = dy != null ? convertToTensor2(dy, "dy", "tf.grad") : null;
        return ENGINE2.tidy(() => {
          const {value, grads: grads2} = ENGINE2.gradients(() => f($x), [$x], $dy);
          if ($dy != null) {
            assertShapesMatch2(value.shape, $dy.shape, "The shape of dy passed in grad(f)(x, dy) must match the shape returned by f(x)");
          }
          checkGrads(grads2);
          return grads2[0];
        });
      };
    }
    function grads(f) {
      assert2(isFunction2(f), () => "The f passed in grads(f) must be a function");
      return (args, dy) => {
        assert2(Array.isArray(args), () => "The args passed in grads(f)(args) must be an array of `Tensor`s or `TensorLike`s");
        const $args = convertToTensorArray(args, "args", "tf.grads", null);
        const $dy = dy != null ? convertToTensor2(dy, "dy", "tf.grads") : null;
        return ENGINE2.tidy(() => {
          const {value, grads: grads2} = ENGINE2.gradients(() => f(...$args), $args, $dy);
          if ($dy != null) {
            assertShapesMatch2(value.shape, $dy.shape, "The shape of dy passed in grads(f)([x1,...], dy) must match the shape returned by f([x1,...])");
          }
          checkGrads(grads2);
          return grads2;
        });
      };
    }
    function valueAndGrad(f) {
      assert2(isFunction2(f), () => "The f passed in valueAndGrad(f) must be a function");
      return (x, dy) => {
        assert2(x instanceof Tensor2, () => "The x passed in valueAndGrad(f)(x) must be a tensor");
        assert2(dy == null || dy instanceof Tensor2, () => "The dy passed in valueAndGrad(f)(x, dy) must be a tensor");
        const {grads: grads2, value} = ENGINE2.gradients(() => f(x), [x], dy);
        checkGrads(grads2);
        return {grad: grads2[0], value};
      };
    }
    function valueAndGrads(f) {
      assert2(isFunction2(f), () => "The f passed in valueAndGrads(f) must be a function");
      return (args, dy) => {
        assert2(Array.isArray(args) && args.every((arg) => arg instanceof Tensor2), () => "The args passed in valueAndGrads(f)(args) must be array of tensors");
        assert2(dy == null || dy instanceof Tensor2, () => "The dy passed in valueAndGrads(f)(args, dy) must be a tensor");
        const res = ENGINE2.gradients(() => f(...args), args, dy);
        if (dy != null) {
          assertShapesMatch2(res.value.shape, dy.shape, "The shape of dy passed in valueAndGrads(f)([x1,...], dy) must match the shape returned by f([x1,...])");
        }
        checkGrads(res.grads);
        return res;
      };
    }
    function variableGrads(f, varList) {
      assert2(isFunction2(f), () => "The f passed in variableGrads(f) must be a function");
      assert2(varList == null || Array.isArray(varList) && varList.every((v) => v instanceof Variable2), () => "The varList passed in variableGrads(f, varList) must be an array of variables");
      const specifiedVarList = varList != null;
      if (!specifiedVarList) {
        varList = [];
        for (const varName in ENGINE2.registeredVariables) {
          varList.push(ENGINE2.registeredVariables[varName]);
        }
      }
      const specifiedNonTrainable = specifiedVarList ? varList.filter((variable2) => !variable2.trainable) : null;
      const originalVarCount = varList.length;
      varList = varList.filter((variable2) => variable2.trainable);
      assert2(varList.length > 0, () => `variableGrads() expects at least one of the input variables to be trainable, but none of the ${originalVarCount} variables is trainable.`);
      const allowNoGradients = true;
      const {value, grads: grads2} = ENGINE2.gradients(f, varList, null, allowNoGradients);
      assert2(grads2.some((g) => g != null), () => "Cannot find a connection between any variable and the result of the loss function y=f(x). Please make sure the operations that use variables are inside the function f passed to minimize().");
      assert2(value.rank === 0, () => `The f passed in variableGrads(f) must return a scalar, but it returned a rank-${value.rank} tensor`);
      const namedGrads = {};
      varList.forEach((v, i) => {
        if (grads2[i] != null) {
          namedGrads[v.name] = grads2[i];
        }
      });
      if (specifiedNonTrainable != null) {
        specifiedNonTrainable.forEach((v) => namedGrads[v.name] = null);
      }
      return {value, grads: namedGrads};
    }
    function customGrad(f) {
      return ENGINE2.customGrad(f);
    }
    function checkGrads(grads2) {
      const numNullGradients = grads2.filter((g) => g == null).length;
      if (numNullGradients > 0) {
        throw new Error(`Cannot compute gradient of y=f(x) with respect to x. Make sure that
    the f you passed encloses all operations that lead from x to y.`);
      }
    }
    /**
     * @license
     * Copyright 2018 Google LLC. All Rights Reserved.
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     * http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     * =============================================================================
     */
    function neg_(x) {
      const $x = convertToTensor2(x, "x", "neg");
      const inputs = {x: $x};
      return ENGINE2.runKernelFunc((backend3) => backend3.neg($x), inputs, null, Negate3);
    }
    const neg = op2({neg_});
    /**
     * @license
     * Copyright 2018 Google LLC. All Rights Reserved.
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     * http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     * =============================================================================
     */
    function softplus_(x) {
      const $x = convertToTensor2(x, "x", "softplus");
      const inputs = {x: $x};
      return ENGINE2.runKernelFunc((backend3, save) => {
        const res = backend3.softplus($x);
        save([$x]);
        return res;
      }, inputs, null, Softplus);
    }
    const softplus = op2({softplus_});
    /**
     * @license
     * Copyright 2018 Google LLC. All Rights Reserved.
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     * http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     * =============================================================================
     */
    function logSigmoid_(x) {
      const $x = convertToTensor2(x, "x", "logSigmoid");
      const customOp = customGrad((x2) => {
        const value = neg(softplus(neg(x2)));
        const gradFunc = (dy) => {
          const derX = mul3(dy, sigmoid2(neg(x2)));
          return derX;
        };
        return {value, gradFunc};
      });
      return customOp($x);
    }
    const logSigmoid = op2({logSigmoid_});
    /**
     * @license
     * Copyright 2020 Google LLC. All Rights Reserved.
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     * http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     * =============================================================================
     */
    function max_(x, axis = null, keepDims = false) {
      const $x = convertToTensor2(x, "x", "max");
      const forward = (backend3, save) => {
        const origAxes = parseAxisParam2(axis, $x.shape);
        let axes = origAxes;
        const permutedAxes = getAxesPermutation2(axes, $x.rank);
        let maxInput = $x;
        if (permutedAxes != null) {
          maxInput = transpose4($x, permutedAxes);
          axes = getInnerMostAxes2(axes.length, maxInput.rank);
        }
        const y = backend3.max(maxInput, axes);
        if (permutedAxes != null) {
          maxInput.dispose();
        }
        let res = y;
        if (keepDims) {
          const expandedShape = expandShapeToKeepDim2(res.shape, parseAxisParam2(axis, $x.shape));
          res = reshape5(res, expandedShape);
          y.dispose();
        }
        save([$x, res]);
        return res;
      };
      const inputs = {x: $x};
      const attrs = {reductionIndices: axis, keepDims};
      return ENGINE2.runKernelFunc(forward, inputs, null, Max3, attrs);
    }
    const max2 = op2({max_});
    /**
     * @license
     * Copyright 2020 Google LLC. All Rights Reserved.
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     * http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     * =============================================================================
     */
    function sub_(a, b) {
      let $a = convertToTensor2(a, "a", "sub");
      let $b = convertToTensor2(b, "b", "sub");
      [$a, $b] = makeTypesMatch2($a, $b);
      const forward = (backend3, save) => {
        const res = backend3.subtract($a, $b);
        save([$a, $b]);
        return res;
      };
      const inputs = {a: $a, b: $b};
      return ENGINE2.runKernelFunc(forward, inputs, null, Sub3);
    }
    const sub = op2({sub_});
    /**
     * @license
     * Copyright 2018 Google LLC. All Rights Reserved.
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     * http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     * =============================================================================
     */
    function sum_2(x, axis = null, keepDims = false) {
      let $x = convertToTensor2(x, "x", "sum");
      if ($x.dtype === "bool") {
        $x = cast7($x, "int32");
      }
      const forward = (backend3, save) => {
        save([$x]);
        const axes = parseAxisParam2(axis, $x.shape);
        const permutation = getAxesPermutation2(axes, $x.rank);
        let reductionAxes = axes;
        let permutedX = $x;
        if (permutation != null) {
          permutedX = transpose4($x, permutation);
          reductionAxes = getInnerMostAxes2(reductionAxes.length, $x.rank);
        }
        let value = backend3.sum(permutedX, reductionAxes);
        if (keepDims) {
          const newShape = expandShapeToKeepDim2(value.shape, axes);
          value = reshape5(value, newShape);
        }
        return value;
      };
      const inputs = {x: $x};
      const attrs = {axis, keepDims};
      return ENGINE2.runKernelFunc(forward, inputs, null, Sum3, attrs);
    }
    const sum$1 = op2({sum_: sum_2});
    /**
     * @license
     * Copyright 2020 Google Inc. All Rights Reserved.
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     * http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     * =============================================================================
     */
    function logSoftmax_(logits, axis = -1) {
      const $logits = convertToTensor2(logits, "logits", "logSoftmax");
      if (axis === -1) {
        axis = $logits.rank - 1;
      }
      if (axis !== $logits.rank - 1) {
        throw Error(`Log Softmax along a non-last dimension is not yet supported. Logits was rank ${$logits.rank} and axis was ${axis}`);
      }
      const forward = (backend3, save) => {
        const keepDims = true;
        const xMax = max2(logits, axis, true);
        const shifted = sub(logits, xMax);
        const value = sub(cast7(shifted, "float32"), log22(sum$1(exp(shifted), axis, keepDims)));
        save([value]);
        return value;
      };
      const inputs = {logits: $logits};
      const attrs = {axis};
      return ENGINE2.runKernelFunc(forward, inputs, null, LogSoftmax, attrs);
    }
    const logSoftmax = op2({logSoftmax_});
    /**
     * @license
     * Copyright 2020 Google LLC. All Rights Reserved.
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     * http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     * =============================================================================
     */
    function logSumExp_(x, axis = null, keepDims = false) {
      const $x = convertToTensor2(x, "x", "logSumExp");
      const axes = parseAxisParam2(axis, $x.shape);
      const xMax = max2($x, axes, true);
      const a = sub($x, xMax);
      const b = exp(a);
      const c = sum$1(b, axes);
      const d = log22(c);
      const res = add$1(reshape5(xMax, d.shape), d);
      if (keepDims) {
        const newShape = expandShapeToKeepDim2(res.shape, axes);
        return reshape5(res, newShape);
      }
      return res;
    }
    const logSumExp = op2({logSumExp_});
    /**
     * @license
     * Copyright 2020 Google LLC. All Rights Reserved.
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     * http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     * =============================================================================
     */
    function logicalAnd_(a, b) {
      const $a = convertToTensor2(a, "a", "logicalAnd", "bool");
      const $b = convertToTensor2(b, "b", "logicalAnd", "bool");
      assertAndGetBroadcastShape2($a.shape, $b.shape);
      const inputs = {a: $a, b: $b};
      return ENGINE2.runKernelFunc((backend3) => backend3.logicalAnd($a, $b), inputs, null, LogicalAnd3);
    }
    const logicalAnd = op2({logicalAnd_});
    /**
     * @license
     * Copyright 2020 Google LLC. All Rights Reserved.
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     * http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     * =============================================================================
     */
    function logicalNot_(x) {
      const $x = convertToTensor2(x, "x", "logicalNot", "bool");
      const inputs = {x: $x};
      return ENGINE2.runKernelFunc((backend3) => backend3.logicalNot($x), inputs, null, LogicalNot);
    }
    const logicalNot = op2({logicalNot_});
    /**
     * @license
     * Copyright 2020 Google LLC. All Rights Reserved.
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     * http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     * =============================================================================
     */
    function logicalOr_(a, b) {
      const $a = convertToTensor2(a, "a", "logicalOr", "bool");
      const $b = convertToTensor2(b, "b", "logicalOr", "bool");
      assertAndGetBroadcastShape2($a.shape, $b.shape);
      const inputs = {a: $a, b: $b};
      return ENGINE2.runKernelFunc((backend3) => backend3.logicalOr($a, $b), inputs, null, LogicalOr);
    }
    const logicalOr = op2({logicalOr_});
    /**
     * @license
     * Copyright 2020 Google LLC. All Rights Reserved.
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     * http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     * =============================================================================
     */
    function logicalXor_(a, b) {
      const $a = convertToTensor2(a, "a", "logicalXor", "bool");
      const $b = convertToTensor2(b, "b", "logicalXor", "bool");
      assertAndGetBroadcastShape2($a.shape, $b.shape);
      return logicalAnd(logicalOr(a, b), logicalNot(logicalAnd(a, b)));
    }
    const logicalXor = op2({logicalXor_});
    /**
     * @license
     * Copyright 2020 Google LLC. All Rights Reserved.
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     * http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     * =============================================================================
     */
    function maxPool_(x, filterSize, strides, pad3, dimRoundingMode) {
      const $x = convertToTensor2(x, "x", "maxPool");
      const dilations = 1;
      let x4D = $x;
      let reshapedTo4D = false;
      if ($x.rank === 3) {
        reshapedTo4D = true;
        x4D = reshape5($x, [1, $x.shape[0], $x.shape[1], $x.shape[2]]);
      }
      assert2(x4D.rank === 4, () => `Error in maxPool: input must be rank 4 but got rank ${x4D.rank}.`);
      assert2(eitherStridesOrDilationsAreOne2(strides, dilations), () => `Error in maxPool: Either strides or dilations must be 1. Got strides ${strides} and dilations '${dilations}'`);
      if (dimRoundingMode != null) {
        assert2(isInt2(pad3), () => `Error in maxPool: pad must be an integer when using, dimRoundingMode ${dimRoundingMode} but got pad ${pad3}.`);
      }
      const forward = (backend3, save) => {
        const convInfo = computePool2DInfo2(x4D.shape, filterSize, strides, 1, pad3, dimRoundingMode);
        let y;
        if (convInfo.filterWidth === 1 && convInfo.filterHeight === 1 && arraysEqual2(convInfo.inShape, convInfo.outShape)) {
          y = x4D.clone();
        } else {
          y = backend3.maxPool(x4D, convInfo);
        }
        save([x4D, y]);
        return y;
      };
      const inputs = {x: x4D};
      const attrs = {filterSize, strides, pad: pad3, dimRoundingMode};
      const res = ENGINE2.runKernelFunc(forward, inputs, null, MaxPool3, attrs);
      if (reshapedTo4D) {
        return reshape5(res, [res.shape[1], res.shape[2], res.shape[3]]);
      }
      return res;
    }
    const maxPool2 = op2({maxPool_});
    /**
     * @license
     * Copyright 2020 Google LLC. All Rights Reserved.
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     * http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     * =============================================================================
     */
    function maxPool3d_(x, filterSize = [1, 1, 1], strides, pad3, dimRoundingMode, dataFormat = "NDHWC", dilations) {
      if (dilations == null) {
        dilations = [1, 1, 1];
      } else {
        deprecationWarn2("dilations is deprecated, this field will be gone in v3.0.0.");
      }
      const $x = convertToTensor2(x, "x", "maxPool3d");
      let x5D = $x;
      let reshapedTo5D = false;
      if ($x.rank === 4) {
        reshapedTo5D = true;
        x5D = reshape5($x, [1, $x.shape[0], $x.shape[1], $x.shape[2], $x.shape[3]]);
      }
      assert2(x5D.rank === 5, () => `Error in maxPool3d: x must be rank 5 but got rank ${x5D.rank}.`);
      assert2(dataFormat === "NDHWC", () => `Error in maxPool3d: Only NDHWC is currently supported, but got dataFormat of ${dataFormat}`);
      assert2(eitherStridesOrDilationsAreOne2(strides, dilations), () => `Error in maxPool3d: Either strides or dilations must be 1. Got strides ${strides} and dilations '${dilations}'`);
      if (dimRoundingMode != null) {
        assert2(isInt2(pad3), () => `Error in maxPool3d: pad must be an integer when using, dimRoundingMode ${dimRoundingMode} but got pad ${pad3}.`);
      }
      const forward = (backend3, save) => {
        if (dilations == null) {
          dilations = [1, 1, 1];
        }
        const convInfo = computePool3DInfo2(x5D.shape, filterSize, strides, dilations, pad3, dimRoundingMode, dataFormat);
        const y = backend3.maxPool3d(x5D, convInfo);
        save([x5D, y]);
        return y;
      };
      const inputs = {x: x5D};
      const attrs = {filterSize, strides, pad: pad3, dimRoundingMode, dataFormat, dilations};
      const res = ENGINE2.runKernelFunc(forward, inputs, null, MaxPool3D, attrs);
      if (reshapedTo5D) {
        return reshape5(res, [res.shape[1], res.shape[2], res.shape[3], res.shape[4]]);
      }
      return res;
    }
    const maxPool3d = op2({maxPool3d_});
    /**
     * @license
     * Copyright 2018 Google LLC. All Rights Reserved.
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     * http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     * =============================================================================
     */
    function maxPoolWithArgmax_(x, filterSize, strides, pad3, includeBatchInIndex = false) {
      const $x = convertToTensor2(x, "x", "maxPoolWithArgmax");
      const inputs = {x: $x};
      const attrs = {filterSize, strides, pad: pad3, includeBatchInIndex};
      const result = ENGINE2.runKernel(MaxPoolWithArgmax, inputs, attrs);
      return {result: result[0], indexes: result[1]};
    }
    const maxPoolWithArgmax = op2({maxPoolWithArgmax_});
    /**
     * @license
     * Copyright 2018 Google LLC. All Rights Reserved.
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     * http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     * =============================================================================
     */
    function zeros3(shape, dtype = "float32") {
      if (dtype === "complex64") {
        const real2 = zeros3(shape, "float32");
        const imag2 = zeros3(shape, "float32");
        return complex3(real2, imag2);
      }
      const values = makeZerosTypedArray2(sizeFromShape2(shape), dtype);
      return ENGINE2.makeTensor(values, shape, dtype);
    }
    /**
     * @license
     * Copyright 2018 Google LLC. All Rights Reserved.
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     * http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     * =============================================================================
     */
    function ones$1(shape, dtype = "float32") {
      if (dtype === "complex64") {
        const real2 = ones$1(shape, "float32");
        const imag2 = zeros3(shape, "float32");
        return complex3(real2, imag2);
      }
      const values = makeOnesTypedArray2(sizeFromShape2(shape), dtype);
      return ENGINE2.makeTensor(values, shape, dtype);
    }
    /**
     * @license
     * Copyright 2020 Google Inc. All Rights Reserved.
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     * http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     * =============================================================================
     */
    function mean_(x, axis = null, keepDims = false) {
      const $x = convertToTensor2(x, "x", "mean");
      const axes = parseAxisParam2(axis, $x.shape);
      const shapes = computeOutAndReduceShapes2($x.shape, axes);
      const reduceShape = shapes[1];
      const reduceSize = sizeFromShape2(reduceShape);
      const inputs = {x: $x};
      const attrs = {axis, keepDims};
      const forward = () => {
        const reduceSizeScalar = scalar3(reduceSize);
        const xReduce = reduceSizeScalar.dtype === $x.dtype ? $x : cast7($x, reduceSizeScalar.dtype);
        const res = div(xReduce, reduceSizeScalar);
        return sum$1(res, axis, keepDims);
      };
      const customOp = customGrad((x2) => {
        const value = ENGINE2.runKernelFunc(forward, inputs, null, Mean, attrs);
        const gradFunc = (dy) => {
          const expandedDyShape = x2.shape.slice();
          axes.forEach((axis2) => {
            expandedDyShape[axis2] = 1;
          });
          const expandedDy = reshape5(dy, expandedDyShape);
          const derX = div(mul3(expandedDy, ones$1(x2.shape, "float32")), reduceSize);
          return derX;
        };
        return {value, gradFunc};
      });
      return customOp($x);
    }
    const mean = op2({mean_});
    function min_(x, axis = null, keepDims = false) {
      const $x = convertToTensor2(x, "x", "min");
      const forward = (backend3, save) => {
        const origAxes = parseAxisParam2(axis, $x.shape);
        let axes = origAxes;
        const permutedAxes = getAxesPermutation2(axes, $x.rank);
        let minInput = $x;
        if (permutedAxes != null) {
          minInput = transpose4($x, permutedAxes);
          axes = getInnerMostAxes2(axes.length, $x.rank);
        }
        const y = backend3.min(minInput, axes);
        if (permutedAxes != null) {
          minInput.dispose();
        }
        let res = y;
        if (keepDims) {
          const expandedShape = expandShapeToKeepDim2(res.shape, origAxes);
          res = reshape5(y, expandedShape);
          y.dispose();
        }
        save([$x, res]);
        return res;
      };
      const inputs = {x: $x};
      const attrs = {axis, keepDims};
      return ENGINE2.runKernelFunc(forward, inputs, null, Min3, attrs);
    }
    const min2 = op2({min_});
    /**
     * @license
     * Copyright 2020 Google LLC. All Rights Reserved.
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     * http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     * =============================================================================
     */
    function minimum_(a, b) {
      let $a = convertToTensor2(a, "a", "minimum");
      let $b = convertToTensor2(b, "b", "minimum");
      [$a, $b] = makeTypesMatch2($a, $b);
      if ($a.dtype === "bool") {
        $a = cast7($a, "int32");
        $b = cast7($b, "int32");
      }
      assertAndGetBroadcastShape2($a.shape, $b.shape);
      const forward = (backend3, save) => {
        const res = backend3.minimum($a, $b);
        save([$a, $b]);
        return res;
      };
      const inputs = {a: $a, b: $b};
      return ENGINE2.runKernelFunc(forward, inputs, null, Minimum3);
    }
    const minimum = op2({minimum_});
    /**
     * @license
     * Copyright 2020 Google LLC. All Rights Reserved.
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     * http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     * =============================================================================
     */
    function mirrorPad_(x, paddings, mode) {
      assert2(mode === "reflect" || mode === "symmetric", () => `Invalid mode. Mode must be either reflect or symmetric. Got ${mode}.`);
      const $x = convertToTensor2(x, "x", "mirrorPad");
      if ($x.rank === 0) {
        throw new Error("mirrorPad(scalar) is not defined. Pass non-scalar to mirrorPad");
      }
      assert2(paddings.length === $x.rank, () => `Padding doesn't match input. Must be ${$x.rank}. Got ${paddings.length}.`);
      const shapeOffset = mode === "reflect" ? 1 : 0;
      for (let i = 0; i < $x.rank; i++) {
        assert2(paddings[i].length === 2, () => `Invalid number of paddings. Must be length of 2 each.`);
        assert2(paddings[i][0] >= 0 && paddings[i][0] <= $x.shape[i] - shapeOffset && paddings[i][1] >= 0 && paddings[i][1] <= $x.shape[i] - shapeOffset, () => `Padding in dimension ${i} cannot be greater than or equal to ${$x.shape[i] - shapeOffset} or less than 0 for input of shape ${$x.shape}`);
      }
      const attrs = {paddings, mode};
      const inputs = {x: $x};
      return ENGINE2.runKernel(MirrorPad, inputs, attrs);
    }
    const mirrorPad = op2({mirrorPad_});
    /**
     * @license
     * Copyright 2020 Google LLC. All Rights Reserved.
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     * http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     * =============================================================================
     */
    function mod_(a, b) {
      let $a = convertToTensor2(a, "a", "mod");
      let $b = convertToTensor2(b, "b", "mod");
      [$a, $b] = makeTypesMatch2($a, $b);
      const forward = (backend3, save) => {
        const res = backend3.mod($a, $b);
        save([$a, $b]);
        return res;
      };
      const inputs = {a: $a, b: $b};
      return ENGINE2.runKernelFunc(forward, inputs, null, Mod);
    }
    const mod = op2({mod_});
    /**
     * @license
     * Copyright 2019 Google LLC. All Rights Reserved.
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     * http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     * =============================================================================
     */
    function square_(x) {
      const $x = convertToTensor2(x, "x", "square");
      const attrs = {};
      const inputsToSave = [$x];
      const outputsToSave = [];
      return ENGINE2.runKernelFunc((backend3, save) => {
        save([$x]);
        return backend3.square($x);
      }, {x: $x}, null, "Square", attrs, inputsToSave, outputsToSave);
    }
    const square = op2({square_});
    /**
     * @license
     * Copyright 2020 Google LLC. All Rights Reserved.
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     * http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     * =============================================================================
     */
    function moments_(x, axis = null, keepDims = false) {
      x = convertToTensor2(x, "x", "moments");
      const axes = parseAxisParam2(axis, x.shape);
      const xMean = mean(x, axes, keepDims);
      let keepDimsShape = xMean.shape;
      if (!keepDims) {
        keepDimsShape = expandShapeToKeepDim2(xMean.shape, axes);
      }
      const devSquared = square(sub(cast7(x, "float32"), reshape5(xMean, keepDimsShape)));
      const variance2 = mean(devSquared, axes, keepDims);
      return {mean: xMean, variance: variance2};
    }
    const moments = op2({moments_});
    function multiRNNCell_(lstmCells, data2, c, h) {
      const $data = convertToTensor2(data2, "data", "multiRNNCell");
      const $c = convertToTensorArray(c, "c", "multiRNNCell");
      const $h = convertToTensorArray(h, "h", "multiRNNCell");
      let input2 = $data;
      const newStates = [];
      for (let i = 0; i < lstmCells.length; i++) {
        const output = lstmCells[i](input2, $c[i], $h[i]);
        newStates.push(output[0]);
        newStates.push(output[1]);
        input2 = output[1];
      }
      const newC = [];
      const newH = [];
      for (let i = 0; i < newStates.length; i += 2) {
        newC.push(newStates[i]);
        newH.push(newStates[i + 1]);
      }
      return [newC, newH];
    }
    const multiRNNCell = op2({multiRNNCell_});
    /**
     * @license
     * Copyright 2020 Google LLC. All Rights Reserved.
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     * http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     * =============================================================================
     */
    function multinomial_(logits, numSamples, seed, normalized = false) {
      const $logits = convertToTensor2(logits, "logits", "multinomial");
      const numOutcomes = $logits.size;
      const origRank = $logits.rank;
      if (numOutcomes < 2) {
        throw new Error(`Error in multinomial: you need at least 2 outcomes, but got ${numOutcomes}.`);
      }
      if (origRank > 2) {
        throw new Error(`Rank of probabilities must be 1 or 2, but is ${origRank}`);
      }
      seed = seed || Math.random();
      const logits2D = origRank === 1 ? reshape5($logits, [1, -1]) : $logits;
      const res = ENGINE2.runKernelFunc((backend3) => backend3.multinomial(logits2D, normalized, numSamples, seed), {logits2D});
      return origRank === 1 ? reshape5(res, [res.size]) : res;
    }
    const multinomial = op2({multinomial_});
    /**
     * @license
     * Copyright 2020 Google LLC. All Rights Reserved.
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     * http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     * =============================================================================
     */
    function notEqual_(a, b) {
      let $a = convertToTensor2(a, "a", "notEqual");
      let $b = convertToTensor2(b, "b", "notEqual");
      [$a, $b] = makeTypesMatch2($a, $b);
      assertAndGetBroadcastShape2($a.shape, $b.shape);
      const forward = (backend3) => backend3.notEqual($a, $b);
      const inputs = {a: $a, b: $b};
      return ENGINE2.runKernelFunc(forward, inputs, null, NotEqual3);
    }
    const notEqual = op2({notEqual_});
    /**
     * @license
     * Copyright 2020 Google LLC. All Rights Reserved.
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     * http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     * =============================================================================
     */
    function real_(input2) {
      const $input = convertToTensor2(input2, "input", "real");
      const forward = (backend3) => {
        return backend3.real($input);
      };
      const inputs = {input: $input};
      return ENGINE2.runKernelFunc(forward, inputs, null, Real);
    }
    const real = op2({real_});
    /**
     * @license
     * Copyright 2018 Google LLC. All Rights Reserved.
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     * http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     * =============================================================================
     */
    function onesLike_(x) {
      const $x = convertToTensor2(x, "x", "onesLike");
      const forward = (backend3, save) => {
        if ($x.dtype === "complex64") {
          const r = onesLike2(real($x));
          const i = zerosLike2(imag($x));
          return complex3(r, i);
        }
        return backend3.onesLike($x);
      };
      const inputs = {x: $x};
      return ENGINE2.runKernelFunc(forward, inputs, null, OnesLike3);
    }
    const onesLike2 = op2({onesLike_});
    function outerProduct_(v1, v2) {
      const $v1 = convertToTensor2(v1, "v1", "outerProduct");
      const $v2 = convertToTensor2(v2, "v2", "outerProduct");
      assert2($v1.rank === 1 && $v2.rank === 1, () => `Error in outerProduct: inputs must be rank 1, but got ranks ${$v1.rank} and ${$v2.rank}.`);
      const v12D = reshape5($v1, [-1, 1]);
      const v22D = reshape5($v2, [1, -1]);
      return matMul(v12D, v22D);
    }
    const outerProduct = op2({outerProduct_});
    /**
     * @license
     * Copyright 2020 Google LLC. All Rights Reserved.
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     * http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     * =============================================================================
     */
    function pad_(x, paddings, constantValue = 0) {
      const $x = convertToTensor2(x, "x", "pad");
      if ($x.rank === 0) {
        throw new Error("pad(scalar) is not defined. Pass non-scalar to pad");
      }
      const forward = (backend3, save) => {
        save([$x]);
        return backend3.pad($x, paddings, constantValue);
      };
      const attrs = {paddings, constantValue};
      const inputs = {x: $x};
      return ENGINE2.runKernelFunc(forward, inputs, null, PadV23, attrs);
    }
    const pad2 = op2({pad_});
    function pad1d_(x, paddings, constantValue = 0) {
      assert2(paddings.length === 2, () => "Invalid number of paddings. Must be length of 2.");
      return pad2(x, [paddings], constantValue);
    }
    const pad1d = op2({pad1d_});
    function pad2d_(x, paddings, constantValue = 0) {
      assert2(paddings.length === 2 && paddings[0].length === 2 && paddings[1].length === 2, () => "Invalid number of paddings. Must be length of 2 each.");
      return pad2(x, paddings, constantValue);
    }
    const pad2d = op2({pad2d_});
    function pad3d_(x, paddings, constantValue = 0) {
      assert2(paddings.length === 3 && paddings[0].length === 2 && paddings[1].length === 2 && paddings[2].length === 2, () => "Invalid number of paddings. Must be length of 2 each.");
      return pad2(x, paddings, constantValue);
    }
    const pad3d = op2({pad3d_});
    function pad4d_(x, paddings, constantValue = 0) {
      assert2(paddings.length === 4 && paddings[0].length === 2 && paddings[1].length === 2 && paddings[2].length === 2 && paddings[3].length === 2, () => "Invalid number of paddings. Must be length of 2 each.");
      return pad2(x, paddings, constantValue);
    }
    const pad4d = op2({pad4d_});
    /**
     * @license
     * Copyright 2020 Google LLC. All Rights Reserved.
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     * http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     * =============================================================================
     */
    function spaceToBatchND_(x, blockShape, paddings) {
      const $x = convertToTensor2(x, "x", "spaceToBatchND");
      assert2($x.rank >= 1 + blockShape.length, () => `input rank ${$x.rank} should be > than [blockShape] ${blockShape.length}`);
      assert2(paddings.length === blockShape.length, () => `paddings.shape[0] ${paddings.length} must be equal to [blockShape] ${blockShape.length}`);
      assert2($x.shape.reduce((a, b, i) => {
        if (i > 0 && i <= blockShape.length) {
          return a && (b + paddings[i - 1][0] + paddings[i - 1][1]) % blockShape[i - 1] === 0;
        }
        return a;
      }, true), () => `input spatial dimensions ${$x.shape.slice(1)} with paddings ${paddings.toString()} must be divisible by blockShapes ${blockShape.toString()}`);
      const forward = (backend3) => backend3.spaceToBatchND($x, blockShape, paddings);
      const inputs = {x: $x};
      const attrs = {blockShape, paddings};
      return ENGINE2.runKernelFunc(forward, inputs, null, SpaceToBatchND, attrs);
    }
    const spaceToBatchND = op2({spaceToBatchND_});
    /**
     * @license
     * Copyright 2018 Google LLC. All Rights Reserved.
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     * http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     * =============================================================================
     */
    function pool_(input2, windowShape, poolingType, pad3, dilations, strides) {
      if (dilations == null) {
        dilations = [1, 1];
      }
      if (strides == null) {
        strides = 1;
      }
      if (pad3 === 0) {
        pad3 = "valid";
      }
      const $x = convertToTensor2(input2, "x", "maxPool");
      let x4D = $x;
      let reshapedTo4D = false;
      if ($x.rank === 3) {
        reshapedTo4D = true;
        x4D = reshape5($x, [1, $x.shape[0], $x.shape[1], $x.shape[2]]);
      }
      assert2(eitherStridesOrDilationsAreOne2(strides, dilations), () => `Error in pool: Either strides or dilations must be 1. Got strides ${strides} and dilations '${dilations}'`);
      const convInfo = computePool2DInfo2(x4D.shape, windowShape, strides, dilations, pad3);
      const dilation = [convInfo.dilationHeight, convInfo.dilationWidth];
      let basePadding;
      if (pad3 === "same") {
        basePadding = withSpaceToBatchBasePaddings([convInfo.filterHeight, convInfo.filterWidth], dilation);
      } else {
        basePadding = [[0, 0], [0, 0]];
      }
      const isDilationOne = dilation[0] === 1 && dilation[1] === 1;
      const [adjustedPadding, adjustedCrops] = requiredSpaceToBatchPaddings([convInfo.inHeight, convInfo.inWidth], dilation, basePadding);
      const convertedPad = isDilationOne ? pad3 : "valid";
      const convertedX = isDilationOne ? x4D : spaceToBatchND(x4D, dilation, adjustedPadding);
      const forwardOp = poolingType === "avg" ? () => avgPool2(convertedX, windowShape, strides, convertedPad) : () => maxPool2(convertedX, windowShape, strides, convertedPad);
      const y = forwardOp();
      const res = isDilationOne ? y : batchToSpaceND(y, dilation, adjustedCrops);
      if (reshapedTo4D) {
        return reshape5(res, [res.shape[1], res.shape[2], res.shape[3]]);
      }
      return res;
    }
    function requiredSpaceToBatchPaddings(inputShape, blockShape, basePadding) {
      const padStart = basePadding.map((b) => b[0]);
      const origPadEnd = basePadding.map((b) => b[1]);
      const fullInputShape = inputShape.concat(padStart, origPadEnd);
      const padEndExtra = blockShape.map((b, i) => (b - fullInputShape[i] % b) % b);
      const padEnd = origPadEnd.map((s, i) => s + padEndExtra[i]);
      const paddings = blockShape.map((_, i) => [padStart[i], padEnd[i]]);
      const crops = blockShape.map((_, i) => [0, padEndExtra[i]]);
      return [paddings, crops];
    }
    function withSpaceToBatchBasePaddings(filterShape, dilation) {
      const dilatedFilterShape = filterShape.map((s, i) => {
        return s + (s - 1) * (dilation[i] - 1);
      });
      const padExtraShape = dilatedFilterShape.map((s) => s - 1);
      const padExtraStart = padExtraShape.map((s) => Math.floor(s / 2));
      const padExtraEnd = padExtraShape.map((s, i) => s - padExtraStart[i]);
      return padExtraShape.map((_, i) => {
        return [padExtraStart[i], padExtraEnd[i]];
      });
    }
    const pool = op2({pool_});
    /**
     * @license
     * Copyright 2020 Google LLC. All Rights Reserved.
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     * http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     * =============================================================================
     */
    function pow_(base2, exp2) {
      let $base = convertToTensor2(base2, "base", "pow");
      let $exp = convertToTensor2(exp2, "exp", "pow");
      [$base, $exp] = makeTypesMatch2($base, $exp);
      const inputs = {a: $base, b: $exp};
      const forward = (backend3, save) => {
        const y = backend3.pow($base, $exp);
        save([$base, $exp, y]);
        return y;
      };
      return ENGINE2.runKernelFunc(forward, inputs, null, Pow3);
    }
    const pow = op2({pow_});
    /**
     * @license
     * Copyright 2020 Google LLC. All Rights Reserved.
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     * http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     * =============================================================================
     */
    function prelu_2(x, alpha) {
      const $x = convertToTensor2(x, "x", "prelu");
      const $alpha = convertToTensor2(alpha, "alpha", "prelu");
      const forward = (backend3, save) => {
        const res = backend3.prelu($x, $alpha);
        save([$x, $alpha]);
        return res;
      };
      const inputs = {x: $x, alpha: $alpha};
      return ENGINE2.runKernelFunc(forward, inputs, null, Prelu3);
    }
    const prelu4 = op2({prelu_: prelu_2});
    /**
     * @license
     * Copyright 2020 Google LLC. All Rights Reserved.
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     * http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     * =============================================================================
     */
    function prod_(x, axis = null, keepDims = false) {
      let $x = convertToTensor2(x, "x", "prod");
      if ($x.dtype === "bool") {
        $x = cast7($x, "int32");
      }
      const forward = (backend3) => {
        const axes = parseAxisParam2(axis, $x.shape);
        const permutation = getAxesPermutation2(axes, $x.rank);
        let reductionAxes = axes;
        let permutedX = $x;
        if (permutation != null) {
          permutedX = transpose4($x, permutation);
          reductionAxes = getInnerMostAxes2(reductionAxes.length, $x.rank);
        }
        let value = backend3.prod(permutedX, reductionAxes);
        if (keepDims) {
          const newShape = expandShapeToKeepDim2(value.shape, axes);
          value = reshape5(value, newShape);
        }
        return value;
      };
      const inputs = {x: $x};
      const attrs = {axis, keepDims};
      return ENGINE2.runKernelFunc(forward, inputs, null, Prod, attrs);
    }
    const prod = op2({prod_});
    /**
     * @license
     * Copyright 2020 Google LLC. All Rights Reserved.
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     * http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     * =============================================================================
     */
    function rand_(shape, randFunction, dtype) {
      const size = sizeFromShape2(shape);
      let values = null;
      if (dtype == null || dtype === "float32") {
        values = new Float32Array(size);
      } else if (dtype === "int32") {
        values = new Int32Array(size);
      } else if (dtype === "bool") {
        values = new Uint8Array(size);
      } else {
        throw new Error(`Unknown data type ${dtype}`);
      }
      for (let i = 0; i < size; i++) {
        values[i] = randFunction();
      }
      return ENGINE2.makeTensor(values, shape, dtype);
    }
    const rand = op2({rand_});
    var commonjsGlobal = typeof globalThis !== "undefined" ? globalThis : typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : {};
    function unwrapExports(x) {
      return x && x.__esModule && Object.prototype.hasOwnProperty.call(x, "default") ? x["default"] : x;
    }
    function createCommonjsModule(fn, module2) {
      return module2 = {exports: {}}, fn(module2, module2.exports), module2.exports;
    }
    function getCjsExportFromNamespace(n) {
      return n && n["default"] || n;
    }
    function commonjsRequire() {
      throw new Error("Dynamic requires are not currently supported by @rollup/plugin-commonjs");
    }
    var alea = createCommonjsModule(function(module2) {
      (function(global2, module3, define2) {
        function Alea(seed) {
          var me = this, mash = Mash();
          me.next = function() {
            var t = 2091639 * me.s0 + me.c * 23283064365386963e-26;
            me.s0 = me.s1;
            me.s1 = me.s2;
            return me.s2 = t - (me.c = t | 0);
          };
          me.c = 1;
          me.s0 = mash(" ");
          me.s1 = mash(" ");
          me.s2 = mash(" ");
          me.s0 -= mash(seed);
          if (me.s0 < 0) {
            me.s0 += 1;
          }
          me.s1 -= mash(seed);
          if (me.s1 < 0) {
            me.s1 += 1;
          }
          me.s2 -= mash(seed);
          if (me.s2 < 0) {
            me.s2 += 1;
          }
          mash = null;
        }
        function copy(f, t) {
          t.c = f.c;
          t.s0 = f.s0;
          t.s1 = f.s1;
          t.s2 = f.s2;
          return t;
        }
        function impl(seed, opts) {
          var xg = new Alea(seed), state = opts && opts.state, prng = xg.next;
          prng.int32 = function() {
            return xg.next() * 4294967296 | 0;
          };
          prng.double = function() {
            return prng() + (prng() * 2097152 | 0) * 11102230246251565e-32;
          };
          prng.quick = prng;
          if (state) {
            if (typeof state == "object")
              copy(state, xg);
            prng.state = function() {
              return copy(xg, {});
            };
          }
          return prng;
        }
        function Mash() {
          var n = 4022871197;
          var mash = function(data2) {
            data2 = data2.toString();
            for (var i = 0; i < data2.length; i++) {
              n += data2.charCodeAt(i);
              var h = 0.02519603282416938 * n;
              n = h >>> 0;
              h -= n;
              h *= n;
              n = h >>> 0;
              h -= n;
              n += h * 4294967296;
            }
            return (n >>> 0) * 23283064365386963e-26;
          };
          return mash;
        }
        if (module3 && module3.exports) {
          module3.exports = impl;
        } else if (define2 && define2.amd) {
          define2(function() {
            return impl;
          });
        } else {
          this.alea = impl;
        }
      })(commonjsGlobal, module2, false);
    });
    var xor128 = createCommonjsModule(function(module2) {
      (function(global2, module3, define2) {
        function XorGen(seed) {
          var me = this, strseed = "";
          me.x = 0;
          me.y = 0;
          me.z = 0;
          me.w = 0;
          me.next = function() {
            var t = me.x ^ me.x << 11;
            me.x = me.y;
            me.y = me.z;
            me.z = me.w;
            return me.w ^= me.w >>> 19 ^ t ^ t >>> 8;
          };
          if (seed === (seed | 0)) {
            me.x = seed;
          } else {
            strseed += seed;
          }
          for (var k = 0; k < strseed.length + 64; k++) {
            me.x ^= strseed.charCodeAt(k) | 0;
            me.next();
          }
        }
        function copy(f, t) {
          t.x = f.x;
          t.y = f.y;
          t.z = f.z;
          t.w = f.w;
          return t;
        }
        function impl(seed, opts) {
          var xg = new XorGen(seed), state = opts && opts.state, prng = function() {
            return (xg.next() >>> 0) / 4294967296;
          };
          prng.double = function() {
            do {
              var top = xg.next() >>> 11, bot = (xg.next() >>> 0) / 4294967296, result = (top + bot) / (1 << 21);
            } while (result === 0);
            return result;
          };
          prng.int32 = xg.next;
          prng.quick = prng;
          if (state) {
            if (typeof state == "object")
              copy(state, xg);
            prng.state = function() {
              return copy(xg, {});
            };
          }
          return prng;
        }
        if (module3 && module3.exports) {
          module3.exports = impl;
        } else if (define2 && define2.amd) {
          define2(function() {
            return impl;
          });
        } else {
          this.xor128 = impl;
        }
      })(commonjsGlobal, module2, false);
    });
    var xorwow = createCommonjsModule(function(module2) {
      (function(global2, module3, define2) {
        function XorGen(seed) {
          var me = this, strseed = "";
          me.next = function() {
            var t = me.x ^ me.x >>> 2;
            me.x = me.y;
            me.y = me.z;
            me.z = me.w;
            me.w = me.v;
            return (me.d = me.d + 362437 | 0) + (me.v = me.v ^ me.v << 4 ^ (t ^ t << 1)) | 0;
          };
          me.x = 0;
          me.y = 0;
          me.z = 0;
          me.w = 0;
          me.v = 0;
          if (seed === (seed | 0)) {
            me.x = seed;
          } else {
            strseed += seed;
          }
          for (var k = 0; k < strseed.length + 64; k++) {
            me.x ^= strseed.charCodeAt(k) | 0;
            if (k == strseed.length) {
              me.d = me.x << 10 ^ me.x >>> 4;
            }
            me.next();
          }
        }
        function copy(f, t) {
          t.x = f.x;
          t.y = f.y;
          t.z = f.z;
          t.w = f.w;
          t.v = f.v;
          t.d = f.d;
          return t;
        }
        function impl(seed, opts) {
          var xg = new XorGen(seed), state = opts && opts.state, prng = function() {
            return (xg.next() >>> 0) / 4294967296;
          };
          prng.double = function() {
            do {
              var top = xg.next() >>> 11, bot = (xg.next() >>> 0) / 4294967296, result = (top + bot) / (1 << 21);
            } while (result === 0);
            return result;
          };
          prng.int32 = xg.next;
          prng.quick = prng;
          if (state) {
            if (typeof state == "object")
              copy(state, xg);
            prng.state = function() {
              return copy(xg, {});
            };
          }
          return prng;
        }
        if (module3 && module3.exports) {
          module3.exports = impl;
        } else if (define2 && define2.amd) {
          define2(function() {
            return impl;
          });
        } else {
          this.xorwow = impl;
        }
      })(commonjsGlobal, module2, false);
    });
    var xorshift7 = createCommonjsModule(function(module2) {
      (function(global2, module3, define2) {
        function XorGen(seed) {
          var me = this;
          me.next = function() {
            var X = me.x, i = me.i, t, v, w;
            t = X[i];
            t ^= t >>> 7;
            v = t ^ t << 24;
            t = X[i + 1 & 7];
            v ^= t ^ t >>> 10;
            t = X[i + 3 & 7];
            v ^= t ^ t >>> 3;
            t = X[i + 4 & 7];
            v ^= t ^ t << 7;
            t = X[i + 7 & 7];
            t = t ^ t << 13;
            v ^= t ^ t << 9;
            X[i] = v;
            me.i = i + 1 & 7;
            return v;
          };
          function init2(me2, seed2) {
            var j, w, X = [];
            if (seed2 === (seed2 | 0)) {
              w = X[0] = seed2;
            } else {
              seed2 = "" + seed2;
              for (j = 0; j < seed2.length; ++j) {
                X[j & 7] = X[j & 7] << 15 ^ seed2.charCodeAt(j) + X[j + 1 & 7] << 13;
              }
            }
            while (X.length < 8)
              X.push(0);
            for (j = 0; j < 8 && X[j] === 0; ++j)
              ;
            if (j == 8)
              w = X[7] = -1;
            else
              w = X[j];
            me2.x = X;
            me2.i = 0;
            for (j = 256; j > 0; --j) {
              me2.next();
            }
          }
          init2(me, seed);
        }
        function copy(f, t) {
          t.x = f.x.slice();
          t.i = f.i;
          return t;
        }
        function impl(seed, opts) {
          if (seed == null)
            seed = +new Date();
          var xg = new XorGen(seed), state = opts && opts.state, prng = function() {
            return (xg.next() >>> 0) / 4294967296;
          };
          prng.double = function() {
            do {
              var top = xg.next() >>> 11, bot = (xg.next() >>> 0) / 4294967296, result = (top + bot) / (1 << 21);
            } while (result === 0);
            return result;
          };
          prng.int32 = xg.next;
          prng.quick = prng;
          if (state) {
            if (state.x)
              copy(state, xg);
            prng.state = function() {
              return copy(xg, {});
            };
          }
          return prng;
        }
        if (module3 && module3.exports) {
          module3.exports = impl;
        } else if (define2 && define2.amd) {
          define2(function() {
            return impl;
          });
        } else {
          this.xorshift7 = impl;
        }
      })(commonjsGlobal, module2, false);
    });
    var xor4096 = createCommonjsModule(function(module2) {
      (function(global2, module3, define2) {
        function XorGen(seed) {
          var me = this;
          me.next = function() {
            var w = me.w, X = me.X, i = me.i, t, v;
            me.w = w = w + 1640531527 | 0;
            v = X[i + 34 & 127];
            t = X[i = i + 1 & 127];
            v ^= v << 13;
            t ^= t << 17;
            v ^= v >>> 15;
            t ^= t >>> 12;
            v = X[i] = v ^ t;
            me.i = i;
            return v + (w ^ w >>> 16) | 0;
          };
          function init2(me2, seed2) {
            var t, v, i, j, w, X = [], limit = 128;
            if (seed2 === (seed2 | 0)) {
              v = seed2;
              seed2 = null;
            } else {
              seed2 = seed2 + "\0";
              v = 0;
              limit = Math.max(limit, seed2.length);
            }
            for (i = 0, j = -32; j < limit; ++j) {
              if (seed2)
                v ^= seed2.charCodeAt((j + 32) % seed2.length);
              if (j === 0)
                w = v;
              v ^= v << 10;
              v ^= v >>> 15;
              v ^= v << 4;
              v ^= v >>> 13;
              if (j >= 0) {
                w = w + 1640531527 | 0;
                t = X[j & 127] ^= v + w;
                i = t == 0 ? i + 1 : 0;
              }
            }
            if (i >= 128) {
              X[(seed2 && seed2.length || 0) & 127] = -1;
            }
            i = 127;
            for (j = 4 * 128; j > 0; --j) {
              v = X[i + 34 & 127];
              t = X[i = i + 1 & 127];
              v ^= v << 13;
              t ^= t << 17;
              v ^= v >>> 15;
              t ^= t >>> 12;
              X[i] = v ^ t;
            }
            me2.w = w;
            me2.X = X;
            me2.i = i;
          }
          init2(me, seed);
        }
        function copy(f, t) {
          t.i = f.i;
          t.w = f.w;
          t.X = f.X.slice();
          return t;
        }
        ;
        function impl(seed, opts) {
          if (seed == null)
            seed = +new Date();
          var xg = new XorGen(seed), state = opts && opts.state, prng = function() {
            return (xg.next() >>> 0) / 4294967296;
          };
          prng.double = function() {
            do {
              var top = xg.next() >>> 11, bot = (xg.next() >>> 0) / 4294967296, result = (top + bot) / (1 << 21);
            } while (result === 0);
            return result;
          };
          prng.int32 = xg.next;
          prng.quick = prng;
          if (state) {
            if (state.X)
              copy(state, xg);
            prng.state = function() {
              return copy(xg, {});
            };
          }
          return prng;
        }
        if (module3 && module3.exports) {
          module3.exports = impl;
        } else if (define2 && define2.amd) {
          define2(function() {
            return impl;
          });
        } else {
          this.xor4096 = impl;
        }
      })(commonjsGlobal, module2, false);
    });
    var tychei = createCommonjsModule(function(module2) {
      (function(global2, module3, define2) {
        function XorGen(seed) {
          var me = this, strseed = "";
          me.next = function() {
            var b = me.b, c = me.c, d = me.d, a = me.a;
            b = b << 25 ^ b >>> 7 ^ c;
            c = c - d | 0;
            d = d << 24 ^ d >>> 8 ^ a;
            a = a - b | 0;
            me.b = b = b << 20 ^ b >>> 12 ^ c;
            me.c = c = c - d | 0;
            me.d = d << 16 ^ c >>> 16 ^ a;
            return me.a = a - b | 0;
          };
          me.a = 0;
          me.b = 0;
          me.c = 2654435769 | 0;
          me.d = 1367130551;
          if (seed === Math.floor(seed)) {
            me.a = seed / 4294967296 | 0;
            me.b = seed | 0;
          } else {
            strseed += seed;
          }
          for (var k = 0; k < strseed.length + 20; k++) {
            me.b ^= strseed.charCodeAt(k) | 0;
            me.next();
          }
        }
        function copy(f, t) {
          t.a = f.a;
          t.b = f.b;
          t.c = f.c;
          t.d = f.d;
          return t;
        }
        ;
        function impl(seed, opts) {
          var xg = new XorGen(seed), state = opts && opts.state, prng = function() {
            return (xg.next() >>> 0) / 4294967296;
          };
          prng.double = function() {
            do {
              var top = xg.next() >>> 11, bot = (xg.next() >>> 0) / 4294967296, result = (top + bot) / (1 << 21);
            } while (result === 0);
            return result;
          };
          prng.int32 = xg.next;
          prng.quick = prng;
          if (state) {
            if (typeof state == "object")
              copy(state, xg);
            prng.state = function() {
              return copy(xg, {});
            };
          }
          return prng;
        }
        if (module3 && module3.exports) {
          module3.exports = impl;
        } else if (define2 && define2.amd) {
          define2(function() {
            return impl;
          });
        } else {
          this.tychei = impl;
        }
      })(commonjsGlobal, module2, false);
    });
    var seedrandom = createCommonjsModule(function(module2) {
      (function(pool2, math2) {
        var global2 = this, width = 256, chunks = 6, digits = 52, rngname = "random", startdenom = math2.pow(width, chunks), significance = math2.pow(2, digits), overflow = significance * 2, mask = width - 1, nodecrypto;
        function seedrandom2(seed, options, callback) {
          var key = [];
          options = options == true ? {entropy: true} : options || {};
          var shortseed = mixkey(flatten3(options.entropy ? [seed, tostring(pool2)] : seed == null ? autoseed() : seed, 3), key);
          var arc4 = new ARC4(key);
          var prng = function() {
            var n = arc4.g(chunks), d = startdenom, x = 0;
            while (n < significance) {
              n = (n + x) * width;
              d *= width;
              x = arc4.g(1);
            }
            while (n >= overflow) {
              n /= 2;
              d /= 2;
              x >>>= 1;
            }
            return (n + x) / d;
          };
          prng.int32 = function() {
            return arc4.g(4) | 0;
          };
          prng.quick = function() {
            return arc4.g(4) / 4294967296;
          };
          prng.double = prng;
          mixkey(tostring(arc4.S), pool2);
          return (options.pass || callback || function(prng2, seed2, is_math_call, state) {
            if (state) {
              if (state.S) {
                copy(state, arc4);
              }
              prng2.state = function() {
                return copy(arc4, {});
              };
            }
            if (is_math_call) {
              math2[rngname] = prng2;
              return seed2;
            } else
              return prng2;
          })(prng, shortseed, "global" in options ? options.global : this == math2, options.state);
        }
        math2["seed" + rngname] = seedrandom2;
        function ARC4(key) {
          var t, keylen = key.length, me = this, i = 0, j = me.i = me.j = 0, s = me.S = [];
          if (!keylen) {
            key = [keylen++];
          }
          while (i < width) {
            s[i] = i++;
          }
          for (i = 0; i < width; i++) {
            s[i] = s[j = mask & j + key[i % keylen] + (t = s[i])];
            s[j] = t;
          }
          (me.g = function(count2) {
            var t2, r = 0, i2 = me.i, j2 = me.j, s2 = me.S;
            while (count2--) {
              t2 = s2[i2 = mask & i2 + 1];
              r = r * width + s2[mask & (s2[i2] = s2[j2 = mask & j2 + t2]) + (s2[j2] = t2)];
            }
            me.i = i2;
            me.j = j2;
            return r;
          })(width);
        }
        function copy(f, t) {
          t.i = f.i;
          t.j = f.j;
          t.S = f.S.slice();
          return t;
        }
        ;
        function flatten3(obj, depth) {
          var result = [], typ = typeof obj, prop;
          if (depth && typ == "object") {
            for (prop in obj) {
              try {
                result.push(flatten3(obj[prop], depth - 1));
              } catch (e) {
              }
            }
          }
          return result.length ? result : typ == "string" ? obj : obj + "\0";
        }
        function mixkey(seed, key) {
          var stringseed = seed + "", smear, j = 0;
          while (j < stringseed.length) {
            key[mask & j] = mask & (smear ^= key[mask & j] * 19) + stringseed.charCodeAt(j++);
          }
          return tostring(key);
        }
        function autoseed() {
          try {
            var out;
            if (nodecrypto && (out = nodecrypto.randomBytes)) {
              out = out(width);
            } else {
              out = new Uint8Array(width);
              (global2.crypto || global2.msCrypto).getRandomValues(out);
            }
            return tostring(out);
          } catch (e) {
            var browser2 = global2.navigator, plugins = browser2 && browser2.plugins;
            return [+new Date(), global2, plugins, global2.screen, tostring(pool2)];
          }
        }
        function tostring(a) {
          return String.fromCharCode.apply(0, a);
        }
        mixkey(math2.random(), pool2);
        if (module2.exports) {
          module2.exports = seedrandom2;
          try {
            nodecrypto = require("crypto");
          } catch (ex) {
          }
        } else if (false) {
          (void 0)(function() {
            return seedrandom2;
          });
        }
      })([], Math);
    });
    seedrandom.alea = alea;
    seedrandom.xor128 = xor128;
    seedrandom.xorwow = xorwow;
    seedrandom.xorshift7 = xorshift7;
    seedrandom.xor4096 = xor4096;
    seedrandom.tychei = tychei;
    var seedrandom$1 = seedrandom;
    var seedrandom_1 = seedrandom$1.alea;
    /**
     * @license
     * Copyright 2018 Google LLC. All Rights Reserved.
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     * http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     * =============================================================================
     */
    class MPRandGauss {
      constructor(mean2, stdDeviation, dtype, truncated, seed) {
        this.mean = mean2;
        this.stdDev = stdDeviation;
        this.dtype = dtype;
        this.nextVal = NaN;
        this.truncated = truncated;
        if (this.truncated) {
          this.upper = this.mean + this.stdDev * 2;
          this.lower = this.mean - this.stdDev * 2;
        }
        const seedValue = seed ? seed : Math.random();
        this.random = seedrandom_1(seedValue.toString());
      }
      nextValue() {
        if (!isNaN(this.nextVal)) {
          const value = this.nextVal;
          this.nextVal = NaN;
          return value;
        }
        let resultX, resultY;
        let isValid = false;
        while (!isValid) {
          let v1, v2, s;
          do {
            v1 = 2 * this.random() - 1;
            v2 = 2 * this.random() - 1;
            s = v1 * v1 + v2 * v2;
          } while (s >= 1 || s === 0);
          const mul4 = Math.sqrt(-2 * Math.log(s) / s);
          resultX = this.mean + this.stdDev * v1 * mul4;
          resultY = this.mean + this.stdDev * v2 * mul4;
          if (!this.truncated || this.isValidTruncated(resultX)) {
            isValid = true;
          }
        }
        if (!this.truncated || this.isValidTruncated(resultY)) {
          this.nextVal = this.convertValue(resultY);
        }
        return this.convertValue(resultX);
      }
      convertValue(value) {
        if (this.dtype == null || this.dtype === "float32") {
          return value;
        }
        return Math.round(value);
      }
      isValidTruncated(value) {
        return value <= this.upper && value >= this.lower;
      }
    }
    class RandGamma {
      constructor(alpha, beta, dtype, seed) {
        this.alpha = alpha;
        this.beta = 1 / beta;
        this.dtype = dtype;
        const seedValue = seed ? seed : Math.random();
        this.randu = seedrandom_1(seedValue.toString());
        this.randn = new MPRandGauss(0, 1, dtype, false, this.randu());
        if (alpha < 1) {
          this.d = alpha + 2 / 3;
        } else {
          this.d = alpha - 1 / 3;
        }
        this.c = 1 / Math.sqrt(9 * this.d);
      }
      nextValue() {
        let x2, v0, v1, x, u, v;
        while (true) {
          do {
            x = this.randn.nextValue();
            v = 1 + this.c * x;
          } while (v <= 0);
          v *= v * v;
          x2 = x * x;
          v0 = 1 - 0.331 * x2 * x2;
          v1 = 0.5 * x2 + this.d * (1 - v + Math.log(v));
          u = this.randu();
          if (u < v0 || Math.log(u) < v1) {
            break;
          }
        }
        v = 1 / this.beta * this.d * v;
        if (this.alpha < 1) {
          v *= Math.pow(this.randu(), 1 / this.alpha);
        }
        return this.convertValue(v);
      }
      convertValue(value) {
        if (this.dtype === "float32") {
          return value;
        }
        return Math.round(value);
      }
    }
    class UniformRandom {
      constructor(min3 = 0, max3 = 1, dtype, seed) {
        this.canReturnFloat = () => this.dtype == null || this.dtype === "float32";
        this.min = min3;
        this.range = max3 - min3;
        this.dtype = dtype;
        if (seed == null) {
          seed = Math.random();
        }
        if (typeof seed === "number") {
          seed = seed.toString();
        }
        if (!this.canReturnFloat() && this.range <= 1) {
          throw new Error(`The difference between ${min3} - ${max3} <= 1 and dtype is not float`);
        }
        this.random = seedrandom_1(seed);
      }
      convertValue(value) {
        if (this.canReturnFloat()) {
          return value;
        }
        return Math.round(value);
      }
      nextValue() {
        return this.convertValue(this.min + this.range * this.random());
      }
    }
    function jarqueBeraNormalityTest(values) {
      const n = values.length;
      const s = skewness(values);
      const k = kurtosis(values);
      const jb = n / 6 * (Math.pow(s, 2) + 0.25 * Math.pow(k - 3, 2));
      const CHI_SQUARE_2DEG = 5.991;
      if (jb > CHI_SQUARE_2DEG) {
        throw new Error(`Invalid p-value for JB: ${jb}`);
      }
    }
    function expectArrayInMeanStdRange(actual, expectedMean, expectedStdDev, epsilon2) {
      if (epsilon2 == null) {
        epsilon2 = testEpsilon();
      }
      const actualMean = mean$1(actual);
      expectNumbersClose(actualMean, expectedMean, epsilon2);
      expectNumbersClose(standardDeviation(actual, actualMean), expectedStdDev, epsilon2);
    }
    function mean$1(values) {
      let sum6 = 0;
      for (let i = 0; i < values.length; i++) {
        sum6 += values[i];
      }
      return sum6 / values.length;
    }
    function standardDeviation(values, mean2) {
      let squareDiffSum = 0;
      for (let i = 0; i < values.length; i++) {
        const diff = values[i] - mean2;
        squareDiffSum += diff * diff;
      }
      return Math.sqrt(squareDiffSum / values.length);
    }
    function kurtosis(values) {
      const valuesMean = mean$1(values);
      const n = values.length;
      let sum22 = 0;
      let sum42 = 0;
      for (let i = 0; i < n; i++) {
        const v = values[i] - valuesMean;
        sum22 += Math.pow(v, 2);
        sum42 += Math.pow(v, 4);
      }
      return 1 / n * sum42 / Math.pow(1 / n * sum22, 2);
    }
    function skewness(values) {
      const valuesMean = mean$1(values);
      const n = values.length;
      let sum22 = 0;
      let sum32 = 0;
      for (let i = 0; i < n; i++) {
        const v = values[i] - valuesMean;
        sum22 += Math.pow(v, 2);
        sum32 += Math.pow(v, 3);
      }
      return 1 / n * sum32 / Math.pow(1 / (n - 1) * sum22, 3 / 2);
    }
    /**
     * @license
     * Copyright 2020 Google LLC. All Rights Reserved.
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     * http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     * =============================================================================
     */
    function randomGamma_(shape, alpha, beta = 1, dtype = "float32", seed) {
      if (beta == null) {
        beta = 1;
      }
      if (dtype == null) {
        dtype = "float32";
      }
      if (dtype !== "float32" && dtype !== "int32") {
        throw new Error(`Unsupported data type ${dtype}`);
      }
      const rgamma = new RandGamma(alpha, beta, dtype, seed);
      const res = buffer2(shape, dtype);
      for (let i = 0; i < res.values.length; i++) {
        res.values[i] = rgamma.nextValue();
      }
      return res.toTensor();
    }
    const randomGamma = op2({randomGamma_});
    /**
     * @license
     * Copyright 2020 Google LLC. All Rights Reserved.
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     * http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     * =============================================================================
     */
    function randomNormal_(shape, mean2 = 0, stdDev = 1, dtype, seed) {
      if (dtype != null && dtype === "bool") {
        throw new Error(`Unsupported data type ${dtype}`);
      }
      const randGauss = new MPRandGauss(mean2, stdDev, dtype, false, seed);
      const res = buffer2(shape, dtype);
      for (let i = 0; i < res.values.length; i++) {
        res.values[i] = randGauss.nextValue();
      }
      return res.toTensor();
    }
    const randomNormal = op2({randomNormal_});
    /**
     * @license
     * Copyright 2020 Google LLC. All Rights Reserved.
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     * http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     * =============================================================================
     */
    function randomUniform_(shape, minval = 0, maxval = 1, dtype = "float32", seed) {
      const res = buffer2(shape, dtype);
      const random = new UniformRandom(minval, maxval, null, seed);
      for (let i = 0; i < res.values.length; i++) {
        res.values[i] = random.nextValue();
      }
      return res.toTensor();
    }
    const randomUniform = op2({randomUniform_});
    /**
     * @license
     * Copyright 2018 Google LLC. All Rights Reserved.
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     * http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     * =============================================================================
     */
    function tensor1d3(values, dtype) {
      assertNonNull2(values);
      const inferredShape = inferShape2(values, dtype);
      if (inferredShape.length !== 1) {
        throw new Error("tensor1d() requires values to be a flat/TypedArray");
      }
      const shape = null;
      return makeTensor2(values, shape, inferredShape, dtype);
    }
    /**
     * @license
     * Copyright 2018 Google LLC. All Rights Reserved.
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     * http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     * =============================================================================
     */
    function range(start, stop, step4 = 1, dtype = "float32") {
      if (step4 === 0) {
        throw new Error("Cannot have a step of zero");
      }
      const forward = () => {
        const sameStartStop = start === stop;
        const increasingRangeNegativeStep = start < stop && step4 < 0;
        const decreasingRangePositiveStep = stop < start && step4 > 1;
        if (sameStartStop || increasingRangeNegativeStep || decreasingRangePositiveStep) {
          return zeros3([0], dtype);
        }
        const numElements = Math.abs(Math.ceil((stop - start) / step4));
        const values = makeZerosTypedArray2(numElements, dtype);
        if (stop < start && step4 === 1) {
          step4 = -1;
        }
        values[0] = start;
        for (let i = 1; i < values.length; i++) {
          values[i] = values[i - 1] + step4;
        }
        return tensor1d3(values, dtype);
      };
      const attrs = {start, stop, step: step4, dtype};
      return ENGINE2.runKernelFunc(forward, {}, null, Range, attrs);
    }
    /**
     * @license
     * Copyright 2018 Google LLC. All Rights Reserved.
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     * http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     * =============================================================================
     */
    function reciprocal_(x) {
      const $x = convertToTensor2(x, "x", "reciprocal");
      const inputs = {x: $x};
      return ENGINE2.runKernelFunc((backend3, save) => {
        const res = backend3.reciprocal($x);
        save([$x]);
        return res;
      }, inputs, null, Reciprocal);
    }
    const reciprocal = op2({reciprocal_});
    /**
     * @license
     * Copyright 2020 Google LLC. All Rights Reserved.
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     * http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     * =============================================================================
     */
    function relu_2(x) {
      const $x = convertToTensor2(x, "x", "relu");
      const forward = (backend3, save) => {
        save([$x]);
        if ($x.dtype === "bool") {
          return cast7($x, "int32");
        }
        return backend3.relu($x);
      };
      const inputs = {x: $x};
      return ENGINE2.runKernelFunc(forward, inputs, null, Relu3);
    }
    const relu3 = op2({relu_: relu_2});
    /**
     * @license
     * Copyright 2020 Google LLC. All Rights Reserved.
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     * http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     * =============================================================================
     */
    function relu6_2(x) {
      const $x = convertToTensor2(x, "x", "relu6");
      const forward = (backend3, save) => {
        save([$x]);
        if ($x.dtype === "bool") {
          return cast7($x, "int32");
        }
        return backend3.relu6($x);
      };
      const inputs = {x: $x};
      return ENGINE2.runKernelFunc(forward, inputs, null, Relu63);
    }
    const relu63 = op2({relu6_: relu6_2});
    /**
     * @license
     * Copyright 2018 Google LLC. All Rights Reserved.
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     * http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     * =============================================================================
     */
    function reverse_(x, axis) {
      const $x = convertToTensor2(x, "x", "reverse");
      const forward = (backend3) => {
        const axes = parseAxisParam2(axis, $x.shape);
        if ($x.rank === 0) {
          return clone($x);
        }
        const res = backend3.reverse($x, axes);
        return reshape5(res, $x.shape);
      };
      const inputs = {x: $x};
      const attrs = {dims: axis};
      return ENGINE2.runKernelFunc(forward, inputs, null, Reverse3, attrs);
    }
    const reverse2 = op2({reverse_});
    /**
     * @license
     * Copyright 2020 Google LLC. All Rights Reserved.
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     * http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     * =============================================================================
     */
    function reverse1d_(x) {
      const $x = convertToTensor2(x, "x", "reverse");
      assert2($x.rank === 1, () => `Error in reverse1D: x must be rank 1 but got rank ${$x.rank}.`);
      return reverse2($x, 0);
    }
    const reverse1d = op2({reverse1d_});
    /**
     * @license
     * Copyright 2020 Google LLC. All Rights Reserved.
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     * http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     * =============================================================================
     */
    function reverse2d_(x, axis) {
      const $x = convertToTensor2(x, "x", "reverse");
      assert2($x.rank === 2, () => `Error in reverse2D: x must be rank 2 but got rank ${$x.rank}.`);
      return reverse2($x, axis);
    }
    const reverse2d = op2({reverse2d_});
    /**
     * @license
     * Copyright 2020 Google LLC. All Rights Reserved.
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     * http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     * =============================================================================
     */
    function reverse3d_(x, axis) {
      const $x = convertToTensor2(x, "x", "reverse");
      assert2($x.rank === 3, () => `Error in reverse3D: x must be rank 3 but got rank ${$x.rank}.`);
      return reverse2($x, axis);
    }
    const reverse3d = op2({reverse3d_});
    /**
     * @license
     * Copyright 2020 Google LLC. All Rights Reserved.
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     * http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     * =============================================================================
     */
    function reverse4d_(x, axis) {
      const $x = convertToTensor2(x, "x", "reverse");
      assert2($x.rank === 4, () => `Error in reverse4D: x must be rank 4 but got rank ${$x.rank}.`);
      return reverse2($x, axis);
    }
    const reverse4d = op2({reverse4d_});
    /**
     * @license
     * Copyright 2018 Google LLC. All Rights Reserved.
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     * http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     * =============================================================================
     */
    function round_(x) {
      const $x = convertToTensor2(x, "x", "round");
      const inputs = {x: $x};
      return ENGINE2.runKernelFunc((backend3) => backend3.round($x), inputs, null, Round);
    }
    const round = op2({round_});
    /**
     * @license
     * Copyright 2018 Google LLC. All Rights Reserved.
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     * http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     * =============================================================================
     */
    function rsqrt_(x) {
      const $x = convertToTensor2(x, "x", "rsqrt");
      const inputs = {x: $x};
      return ENGINE2.runKernelFunc((backend3, save) => {
        const res = backend3.rsqrt($x);
        save([$x]);
        return res;
      }, inputs, null, Rsqrt3);
    }
    const rsqrt = op2({rsqrt_});
    /**
     * @license
     * Copyright 2020 Google LLC. All Rights Reserved.
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     * http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     * =============================================================================
     */
    function selu_(x) {
      const $x = convertToTensor2(x, "x", "selu");
      const forward = (backend3, save) => {
        const res = backend3.selu($x);
        save([$x]);
        return res;
      };
      const inputs = {x: $x};
      return ENGINE2.runKernelFunc(forward, inputs, null, Selu);
    }
    const selu = op2({selu_});
    function separableConv2d_(x, depthwiseFilter, pointwiseFilter, strides, pad3, dilation = [1, 1], dataFormat = "NHWC") {
      const $x = convertToTensor2(x, "x", "separableConv2d");
      const $depthwiseFilter = convertToTensor2(depthwiseFilter, "depthwiseFilter", "separableConv2d");
      const $pointwiseFilter = convertToTensor2(pointwiseFilter, "pointwiseFilter", "separableConv2d");
      let x4D = $x;
      let reshapedTo4D = false;
      if ($x.rank === 3) {
        reshapedTo4D = true;
        x4D = reshape5($x, [1, $x.shape[0], $x.shape[1], $x.shape[2]]);
      }
      if (dataFormat === "NCHW") {
        throw new Error("separableConv2d currently does not support dataFormat NCHW; only NHWC is supported");
      }
      assert2(x4D.rank === 4, () => `Error in separableConv2d: input must be rank 4, but got rank ${x4D.rank}.`);
      assert2($depthwiseFilter.rank === 4, () => `Error in separableConv2d: depthwise filter must be rank 4, but got rank ${$depthwiseFilter.rank}.`);
      assert2($pointwiseFilter.rank === 4, () => `Error in separableConv2d: pointwise filter must be rank 4, but got rank ${$depthwiseFilter.rank}.`);
      assert2($pointwiseFilter.shape[0] === 1, () => `Error in separableConv2d: the first dimension of pointwise filter  must be 1, but got ${$pointwiseFilter.shape[0]}.`);
      assert2($pointwiseFilter.shape[1] === 1, () => `Error in separableConv2d: the second dimension of pointwise filter must be 1, but got ${$pointwiseFilter.shape[1]}.`);
      const inChannels = $depthwiseFilter.shape[2];
      const channelMultiplier = $depthwiseFilter.shape[3];
      assert2($pointwiseFilter.shape[2] === inChannels * channelMultiplier, () => `Error in separableConv2d: the third dimension of pointwise filter must be ${inChannels * channelMultiplier}, but got ${$pointwiseFilter.shape[2]}.`);
      const depthwise = depthwiseConv2d2(x4D, $depthwiseFilter, strides, pad3, dataFormat, dilation);
      const pointwiseStride = 1;
      const res = conv2d2(depthwise, $pointwiseFilter, pointwiseStride, "valid", dataFormat);
      if (reshapedTo4D) {
        return reshape5(res, [res.shape[1], res.shape[2], res.shape[3]]);
      }
      return res;
    }
    const separableConv2d = op2({separableConv2d_});
    /**
     * @license
     * Copyright 2020 Google Inc. All Rights Reserved.
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     * http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     * =============================================================================
     */
    async function setdiff1dAsync_(x, y) {
      const $x = convertToTensor2(x, "x", "setdiff1d");
      const $y = convertToTensor2(y, "y", "setdiff1d");
      assert2($x.dtype === $y.dtype, () => `x and y should have the same dtype, but got x (${$x.dtype}) and y (${$y.dtype}).`);
      assert2($x.rank === 1, () => `x should be 1D tensor, but got x (${$x.shape}).`);
      assert2($y.rank === 1, () => `y should be 1D tensor, but got y (${$y.shape}).`);
      const xVals = await $x.data();
      const yVals = await $y.data();
      const ySet = new Set(yVals);
      let outputSize = 0;
      for (let i = 0; i < xVals.length; i++) {
        if (!ySet.has(xVals[i])) {
          outputSize++;
        }
      }
      const buffer3 = new TensorBuffer2([outputSize], $x.dtype);
      const indices = new TensorBuffer2([outputSize], "int32");
      for (let i = 0, p2 = 0; i < xVals.length; i++) {
        if (!ySet.has(xVals[i])) {
          buffer3.values[p2] = xVals[i];
          indices.values[p2] = i;
          p2++;
        }
      }
      return [buffer3.toTensor(), indices.toTensor()];
    }
    const setdiff1dAsync = setdiff1dAsync_;
    /**
     * @license
     * Copyright 2018 Google LLC. All Rights Reserved.
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     * http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     * =============================================================================
     */
    function sign_(x) {
      const $x = convertToTensor2(x, "x", "sign");
      const inputs = {x: $x};
      return ENGINE2.runKernelFunc((backend3) => backend3.sign($x), inputs, null, Sign);
    }
    const sign = op2({sign_});
    /**
     * @license
     * Copyright 2018 Google LLC. All Rights Reserved.
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     * http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     * =============================================================================
     */
    function sin_(x) {
      const $x = convertToTensor2(x, "x", "sin");
      const inputs = {x: $x};
      return ENGINE2.runKernelFunc((backend3, save) => {
        const res = backend3.sin($x);
        save([$x]);
        return res;
      }, inputs, null, Sin3);
    }
    const sin = op2({sin_});
    /**
     * @license
     * Copyright 2018 Google LLC. All Rights Reserved.
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     * http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     * =============================================================================
     */
    function sinh_(x) {
      const $x = convertToTensor2(x, "x", "sinh");
      const inputs = {x: $x};
      return ENGINE2.runKernelFunc((backend3, save) => {
        const res = backend3.sinh($x);
        save([$x]);
        return res;
      }, inputs, null, Sinh);
    }
    const sinh = op2({sinh_});
    /**
     * @license
     * Copyright 2018 Google LLC. All Rights Reserved.
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     * http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     * =============================================================================
     */
    function slice1d_(x, begin, size) {
      const $x = convertToTensor2(x, "x", "slice1d");
      assert2($x.rank === 1, () => `slice1d expects a rank-1 tensor, but got a rank-${$x.rank} tensor`);
      return slice2($x, [begin], [size]);
    }
    const slice1d = op2({slice1d_});
    /**
     * @license
     * Copyright 2018 Google LLC. All Rights Reserved.
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     * http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     * =============================================================================
     */
    function slice2d_(x, begin, size) {
      const $x = convertToTensor2(x, "x", "slice2d");
      assert2($x.rank === 2, () => `slice2d expects a rank-2 tensor, but got a rank-${$x.rank} tensor`);
      return slice2($x, begin, size);
    }
    const slice2d2 = op2({slice2d_});
    /**
     * @license
     * Copyright 2018 Google LLC. All Rights Reserved.
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     * http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     * =============================================================================
     */
    function slice3d_(x, begin, size) {
      const $x = convertToTensor2(x, "x", "slice3d");
      assert2($x.rank === 3, () => `slice3d expects a rank-3 tensor, but got a rank-${$x.rank} tensor`);
      return slice2($x, begin, size);
    }
    const slice3d2 = op2({slice3d_});
    /**
     * @license
     * Copyright 2018 Google LLC. All Rights Reserved.
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     * http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     * =============================================================================
     */
    function slice4d_(x, begin, size) {
      const $x = convertToTensor2(x, "x", "slice4d");
      assert2($x.rank === 4, () => `slice4d expects a rank-4 tensor, but got a rank-${$x.rank} tensor`);
      return slice2($x, begin, size);
    }
    const slice4d2 = op2({slice4d_});
    /**
     * @license
     * Copyright 2018 Google LLC. All Rights Reserved.
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     * http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     * =============================================================================
     */
    function softmax_(logits, dim = -1) {
      const $logits = convertToTensor2(logits, "logits", "softmax", "float32");
      if (dim === -1) {
        dim = $logits.rank - 1;
      }
      if (dim !== $logits.rank - 1) {
        throw Error(`Softmax along a non-last dimension is not yet supported. Logits was rank ${$logits.rank} and dim was ${dim}`);
      }
      const inputs = {logits: $logits};
      const attrs = {dim};
      return ENGINE2.runKernelFunc((backend3, save) => {
        const y = backend3.softmax($logits, dim);
        save([y]);
        return y;
      }, inputs, null, Softmax3, attrs);
    }
    const softmax2 = op2({softmax_});
    /**
     * @license
     * Copyright 2020 Google LLC. All Rights Reserved.
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     * http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     * =============================================================================
     */
    function fft_(input2) {
      assert2(input2.dtype === "complex64", () => `The dtype for tf.spectral.fft() must be complex64 but got ${input2.dtype}.`);
      const inputs = {input: input2};
      return ENGINE2.runKernelFunc((backend3) => {
        const innerDimensionSize = input2.shape[input2.shape.length - 1];
        const batch = input2.size / innerDimensionSize;
        const input2D = input2.as2D(batch, innerDimensionSize);
        const result = backend3.fft(input2D);
        return result.reshape(input2.shape);
      }, inputs, null, FFT);
    }
    const fft = op2({fft_});
    /**
     * @license
     * Copyright 2020 Google LLC. All Rights Reserved.
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     * http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     * =============================================================================
     */
    function ifft_(input2) {
      assert2(input2.dtype === "complex64", () => `The dtype for tf.spectral.ifft() must be complex64 but got ${input2.dtype}.`);
      const inputs = {input: input2};
      return ENGINE2.runKernelFunc((backend3) => {
        const innerDimensionSize = input2.shape[input2.shape.length - 1];
        const batch = input2.size / innerDimensionSize;
        const input2D = reshape5(input2, [batch, innerDimensionSize]);
        const result = backend3.ifft(input2D);
        return reshape5(result, input2.shape);
      }, inputs, null, IFFT);
    }
    const ifft = op2({ifft_});
    /**
     * @license
     * Copyright 2018 Google LLC. All Rights Reserved.
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     * http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     * =============================================================================
     */
    function irfft_(input2) {
      const innerDimensionSize = input2.shape[input2.shape.length - 1];
      const batch = input2.size / innerDimensionSize;
      let ret;
      if (innerDimensionSize <= 2) {
        const complexInput = reshape5(input2, [batch, innerDimensionSize]);
        ret = ifft(complexInput);
      } else {
        const outputShape = [batch, 2 * (innerDimensionSize - 1)];
        const realInput = reshape5(real(input2), [batch, innerDimensionSize]);
        const imagInput = reshape5(imag(input2), [batch, innerDimensionSize]);
        const realConjugate = reverse2(slice2(realInput, [0, 1], [batch, innerDimensionSize - 2]), 1);
        const imagConjugate = mul3(reverse2(slice2(imagInput, [0, 1], [batch, innerDimensionSize - 2]), 1), scalar3(-1));
        const r = concat2([realInput, realConjugate], 1);
        const i = concat2([imagInput, imagConjugate], 1);
        const complexInput = reshape5(complex3(r, i), [outputShape[0], outputShape[1]]);
        ret = ifft(complexInput);
      }
      ret = real(ret);
      if (input2.rank === 3 && input2.shape[0] !== 0) {
        const temp = ret;
        const batch2 = input2.shape[0];
        ret = reshape5(ret, [batch2, ret.shape[0] / batch2, ret.shape[1]]);
        temp.dispose();
      }
      return ret;
    }
    const irfft = op2({irfft_});
    function prepareSplitSize2(x, numOrSizeSplits, axis = 0) {
      let splitSizes = [];
      if (typeof numOrSizeSplits === "number") {
        assert2(x.shape[axis] % numOrSizeSplits === 0, () => "Number of splits must evenly divide the axis.");
        splitSizes = new Array(numOrSizeSplits).fill(x.shape[axis] / numOrSizeSplits);
      } else {
        const numOfNegs = numOrSizeSplits.reduce((count2, value) => {
          if (value === -1) {
            count2 += 1;
          }
          return count2;
        }, 0);
        assert2(numOfNegs <= 1, () => "There should be only one negative value in split array.");
        const negIndex = numOrSizeSplits.indexOf(-1);
        if (negIndex !== -1) {
          const total = numOrSizeSplits.reduce((a, b) => b > 0 ? a + b : a);
          numOrSizeSplits[negIndex] = x.shape[axis] - total;
        }
        assert2(x.shape[axis] === numOrSizeSplits.reduce((a, b) => a + b), () => "The sum of sizes must match the size of the axis dimension.");
        splitSizes = numOrSizeSplits;
      }
      return splitSizes;
    }
    /**
     * @license
     * Copyright 2020 Google LLC. All Rights Reserved.
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     * http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     * =============================================================================
     */
    function split_(x, numOrSizeSplits, axis = 0) {
      const $x = convertToTensor2(x, "x", "split");
      const forward = (backend3, _) => {
        const $axis = parseAxisParam2(axis, $x.shape)[0];
        const splitSizes = prepareSplitSize2($x, numOrSizeSplits, $axis);
        return backend3.split($x, splitSizes, $axis);
      };
      const inputs = {x: $x};
      const attr = {numOrSizeSplits, axis};
      return ENGINE2.runKernelFunc(forward, inputs, null, SplitV2, attr);
    }
    const split2 = op2({split_});
    /**
     * @license
     * Copyright 2018 Google LLC. All Rights Reserved.
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     * http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     * =============================================================================
     */
    function rfft_(input2, fftLength) {
      assert2(input2.dtype === "float32", () => `The dtype for rfft() must be real value but got ${input2.dtype}`);
      let innerDimensionSize = input2.shape[input2.shape.length - 1];
      const batch = input2.size / innerDimensionSize;
      let adjustedInput;
      if (fftLength != null && fftLength < innerDimensionSize) {
        const begin = input2.shape.map((v) => 0);
        const size = input2.shape.map((v) => v);
        size[input2.shape.length - 1] = fftLength;
        adjustedInput = slice2(input2, begin, size);
        innerDimensionSize = fftLength;
      } else if (fftLength != null && fftLength > innerDimensionSize) {
        const zerosShape = input2.shape.map((v) => v);
        zerosShape[input2.shape.length - 1] = fftLength - innerDimensionSize;
        adjustedInput = concat2([input2, zeros3(zerosShape)], input2.shape.length - 1);
        innerDimensionSize = fftLength;
      } else {
        adjustedInput = input2;
      }
      const zerosInput = zerosLike2(adjustedInput);
      const complexInput = reshape5(complex3(adjustedInput, zerosInput), [batch, innerDimensionSize]);
      const ret = fft(complexInput);
      const half = Math.floor(innerDimensionSize / 2) + 1;
      const realValues = real(ret);
      const imagValues = imag(ret);
      const realComplexConjugate = split2(realValues, [half, innerDimensionSize - half], realValues.shape.length - 1);
      const imagComplexConjugate = split2(imagValues, [half, innerDimensionSize - half], imagValues.shape.length - 1);
      const outputShape = adjustedInput.shape.slice();
      outputShape[adjustedInput.shape.length - 1] = half;
      return reshape5(complex3(realComplexConjugate[0], imagComplexConjugate[0]), outputShape);
    }
    const rfft = op2({rfft_});
    /**
     * @license
     * Copyright 2018 Google LLC. All Rights Reserved.
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     * http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     * =============================================================================
     */
    function sqrt_(x) {
      const $x = convertToTensor2(x, "x", "sqrt");
      const inputs = {x: $x};
      return ENGINE2.runKernelFunc((backend3, save) => {
        const res = backend3.sqrt($x);
        save([$x]);
        return res;
      }, inputs, null, Sqrt3);
    }
    const sqrt = op2({sqrt_});
    /**
     * @license
     * Copyright 2020 Google LLC. All Rights Reserved.
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     * http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     * =============================================================================
     */
    function squaredDifference_(a, b) {
      let $a = convertToTensor2(a, "a", "squaredDifference");
      let $b = convertToTensor2(b, "b", "squaredDifference");
      [$a, $b] = makeTypesMatch2($a, $b);
      assertAndGetBroadcastShape2($a.shape, $b.shape);
      const forward = (backend3, save) => {
        const res = backend3.squaredDifference($a, $b);
        save([$a, $b]);
        return res;
      };
      const inputs = {a: $a, b: $b};
      const attrs = {};
      return ENGINE2.runKernelFunc(forward, inputs, null, SquaredDifference3, attrs);
    }
    const squaredDifference = op2({squaredDifference_});
    /**
     * @license
     * Copyright 2020 Google LLC. All Rights Reserved.
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     * http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     * =============================================================================
     */
    function squeeze_(x, axis) {
      const $x = convertToTensor2(x, "x", "squeeze");
      return reshape5($x, squeezeShape2($x.shape, axis).newShape);
    }
    const squeeze = op2({squeeze_});
    /**
     * @license
     * Copyright 2020 Google LLC. All Rights Reserved.
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     * http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     * =============================================================================
     */
    function stack_(tensors, axis = 0) {
      const $tensors = convertToTensorArray(tensors, "tensors", "stack");
      assert2($tensors.length >= 1, () => "Pass at least one tensor to tf.stack");
      if ($tensors.length === 1) {
        return expandDims($tensors[0], axis);
      }
      const rank = $tensors[0].rank;
      const shape = $tensors[0].shape;
      const dtype = $tensors[0].dtype;
      assert2(axis <= rank, () => "Axis must be <= rank of the tensor");
      $tensors.forEach((t) => {
        assertShapesMatch2(shape, t.shape, "All tensors passed to stack must have matching shapes");
        assert2(dtype === t.dtype, () => "All tensors passed to stack must have matching dtypes");
      });
      const expandedTensors = $tensors.map((t) => expandDims(t, axis));
      return concat2(expandedTensors, axis);
    }
    const stack = op2({stack_});
    /**
     * @license
     * Copyright 2018 Google LLC. All Rights Reserved.
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     * http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     * =============================================================================
     */
    function step_2(x, alpha = 0) {
      const $x = convertToTensor2(x, "x", "step");
      const inputs = {x: $x};
      const attrs = {alpha};
      return ENGINE2.runKernelFunc((backend3) => backend3.step($x, alpha), inputs, null, Step2, attrs);
    }
    const step3 = op2({step_: step_2});
    /**
     * @license
     * Copyright 2018 Google LLC. All Rights Reserved.
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     * http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     * =============================================================================
     */
    function stridedSlice_(x, begin, end, strides, beginMask = 0, endMask = 0, ellipsisMask = 0, newAxisMask = 0, shrinkAxisMask = 0) {
      let $x = convertToTensor2(x, "x", "stridedSlice");
      const forward = (backend3) => {
        if (strides == null) {
          strides = new Array(begin.length);
        }
        const ellipsisAxes = maskToAxes2(ellipsisMask);
        if (ellipsisAxes.length > 1) {
          throw new Error("Multiple ellipses in slice is not allowed.");
        }
        if (ellipsisMask !== 0 && newAxisMask !== 0) {
          throw new Error("Using both ellipsisMask and newAxisMask is not yet supported.");
        }
        if (ellipsisMask !== 0 && shrinkAxisMask !== 0) {
          throw new Error("Using both ellipsisMask and shrinkAxisMask is not yet supported.");
        }
        const numInterpolatedAxes = $x.rank - begin.length;
        const expandAxes = maskToAxes2(newAxisMask);
        const newShape = $x.shape.slice();
        expandAxes.forEach((axis) => {
          begin[axis] = 0;
          end[axis] = 1;
          newShape.splice(axis, 0, 1);
        });
        $x = reshape5($x, newShape);
        const {begin: normalizedBegin, end: normalizedEnd, strides: normalizedStrides} = getNormalizedAxes2($x.shape, ellipsisAxes, numInterpolatedAxes, begin, end, strides, beginMask, endMask, ellipsisMask);
        begin = normalizedBegin;
        end = normalizedEnd;
        strides = normalizedStrides;
        const shrinkAxes = maskToAxes2(shrinkAxisMask);
        shrinkAxes.forEach((axis) => {
          end[axis] = begin[axis] + 1;
          strides[axis] = 1;
        });
        const size = computeOutShape5(begin, end, strides);
        const outShape = size.filter((_, axis) => shrinkAxes.indexOf(axis) === -1);
        const nonStrided = strides.every((v) => v === 1);
        if (nonStrided) {
          return reshape5(slice2($x, begin, size), outShape);
        }
        const res = backend3.stridedSlice($x, begin, end, strides);
        return reshape5(res, outShape);
      };
      const inputs = {x: $x};
      const attrs = {
        begin,
        end,
        strides,
        beginMask,
        endMask,
        ellipsisMask,
        newAxisMask,
        shrinkAxisMask
      };
      return ENGINE2.runKernelFunc(forward, inputs, null, StridedSlice3, attrs);
    }
    const stridedSlice2 = op2({stridedSlice_});
    /**
     * @license
     * Copyright 2018 Google LLC. All Rights Reserved.
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     * http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     * =============================================================================
     */
    function tan_(x) {
      const $x = convertToTensor2(x, "x", "tan");
      const inputs = {x: $x};
      return ENGINE2.runKernelFunc((backend3, save) => {
        const res = backend3.tan($x);
        save([$x]);
        return res;
      }, inputs, null, Tan);
    }
    const tan = op2({tan_});
    /**
     * @license
     * Copyright 2018 Google LLC. All Rights Reserved.
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     * http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     * =============================================================================
     */
    function tensor2d(values, shape, dtype) {
      assertNonNull2(values);
      if (shape != null && shape.length !== 2) {
        throw new Error("tensor2d() requires shape to have two numbers");
      }
      const inferredShape = inferShape2(values, dtype);
      if (inferredShape.length !== 2 && inferredShape.length !== 1) {
        throw new Error("tensor2d() requires values to be number[][] or flat/TypedArray");
      }
      if (inferredShape.length === 1 && shape == null) {
        throw new Error("tensor2d() requires shape to be provided when `values` are a flat/TypedArray");
      }
      return makeTensor2(values, shape, inferredShape, dtype);
    }
    /**
     * @license
     * Copyright 2018 Google LLC. All Rights Reserved.
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     * http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     * =============================================================================
     */
    function tensor4d(values, shape, dtype) {
      assertNonNull2(values);
      if (shape != null && shape.length !== 4) {
        throw new Error("tensor4d() requires shape to have four numbers");
      }
      const inferredShape = inferShape2(values, dtype);
      if (inferredShape.length !== 4 && inferredShape.length !== 1) {
        throw new Error("tensor4d() requires values to be number[][][][] or flat/TypedArray");
      }
      if (inferredShape.length === 1 && shape == null) {
        throw new Error("tensor4d() requires shape to be provided when `values` are a flat array");
      }
      return makeTensor2(values, shape, inferredShape, dtype);
    }
    /**
     * @license
     * Copyright 2018 Google LLC. All Rights Reserved.
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     * http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     * =============================================================================
     */
    function tensor5d(values, shape, dtype) {
      assertNonNull2(values);
      if (shape != null && shape.length !== 5) {
        throw new Error("tensor5d() requires shape to have five numbers");
      }
      const inferredShape = inferShape2(values, dtype);
      if (inferredShape.length !== 5 && inferredShape.length !== 1) {
        throw new Error("tensor5d() requires values to be number[][][][][] or flat/TypedArray");
      }
      if (inferredShape.length === 1 && shape == null) {
        throw new Error("tensor5d() requires shape to be provided when `values` are a flat array");
      }
      return makeTensor2(values, shape, inferredShape, dtype);
    }
    /**
     * @license
     * Copyright 2018 Google LLC. All Rights Reserved.
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     * http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     * =============================================================================
     */
    function tensor6d(values, shape, dtype) {
      assertNonNull2(values);
      if (shape != null && shape.length !== 6) {
        throw new Error("tensor6d() requires shape to have six numbers");
      }
      const inferredShape = inferShape2(values, dtype);
      if (inferredShape.length !== 6 && inferredShape.length !== 1) {
        throw new Error("tensor6d() requires values to be number[][][][][][] or flat/TypedArray");
      }
      if (inferredShape.length === 1 && shape == null) {
        throw new Error("tensor6d() requires shape to be provided when `values` are a flat array");
      }
      shape = shape || inferredShape;
      return makeTensor2(values, shape, inferredShape, dtype);
    }
    /**
     * @license
     * Copyright 2018 Google LLC. All Rights Reserved.
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     * http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     * =============================================================================
     */
    function topk_(x, k = 1, sorted = true) {
      const $x = convertToTensor2(x, "x", "topk");
      if ($x.rank === 0) {
        throw new Error("topk() expects the input to be of rank 1 or higher");
      }
      const lastDim = $x.shape[$x.shape.length - 1];
      if (k > lastDim) {
        throw new Error(`'k' passed to topk() must be <= the last dimension (${lastDim}) but got ${k}`);
      }
      const inputs = {x: $x};
      const attrs = {k, sorted};
      const [values, indices] = ENGINE2.runKernelFunc((b) => b.topk($x, k, sorted), inputs, null, TopK, attrs);
      return {values, indices};
    }
    const topk = op2({topk_});
    /**
     * @license
     * Copyright 2020 Google LLC. All Rights Reserved.
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     * http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     * =============================================================================
     */
    function truncatedNormal_(shape, mean2 = 0, stdDev = 1, dtype, seed) {
      if (dtype != null && dtype === "bool") {
        throw new Error(`Unsupported data type $ { dtype }`);
      }
      const randGauss = new MPRandGauss(mean2, stdDev, dtype, true, seed);
      const res = buffer2(shape, dtype);
      for (let i = 0; i < res.values.length; i++) {
        res.values[i] = randGauss.nextValue();
      }
      return res.toTensor();
    }
    const truncatedNormal = op2({truncatedNormal_});
    /**
     * @license
     * Copyright 2020 Google LLC. All Rights Reserved.
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     * http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     * =============================================================================
     */
    function unique_(x, axis = 0) {
      const $x = convertToTensor2(x, "x", "unique", null);
      assert2($x.rank > 0, () => "The input tensor must be at least 1D");
      const inputs = {x: $x};
      const attrs = {axis};
      const [values, indices] = ENGINE2.runKernel(Unique, inputs, attrs);
      return {values, indices};
    }
    const unique = op2({unique_});
    /**
     * @license
     * Copyright 2020 Google LLC. All Rights Reserved.
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     * http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     * =============================================================================
     */
    function unsortedSegmentSum_(x, segmentIds, numSegments) {
      const $x = convertToTensor2(x, "x", "unsortedSegmentSum");
      const $segmentIds = convertToTensor2(segmentIds, "segmentIds", "unsortedSegmentSum", "int32");
      assert2(isInt2(numSegments), () => "numSegments must be of dtype int");
      const inputs = {x: $x, segmentIds: $segmentIds};
      const attrs = {numSegments};
      const forward = (backend3, save) => {
        const res = backend3.unsortedSegmentSum($x, $segmentIds, numSegments);
        save([$segmentIds]);
        return res;
      };
      return ENGINE2.runKernelFunc(forward, inputs, null, UnsortedSegmentSum, attrs);
    }
    const unsortedSegmentSum = op2({unsortedSegmentSum_});
    /**
     * @license
     * Copyright 2020 Google LLC. All Rights Reserved.
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     * http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     * =============================================================================
     */
    function unstack_(x, axis = 0) {
      const $x = convertToTensor2(x, "x", "unstack");
      assert2(axis >= -$x.shape.length && axis < $x.shape.length, () => `Axis = ${axis} is not in [-${$x.shape.length}, ${$x.shape.length})`);
      if (axis < 0) {
        axis += $x.shape.length;
      }
      const inputs = {value: $x};
      const attrs = {axis};
      const forward = (backend3) => backend3.unstack($x, axis);
      return ENGINE2.runKernelFunc(forward, inputs, null, Unpack3, attrs);
    }
    const unstack = op2({unstack_});
    /**
     * @license
     * Copyright 2018 Google LLC. All Rights Reserved.
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     * http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     * =============================================================================
     */
    function variable(initialValue, trainable = true, name, dtype) {
      return ENGINE2.makeVariable(initialValue, trainable, name, dtype);
    }
    /**
     * @license
     * Copyright 2018 Google LLC. All Rights Reserved.
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     * http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     * =============================================================================
     */
    function whereImpl(condShape, condVals) {
      const indices = [];
      for (let i = 0; i < condVals.length; i++) {
        if (condVals[i]) {
          indices.push(i);
        }
      }
      const inBuffer = buffer2(condShape, "int32");
      const out = buffer2([indices.length, condShape.length], "int32");
      for (let i = 0; i < indices.length; i++) {
        const loc = inBuffer.indexToLoc(indices[i]);
        const offset = i * condShape.length;
        out.values.set(loc, offset);
      }
      return out.toTensor();
    }
    /**
     * @license
     * Copyright 2020 Google LLC. All Rights Reserved.
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     * http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     * =============================================================================
     */
    async function whereAsync_(condition) {
      const $condition = convertToTensor2(condition, "condition", "whereAsync", "bool");
      const vals = await $condition.data();
      const res = whereImpl($condition.shape, vals);
      if (condition !== $condition) {
        $condition.dispose();
      }
      return res;
    }
    const whereAsync = whereAsync_;
    /**
     * @license
     * Copyright 2018 Google LLC. All Rights Reserved.
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     * http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     * =============================================================================
     */
    async function booleanMaskAsync_(tensor7, mask, axis) {
      const $tensor = convertToTensor2(tensor7, "tensor", "boolMask");
      const $mask = convertToTensor2(mask, "mask", "boolMask", "bool");
      const axisFrom = axis == null ? 0 : axis;
      const maskDim = $mask.rank;
      const tensorShape = $tensor.shape;
      assert2(maskDim > 0, () => "mask cannot be scalar");
      assertShapesMatch2(tensorShape.slice(axisFrom, axisFrom + maskDim), $mask.shape, `mask's shape must match the first K dimensions of tensor's shape,`);
      let leadingSize = 1;
      for (let i = axisFrom; i < axisFrom + maskDim; i++) {
        leadingSize *= tensorShape[i];
      }
      const targetTensorShape = tensorShape.slice(0, axisFrom).concat([leadingSize], tensorShape.slice(axisFrom + maskDim));
      const reshapedTensor = reshape5($tensor, targetTensorShape);
      const reshapedMask = reshape5($mask, [-1]);
      const positivePositions = await whereAsync(reshapedMask);
      const indices = squeeze(positivePositions, [1]);
      const res = gather(reshapedTensor, indices, axisFrom);
      if (tensor7 !== $tensor) {
        $tensor.dispose();
      }
      if (mask !== $mask) {
        $mask.dispose();
      }
      indices.dispose();
      reshapedTensor.dispose();
      reshapedMask.dispose();
      positivePositions.dispose();
      return res;
    }
    const booleanMaskAsync = booleanMaskAsync_;
    /**
     * @license
     * Copyright 2018 Google LLC. All Rights Reserved.
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     * http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     * =============================================================================
     */
    function notEqualStrict_(a, b) {
      deprecationWarn2("strict variants of ops have been deprecated and will be removed in future");
      const $a = convertToTensor2(a, "a", "notEqualStrict");
      const $b = convertToTensor2(b, "b", "notEqualStrict");
      assertShapesMatch2($a.shape, $b.shape, "Error in notEqualStrict: ");
      return notEqual($a, $b);
    }
    function lessStrict_(a, b) {
      deprecationWarn2("strict variants of ops have been deprecated and will be removed in future");
      const $a = convertToTensor2(a, "a", "lessStrict");
      const $b = convertToTensor2(b, "b", "lessStrict");
      assertShapesMatch2($a.shape, $b.shape, "Error in lessStrict: ");
      return less($a, $b);
    }
    function equalStrict_(a, b) {
      deprecationWarn2("strict variants of ops have been deprecated and will be removed in future");
      const $a = convertToTensor2(a, "a", "equalStrict");
      const $b = convertToTensor2(b, "b", "equalStrict");
      assertShapesMatch2($a.shape, $b.shape, "Error in equalStrict: ");
      return equal($a, $b);
    }
    function lessEqualStrict_(a, b) {
      deprecationWarn2("strict variants of ops have been deprecated and will be removed in future");
      const $a = convertToTensor2(a, "a", "lessEqualStrict");
      const $b = convertToTensor2(b, "b", "lessEqualStrict");
      assertShapesMatch2($a.shape, $b.shape, "Error in lessEqualStrict: ");
      return lessEqual($a, $b);
    }
    function greaterStrict_(a, b) {
      deprecationWarn2("strict variants of ops have been deprecated and will be removed in future");
      const $a = convertToTensor2(a, "a", "greaterStrict");
      const $b = convertToTensor2(b, "b", "greaterStrict");
      assertShapesMatch2($a.shape, $b.shape, "Error in greaterStrict: ");
      return greater($a, $b);
    }
    function greaterEqualStrict_(a, b) {
      deprecationWarn2("strict variants of ops have been deprecated and will be removed in future");
      const $a = convertToTensor2(a, "a", "greaterEqualStrict");
      const $b = convertToTensor2(b, "b", "greaterEqualStrict");
      assertShapesMatch2($a.shape, $b.shape, "Error in greaterEqualStrict: ");
      return greaterEqual($a, $b);
    }
    const equalStrict = op2({equalStrict_});
    const greaterEqualStrict = op2({greaterEqualStrict_});
    const greaterStrict = op2({greaterStrict_});
    const lessEqualStrict = op2({lessEqualStrict_});
    const lessStrict = op2({lessStrict_});
    const notEqualStrict = op2({notEqualStrict_});
    /**
     * @license
     * Copyright 2018 Google LLC. All Rights Reserved.
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     * http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     * =============================================================================
     */
    function addStrict_(a, b) {
      deprecationWarn2("strict variants of ops have been deprecated and will be removed in future");
      const $a = convertToTensor2(a, "a", "addStrict");
      const $b = convertToTensor2(b, "b", "addStrict");
      assertShapesMatch2($a.shape, $b.shape, "Error in addStrict: ");
      return add$1($a, $b);
    }
    function subStrict_(a, b) {
      deprecationWarn2("strict variants of ops have been deprecated and will be removed in future");
      const $a = convertToTensor2(a, "a", "subStrict");
      const $b = convertToTensor2(b, "b", "subStrict");
      assertShapesMatch2($a.shape, $b.shape, "Error in subStrict: ");
      return sub($a, $b);
    }
    function powStrict_(base2, exp2) {
      deprecationWarn2("strict variants of ops have been deprecated and will be removed in future");
      assertShapesMatch2(base2.shape, exp2.shape, "Error in powStrict: ");
      return pow(base2, exp2);
    }
    function mulStrict_(a, b) {
      deprecationWarn2("strict variants of ops have been deprecated and will be removed in future");
      const $a = convertToTensor2(a, "a", "mul");
      const $b = convertToTensor2(b, "b", "mul");
      assertShapesMatch2($a.shape, $b.shape, "Error in multiplyStrict: ");
      return mul3($a, $b);
    }
    function divStrict_(a, b) {
      deprecationWarn2("strict variants of ops have been deprecated and will be removed in future");
      const $a = convertToTensor2(a, "a", "div");
      const $b = convertToTensor2(b, "b", "div");
      assertShapesMatch2($a.shape, $b.shape, "Error in divideStrict: ");
      return div($a, $b);
    }
    function modStrict_(a, b) {
      deprecationWarn2("strict variants of ops have been deprecated and will be removed in future");
      const $a = convertToTensor2(a, "a", "modStrict");
      const $b = convertToTensor2(b, "b", "modStrict");
      assertShapesMatch2($a.shape, $b.shape, "Error in modStrict: ");
      return mod($a, $b);
    }
    function minimumStrict_(a, b) {
      deprecationWarn2("strict variants of ops have been deprecated and will be removed in future");
      const $a = convertToTensor2(a, "a", "minimumStrict");
      const $b = convertToTensor2(b, "b", "minimumStrict");
      assertShapesMatch2($a.shape, $b.shape, "Error in minimumStrict: ");
      return minimum($a, $b);
    }
    function maximumStrict_(a, b) {
      deprecationWarn2("strict variants of ops have been deprecated and will be removed in future");
      const $a = convertToTensor2(a, "a", "maximumStrict");
      const $b = convertToTensor2(b, "b", "maximumStrict");
      assertShapesMatch2($a.shape, $b.shape, "Error in maximumStrict: ");
      return maximum($a, $b);
    }
    function squaredDifferenceStrict_(a, b) {
      deprecationWarn2("strict variants of ops have been deprecated and will be removed in future");
      const $a = convertToTensor2(a, "a", "squaredDifferenceStrict");
      const $b = convertToTensor2(b, "b", "squaredDifferenceStrict");
      assertShapesMatch2($a.shape, $b.shape, "Error in squaredDifferenceStrict: ");
      return squaredDifference($a, $b);
    }
    const addStrict = op2({addStrict_});
    const divStrict = op2({divStrict_});
    const maximumStrict = op2({maximumStrict_});
    const minimumStrict = op2({minimumStrict_});
    const modStrict = op2({modStrict_});
    const mulStrict = op2({mulStrict_});
    const powStrict = op2({powStrict_});
    const squaredDifferenceStrict = op2({squaredDifferenceStrict_});
    const subStrict = op2({subStrict_});
    /**
     * @license
     * Copyright 2018 Google LLC. All Rights Reserved.
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     * http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     * =============================================================================
     */
    function norm_(x, ord = "euclidean", axis = null, keepDims = false) {
      x = convertToTensor2(x, "x", "norm");
      const norm2 = normImpl(x, ord, axis);
      let keepDimsShape = norm2.shape;
      if (keepDims) {
        const axes = parseAxisParam2(axis, x.shape);
        keepDimsShape = expandShapeToKeepDim2(norm2.shape, axes);
      }
      return reshape5(norm2, keepDimsShape);
    }
    function normImpl(x, p2, axis = null) {
      if (x.rank === 0) {
        return abs(x);
      }
      if (x.rank !== 1 && axis === null) {
        return normImpl(reshape5(x, [-1]), p2, axis);
      }
      if (x.rank === 1 || typeof axis === "number" || Array.isArray(axis) && axis.length === 1) {
        if (p2 === 1) {
          return sum$1(abs(x), axis);
        }
        if (p2 === Infinity) {
          return max2(abs(x), axis);
        }
        if (p2 === -Infinity) {
          return min2(abs(x), axis);
        }
        if (p2 === "euclidean" || p2 === 2) {
          return sqrt(sum$1(pow(abs(x), scalar3(2, "int32")), axis));
        }
        throw new Error(`Error in norm: invalid ord value: ${p2}`);
      }
      if (Array.isArray(axis) && axis.length === 2) {
        if (p2 === 1) {
          return max2(sum$1(abs(x), axis[0]), axis[1] - 1);
        }
        if (p2 === Infinity) {
          return max2(sum$1(abs(x), axis[1]), axis[0]);
        }
        if (p2 === -Infinity) {
          return min2(sum$1(abs(x), axis[1]), axis[0]);
        }
        if (p2 === "fro" || p2 === "euclidean") {
          return sqrt(sum$1(square(x), axis));
        }
        throw new Error(`Error in norm: invalid ord value: ${p2}`);
      }
      throw new Error(`Error in norm: invalid axis: ${axis}`);
    }
    const norm = op2({norm_});
    /**
     * @license
     * Copyright 2018 Google LLC. All Rights Reserved.
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     * http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     * =============================================================================
     */
    function movingAverage_(v, x, decay, step4, zeroDebias = true) {
      const $v = convertToTensor2(v, "v", "movingAverage");
      const $x = convertToTensor2(x, "x", "movingAverage");
      const $decay = convertToTensor2(decay, "decay", "movingAverage");
      assertTypesMatch($v, $x);
      assert2(arraysEqual2($v.shape, $x.shape), () => "Shape mismatch in v and x");
      const one = scalar3(1);
      const oneMinusDecay = sub(one, $decay);
      let update2 = mul3(sub($x, $v), oneMinusDecay);
      if (zeroDebias) {
        assert2(step4 != null, () => "When using zeroDebias: true, step is required.");
        const $step = convertToTensor2(step4, "step", "movingAverage");
        update2 = div(update2, sub(one, pow($decay, $step)));
      }
      return add$1($v, update2);
    }
    const movingAverage = op2({movingAverage_});
    /**
     * @license
     * Copyright 2018 Google LLC. All Rights Reserved.
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     * http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     * =============================================================================
     */
    function scatterND_(indices, updates, shape) {
      const $indices = convertToTensor2(indices, "indices", "scatterND", "int32");
      const $updates = convertToTensor2(updates, "updates", "scatterND");
      validateInput2($updates, $indices, shape);
      const forward = (backend3) => {
        return backend3.scatterND($indices, $updates, shape);
      };
      const inputs = {indices: $indices, updates: $updates};
      const attrs = {shape};
      return ENGINE2.runKernelFunc(forward, inputs, null, ScatterNd3, attrs);
    }
    const scatterND = op2({scatterND_});
    function validateInput$1(sparseIndices, sparseValues, outputShape, defaultValues) {
      if (sparseIndices.dtype !== "int32") {
        throw new Error(`tf.sparseToDense() expects the indices to be int32 type, but the dtype was ${sparseIndices.dtype}.`);
      }
      if (sparseIndices.rank > 2) {
        throw new Error(`sparseIndices should be a scalar, vector, or matrix, but got shape ${sparseIndices.shape}.`);
      }
      const numElems = sparseIndices.rank > 0 ? sparseIndices.shape[0] : 1;
      const numDims = sparseIndices.rank > 1 ? sparseIndices.shape[1] : 1;
      if (outputShape.length !== numDims) {
        throw new Error(`outputShape has incorrect number of elements:, ${outputShape.length}, should be: ${numDims}.`);
      }
      const numValues = sparseValues.size;
      if (!(sparseValues.rank === 0 || sparseValues.rank === 1 && numValues === numElems)) {
        throw new Error(`sparseValues has incorrect shape ${sparseValues.shape}, should be [] or [${numElems}]`);
      }
      if (sparseValues.dtype !== defaultValues.dtype) {
        throw new Error("sparseValues.dtype must match defaultValues.dtype");
      }
    }
    /**
     * @license
     * Copyright 2018 Google LLC. All Rights Reserved.
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     * http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     * =============================================================================
     */
    function sparseToDense_(sparseIndices, sparseValues, outputShape, defaultValue = 0) {
      const $sparseIndices = convertToTensor2(sparseIndices, "sparseIndices", "sparseToDense", "int32");
      const $sparseValues = convertToTensor2(sparseValues, "sparseValues", "sparseToDense");
      const $defaultValue = convertToTensor2(defaultValue, "defaultValue", "sparseToDense", $sparseValues.dtype);
      validateInput$1($sparseIndices, $sparseValues, outputShape, $defaultValue);
      const inputs = {
        sparseIndices: $sparseIndices,
        sparseValues: $sparseValues,
        defaultValue: $defaultValue
      };
      const attrs = {outputShape};
      return ENGINE2.runKernelFunc((backend3) => backend3.sparseToDense($sparseIndices, $sparseValues, outputShape, $defaultValue), inputs, null, SparseToDense, attrs);
    }
    const sparseToDense = op2({sparseToDense_});
    /**
     * @license
     * Copyright 2018 Google LLC. All Rights Reserved.
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     * http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     * =============================================================================
     */
    function gatherND_(x, indices) {
      const $indices = convertToTensor2(indices, "indices", "gatherND", "int32");
      const $x = convertToTensor2(x, "x", "gatherND");
      const forward = (backend3) => {
        return backend3.gatherND($x, $indices);
      };
      const inputs = {params: $x, indices: $indices};
      return ENGINE2.runKernelFunc(forward, inputs, null, GatherNd3);
    }
    const gatherND = op2({gatherND_});
    /**
     * @license
     * Copyright 2019 Google LLC. All Rights Reserved.
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     * http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     * =============================================================================
     */
    function getNoiseShape(x, noiseShape) {
      if (noiseShape == null) {
        return x.shape.slice();
      }
      if (arraysEqual2(x.shape, noiseShape)) {
        return noiseShape;
      }
      if (x.shape.length === noiseShape.length) {
        const newDimension = [];
        for (let i = 0; i < x.shape.length; i++) {
          if (noiseShape[i] == null && x.shape[i] != null) {
            newDimension.push(x.shape[i]);
          } else {
            newDimension.push(noiseShape[i]);
          }
        }
        return newDimension;
      }
      return noiseShape;
    }
    /**
     * @license
     * Copyright 2018 Google LLC. All Rights Reserved.
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     * http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     * =============================================================================
     */
    function dropout_(x, rate, noiseShape, seed) {
      const $x = convertToTensor2(x, "x", "dropout");
      assert2($x.dtype === "float32", () => `x has to be a floating point tensor since it's going to be scaled, but got a ${$x.dtype} tensor instead.`);
      assert2(rate >= 0 && rate < 1, () => `rate must be a float in the range [0, 1), but got ${rate}.`);
      if (rate === 0) {
        return x instanceof Tensor2 ? $x.clone() : $x;
      }
      const $noiseShape = getNoiseShape($x, noiseShape);
      const keepProb = 1 - rate;
      const multiplier = div(floor(add$1(randomUniform($noiseShape, 0, 1, "float32", seed), keepProb)), keepProb);
      return mul3($x, multiplier);
    }
    const dropout = op2({dropout_});
    /**
     * @license
     * Copyright 2019 Google LLC. All Rights Reserved.
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     * http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     * =============================================================================
     */
    function enclosingPowerOfTwo(value) {
      return Math.floor(Math.pow(2, Math.ceil(Math.log(value) / Math.log(2))));
    }
    function cosineWindow(windowLength, a, b) {
      const even = 1 - windowLength % 2;
      const newValues = new Float32Array(windowLength);
      for (let i = 0; i < windowLength; ++i) {
        const cosArg = 2 * Math.PI * i / (windowLength + even - 1);
        newValues[i] = a - b * Math.cos(cosArg);
      }
      return tensor1d3(newValues, "float32");
    }
    /**
     * @license
     * Copyright 2019 Google LLC. All Rights Reserved.
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     * http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     * =============================================================================
     */
    async function inTopKAsync_(predictions, targets, k = 1) {
      const $predictions = convertToTensor2(predictions, "predictions", "inTopK");
      const $targets = convertToTensor2(targets, "targets", "inTopK");
      assert2($predictions.rank > 1, () => `inTopK() expects the predictions to be of rank 2 or higher, but got ${$predictions.rank}`);
      assert2($predictions.rank - 1 === $targets.rank, () => `predictions rank should be 1 larger than targets rank, but got predictions rank ${$predictions.rank} and targets rank ${$targets.rank}`);
      assertShapesMatch2($predictions.shape.slice(0, $predictions.shape.length - 1), $targets.shape, `predictions's shape should be align with the targets' shape, except the last dimension.`);
      const lastDim = $predictions.shape[$predictions.shape.length - 1];
      assert2(k > 0 && k <= lastDim, () => `'k' passed to inTopK() must be > 0 && <= the predictions last dimension (${lastDim}), but got ${k}`);
      const predictionsVals = await $predictions.data();
      const targetsVals = await $targets.data();
      const [batch, size] = [predictionsVals.length / lastDim, lastDim];
      const precision2 = getTypedArrayFromDType2("bool", batch);
      for (let b = 0; b < batch; b++) {
        const offset = b * size;
        const vals = predictionsVals.subarray(offset, offset + size);
        const valAndInd = [];
        for (let i = 0; i < vals.length; i++) {
          valAndInd.push({value: vals[i], index: i});
        }
        valAndInd.sort((a, b2) => b2.value - a.value);
        precision2[b] = 0;
        for (let i = 0; i < k; i++) {
          if (valAndInd[i].index === targetsVals[b]) {
            precision2[b] = 1;
            break;
          }
        }
      }
      if (predictions !== $predictions) {
        $predictions.dispose();
      }
      if (targets !== $targets) {
        $targets.dispose();
      }
      return tensor6(precision2, $targets.shape, "bool");
    }
    const inTopKAsync = inTopKAsync_;
    /**
     * @license
     * Copyright 2020 Google LLC. All Rights Reserved.
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     * http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     * =============================================================================
     */
    function conv2DBackpropFilter_(x, dy, filterShape, strides, pad3, dataFormat = "NHWC", dimRoundingMode) {
      let x4D = x;
      if (x.rank === 3) {
        x4D = reshape5(x, [1, x.shape[0], x.shape[1], x.shape[2]]);
      }
      let dy4D = dy;
      if (dy4D.rank === 3) {
        dy4D = reshape5(dy, [1, dy.shape[0], dy.shape[1], dy.shape[2]]);
      }
      assert2(x4D.rank === 4, () => `Error in conv2dDerFilter: input must be rank 4, but got shape ${x4D.shape}.`);
      assert2(dy4D.rank === 4, () => `Error in conv2dDerFilter: dy must be rank 4, but got shape ${dy4D.shape}.`);
      assert2(filterShape.length === 4, () => `Error in conv2dDerFilter: filterShape must be length 4, but got ${filterShape}.`);
      const inDepth = dataFormat === "NHWC" ? x4D.shape[3] : x4D.shape[1];
      const outDepth = dataFormat === "NHWC" ? dy4D.shape[3] : dy4D.shape[1];
      assert2(inDepth === filterShape[2], () => `Error in conv2dDerFilter: depth of input ${inDepth}) must match input depth in filter (${filterShape[2]}.`);
      assert2(outDepth === filterShape[3], () => `Error in conv2dDerFilter: depth of dy (${outDepth}) must match output depth for filter (${filterShape[3]}).`);
      if (dimRoundingMode != null) {
        assert2(isInt2(pad3), () => `Error in conv2dDerFilter: pad must be an integer when using, dimRoundingMode ${dimRoundingMode} but got pad ${pad3}.`);
      }
      const forward = (backend3) => {
        const dilations = 1;
        const $dataFormat = convertConv2DDataFormat2(dataFormat);
        const convInfo = computeConv2DInfo2(x4D.shape, filterShape, strides, dilations, pad3, dimRoundingMode, false, $dataFormat);
        return backend3.conv2dDerFilter(x4D, dy4D, convInfo);
      };
      const inputs = {x: x4D, dy: dy4D};
      const attrs = {strides, pad: pad3, dataFormat, dimRoundingMode, filterShape};
      return ENGINE2.runKernelFunc(forward, inputs, null, Conv2DBackpropFilter, attrs);
    }
    const conv2DBackpropFilter = op2({conv2DBackpropFilter_});
    /**
     * @license
     * Copyright 2019 Google LLC. All Rights Reserved.
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     * http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     * =============================================================================
     */
    function getFusedDyActivation2(dy, y, activation2) {
      if (activation2 == null || activation2 === "linear") {
        return dy;
      }
      if (activation2 === "relu") {
        return mul3(dy, step3(y));
      }
      throw new Error(`Cannot compute gradient for fused activation ${activation2}.`);
    }
    function getFusedBiasGradient2(bias, dyActivation) {
      let res = dyActivation;
      const reduceAxes = getReductionAxes2(bias.shape, dyActivation.shape);
      if (reduceAxes.length > 0) {
        res = sum$1(res, reduceAxes);
      }
      return reshape5(res, bias.shape);
    }
    function applyActivation2(x, activation2, preluActivationWeights) {
      if (activation2 === "linear") {
        return x;
      } else if (activation2 === "relu") {
        return relu3(x);
      } else if (activation2 === "elu") {
        return elu3(x);
      } else if (activation2 === "relu6") {
        return relu63(x);
      } else if (activation2 === "prelu") {
        return prelu4(x, preluActivationWeights);
      }
      throw new Error(`Unknown fused activation ${activation2}.`);
    }
    const shouldFuse2 = (gradientDepth, activation2) => {
      const gradientMode = gradientDepth > 0;
      return !gradientMode || activation2 === "linear";
    };
    /**
     * @license
     * Copyright 2019 Google LLC. All Rights Reserved.
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     * http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     * =============================================================================
     */
    function fusedConv2d_({x, filter, strides, pad: pad3, dataFormat = "NHWC", dilations = [1, 1], dimRoundingMode, bias, activation: activation2 = "linear", preluActivationWeights}) {
      activation2 = activation2 || "linear";
      if (shouldFuse2(ENGINE2.state.gradientDepth, activation2) === false) {
        let result = conv2d2(x, filter, strides, pad3, dataFormat, dilations, dimRoundingMode);
        if (bias != null) {
          result = add$1(result, bias);
        }
        return applyActivation2(result, activation2, preluActivationWeights);
      }
      const $x = convertToTensor2(x, "x", "conv2d");
      const $filter = convertToTensor2(filter, "filter", "conv2d");
      let x4D = $x;
      let reshapedTo4D = false;
      if ($x.rank === 3) {
        reshapedTo4D = true;
        x4D = reshape5($x, [1, $x.shape[0], $x.shape[1], $x.shape[2]]);
      }
      assert2(x4D.rank === 4, () => `Error in fused conv2d: input must be rank 4, but got rank ${x4D.rank}.`);
      assert2($filter.rank === 4, () => `Error in fused conv2d: filter must be rank 4, but got rank ${$filter.rank}.`);
      if (dimRoundingMode != null) {
        assert2(isInt2(pad3), () => `Error in fused conv2d: pad must be an integer when using, dimRoundingMode ${dimRoundingMode} but got pad ${pad3}.`);
      }
      assert2(x4D.shape[3] === $filter.shape[2], () => `Error in conv2d: depth of input (${x4D.shape[3]}) must match input depth for filter ${$filter.shape[2]}.`);
      assert2(eitherStridesOrDilationsAreOne2(strides, dilations), () => `Error in conv2D: Either strides or dilations must be 1. Got strides ${strides} and dilations '${dilations}'`);
      assert2(dataFormat === "NHWC", () => `Error in conv2d: got dataFormat of ${dataFormat} but only NHWC is currently supported.`);
      const convInfo = computeConv2DInfo2(x4D.shape, $filter.shape, strides, dilations, pad3, dimRoundingMode);
      let $bias;
      if (bias != null) {
        $bias = convertToTensor2(bias, "bias", "fused conv2d");
        [$bias] = makeTypesMatch2($bias, $x);
        assertAndGetBroadcastShape2(convInfo.outShape, $bias.shape);
      }
      let $preluActivationWeights;
      if (preluActivationWeights != null) {
        $preluActivationWeights = convertToTensor2(preluActivationWeights, "prelu weights", "fused conv2d");
      }
      const grad2 = (dy, saved) => {
        const [$filter2, x4D2, y, $bias2] = saved;
        const dyActivation = getFusedDyActivation2(dy, y, activation2);
        assert2(tupleValuesAreOne2(dilations), () => `Error in gradient of fused conv2D: dilation rates greater than 1 are not yet supported in gradients. Got dilations '${dilations}'`);
        const xDer = conv2DBackpropInput2(x4D2.shape, dyActivation, $filter2, strides, pad3);
        const filterDer = conv2DBackpropFilter(x4D2, dyActivation, $filter2.shape, strides, pad3);
        const der = [xDer, filterDer];
        if ($bias2 != null) {
          const biasDer = getFusedBiasGradient2($bias2, dyActivation);
          der.push(biasDer);
        }
        return der;
      };
      const forward = (backend3) => {
        const res = backend3.fusedConv2d({
          input: x4D,
          filter: $filter,
          convInfo,
          bias: $bias,
          activation: activation2,
          preluActivationWeights: $preluActivationWeights
        });
        return res;
      };
      const inputs = {
        x: x4D,
        filter: $filter,
        bias: $bias,
        preluActivationWeights: $preluActivationWeights
      };
      const attrs = {strides, pad: pad3, dataFormat, dilations, dimRoundingMode, activation: activation2};
      if (bias == null) {
        const customOp = customGrad((x4D2, filter2, save) => {
          let res = ENGINE2.runKernelFunc(forward, inputs, null, FusedConv2D3, attrs);
          save([filter2, x4D2, res]);
          if (reshapedTo4D) {
            res = reshape5(res, [res.shape[1], res.shape[2], res.shape[3]]);
          }
          return {value: res, gradFunc: grad2};
        });
        return customOp(x4D, $filter);
      } else {
        const customOpWithBias = customGrad((x4D2, filter2, bias2, save) => {
          let res = ENGINE2.runKernelFunc(forward, inputs, null, FusedConv2D3, attrs);
          save([filter2, x4D2, res, bias2]);
          if (reshapedTo4D) {
            res = reshape5(res, [res.shape[1], res.shape[2], res.shape[3]]);
          }
          return {value: res, gradFunc: grad2};
        });
        return customOpWithBias(x4D, $filter, $bias);
      }
    }
    const conv2d$1 = op2({fusedConv2d_});
    /**
     * @license
     * Copyright 2020 Google LLC. All Rights Reserved.
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     * http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     * =============================================================================
     */
    function depthwiseConv2dNativeBackpropFilter_(x, dy, filterShape, strides, pad3, dilations = [1, 1], dimRoundingMode) {
      let x4D = x;
      if (x.rank === 3) {
        x4D = reshape5(x, [1, x.shape[0], x.shape[1], x.shape[2]]);
      }
      let dy4D = dy;
      if (dy4D.rank === 3) {
        dy4D = reshape5(dy, [1, dy.shape[0], dy.shape[1], dy.shape[2]]);
      }
      const forward = (backend3) => {
        const convInfo = computeConv2DInfo2(x.shape, filterShape, strides, dilations, pad3, dimRoundingMode, true);
        return backend3.depthwiseConv2DDerFilter(x4D, dy4D, convInfo);
      };
      const inputs = {x: x4D, dy: dy4D};
      const attrs = {strides, pad: pad3, dimRoundingMode, dilations, filterShape};
      return ENGINE2.runKernelFunc(forward, inputs, null, DepthwiseConv2dNativeBackpropFilter, attrs);
    }
    const depthwiseConv2dNativeBackpropFilter = op2({depthwiseConv2dNativeBackpropFilter_});
    /**
     * @license
     * Copyright 2020 Google LLC. All Rights Reserved.
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     * http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     * =============================================================================
     */
    function depthwiseConv2dNativeBackpropInput_(xShape, dy, filter, strides, pad3, dilations = [1, 1], dimRoundingMode) {
      let dy4D = dy;
      let reshapedTo4D = false;
      if (dy.rank === 3) {
        reshapedTo4D = true;
        dy4D = reshape5(dy, [1, dy.shape[0], dy.shape[1], dy.shape[2]]);
      }
      const forward = (backend3) => {
        const convInfo = computeConv2DInfo2(xShape, filter.shape, strides, dilations, pad3, dimRoundingMode, true);
        return backend3.depthwiseConv2DDerInput(dy4D, filter, convInfo);
      };
      const inputs = {dy: dy4D, filter};
      const attrs = {strides, pad: pad3, dimRoundingMode, dilations, inputShape: xShape};
      const res = ENGINE2.runKernelFunc(forward, inputs, null, DepthwiseConv2dNativeBackpropInput, attrs);
      if (reshapedTo4D) {
        return reshape5(res, [res.shape[1], res.shape[2], res.shape[3]]);
      }
      return res;
    }
    const depthwiseConv2dNativeBackpropInput = op2({depthwiseConv2dNativeBackpropInput_});
    /**
     * @license
     * Copyright 2019 Google LLC. All Rights Reserved.
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     * http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     * =============================================================================
     */
    function fusedDepthwiseConv2d_({x, filter, strides, pad: pad3, dataFormat = "NHWC", dilations = [1, 1], dimRoundingMode, bias, activation: activation2 = "linear", preluActivationWeights}) {
      if (shouldFuse2(ENGINE2.state.gradientDepth, activation2) === false) {
        let result = depthwiseConv2d2(x, filter, strides, pad3, dataFormat, dilations, dimRoundingMode);
        if (bias != null) {
          result = add$1(result, bias);
        }
        return applyActivation2(result, activation2, preluActivationWeights);
      }
      const $x = convertToTensor2(x, "x", "depthwiseConv2d");
      const $filter = convertToTensor2(filter, "filter", "depthwiseConv2d");
      let x4D = $x;
      let reshapedTo4D = false;
      if ($x.rank === 3) {
        reshapedTo4D = true;
        x4D = reshape5($x, [1, $x.shape[0], $x.shape[1], $x.shape[2]]);
      }
      assert2(x4D.rank === 4, () => `Error in fused depthwiseConv2d: input must be rank 4, but got rank ${x4D.rank}.`);
      assert2($filter.rank === 4, () => `Error in fused depthwiseConv2d: filter must be rank 4, but got rank ${$filter.rank}.`);
      assert2(x4D.shape[3] === $filter.shape[2], () => `Error in fused depthwiseConv2d: number of input channels (${x4D.shape[3]}) must match the inChannels dimension in filter ${$filter.shape[2]}.`);
      if (dilations == null) {
        dilations = [1, 1];
      }
      assert2(eitherStridesOrDilationsAreOne2(strides, dilations), () => `Error in fused depthwiseConv2d: Either strides or dilations must be 1. Got strides ${strides} and dilations '${dilations}'`);
      if (dimRoundingMode != null) {
        assert2(isInt2(pad3), () => `Error in fused depthwiseConv2d: pad must be an integer when using dimRoundingMode ${dimRoundingMode} but got pad ${pad3}.`);
      }
      const convInfo = computeConv2DInfo2(x4D.shape, $filter.shape, strides, dilations, pad3, dimRoundingMode, true);
      let $bias;
      if (bias != null) {
        $bias = convertToTensor2(bias, "bias", "fused conv2d");
        [$bias] = makeTypesMatch2($bias, $x);
        assertAndGetBroadcastShape2(convInfo.outShape, $bias.shape);
      }
      let $preluActivationWeights;
      if (preluActivationWeights != null) {
        $preluActivationWeights = convertToTensor2(preluActivationWeights, "prelu weights", "fused depthwiseConv2d");
      }
      const grad2 = (dy, saved) => {
        assert2(tupleValuesAreOne2(dilations), () => `Error in gradient of fused depthwiseConv2d: dilation rates greater than 1 are not yet supported. Got dilations '${dilations}'`);
        const [$filter2, x4D2, y, bias2] = saved;
        const dyActivation = getFusedDyActivation2(dy, y, activation2);
        const xDer = depthwiseConv2dNativeBackpropInput(x4D2.shape, dyActivation, $filter2, strides, pad3, dilations, dimRoundingMode);
        const filterDer = depthwiseConv2dNativeBackpropFilter(x4D2, dyActivation, $filter2.shape, strides, pad3, dilations, dimRoundingMode);
        if (bias2 != null) {
          const biasDer = getFusedBiasGradient2($bias, dyActivation);
          return [xDer, filterDer, biasDer];
        }
        return [xDer, filterDer];
      };
      const forward = (backend3) => {
        const res = backend3.fusedDepthwiseConv2D({
          input: x4D,
          filter: $filter,
          convInfo,
          bias: $bias,
          activation: activation2,
          preluActivationWeights: $preluActivationWeights
        });
        return res;
      };
      const inputs = {
        x: x4D,
        filter: $filter,
        bias: $bias,
        preluActivationWeights: $preluActivationWeights
      };
      const attrs = {strides, pad: pad3, dataFormat, dilations, dimRoundingMode, activation: activation2};
      if (bias == null) {
        const customOp = customGrad((x4D2, filter2, save) => {
          let res = ENGINE2.runKernelFunc(forward, inputs, null, FusedDepthwiseConv2D3, attrs);
          save([filter2, x4D2, res]);
          if (reshapedTo4D) {
            res = reshape5(res, [res.shape[1], res.shape[2], res.shape[3]]);
          }
          return {value: res, gradFunc: grad2};
        });
        return customOp(x4D, $filter);
      } else {
        const customOpWithBias = customGrad((x4D2, filter2, bias2, save) => {
          let res = ENGINE2.runKernelFunc(forward, inputs, null, FusedDepthwiseConv2D3, attrs);
          save([filter2, x4D2, res, bias2]);
          if (reshapedTo4D) {
            res = reshape5(res, [res.shape[1], res.shape[2], res.shape[3]]);
          }
          return {value: res, gradFunc: grad2};
        });
        return customOpWithBias(x4D, $filter, $bias);
      }
    }
    const depthwiseConv2d$1 = op2({fusedDepthwiseConv2d_});
    /**
     * @license
     * Copyright 2019 Google LLC. All Rights Reserved.
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     * http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     * =============================================================================
     */
    function fusedMatMul_({a, b, transposeA = false, transposeB = false, bias, activation: activation2 = "linear", preluActivationWeights}) {
      if (shouldFuse2(ENGINE2.state.gradientDepth, activation2) === false) {
        let result = matMul(a, b, transposeA, transposeB);
        if (bias != null) {
          result = add$1(result, bias);
        }
        return applyActivation2(result, activation2, preluActivationWeights);
      }
      let $a = convertToTensor2(a, "a", "fused matMul");
      let $b = convertToTensor2(b, "b", "fused matMul");
      [$a, $b] = makeTypesMatch2($a, $b);
      const innerShapeA = transposeA ? $a.shape[$a.rank - 2] : $a.shape[$a.rank - 1];
      const innerShapeB = transposeB ? $b.shape[$b.rank - 1] : $b.shape[$b.rank - 2];
      const outerShapeA = transposeA ? $a.shape[$a.rank - 1] : $a.shape[$a.rank - 2];
      const outerShapeB = transposeB ? $b.shape[$b.rank - 2] : $b.shape[$b.rank - 1];
      const outerDimsA = $a.shape.slice(0, -2);
      const outerDimsB = $b.shape.slice(0, -2);
      const batchDimA = sizeFromShape2(outerDimsA);
      const batchDimB = sizeFromShape2(outerDimsB);
      assert2($a.rank >= 2 && $b.rank >= 2 && $a.rank === $b.rank, () => `Error in fused matMul: inputs must have the same rank of at least 2, got ranks ${$a.rank} and ${$b.rank}.`);
      assert2(arraysEqual2(outerDimsA, outerDimsB), () => `Error in fused matMul: outer dimensions (${outerDimsA}) and (${outerDimsB}) of Tensors with shapes ${$a.shape} and ${$b.shape} must match.`);
      assert2(innerShapeA === innerShapeB, () => `Error in fused matMul: inner shapes (${innerShapeA}) and (${innerShapeB}) of Tensors with shapes ${$a.shape} and ${$b.shape} and transposeA=${transposeA} and transposeB=${transposeB} must match.`);
      const outShape = $a.shape.slice(0, -2).concat([outerShapeA, outerShapeB]);
      const a3D = transposeA ? reshape5($a, [batchDimA, innerShapeA, outerShapeA]) : reshape5($a, [batchDimA, outerShapeA, innerShapeA]);
      const b3D = transposeB ? reshape5($b, [batchDimB, outerShapeB, innerShapeB]) : reshape5($b, [batchDimB, innerShapeB, outerShapeB]);
      let $bias;
      if (bias != null) {
        $bias = convertToTensor2(bias, "bias", "fused matMul");
        [$bias] = makeTypesMatch2($bias, $a);
        assertAndGetBroadcastShape2(outShape, $bias.shape);
      }
      let $preluActivationWeights;
      if (preluActivationWeights != null) {
        $preluActivationWeights = convertToTensor2(preluActivationWeights, "prelu weights", "fused matMul");
      }
      const grad2 = (dy, saved) => {
        const [a3D2, b3D2, y, $bias2] = saved;
        const dyActivation = getFusedDyActivation2(reshape5(dy, y.shape), y, activation2);
        let aDer;
        let bDer;
        if (!transposeA && !transposeB) {
          aDer = matMul(dyActivation, b3D2, false, true);
          bDer = matMul(a3D2, dyActivation, true, false);
        } else if (!transposeA && transposeB) {
          aDer = matMul(dyActivation, b3D2, false, false);
          bDer = matMul(dyActivation, a3D2, true, false);
        } else if (transposeA && !transposeB) {
          aDer = matMul(b3D2, dyActivation, false, true);
          bDer = matMul(a3D2, dyActivation, false, false);
        } else {
          aDer = matMul(b3D2, dyActivation, true, true);
          bDer = matMul(dyActivation, a3D2, true, true);
        }
        if (bias != null) {
          const biasDer = getFusedBiasGradient2($bias2, dyActivation);
          return [aDer, bDer, biasDer];
        } else {
          return [aDer, bDer];
        }
      };
      const forward = (backend3) => {
        const y = backend3.fusedBatchMatMul({
          a: a3D,
          b: b3D,
          transposeA,
          transposeB,
          bias: $bias,
          activation: activation2,
          preluActivationWeights: $preluActivationWeights
        });
        return y;
      };
      const inputs = {
        a: a3D,
        b: b3D,
        bias: $bias,
        preluActivationWeights: $preluActivationWeights
      };
      const attrs = {transposeA, transposeB, activation: activation2};
      if (bias == null) {
        const customOp = customGrad((a3D2, b3D2, save) => {
          const res = ENGINE2.runKernelFunc(forward, inputs, null, _FusedMatMul2, attrs);
          save([a3D2, b3D2, res]);
          return {value: reshape5(res, outShape), gradFunc: grad2};
        });
        return customOp(a3D, b3D);
      } else {
        const customOpWithBias = customGrad((a3D2, b3D2, $bias2, save) => {
          const res = ENGINE2.runKernelFunc(forward, inputs, null, _FusedMatMul2, attrs);
          save([a3D2, b3D2, res, $bias2]);
          return {value: reshape5(res, outShape), gradFunc: grad2};
        });
        return customOpWithBias(a3D, b3D, $bias);
      }
    }
    const matMul$1 = op2({fusedMatMul_});
    /**
     * @license
     * Copyright 2019 Google LLC. All Rights Reserved.
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     * http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     * =============================================================================
     */
    var fused_ops = /* @__PURE__ */ Object.freeze({
      __proto__: null,
      conv2d: conv2d$1,
      depthwiseConv2d: depthwiseConv2d$1,
      matMul: matMul$1
    });
    /**
     * @license
     * Copyright 2019 Google LLC. All Rights Reserved.
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     * http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     * =============================================================================
     */
    function hammingWindow_(windowLength) {
      return cosineWindow(windowLength, 0.54, 0.46);
    }
    const hammingWindow = op2({hammingWindow_});
    /**
     * @license
     * Copyright 2019 Google LLC. All Rights Reserved.
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     * http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     * =============================================================================
     */
    function hannWindow_(windowLength) {
      return cosineWindow(windowLength, 0.5, 0.5);
    }
    const hannWindow = op2({hannWindow_});
    /**
     * @license
     * Copyright 2019 Google LLC. All Rights Reserved.
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     * http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     * =============================================================================
     */
    function frame_(signal2, frameLength, frameStep, padEnd = false, padValue = 0) {
      let start = 0;
      const output = [];
      while (start + frameLength <= signal2.size) {
        output.push(slice2(signal2, start, frameLength));
        start += frameStep;
      }
      if (padEnd) {
        while (start < signal2.size) {
          const padLen = start + frameLength - signal2.size;
          const pad3 = concat2([
            slice2(signal2, start, frameLength - padLen),
            fill2([padLen], padValue)
          ]);
          output.push(pad3);
          start += frameStep;
        }
      }
      if (output.length === 0) {
        return tensor2d([], [0, frameLength]);
      }
      return reshape5(concat2(output), [output.length, frameLength]);
    }
    const frame = op2({frame_});
    /**
     * @license
     * Copyright 2019 Google LLC. All Rights Reserved.
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     * http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     * =============================================================================
     */
    function stft_(signal2, frameLength, frameStep, fftLength, windowFn = hannWindow) {
      if (fftLength == null) {
        fftLength = enclosingPowerOfTwo(frameLength);
      }
      const framedSignal = frame(signal2, frameLength, frameStep);
      const windowedSignal = mul3(framedSignal, windowFn(frameLength));
      const output = [];
      for (let i = 0; i < framedSignal.shape[0]; i++) {
        output.push(rfft(slice2(windowedSignal, [i, 0], [1, frameLength]), fftLength));
      }
      return concat2(output);
    }
    const stft = op2({stft_});
    /**
     * @license
     * Copyright 2020 Google LLC. All Rights Reserved.
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     * http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     * =============================================================================
     */
    function cropAndResize_(image3, boxes, boxInd, cropSize, method, extrapolationValue) {
      const $image = convertToTensor2(image3, "image", "cropAndResize");
      const $boxes = convertToTensor2(boxes, "boxes", "cropAndResize", "float32");
      const $boxInd = convertToTensor2(boxInd, "boxInd", "cropAndResize", "int32");
      method = method || "bilinear";
      extrapolationValue = extrapolationValue || 0;
      const numBoxes = $boxes.shape[0];
      assert2($image.rank === 4, () => `Error in cropAndResize: image must be rank 4,but got rank ${$image.rank}.`);
      assert2($boxes.rank === 2 && $boxes.shape[1] === 4, () => `Error in cropAndResize: boxes must be have size [${numBoxes},4] but had shape ${$boxes.shape}.`);
      assert2($boxInd.rank === 1 && $boxInd.shape[0] === numBoxes, () => `Error in cropAndResize: boxInd must be have size [${numBoxes}] but had shape ${$boxes.shape}.`);
      assert2(cropSize.length === 2, () => `Error in cropAndResize: cropSize must be of length 2, but got length ${cropSize.length}.`);
      assert2(cropSize[0] >= 1 && cropSize[1] >= 1, () => `cropSize must be atleast [1,1], but was ${cropSize}`);
      assert2(method === "bilinear" || method === "nearest", () => `method must be bilinear or nearest, but was ${method}`);
      const forward = (backend3) => backend3.cropAndResize($image, $boxes, $boxInd, cropSize, method, extrapolationValue);
      const inputs = {image: $image, boxes: $boxes, boxInd: $boxInd};
      const attrs = {method, extrapolationValue, cropSize};
      const res = ENGINE2.runKernelFunc(forward, inputs, null, CropAndResize3, attrs);
      return res;
    }
    const cropAndResize2 = op2({cropAndResize_});
    /**
     * @license
     * Copyright 2020 Google LLC. All Rights Reserved.
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     * http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     * =============================================================================
     */
    function flipLeftRight_(image3) {
      const $image = convertToTensor2(image3, "image", "flipLeftRight", "float32");
      assert2($image.rank === 4, () => `Error in flipLeftRight: image must be rank 4,but got rank ${$image.rank}.`);
      const inputs = {image: $image};
      const res = ENGINE2.runKernel(FlipLeftRight3, inputs, {});
      return res;
    }
    const flipLeftRight2 = op2({flipLeftRight_});
    /**
     * @license
     * Copyright 2020 Google LLC. All Rights Reserved.
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     * http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     * =============================================================================
     */
    function rotateWithOffset_(image3, radians, fillValue = 0, center = 0.5) {
      const $image = convertToTensor2(image3, "image", "rotateWithOffset", "float32");
      assert2($image.rank === 4, () => `Error in rotateWithOffset: image must be rank 4,but got rank ${$image.rank}.`);
      const inputs = {image: $image};
      const attrs = {radians, fillValue, center};
      const res = ENGINE2.runKernel(RotateWithOffset3, inputs, attrs);
      return res;
    }
    const rotateWithOffset2 = op2({rotateWithOffset_});
    /**
     * @license
     * Copyright 2020 Google LLC. All Rights Reserved.
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     * http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     * =============================================================================
     */
    function nonMaxSuppSanityCheck(boxes, scores, maxOutputSize, iouThreshold, scoreThreshold, softNmsSigma) {
      if (iouThreshold == null) {
        iouThreshold = 0.5;
      }
      if (scoreThreshold == null) {
        scoreThreshold = Number.NEGATIVE_INFINITY;
      }
      if (softNmsSigma == null) {
        softNmsSigma = 0;
      }
      const numBoxes = boxes.shape[0];
      maxOutputSize = Math.min(maxOutputSize, numBoxes);
      assert2(0 <= iouThreshold && iouThreshold <= 1, () => `iouThreshold must be in [0, 1], but was '${iouThreshold}'`);
      assert2(boxes.rank === 2, () => `boxes must be a 2D tensor, but was of rank '${boxes.rank}'`);
      assert2(boxes.shape[1] === 4, () => `boxes must have 4 columns, but 2nd dimension was ${boxes.shape[1]}`);
      assert2(scores.rank === 1, () => "scores must be a 1D tensor");
      assert2(scores.shape[0] === numBoxes, () => `scores has incompatible shape with boxes. Expected ${numBoxes}, but was ${scores.shape[0]}`);
      assert2(0 <= softNmsSigma && softNmsSigma <= 1, () => `softNmsSigma must be in [0, 1], but was '${softNmsSigma}'`);
      return {maxOutputSize, iouThreshold, scoreThreshold, softNmsSigma};
    }
    /**
     * @license
     * Copyright 2020 Google LLC. All Rights Reserved.
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     * http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     * =============================================================================
     */
    function nonMaxSuppression_(boxes, scores, maxOutputSize, iouThreshold = 0.5, scoreThreshold = Number.NEGATIVE_INFINITY) {
      const $boxes = convertToTensor2(boxes, "boxes", "nonMaxSuppression");
      const $scores = convertToTensor2(scores, "scores", "nonMaxSuppression");
      const inputs = nonMaxSuppSanityCheck($boxes, $scores, maxOutputSize, iouThreshold, scoreThreshold);
      maxOutputSize = inputs.maxOutputSize;
      iouThreshold = inputs.iouThreshold;
      scoreThreshold = inputs.scoreThreshold;
      const attrs = {maxOutputSize, iouThreshold, scoreThreshold};
      return ENGINE2.runKernelFunc((b) => b.nonMaxSuppression($boxes, $scores, maxOutputSize, iouThreshold, scoreThreshold), {boxes: $boxes, scores: $scores}, null, NonMaxSuppressionV33, attrs);
    }
    const nonMaxSuppression = op2({nonMaxSuppression_});
    /**
     * @license
     * Copyright 2019 Google LLC. All Rights Reserved.
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     * http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     * =============================================================================
     */
    function binaryInsert(arr, element, comparator) {
      const index2 = binarySearch(arr, element, comparator);
      const insertionPoint = index2 < 0 ? -(index2 + 1) : index2;
      arr.splice(insertionPoint, 0, element);
    }
    function binarySearch(arr, target, comparator) {
      return binarySearch_(arr, target, comparator || defaultComparator);
    }
    function defaultComparator(a, b) {
      return a > b ? 1 : a < b ? -1 : 0;
    }
    function binarySearch_(arr, target, comparator) {
      let left = 0;
      let right = arr.length;
      let middle = 0;
      let found = false;
      while (left < right) {
        middle = left + (right - left >>> 1);
        const compareResult = comparator(target, arr[middle]);
        if (compareResult > 0) {
          left = middle + 1;
        } else {
          right = middle;
          found = !compareResult;
        }
      }
      return found ? left : -left - 1;
    }
    /**
     * @license
     * Copyright 2020 Google LLC. All Rights Reserved.
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     * http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     * =============================================================================
     */
    function nonMaxSuppressionV3Impl(boxes, scores, maxOutputSize, iouThreshold, scoreThreshold) {
      return nonMaxSuppressionImpl_(boxes, scores, maxOutputSize, iouThreshold, scoreThreshold, 0).selectedIndices;
    }
    function nonMaxSuppressionV4Impl(boxes, scores, maxOutputSize, iouThreshold, scoreThreshold, padToMaxOutputSize) {
      return nonMaxSuppressionImpl_(boxes, scores, maxOutputSize, iouThreshold, scoreThreshold, 0, false, padToMaxOutputSize, true);
    }
    function nonMaxSuppressionV5Impl(boxes, scores, maxOutputSize, iouThreshold, scoreThreshold, softNmsSigma) {
      return nonMaxSuppressionImpl_(boxes, scores, maxOutputSize, iouThreshold, scoreThreshold, softNmsSigma, true);
    }
    function nonMaxSuppressionImpl_(boxes, scores, maxOutputSize, iouThreshold, scoreThreshold, softNmsSigma, returnScoresTensor = false, padToMaxOutputSize = false, returnValidOutputs = false) {
      const candidates = [];
      for (let i = 0; i < scores.length; i++) {
        if (scores[i] > scoreThreshold) {
          candidates.push({score: scores[i], boxIndex: i, suppressBeginIndex: 0});
        }
      }
      candidates.sort(ascendingComparator);
      const scale2 = softNmsSigma > 0 ? -0.5 / softNmsSigma : 0;
      const selectedIndices = [];
      const selectedScores = [];
      while (selectedIndices.length < maxOutputSize && candidates.length > 0) {
        const candidate = candidates.pop();
        const {score: originalScore, boxIndex, suppressBeginIndex} = candidate;
        if (originalScore < scoreThreshold) {
          break;
        }
        let ignoreCandidate = false;
        for (let j = selectedIndices.length - 1; j >= suppressBeginIndex; --j) {
          const iou = intersectionOverUnion(boxes, boxIndex, selectedIndices[j]);
          if (iou >= iouThreshold) {
            ignoreCandidate = true;
            break;
          }
          candidate.score = candidate.score * suppressWeight(iouThreshold, scale2, iou);
          if (candidate.score <= scoreThreshold) {
            break;
          }
        }
        candidate.suppressBeginIndex = selectedIndices.length;
        if (!ignoreCandidate) {
          if (candidate.score === originalScore) {
            selectedIndices.push(boxIndex);
            selectedScores.push(candidate.score);
          } else if (candidate.score > scoreThreshold) {
            binaryInsert(candidates, candidate, ascendingComparator);
          }
        }
      }
      const validOutputs = selectedIndices.length;
      const elemsToPad = maxOutputSize - validOutputs;
      if (padToMaxOutputSize && elemsToPad > 0) {
        selectedIndices.push(...new Array(elemsToPad).fill(0));
        selectedScores.push(...new Array(elemsToPad).fill(0));
      }
      const result = {selectedIndices: tensor1d3(selectedIndices, "int32")};
      if (returnScoresTensor) {
        result["selectedScores"] = tensor1d3(selectedScores, "float32");
      }
      if (returnValidOutputs) {
        result["validOutputs"] = scalar3(validOutputs, "int32");
      }
      return result;
    }
    function intersectionOverUnion(boxes, i, j) {
      const iCoord = boxes.subarray(i * 4, i * 4 + 4);
      const jCoord = boxes.subarray(j * 4, j * 4 + 4);
      const yminI = Math.min(iCoord[0], iCoord[2]);
      const xminI = Math.min(iCoord[1], iCoord[3]);
      const ymaxI = Math.max(iCoord[0], iCoord[2]);
      const xmaxI = Math.max(iCoord[1], iCoord[3]);
      const yminJ = Math.min(jCoord[0], jCoord[2]);
      const xminJ = Math.min(jCoord[1], jCoord[3]);
      const ymaxJ = Math.max(jCoord[0], jCoord[2]);
      const xmaxJ = Math.max(jCoord[1], jCoord[3]);
      const areaI = (ymaxI - yminI) * (xmaxI - xminI);
      const areaJ = (ymaxJ - yminJ) * (xmaxJ - xminJ);
      if (areaI <= 0 || areaJ <= 0) {
        return 0;
      }
      const intersectionYmin = Math.max(yminI, yminJ);
      const intersectionXmin = Math.max(xminI, xminJ);
      const intersectionYmax = Math.min(ymaxI, ymaxJ);
      const intersectionXmax = Math.min(xmaxI, xmaxJ);
      const intersectionArea = Math.max(intersectionYmax - intersectionYmin, 0) * Math.max(intersectionXmax - intersectionXmin, 0);
      return intersectionArea / (areaI + areaJ - intersectionArea);
    }
    function suppressWeight(iouThreshold, scale2, iou) {
      const weight = Math.exp(scale2 * iou * iou);
      return iou <= iouThreshold ? weight : 0;
    }
    function ascendingComparator(c1, c2) {
      return c1.score - c2.score || c1.score === c2.score && c2.boxIndex - c1.boxIndex;
    }
    /**
     * @license
     * Copyright 2020 Google LLC. All Rights Reserved.
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     * http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     * =============================================================================
     */
    async function nonMaxSuppressionAsync_(boxes, scores, maxOutputSize, iouThreshold = 0.5, scoreThreshold = Number.NEGATIVE_INFINITY) {
      const $boxes = convertToTensor2(boxes, "boxes", "nonMaxSuppressionAsync");
      const $scores = convertToTensor2(scores, "scores", "nonMaxSuppressionAsync");
      const inputs = nonMaxSuppSanityCheck($boxes, $scores, maxOutputSize, iouThreshold, scoreThreshold);
      maxOutputSize = inputs.maxOutputSize;
      iouThreshold = inputs.iouThreshold;
      scoreThreshold = inputs.scoreThreshold;
      const boxesAndScores = await Promise.all([$boxes.data(), $scores.data()]);
      const boxesVals = boxesAndScores[0];
      const scoresVals = boxesAndScores[1];
      const res = nonMaxSuppressionV3Impl(boxesVals, scoresVals, maxOutputSize, iouThreshold, scoreThreshold);
      if ($boxes !== boxes) {
        $boxes.dispose();
      }
      if ($scores !== scores) {
        $scores.dispose();
      }
      return res;
    }
    const nonMaxSuppressionAsync = nonMaxSuppressionAsync_;
    /**
     * @license
     * Copyright 2020 Google LLC. All Rights Reserved.
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     * http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     * =============================================================================
     */
    function nonMaxSuppressionWithScore_(boxes, scores, maxOutputSize, iouThreshold = 0.5, scoreThreshold = Number.NEGATIVE_INFINITY, softNmsSigma = 0) {
      const $boxes = convertToTensor2(boxes, "boxes", "nonMaxSuppression");
      const $scores = convertToTensor2(scores, "scores", "nonMaxSuppression");
      const params = nonMaxSuppSanityCheck($boxes, $scores, maxOutputSize, iouThreshold, scoreThreshold, softNmsSigma);
      maxOutputSize = params.maxOutputSize;
      iouThreshold = params.iouThreshold;
      scoreThreshold = params.scoreThreshold;
      softNmsSigma = params.softNmsSigma;
      const inputs = {boxes: $boxes, scores: $scores};
      const attrs = {maxOutputSize, iouThreshold, scoreThreshold, softNmsSigma};
      const result = ENGINE2.runKernel(NonMaxSuppressionV53, inputs, attrs);
      return {selectedIndices: result[0], selectedScores: result[1]};
    }
    const nonMaxSuppressionWithScore = op2({nonMaxSuppressionWithScore_});
    /**
     * @license
     * Copyright 2020 Google LLC. All Rights Reserved.
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     * http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     * =============================================================================
     */
    async function nonMaxSuppressionWithScoreAsync_(boxes, scores, maxOutputSize, iouThreshold = 0.5, scoreThreshold = Number.NEGATIVE_INFINITY, softNmsSigma = 0) {
      const $boxes = convertToTensor2(boxes, "boxes", "nonMaxSuppressionAsync");
      const $scores = convertToTensor2(scores, "scores", "nonMaxSuppressionAsync");
      const params = nonMaxSuppSanityCheck($boxes, $scores, maxOutputSize, iouThreshold, scoreThreshold, softNmsSigma);
      maxOutputSize = params.maxOutputSize;
      iouThreshold = params.iouThreshold;
      scoreThreshold = params.scoreThreshold;
      softNmsSigma = params.softNmsSigma;
      const boxesAndScores = await Promise.all([$boxes.data(), $scores.data()]);
      const boxesVals = boxesAndScores[0];
      const scoresVals = boxesAndScores[1];
      const res = nonMaxSuppressionV5Impl(boxesVals, scoresVals, maxOutputSize, iouThreshold, scoreThreshold, softNmsSigma);
      if ($boxes !== boxes) {
        $boxes.dispose();
      }
      if ($scores !== scores) {
        $scores.dispose();
      }
      return res;
    }
    const nonMaxSuppressionWithScoreAsync = nonMaxSuppressionWithScoreAsync_;
    /**
     * @license
     * Copyright 2020 Google LLC. All Rights Reserved.
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     * http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     * =============================================================================
     */
    function nonMaxSuppressionPadded_(boxes, scores, maxOutputSize, iouThreshold = 0.5, scoreThreshold = Number.NEGATIVE_INFINITY, padToMaxOutputSize = false) {
      const $boxes = convertToTensor2(boxes, "boxes", "nonMaxSuppression");
      const $scores = convertToTensor2(scores, "scores", "nonMaxSuppression");
      const params = nonMaxSuppSanityCheck($boxes, $scores, maxOutputSize, iouThreshold, scoreThreshold, null);
      const $maxOutputSize = params.maxOutputSize;
      const $iouThreshold = params.iouThreshold;
      const $scoreThreshold = params.scoreThreshold;
      const inputs = {boxes: $boxes, scores: $scores};
      const attrs = {
        maxOutputSize: $maxOutputSize,
        iouThreshold: $iouThreshold,
        scoreThreshold: $scoreThreshold,
        padToMaxOutputSize
      };
      const result = ENGINE2.runKernel(NonMaxSuppressionV43, inputs, attrs);
      return {selectedIndices: result[0], validOutputs: result[1]};
    }
    const nonMaxSuppressionPadded = op2({nonMaxSuppressionPadded_});
    /**
     * @license
     * Copyright 2020 Google LLC. All Rights Reserved.
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     * http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     * =============================================================================
     */
    async function nonMaxSuppressionPaddedAsync_(boxes, scores, maxOutputSize, iouThreshold = 0.5, scoreThreshold = Number.NEGATIVE_INFINITY, padToMaxOutputSize = false) {
      const $boxes = convertToTensor2(boxes, "boxes", "nonMaxSuppressionAsync");
      const $scores = convertToTensor2(scores, "scores", "nonMaxSuppressionAsync");
      const params = nonMaxSuppSanityCheck($boxes, $scores, maxOutputSize, iouThreshold, scoreThreshold, null);
      const $maxOutputSize = params.maxOutputSize;
      const $iouThreshold = params.iouThreshold;
      const $scoreThreshold = params.scoreThreshold;
      const [boxesVals, scoresVals] = await Promise.all([$boxes.data(), $scores.data()]);
      const res = nonMaxSuppressionV4Impl(boxesVals, scoresVals, $maxOutputSize, $iouThreshold, $scoreThreshold, padToMaxOutputSize);
      if ($boxes !== boxes) {
        $boxes.dispose();
      }
      if ($scores !== scores) {
        $scores.dispose();
      }
      return res;
    }
    const nonMaxSuppressionPaddedAsync = nonMaxSuppressionPaddedAsync_;
    /**
     * @license
     * Copyright 2020 Google LLC. All Rights Reserved.
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     * http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     * =============================================================================
     */
    function resizeBilinear_(images, size, alignCorners = false) {
      const $images = convertToTensor2(images, "images", "resizeBilinear");
      assert2($images.rank === 3 || $images.rank === 4, () => `Error in resizeBilinear: x must be rank 3 or 4, but got rank ${$images.rank}.`);
      assert2(size.length === 2, () => `Error in resizeBilinear: new shape must 2D, but got shape ${size}.`);
      let batchImages = $images;
      let reshapedTo4D = false;
      if ($images.rank === 3) {
        reshapedTo4D = true;
        batchImages = reshape5($images, [1, $images.shape[0], $images.shape[1], $images.shape[2]]);
      }
      const [newHeight, newWidth] = size;
      const forward = (backend3, save) => {
        save([batchImages]);
        return backend3.resizeBilinear(batchImages, newHeight, newWidth, alignCorners);
      };
      const inputs = {images: batchImages};
      const attrs = {alignCorners, size};
      const res = ENGINE2.runKernelFunc(forward, inputs, null, ResizeBilinear3, attrs);
      if (reshapedTo4D) {
        return reshape5(res, [res.shape[1], res.shape[2], res.shape[3]]);
      }
      return res;
    }
    const resizeBilinear2 = op2({resizeBilinear_});
    /**
     * @license
     * Copyright 2020 Google LLC. All Rights Reserved.
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     * http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     * =============================================================================
     */
    function resizeNearestNeighbor_(images, size, alignCorners = false) {
      const $images = convertToTensor2(images, "images", "resizeNearestNeighbor");
      assert2($images.rank === 3 || $images.rank === 4, () => `Error in resizeNearestNeighbor: x must be rank 3 or 4, but got rank ${$images.rank}.`);
      assert2(size.length === 2, () => `Error in resizeNearestNeighbor: new shape must 2D, but got shape ${size}.`);
      assert2($images.dtype === "float32" || $images.dtype === "int32", () => "`images` must have `int32` or `float32` as dtype");
      let batchImages = $images;
      let reshapedTo4D = false;
      if ($images.rank === 3) {
        reshapedTo4D = true;
        batchImages = reshape5($images, [1, $images.shape[0], $images.shape[1], $images.shape[2]]);
      }
      const [newHeight, newWidth] = size;
      const inputs = {images: batchImages};
      const attrs = {alignCorners, size};
      const forward = (backend3, save) => {
        save([batchImages]);
        return backend3.resizeNearestNeighbor(batchImages, newHeight, newWidth, alignCorners);
      };
      const res = ENGINE2.runKernelFunc(forward, inputs, null, ResizeNearestNeighbor, attrs);
      if (reshapedTo4D) {
        return reshape5(res, [res.shape[1], res.shape[2], res.shape[3]]);
      }
      return res;
    }
    const resizeNearestNeighbor = op2({resizeNearestNeighbor_});
    /**
     * @license
     * Copyright 2020 Google LLC. All Rights Reserved.
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     * http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     * =============================================================================
     */
    function bandPart_(a, numLower, numUpper) {
      assert2(numLower % 1 === 0, () => `bandPart(): numLower must be an integer, got ${numLower}.`);
      assert2(numUpper % 1 === 0, () => `bandPart(): numUpper must be an integer, got ${numUpper}.`);
      const $a = convertToTensor2(a, "a", "bandPart");
      assert2($a.rank >= 2, () => `bandPart(): Rank must be at least 2, got ${$a.rank}.`);
      const shape = $a.shape;
      const [M, N] = $a.shape.slice(-2);
      if (!(numLower <= M)) {
        throw new Error(`bandPart(): numLower (${numLower}) must not be greater than the number of rows (${M}).`);
      }
      if (!(numUpper <= N)) {
        throw new Error(`bandPart(): numUpper (${numUpper}) must not be greater than the number of columns (${N}).`);
      }
      if (numLower < 0) {
        numLower = M;
      }
      if (numUpper < 0) {
        numUpper = N;
      }
      const i = reshape5(range(0, M, 1, "int32"), [-1, 1]);
      const j = range(0, N, 1, "int32");
      const ij = sub(i, j);
      const inBand = logicalAnd(lessEqual(ij, scalar3(+numLower, "int32")), greaterEqual(ij, scalar3(-numUpper, "int32")));
      const zero = zeros3([M, N], $a.dtype);
      return reshape5(stack(unstack(reshape5($a, [-1, M, N])).map((mat) => where(inBand, mat, zero))), shape);
    }
    const bandPart = op2({bandPart_});
    /**
     * @license
     * Copyright 2020 Google LLC. All Rights Reserved.
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     * http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     * =============================================================================
     */
    function gramSchmidt_(xs) {
      let inputIsTensor2D;
      if (Array.isArray(xs)) {
        inputIsTensor2D = false;
        assert2(xs != null && xs.length > 0, () => "Gram-Schmidt process: input must not be null, undefined, or empty");
        const dim = xs[0].shape[0];
        for (let i = 1; i < xs.length; ++i) {
          assert2(xs[i].shape[0] === dim, () => `Gram-Schmidt: Non-unique lengths found in the input vectors: (${xs[i].shape[0]} vs. ${dim})`);
        }
      } else {
        inputIsTensor2D = true;
        xs = split2(xs, xs.shape[0], 0).map((x) => squeeze(x, [0]));
      }
      assert2(xs.length <= xs[0].shape[0], () => `Gram-Schmidt: Number of vectors (${xs.length}) exceeds number of dimensions (${xs[0].shape[0]}).`);
      const ys = [];
      const xs1d = xs;
      for (let i = 0; i < xs.length; ++i) {
        ys.push(ENGINE2.tidy(() => {
          let x = xs1d[i];
          if (i > 0) {
            for (let j = 0; j < i; ++j) {
              const proj = mul3(sum$1(mul3(ys[j], x)), ys[j]);
              x = sub(x, proj);
            }
          }
          return div(x, norm(x, "euclidean"));
        }));
      }
      if (inputIsTensor2D) {
        return stack(ys, 0);
      } else {
        return ys;
      }
    }
    const gramSchmidt = op2({gramSchmidt_});
    /**
     * @license
     * Copyright 2020 Google LLC. All Rights Reserved.
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     * http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     * =============================================================================
     */
    function qr_(x, fullMatrices = false) {
      assert2(x.rank >= 2, () => `qr() requires input tensor to have a rank >= 2, but got rank ${x.rank}`);
      if (x.rank === 2) {
        return qr2d(x, fullMatrices);
      } else {
        const outerDimsProd = x.shape.slice(0, x.shape.length - 2).reduce((value, prev) => value * prev);
        const x2ds = unstack(reshape5(x, [
          outerDimsProd,
          x.shape[x.shape.length - 2],
          x.shape[x.shape.length - 1]
        ]), 0);
        const q2ds = [];
        const r2ds = [];
        x2ds.forEach((x2d) => {
          const [q2d, r2d] = qr2d(x2d, fullMatrices);
          q2ds.push(q2d);
          r2ds.push(r2d);
        });
        const q = reshape5(stack(q2ds, 0), x.shape);
        const r = reshape5(stack(r2ds, 0), x.shape);
        return [q, r];
      }
    }
    function qr2d(x, fullMatrices = false) {
      return ENGINE2.tidy(() => {
        assert2(x.shape.length === 2, () => `qr2d() requires a 2D Tensor, but got a ${x.shape.length}D Tensor.`);
        const m = x.shape[0];
        const n = x.shape[1];
        let q = eye(m);
        let r = clone(x);
        const one2D = tensor2d([[1]], [1, 1]);
        let w = clone(one2D);
        const iters = m >= n ? n : m;
        for (let j = 0; j < iters; ++j) {
          const rTemp = r;
          const wTemp = w;
          const qTemp = q;
          [w, r, q] = ENGINE2.tidy(() => {
            const rjEnd1 = slice2(r, [j, j], [m - j, 1]);
            const normX = norm(rjEnd1);
            const rjj = slice2(r, [j, j], [1, 1]);
            const s = where(greater(rjj, 0), tensor2d([[-1]]), tensor2d([[1]]));
            const u1 = sub(rjj, mul3(s, normX));
            const wPre = div(rjEnd1, u1);
            if (wPre.shape[0] === 1) {
              w = clone(one2D);
            } else {
              w = concat2([
                one2D,
                slice2(wPre, [1, 0], [wPre.shape[0] - 1, wPre.shape[1]])
              ], 0);
            }
            const tau = neg(div(matMul(s, u1), normX));
            const rjEndAll = slice2(r, [j, 0], [m - j, n]);
            const tauTimesW = mul3(tau, w);
            const wT = transpose4(w);
            if (j === 0) {
              r = sub(rjEndAll, matMul(tauTimesW, matMul(wT, rjEndAll)));
            } else {
              const rTimesTau = sub(rjEndAll, matMul(tauTimesW, matMul(wT, rjEndAll)));
              r = concat2([slice2(r, [0, 0], [j, n]), rTimesTau], 0);
            }
            const tawTimesWT = transpose4(tauTimesW);
            const qAllJEnd = slice2(q, [0, j], [m, q.shape[1] - j]);
            if (j === 0) {
              q = sub(qAllJEnd, matMul(matMul(qAllJEnd, w), tawTimesWT));
            } else {
              const qTimesTau = sub(qAllJEnd, matMul(matMul(qAllJEnd, w), tawTimesWT));
              q = concat2([slice2(q, [0, 0], [m, j]), qTimesTau], 1);
            }
            return [w, r, q];
          });
          dispose([rTemp, wTemp, qTemp]);
        }
        if (!fullMatrices && m > n) {
          q = slice2(q, [0, 0], [m, n]);
          r = slice2(r, [0, 0], [n, n]);
        }
        return [q, r];
      });
    }
    const qr = op2({qr_});
    /**
     * @license
     * Copyright 2020 Google LLC. All Rights Reserved.
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     * http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     * =============================================================================
     */
    (function(Reduction) {
      Reduction[Reduction["NONE"] = 0] = "NONE";
      Reduction[Reduction["MEAN"] = 1] = "MEAN";
      Reduction[Reduction["SUM"] = 2] = "SUM";
      Reduction[Reduction["SUM_BY_NONZERO_WEIGHTS"] = 3] = "SUM_BY_NONZERO_WEIGHTS";
    })(exports2.Reduction || (exports2.Reduction = {}));
    function computeWeightedLoss_(losses2, weights, reduction2 = exports2.Reduction.SUM_BY_NONZERO_WEIGHTS) {
      const $losses = convertToTensor2(losses2, "losses", "computeWeightedLoss");
      let $weights = null;
      if (weights != null) {
        $weights = convertToTensor2(weights, "weights", "computeWeightedLoss");
      }
      const weightedLoss = $weights == null ? $losses : mul3($losses, $weights);
      if (reduction2 === exports2.Reduction.NONE) {
        return weightedLoss;
      }
      if (reduction2 === exports2.Reduction.SUM) {
        return sum$1(weightedLoss);
      }
      if (reduction2 === exports2.Reduction.MEAN) {
        if ($weights == null) {
          return mean(weightedLoss);
        } else {
          const broadcastFactor = $losses.size / $weights.size;
          const result = div(sum$1(weightedLoss), sum$1($weights));
          return broadcastFactor > 1 ? div(result, scalar3(broadcastFactor)) : result;
        }
      }
      if (reduction2 === exports2.Reduction.SUM_BY_NONZERO_WEIGHTS) {
        if ($weights == null) {
          return div(sum$1(weightedLoss), scalar3($losses.size));
        } else {
          const broadcastedWeights = mul3($weights, ones$1($losses.shape));
          const numNonZeros = cast7(sum$1(notEqual(broadcastedWeights, scalar3(0))), "float32");
          return div(sum$1(weightedLoss), numNonZeros);
        }
      }
      throw Error(`Unknown reduction: ${reduction2}`);
    }
    const computeWeightedLoss = op2({computeWeightedLoss_});
    /**
     * @license
     * Copyright 2020 Google LLC. All Rights Reserved.
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     * http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     * =============================================================================
     */
    function absoluteDifference_(labels, predictions, weights, reduction2 = exports2.Reduction.SUM_BY_NONZERO_WEIGHTS) {
      const $labels = convertToTensor2(labels, "labels", "absoluteDifference");
      const $predictions = convertToTensor2(predictions, "predictions", "absoluteDifference");
      let $weights = null;
      if (weights != null) {
        $weights = convertToTensor2(weights, "weights", "absoluteDifference");
      }
      assertShapesMatch2($labels.shape, $predictions.shape, "Error in absoluteDifference: ");
      const losses2 = abs(sub($labels, $predictions));
      return computeWeightedLoss(losses2, $weights, reduction2);
    }
    const absoluteDifference = op2({absoluteDifference_});
    function cosineDistance_(labels, predictions, axis, weights, reduction2 = exports2.Reduction.SUM_BY_NONZERO_WEIGHTS) {
      const $labels = convertToTensor2(labels, "labels", "cosineDistance");
      const $predictions = convertToTensor2(predictions, "predictions", "cosineDistance");
      let $weights = null;
      if (weights != null) {
        $weights = convertToTensor2(weights, "weights", "cosineDistance");
      }
      assertShapesMatch2($labels.shape, $predictions.shape, "Error in cosineDistance: ");
      const one = scalar3(1);
      const losses2 = sub(one, sum$1(mul3($labels, $predictions), axis, true));
      return computeWeightedLoss(losses2, $weights, reduction2);
    }
    const cosineDistance = op2({cosineDistance_});
    function hingeLoss_(labels, predictions, weights, reduction2 = exports2.Reduction.SUM_BY_NONZERO_WEIGHTS) {
      let $labels = convertToTensor2(labels, "labels", "hingeLoss");
      const $predictions = convertToTensor2(predictions, "predictions", "hingeLoss");
      let $weights = null;
      if (weights != null) {
        $weights = convertToTensor2(weights, "weights", "hingeLoss");
      }
      assertShapesMatch2($labels.shape, $predictions.shape, "Error in hingeLoss: ");
      const one = scalar3(1);
      $labels = sub(mul3(scalar3(2), $labels), one);
      const losses2 = relu3(sub(one, mul3($labels, $predictions)));
      return computeWeightedLoss(losses2, $weights, reduction2);
    }
    const hingeLoss = op2({hingeLoss_});
    /**
     * @license
     * Copyright 2020 Google LLC. All Rights Reserved.
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     * http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     * =============================================================================
     */
    function huberLoss_(labels, predictions, weights, delta = 1, reduction2 = exports2.Reduction.SUM_BY_NONZERO_WEIGHTS) {
      const $labels = convertToTensor2(labels, "labels", "huberLoss");
      const $predictions = convertToTensor2(predictions, "predictions", "huberLoss");
      let $weights = null;
      if (weights != null) {
        $weights = convertToTensor2(weights, "weights", "huberLoss");
      }
      assertShapesMatch2($labels.shape, $predictions.shape, "Error in huberLoss: ");
      const deltaScalar = scalar3(delta);
      const error = abs(sub($predictions, $labels));
      const quadratic = minimum(error, deltaScalar);
      const linear = sub(error, quadratic);
      const losses2 = add$1(mul3(scalar3(0.5), square(quadratic)), mul3(deltaScalar, linear));
      return computeWeightedLoss(losses2, $weights, reduction2);
    }
    const huberLoss = op2({huberLoss_});
    /**
     * @license
     * Copyright 2020 Google LLC. All Rights Reserved.
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     * http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     * =============================================================================
     */
    function logLoss_(labels, predictions, weights, epsilon2 = 1e-7, reduction2 = exports2.Reduction.SUM_BY_NONZERO_WEIGHTS) {
      const $labels = convertToTensor2(labels, "labels", "logLoss");
      const $predictions = convertToTensor2(predictions, "predictions", "logLoss");
      let $weights = null;
      if (weights != null) {
        $weights = convertToTensor2(weights, "weights", "logLoss");
      }
      assertShapesMatch2($labels.shape, $predictions.shape, "Error in logLoss: ");
      const one = scalar3(1);
      const epsilonScalar = scalar3(epsilon2);
      const l12 = neg(mul3($labels, log22(add$1($predictions, epsilonScalar))));
      const l22 = mul3(sub(one, $labels), log22(add$1(sub(one, $predictions), epsilonScalar)));
      const losses2 = sub(l12, l22);
      return computeWeightedLoss(losses2, $weights, reduction2);
    }
    const logLoss = op2({logLoss_});
    /**
     * @license
     * Copyright 2020 Google LLC. All Rights Reserved.
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     * http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     * =============================================================================
     */
    function meanSquaredError_(labels, predictions, weights, reduction2 = exports2.Reduction.SUM_BY_NONZERO_WEIGHTS) {
      const $labels = convertToTensor2(labels, "labels", "meanSquaredError");
      const $predictions = convertToTensor2(predictions, "predictions", "meanSquaredError");
      let $weights = null;
      if (weights != null) {
        $weights = convertToTensor2(weights, "weights", "meanSquaredError");
      }
      assertShapesMatch2($labels.shape, $predictions.shape, "Error in meanSquaredError: ");
      const losses2 = squaredDifference($labels, $predictions);
      return computeWeightedLoss(losses2, $weights, reduction2);
    }
    const meanSquaredError = op2({meanSquaredError_});
    /**
     * @license
     * Copyright 2020 Google LLC. All Rights Reserved.
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     * http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     * =============================================================================
     */
    function sigmoidCrossEntropyWithLogits_(labels, logits) {
      const $labels = convertToTensor2(labels, "labels", "sigmoidCrossEntropyWithLogits");
      const $logits = convertToTensor2(logits, "logits", "sigmoidCrossEntropyWithLogits");
      assertShapesMatch2($labels.shape, $logits.shape, "Error in sigmoidCrossEntropyWithLogits: ");
      const maxOutput = relu3($logits);
      const outputXTarget = mul3($logits, $labels);
      const sigmoidOutput = log1p(exp(neg(abs($logits))));
      return add$1(sub(maxOutput, outputXTarget), sigmoidOutput);
    }
    function sigmoidCrossEntropy_(multiClassLabels, logits, weights, labelSmoothing = 0, reduction2 = exports2.Reduction.SUM_BY_NONZERO_WEIGHTS) {
      let $multiClassLabels = convertToTensor2(multiClassLabels, "multiClassLabels", "sigmoidCrossEntropy");
      const $logits = convertToTensor2(logits, "logits", "sigmoidCrossEntropy");
      let $weights = null;
      if (weights != null) {
        $weights = convertToTensor2(weights, "weights", "sigmoidCrossEntropy");
      }
      assertShapesMatch2($multiClassLabels.shape, $logits.shape, "Error in sigmoidCrossEntropy: ");
      if (labelSmoothing > 0) {
        const labelSmoothingScalar = scalar3(labelSmoothing);
        const one = scalar3(1);
        const half = scalar3(0.5);
        $multiClassLabels = add$1(mul3($multiClassLabels, sub(one, labelSmoothingScalar)), mul3(half, labelSmoothingScalar));
      }
      const losses2 = sigmoidCrossEntropyWithLogits_($multiClassLabels, $logits);
      return computeWeightedLoss(losses2, $weights, reduction2);
    }
    const sigmoidCrossEntropy = op2({sigmoidCrossEntropy_});
    /**
     * @license
     * Copyright 2020 Google LLC. All Rights Reserved.
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     * http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     * =============================================================================
     */
    function softmaxCrossEntropyWithLogits_(labels, logits, dim = -1) {
      if (dim === -1) {
        dim = logits.rank - 1;
      }
      if (dim !== logits.rank - 1) {
        throw Error(`Softmax cross entropy along a non-last dimension is not yet supported. Labels / logits was rank ${logits.rank} and dim was ${dim}`);
      }
      const customOp = customGrad((labels2, logits2, save) => {
        const keepDims = true;
        const lse = logSumExp(logits2, [dim], keepDims);
        const logResult = sub(cast7(logits2, "float32"), lse);
        save([labels2, logResult]);
        const costVector = neg(mul3(logResult, labels2));
        const value = sum$1(costVector, [dim]);
        const gradFunc = (dy, saved) => {
          const [labels3, logResult2] = saved;
          const dyShape = expandShapeToKeepDim2(dy.shape, [dim]);
          return [
            mul3(reshape5(dy, dyShape), sub(cast7(labels3, "float32"), exp(logResult2))),
            mul3(reshape5(dy, dyShape), sub(exp(logResult2), cast7(labels3, "float32")))
          ];
        };
        return {value, gradFunc};
      });
      return customOp(labels, logits);
    }
    function softmaxCrossEntropy_(onehotLabels, logits, weights, labelSmoothing = 0, reduction2 = exports2.Reduction.SUM_BY_NONZERO_WEIGHTS) {
      let $onehotLabels = convertToTensor2(onehotLabels, "onehotLabels", "softmaxCrossEntropy");
      const $logits = convertToTensor2(logits, "logits", "softmaxCrossEntropy");
      let $weights = null;
      if (weights != null) {
        $weights = convertToTensor2(weights, "weights", "softmaxCrossEntropy");
      }
      assertShapesMatch2($onehotLabels.shape, $logits.shape, "Error in softmaxCrossEntropy: ");
      if (labelSmoothing > 0) {
        const labelSmoothingScalar = scalar3(labelSmoothing);
        const one = scalar3(1);
        const numClasses = scalar3($onehotLabels.shape[1]);
        $onehotLabels = add$1(mul3($onehotLabels, sub(one, labelSmoothingScalar)), div(labelSmoothingScalar, numClasses));
      }
      const losses2 = softmaxCrossEntropyWithLogits_($onehotLabels, $logits);
      return computeWeightedLoss(losses2, $weights, reduction2);
    }
    const softmaxCrossEntropy = op2({softmaxCrossEntropy_});
    /**
     * @license
     * Copyright 2020 Google LLC. All Rights Reserved.
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     * http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     * =============================================================================
     */
    const spectral = {
      fft,
      ifft,
      rfft,
      irfft
    };
    const signal = {
      hammingWindow,
      hannWindow,
      frame,
      stft
    };
    const image2 = {
      flipLeftRight: flipLeftRight2,
      resizeNearestNeighbor,
      resizeBilinear: resizeBilinear2,
      rotateWithOffset: rotateWithOffset2,
      cropAndResize: cropAndResize2,
      nonMaxSuppression,
      nonMaxSuppressionAsync,
      nonMaxSuppressionWithScore,
      nonMaxSuppressionWithScoreAsync,
      nonMaxSuppressionPadded,
      nonMaxSuppressionPaddedAsync
    };
    const linalg = {
      bandPart,
      gramSchmidt,
      qr
    };
    const losses = {
      absoluteDifference,
      computeWeightedLoss,
      cosineDistance,
      hingeLoss,
      huberLoss,
      logLoss,
      meanSquaredError,
      sigmoidCrossEntropy,
      softmaxCrossEntropy
    };
    /**
     * @license
     * Copyright 2018 Google LLC. All Rights Reserved.
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     * http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     * =============================================================================
     */
    class Optimizer extends Serializable {
      minimize(f, returnCost = false, varList) {
        const {value, grads: grads2} = this.computeGradients(f, varList);
        if (varList != null) {
          const gradArray = varList.map((v) => ({name: v.name, tensor: grads2[v.name]}));
          this.applyGradients(gradArray);
        } else {
          this.applyGradients(grads2);
        }
        dispose(grads2);
        if (returnCost) {
          return value;
        } else {
          value.dispose();
          return null;
        }
      }
      get iterations() {
        if (this.iterations_ == null) {
          this.iterations_ = 0;
        }
        return this.iterations_;
      }
      incrementIterations() {
        this.iterations_ = this.iterations + 1;
      }
      computeGradients(f, varList) {
        return variableGrads(f, varList);
      }
      dispose() {
        if (this.iterations_ != null) {
          dispose(this.iterations_);
        }
      }
      async saveIterations() {
        if (this.iterations_ == null) {
          this.iterations_ = 0;
        }
        return {
          name: "iter",
          tensor: scalar3(this.iterations_, "int32")
        };
      }
      async getWeights() {
        throw new Error("getWeights() is not implemented for this optimizer yet.");
      }
      async setWeights(weightValues) {
        throw new Error(`setWeights() is not implemented for this optimizer class ${this.getClassName()}`);
      }
      async extractIterations(weightValues) {
        this.iterations_ = (await weightValues[0].tensor.data())[0];
        return weightValues.slice(1);
      }
    }
    Object.defineProperty(Optimizer, Symbol.hasInstance, {
      value: (instance2) => {
        return instance2.minimize != null && instance2.computeGradients != null && instance2.applyGradients != null;
      }
    });
    /**
     * @license
     * Copyright 2018 Google LLC. All Rights Reserved.
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     * http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     * =============================================================================
     */
    class AdadeltaOptimizer extends Optimizer {
      constructor(learningRate, rho, epsilon2 = null) {
        super();
        this.learningRate = learningRate;
        this.rho = rho;
        this.epsilon = epsilon2;
        this.accumulatedGrads = [];
        this.accumulatedUpdates = [];
        if (epsilon2 == null) {
          this.epsilon = ENGINE2.backend.epsilon();
        }
      }
      applyGradients(variableGradients) {
        const variableNames = Array.isArray(variableGradients) ? variableGradients.map((item) => item.name) : Object.keys(variableGradients);
        variableNames.forEach((name, i) => {
          const value = ENGINE2.registeredVariables[name];
          const trainable = false;
          if (this.accumulatedGrads[i] == null) {
            this.accumulatedGrads[i] = {
              originalName: `${name}/accum_grad`,
              variable: tidy(() => zerosLike2(value).variable(trainable))
            };
          }
          if (this.accumulatedUpdates[i] == null) {
            this.accumulatedUpdates[i] = {
              originalName: `${name}/accum_var`,
              variable: tidy(() => zerosLike2(value).variable(trainable))
            };
          }
          const gradient = Array.isArray(variableGradients) ? variableGradients[i].tensor : variableGradients[name];
          if (gradient == null) {
            return;
          }
          const accumulatedGrad = this.accumulatedGrads[i].variable;
          const accumulatedUpdate = this.accumulatedUpdates[i].variable;
          tidy(() => {
            const newAccumulatedGrad = add$1(mul3(accumulatedGrad, this.rho), mul3(square(gradient), 1 - this.rho));
            const updates = mul3(div(sqrt(add$1(accumulatedUpdate, this.epsilon)), sqrt(add$1(accumulatedGrad, this.epsilon))), gradient);
            const newAccumulatedUpdate = add$1(mul3(accumulatedUpdate, this.rho), mul3(square(updates), 1 - this.rho));
            accumulatedGrad.assign(newAccumulatedGrad);
            accumulatedUpdate.assign(newAccumulatedUpdate);
            const newValue = add$1(mul3(updates, -this.learningRate), value);
            value.assign(newValue);
          });
        });
        this.incrementIterations();
      }
      dispose() {
        if (this.accumulatedUpdates != null) {
          dispose(this.accumulatedGrads.map((v) => v.variable));
          dispose(this.accumulatedUpdates.map((v) => v.variable));
        }
      }
      async getWeights() {
        const variables = [...this.accumulatedGrads, ...this.accumulatedUpdates];
        return [await this.saveIterations()].concat(variables.map((v) => ({name: v.originalName, tensor: v.variable})));
      }
      async setWeights(weightValues) {
        weightValues = await this.extractIterations(weightValues);
        const variableCount = weightValues.length / 2;
        const trainable = false;
        this.accumulatedGrads = weightValues.slice(0, variableCount).map((v) => ({
          originalName: v.name,
          variable: v.tensor.variable(trainable)
        }));
        this.accumulatedUpdates = weightValues.slice(variableCount, variableCount * 2).map((v) => ({
          originalName: v.name,
          variable: v.tensor.variable(trainable)
        }));
      }
      getConfig() {
        return {
          learningRate: this.learningRate,
          rho: this.rho,
          epsilon: this.epsilon
        };
      }
      static fromConfig(cls, config2) {
        return new cls(config2["learningRate"], config2["rho"], config2["epsilon"]);
      }
    }
    AdadeltaOptimizer.className = "Adadelta";
    registerClass(AdadeltaOptimizer);
    /**
     * @license
     * Copyright 2018 Google LLC. All Rights Reserved.
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     * http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     * =============================================================================
     */
    class AdagradOptimizer extends Optimizer {
      constructor(learningRate, initialAccumulatorValue = 0.1) {
        super();
        this.learningRate = learningRate;
        this.initialAccumulatorValue = initialAccumulatorValue;
        this.accumulatedGrads = [];
      }
      applyGradients(variableGradients) {
        const variableNames = Array.isArray(variableGradients) ? variableGradients.map((item) => item.name) : Object.keys(variableGradients);
        variableNames.forEach((name, i) => {
          const value = ENGINE2.registeredVariables[name];
          if (this.accumulatedGrads[i] == null) {
            const trainable = false;
            this.accumulatedGrads[i] = {
              originalName: `${name}/accumulator`,
              variable: tidy(() => fill2(value.shape, this.initialAccumulatorValue).variable(trainable))
            };
          }
          const gradient = Array.isArray(variableGradients) ? variableGradients[i].tensor : variableGradients[name];
          if (gradient == null) {
            return;
          }
          const accumulatedGrad = this.accumulatedGrads[i].variable;
          tidy(() => {
            const newAccumulatedGrad = add$1(accumulatedGrad, square(gradient));
            accumulatedGrad.assign(newAccumulatedGrad);
            const newValue = add$1(mul3(div(gradient, sqrt(add$1(newAccumulatedGrad, ENGINE2.backend.epsilon()))), -this.learningRate), value);
            value.assign(newValue);
          });
        });
        this.incrementIterations();
      }
      dispose() {
        if (this.accumulatedGrads != null) {
          dispose(this.accumulatedGrads.map((v) => v.variable));
        }
      }
      async getWeights() {
        return [await this.saveIterations()].concat(this.accumulatedGrads.map((v) => ({name: v.originalName, tensor: v.variable})));
      }
      async setWeights(weightValues) {
        weightValues = await this.extractIterations(weightValues);
        const trainable = false;
        this.accumulatedGrads = weightValues.map((v) => ({originalName: v.name, variable: v.tensor.variable(trainable)}));
      }
      getConfig() {
        return {
          learningRate: this.learningRate,
          initialAccumulatorValue: this.initialAccumulatorValue
        };
      }
      static fromConfig(cls, config2) {
        return new cls(config2["learningRate"], config2["initialAccumulatorValue"]);
      }
    }
    AdagradOptimizer.className = "Adagrad";
    registerClass(AdagradOptimizer);
    /**
     * @license
     * Copyright 2018 Google LLC. All Rights Reserved.
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     * http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     * =============================================================================
     */
    class AdamOptimizer extends Optimizer {
      constructor(learningRate, beta1, beta2, epsilon2 = null) {
        super();
        this.learningRate = learningRate;
        this.beta1 = beta1;
        this.beta2 = beta2;
        this.epsilon = epsilon2;
        this.accumulatedFirstMoment = [];
        this.accumulatedSecondMoment = [];
        tidy(() => {
          this.accBeta1 = scalar3(beta1).variable();
          this.accBeta2 = scalar3(beta2).variable();
        });
        if (epsilon2 == null) {
          this.epsilon = ENGINE2.backend.epsilon();
        }
      }
      applyGradients(variableGradients) {
        const varNames = Array.isArray(variableGradients) ? variableGradients.map((v) => v.name) : Object.keys(variableGradients);
        tidy(() => {
          const oneMinusAccBeta1 = sub(1, this.accBeta1);
          const oneMinusAccBeta2 = sub(1, this.accBeta2);
          varNames.forEach((name, i) => {
            const value = ENGINE2.registeredVariables[name];
            const trainable = false;
            if (this.accumulatedFirstMoment[i] == null) {
              this.accumulatedFirstMoment[i] = {
                originalName: `${name}/m`,
                variable: tidy(() => zerosLike2(value).variable(trainable))
              };
            }
            if (this.accumulatedSecondMoment[i] == null) {
              this.accumulatedSecondMoment[i] = {
                originalName: `${name}/v`,
                variable: tidy(() => zerosLike2(value).variable(trainable))
              };
            }
            const gradient = Array.isArray(variableGradients) ? variableGradients[i].tensor : variableGradients[name];
            if (gradient == null) {
              return;
            }
            const firstMoment = this.accumulatedFirstMoment[i].variable;
            const secondMoment = this.accumulatedSecondMoment[i].variable;
            const newFirstMoment = add$1(mul3(firstMoment, this.beta1), mul3(gradient, 1 - this.beta1));
            const newSecondMoment = add$1(mul3(secondMoment, this.beta2), mul3(square(gradient), 1 - this.beta2));
            const biasCorrectedFirstMoment = div(newFirstMoment, oneMinusAccBeta1);
            const biasCorrectedSecondMoment = div(newSecondMoment, oneMinusAccBeta2);
            firstMoment.assign(newFirstMoment);
            secondMoment.assign(newSecondMoment);
            const newValue = add$1(mul3(div(biasCorrectedFirstMoment, add$1(sqrt(biasCorrectedSecondMoment), this.epsilon)), -this.learningRate), value);
            value.assign(newValue);
          });
          this.accBeta1.assign(mul3(this.accBeta1, this.beta1));
          this.accBeta2.assign(mul3(this.accBeta2, this.beta2));
        });
        this.incrementIterations();
      }
      dispose() {
        this.accBeta1.dispose();
        this.accBeta2.dispose();
        if (this.accumulatedFirstMoment != null) {
          dispose(this.accumulatedFirstMoment.map((v) => v.variable));
        }
        if (this.accumulatedSecondMoment != null) {
          dispose(this.accumulatedSecondMoment.map((v) => v.variable));
        }
      }
      async getWeights() {
        const variables = [...this.accumulatedFirstMoment, ...this.accumulatedSecondMoment];
        return [await this.saveIterations()].concat(variables.map((v) => ({name: v.originalName, tensor: v.variable})));
      }
      async setWeights(weightValues) {
        weightValues = await this.extractIterations(weightValues);
        tidy(() => {
          this.accBeta1.assign(pow(this.beta1, this.iterations_ + 1));
          this.accBeta2.assign(pow(this.beta2, this.iterations_ + 1));
        });
        const variableCount = weightValues.length / 2;
        const trainable = false;
        this.accumulatedFirstMoment = weightValues.slice(0, variableCount).map((v) => ({
          originalName: v.name,
          variable: v.tensor.variable(trainable)
        }));
        this.accumulatedSecondMoment = weightValues.slice(variableCount, variableCount * 2).map((v) => ({
          originalName: v.name,
          variable: v.tensor.variable(trainable)
        }));
      }
      getConfig() {
        return {
          learningRate: this.learningRate,
          beta1: this.beta1,
          beta2: this.beta2,
          epsilon: this.epsilon
        };
      }
      static fromConfig(cls, config2) {
        return new cls(config2["learningRate"], config2["beta1"], config2["beta2"], config2["epsilon"]);
      }
    }
    AdamOptimizer.className = "Adam";
    registerClass(AdamOptimizer);
    /**
     * @license
     * Copyright 2018 Google LLC. All Rights Reserved.
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     * http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     * =============================================================================
     */
    class AdamaxOptimizer extends Optimizer {
      constructor(learningRate, beta1, beta2, epsilon2 = null, decay = 0) {
        super();
        this.learningRate = learningRate;
        this.beta1 = beta1;
        this.beta2 = beta2;
        this.epsilon = epsilon2;
        this.decay = decay;
        this.accumulatedFirstMoment = [];
        this.accumulatedWeightedInfNorm = [];
        tidy(() => {
          this.iteration = scalar3(0).variable();
          this.accBeta1 = scalar3(beta1).variable();
        });
        if (epsilon2 == null) {
          this.epsilon = ENGINE2.backend.epsilon();
        }
      }
      applyGradients(variableGradients) {
        const variableNames = Array.isArray(variableGradients) ? variableGradients.map((item) => item.name) : Object.keys(variableGradients);
        tidy(() => {
          const oneMinusAccBeta1 = sub(1, this.accBeta1);
          const lr = div(-this.learningRate, add$1(mul3(this.iteration, this.decay), 1));
          variableNames.forEach((name, i) => {
            const value = ENGINE2.registeredVariables[name];
            const trainable = false;
            if (this.accumulatedFirstMoment[i] == null) {
              this.accumulatedFirstMoment[i] = {
                originalName: `${name}/m`,
                variable: zerosLike2(value).variable(trainable)
              };
            }
            if (this.accumulatedWeightedInfNorm[i] == null) {
              this.accumulatedWeightedInfNorm[i] = {
                originalName: `${name}/v`,
                variable: zerosLike2(value).variable(trainable)
              };
            }
            const gradient = Array.isArray(variableGradients) ? variableGradients[i].tensor : variableGradients[name];
            if (gradient == null) {
              return;
            }
            const firstMoment = this.accumulatedFirstMoment[i].variable;
            const weightedInfNorm = this.accumulatedWeightedInfNorm[i].variable;
            const newFirstMoment = add$1(mul3(firstMoment, this.beta1), mul3(gradient, 1 - this.beta1));
            const ut0 = mul3(weightedInfNorm, this.beta2);
            const ut1 = abs(gradient);
            const newWeightedInfNorm = maximum(ut0, ut1);
            firstMoment.assign(newFirstMoment);
            weightedInfNorm.assign(newWeightedInfNorm);
            const newValue = add$1(mul3(div(lr, oneMinusAccBeta1), div(newFirstMoment, add$1(newWeightedInfNorm, this.epsilon))), value);
            value.assign(newValue);
          });
          this.iteration.assign(add$1(this.iteration, 1));
          this.accBeta1.assign(mul3(this.accBeta1, this.beta1));
        });
        this.incrementIterations();
      }
      dispose() {
        this.accBeta1.dispose();
        this.iteration.dispose();
        if (this.accumulatedFirstMoment != null) {
          dispose(this.accumulatedFirstMoment.map((v) => v.variable));
        }
        if (this.accumulatedWeightedInfNorm != null) {
          dispose(this.accumulatedWeightedInfNorm.map((v) => v.variable));
        }
      }
      async getWeights() {
        throw new Error("getWeights() is not implemented for Adamax yet.");
      }
      async setWeights(weightValues) {
        throw new Error("setWeights() is not implemented for Adamax yet.");
      }
      getConfig() {
        return {
          learningRate: this.learningRate,
          beta1: this.beta1,
          beta2: this.beta2,
          epsilon: this.epsilon,
          decay: this.decay
        };
      }
      static fromConfig(cls, config2) {
        return new cls(config2["learningRate"], config2["beta1"], config2["beta2"], config2["epsilon"], config2["decay"]);
      }
    }
    AdamaxOptimizer.className = "Adamax";
    registerClass(AdamaxOptimizer);
    /**
     * @license
     * Copyright 2018 Google LLC. All Rights Reserved.
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     * http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     * =============================================================================
     */
    class SGDOptimizer extends Optimizer {
      constructor(learningRate) {
        super();
        this.learningRate = learningRate;
        this.setLearningRate(learningRate);
      }
      applyGradients(variableGradients) {
        const varNames = Array.isArray(variableGradients) ? variableGradients.map((v) => v.name) : Object.keys(variableGradients);
        varNames.forEach((name, i) => {
          const gradient = Array.isArray(variableGradients) ? variableGradients[i].tensor : variableGradients[name];
          if (gradient == null) {
            return;
          }
          const value = ENGINE2.registeredVariables[name];
          tidy(() => {
            const newValue = add$1(mul3(this.c, gradient), value);
            value.assign(newValue);
          });
        });
        this.incrementIterations();
      }
      setLearningRate(learningRate) {
        this.learningRate = learningRate;
        if (this.c != null) {
          this.c.dispose();
        }
        this.c = keep(scalar3(-learningRate));
      }
      dispose() {
        this.c.dispose();
      }
      async getWeights() {
        return [await this.saveIterations()];
      }
      async setWeights(weightValues) {
        weightValues = await this.extractIterations(weightValues);
        if (weightValues.length !== 0) {
          throw new Error("SGD optimizer does not have settable weights.");
        }
      }
      getConfig() {
        return {learningRate: this.learningRate};
      }
      static fromConfig(cls, config2) {
        return new cls(config2["learningRate"]);
      }
    }
    SGDOptimizer.className = "SGD";
    registerClass(SGDOptimizer);
    /**
     * @license
     * Copyright 2018 Google LLC. All Rights Reserved.
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     * http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     * =============================================================================
     */
    class MomentumOptimizer extends SGDOptimizer {
      constructor(learningRate, momentum, useNesterov = false) {
        super(learningRate);
        this.learningRate = learningRate;
        this.momentum = momentum;
        this.useNesterov = useNesterov;
        this.accumulations = [];
        this.m = scalar3(this.momentum);
      }
      applyGradients(variableGradients) {
        const variableNames = Array.isArray(variableGradients) ? variableGradients.map((item) => item.name) : Object.keys(variableGradients);
        variableNames.forEach((name, i) => {
          const value = ENGINE2.registeredVariables[name];
          if (this.accumulations[i] == null) {
            const trainable = false;
            this.accumulations[i] = {
              originalName: `${name}/momentum`,
              variable: tidy(() => zerosLike2(value).variable(trainable))
            };
          }
          const accumulation = this.accumulations[i].variable;
          const gradient = Array.isArray(variableGradients) ? variableGradients[i].tensor : variableGradients[name];
          if (gradient == null) {
            return;
          }
          tidy(() => {
            let newValue;
            const newAccumulation = add$1(mul3(this.m, accumulation), gradient);
            if (this.useNesterov) {
              newValue = add$1(mul3(this.c, add$1(gradient, mul3(newAccumulation, this.m))), value);
            } else {
              newValue = add$1(mul3(this.c, newAccumulation), value);
            }
            accumulation.assign(newAccumulation);
            value.assign(newValue);
          });
        });
        this.incrementIterations();
      }
      dispose() {
        this.m.dispose();
        if (this.accumulations != null) {
          dispose(this.accumulations.map((v) => v.variable));
        }
      }
      setMomentum(momentum) {
        this.momentum = momentum;
      }
      async getWeights() {
        return [await this.saveIterations()].concat(this.accumulations.map((v) => ({name: v.originalName, tensor: v.variable})));
      }
      async setWeights(weightValues) {
        weightValues = await this.extractIterations(weightValues);
        const trainable = false;
        this.accumulations = weightValues.map((v) => ({originalName: v.name, variable: v.tensor.variable(trainable)}));
      }
      getConfig() {
        return {
          learningRate: this.learningRate,
          momentum: this.momentum,
          useNesterov: this.useNesterov
        };
      }
      static fromConfig(cls, config2) {
        return new cls(config2["learningRate"], config2["momentum"], config2["useNesterov"]);
      }
    }
    MomentumOptimizer.className = "Momentum";
    registerClass(MomentumOptimizer);
    /**
     * @license
     * Copyright 2018 Google LLC. All Rights Reserved.
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     * http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     * =============================================================================
     */
    class RMSPropOptimizer extends Optimizer {
      constructor(learningRate, decay = 0.9, momentum = 0, epsilon2 = null, centered = false) {
        super();
        this.learningRate = learningRate;
        this.decay = decay;
        this.momentum = momentum;
        this.epsilon = epsilon2;
        this.accumulatedMeanSquares = [];
        this.accumulatedMoments = [];
        this.accumulatedMeanGrads = [];
        this.centered = centered;
        if (epsilon2 == null) {
          this.epsilon = ENGINE2.backend.epsilon();
        }
        if (learningRate == null) {
          throw new Error(`learningRate for RMSPropOptimizer must be defined.`);
        }
      }
      applyGradients(variableGradients) {
        const variableNames = Array.isArray(variableGradients) ? variableGradients.map((item) => item.name) : Object.keys(variableGradients);
        variableNames.forEach((name, i) => {
          const value = ENGINE2.registeredVariables[name];
          const trainable = false;
          if (this.accumulatedMeanSquares[i] == null) {
            this.accumulatedMeanSquares[i] = {
              originalName: `${name}/rms`,
              variable: tidy(() => zerosLike2(value).variable(trainable))
            };
          }
          if (this.accumulatedMoments[i] == null) {
            this.accumulatedMoments[i] = {
              originalName: `${name}/momentum`,
              variable: tidy(() => zerosLike2(value).variable(trainable))
            };
          }
          if (this.accumulatedMeanGrads[i] == null && this.centered) {
            this.accumulatedMeanGrads[i] = {
              originalName: `${name}/mg`,
              variable: tidy(() => zerosLike2(value).variable(trainable))
            };
          }
          const gradient = Array.isArray(variableGradients) ? variableGradients[i].tensor : variableGradients[name];
          if (gradient == null) {
            return;
          }
          const accumulatedMeanSquare = this.accumulatedMeanSquares[i].variable;
          const accumulatedMoments = this.accumulatedMoments[i].variable;
          tidy(() => {
            const newAccumulatedMeanSquare = add$1(mul3(accumulatedMeanSquare, this.decay), mul3(square(gradient), 1 - this.decay));
            if (this.centered) {
              const accumulatedMeanGrad = this.accumulatedMeanGrads[i].variable;
              const newAccumulatedMeanGrad = add$1(mul3(accumulatedMeanGrad, this.decay), mul3(gradient, 1 - this.decay));
              const gradContribution = div(mul3(gradient, this.learningRate), sqrt(sub(newAccumulatedMeanSquare, add$1(square(newAccumulatedMeanGrad), this.epsilon))));
              const newAccumulatedMoments = add$1(mul3(accumulatedMoments, this.momentum), gradContribution);
              accumulatedMeanSquare.assign(newAccumulatedMeanSquare);
              accumulatedMeanGrad.assign(newAccumulatedMeanGrad);
              accumulatedMoments.assign(newAccumulatedMoments);
              const newValue = sub(value, newAccumulatedMoments);
              value.assign(newValue);
            } else {
              const newAccumulatedMeanSquare2 = add$1(mul3(accumulatedMeanSquare, this.decay), mul3(square(gradient), 1 - this.decay));
              const newAccumulatedMoments = add$1(mul3(accumulatedMoments, this.momentum), div(mul3(gradient, this.learningRate), sqrt(add$1(newAccumulatedMeanSquare2, this.epsilon))));
              accumulatedMeanSquare.assign(newAccumulatedMeanSquare2);
              accumulatedMoments.assign(newAccumulatedMoments);
              const newValue = sub(value, newAccumulatedMoments);
              value.assign(newValue);
            }
          });
        });
        this.incrementIterations();
      }
      dispose() {
        if (this.accumulatedMeanSquares != null) {
          dispose(this.accumulatedMeanSquares.map((v) => v.variable));
        }
        if (this.accumulatedMeanGrads != null && this.centered) {
          dispose(this.accumulatedMeanGrads.map((v) => v.variable));
        }
        if (this.accumulatedMoments != null) {
          dispose(this.accumulatedMoments.map((v) => v.variable));
        }
      }
      async getWeights() {
        const variables = [...this.accumulatedMeanSquares, ...this.accumulatedMoments];
        if (this.centered) {
          variables.push(...this.accumulatedMeanGrads);
        }
        return [await this.saveIterations()].concat(variables.map((v) => ({name: v.originalName, tensor: v.variable})));
      }
      async setWeights(weightValues) {
        weightValues = await this.extractIterations(weightValues);
        const variableCount = this.centered ? weightValues.length / 3 : weightValues.length / 2;
        const trainable = false;
        this.accumulatedMeanSquares = weightValues.slice(0, variableCount).map((v) => ({
          originalName: v.name,
          variable: v.tensor.variable(trainable)
        }));
        this.accumulatedMoments = weightValues.slice(variableCount, variableCount * 2).map((v) => ({
          originalName: v.name,
          variable: v.tensor.variable(trainable)
        }));
        if (this.centered) {
          this.accumulatedMeanGrads = weightValues.slice(variableCount * 2, variableCount * 3).map((v) => ({
            originalName: v.name,
            variable: v.tensor.variable(trainable)
          }));
        }
      }
      getConfig() {
        return {
          learningRate: this.learningRate,
          decay: this.decay,
          momentum: this.momentum,
          epsilon: this.epsilon,
          centered: this.centered
        };
      }
      static fromConfig(cls, config2) {
        return new cls(config2["learningRate"], config2["decay"], config2["momentum"], config2["epsilon"], config2["centered"]);
      }
    }
    RMSPropOptimizer.className = "RMSProp";
    registerClass(RMSPropOptimizer);
    /**
     * @license
     * Copyright 2018 Google LLC. All Rights Reserved.
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     * http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     * =============================================================================
     */
    class OptimizerConstructors {
      static sgd(learningRate) {
        return new SGDOptimizer(learningRate);
      }
      static momentum(learningRate, momentum, useNesterov = false) {
        return new MomentumOptimizer(learningRate, momentum, useNesterov);
      }
      static rmsprop(learningRate, decay = 0.9, momentum = 0, epsilon2 = null, centered = false) {
        return new RMSPropOptimizer(learningRate, decay, momentum, epsilon2, centered);
      }
      static adam(learningRate = 1e-3, beta1 = 0.9, beta2 = 0.999, epsilon2 = null) {
        return new AdamOptimizer(learningRate, beta1, beta2, epsilon2);
      }
      static adadelta(learningRate = 1e-3, rho = 0.95, epsilon2 = null) {
        return new AdadeltaOptimizer(learningRate, rho, epsilon2);
      }
      static adamax(learningRate = 2e-3, beta1 = 0.9, beta2 = 0.999, epsilon2 = null, decay = 0) {
        return new AdamaxOptimizer(learningRate, beta1, beta2, epsilon2, decay);
      }
      static adagrad(learningRate, initialAccumulatorValue = 0.1) {
        return new AdagradOptimizer(learningRate, initialAccumulatorValue);
      }
    }
    /**
     * @license
     * Copyright 2018 Google LLC. All Rights Reserved.
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     * http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     * =============================================================================
     */
    [
      MomentumOptimizer,
      SGDOptimizer,
      AdadeltaOptimizer,
      AdagradOptimizer,
      RMSPropOptimizer,
      AdamaxOptimizer,
      AdamOptimizer
    ];
    const train = {
      sgd: OptimizerConstructors.sgd,
      momentum: OptimizerConstructors.momentum,
      adadelta: OptimizerConstructors.adadelta,
      adagrad: OptimizerConstructors.adagrad,
      rmsprop: OptimizerConstructors.rmsprop,
      adamax: OptimizerConstructors.adamax,
      adam: OptimizerConstructors.adam
    };
    /**
     * @license
     * Copyright 2017 Google LLC. All Rights Reserved.
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     * http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     * =============================================================================
     */
    const delayCallback = (() => {
      if (typeof requestAnimationFrame !== "undefined") {
        return requestAnimationFrame;
      } else if (typeof setImmediate !== "undefined") {
        return setImmediate;
      }
      return (f) => f();
    })();
    function nextFrame() {
      return new Promise((resolve) => delayCallback(() => resolve()));
    }
    /**
     * @license
     * Copyright 2020 Google LLC. All Rights Reserved.
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     * http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     * =============================================================================
     */
    function getImageCenter2(center, imageHeight, imageWidth) {
      const centerX = imageWidth * (typeof center === "number" ? center : center[0]);
      const centerY = imageHeight * (typeof center === "number" ? center : center[1]);
      return [centerX, centerY];
    }
    /**
     * @license
     * Copyright 2018 Google LLC. All Rights Reserved.
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     * http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     * =============================================================================
     */
    function getReshaped2(inputShape, blockShape, prod2, batchToSpace = true) {
      let reshaped = [];
      if (batchToSpace) {
        reshaped = reshaped.concat(blockShape.slice(0));
        reshaped.push(inputShape[0] / prod2);
        reshaped = reshaped.concat(inputShape.slice(1));
      } else {
        reshaped = reshaped.concat(inputShape[0]);
        const spatialLength = blockShape.length;
        for (let i = 0; i < spatialLength; ++i) {
          reshaped = reshaped.concat([inputShape[i + 1] / blockShape[i], blockShape[i]]);
        }
        reshaped = reshaped.concat(inputShape.slice(spatialLength + 1));
      }
      return reshaped;
    }
    function getPermuted2(reshapedRank, blockShapeRank, batchToSpace = true) {
      const permuted = [];
      if (batchToSpace) {
        permuted.push(blockShapeRank);
        for (let i = blockShapeRank + 1; i < reshapedRank; ++i) {
          if (i <= 2 * blockShapeRank) {
            permuted.push(i);
            permuted.push(i - (blockShapeRank + 1));
          } else {
            permuted.push(i);
          }
        }
      } else {
        const permutedBeforeBatch = [];
        const permutedAfterBatch = [];
        for (let i = 1; i < reshapedRank; ++i) {
          if (i >= blockShapeRank * 2 + 1 || i % 2 === 1) {
            permutedAfterBatch.push(i);
          } else {
            permutedBeforeBatch.push(i);
          }
        }
        permuted.push(...permutedBeforeBatch);
        permuted.push(0);
        permuted.push(...permutedAfterBatch);
      }
      return permuted;
    }
    function getReshapedPermuted2(inputShape, blockShape, prod2, batchToSpace = true) {
      const reshapedPermuted = [];
      if (batchToSpace) {
        reshapedPermuted.push(inputShape[0] / prod2);
      } else {
        reshapedPermuted.push(inputShape[0] * prod2);
      }
      for (let i = 1; i < inputShape.length; ++i) {
        if (i <= blockShape.length) {
          if (batchToSpace) {
            reshapedPermuted.push(blockShape[i - 1] * inputShape[i]);
          } else {
            reshapedPermuted.push(inputShape[i] / blockShape[i - 1]);
          }
        } else {
          reshapedPermuted.push(inputShape[i]);
        }
      }
      return reshapedPermuted;
    }
    function getSliceBeginCoords2(crops, blockShape) {
      const sliceBeginCoords = [0];
      for (let i = 0; i < blockShape; ++i) {
        sliceBeginCoords.push(crops[i][0]);
      }
      return sliceBeginCoords;
    }
    function getSliceSize2(uncroppedShape, crops, blockShape) {
      const sliceSize = uncroppedShape.slice(0, 1);
      for (let i = 0; i < blockShape; ++i) {
        sliceSize.push(uncroppedShape[i + 1] - crops[i][0] - crops[i][1]);
      }
      return sliceSize;
    }
    /**
     * @license
     * Copyright 2018 Google LLC. All Rights Reserved.
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     * http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     * =============================================================================
     */
    const SELU_SCALEALPHA2 = 1.7580993408473768;
    const SELU_SCALE2 = 1.0507009873554805;
    /**
     * @license
     * Copyright 2018 Google LLC. All Rights Reserved.
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     * http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     * =============================================================================
     */
    const ERF_P2 = 0.3275911;
    const ERF_A12 = 0.254829592;
    const ERF_A22 = -0.284496736;
    const ERF_A32 = 1.421413741;
    const ERF_A42 = -1.453152027;
    const ERF_A52 = 1.061405429;
    /**
     * @license
     * Copyright 2018 Google LLC. All Rights Reserved.
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     * http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     * =============================================================================
     */
    function warn2(...msg) {
      if (!env2().getBool("IS_TEST")) {
        console.warn(...msg);
      }
    }
    function log$1(...msg) {
      if (!env2().getBool("IS_TEST")) {
        console.log(...msg);
      }
    }
    /**
     * @license
     * Copyright 2018 Google LLC. All Rights Reserved.
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     * http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     * =============================================================================
     */
    function mergeRealAndImagArrays2(real2, imag2) {
      if (real2.length !== imag2.length) {
        throw new Error(`Cannot merge real and imag arrays of different lengths. real:${real2.length}, imag: ${imag2.length}.`);
      }
      const result = new Float32Array(real2.length * 2);
      for (let i = 0; i < result.length; i += 2) {
        result[i] = real2[i / 2];
        result[i + 1] = imag2[i / 2];
      }
      return result;
    }
    function splitRealAndImagArrays2(complex4) {
      const real2 = new Float32Array(complex4.length / 2);
      const imag2 = new Float32Array(complex4.length / 2);
      for (let i = 0; i < complex4.length; i += 2) {
        real2[i / 2] = complex4[i];
        imag2[i / 2] = complex4[i + 1];
      }
      return {real: real2, imag: imag2};
    }
    function complexWithEvenIndex2(complex4) {
      const len = Math.ceil(complex4.length / 4);
      const real2 = new Float32Array(len);
      const imag2 = new Float32Array(len);
      for (let i = 0; i < complex4.length; i += 4) {
        real2[Math.floor(i / 4)] = complex4[i];
        imag2[Math.floor(i / 4)] = complex4[i + 1];
      }
      return {real: real2, imag: imag2};
    }
    function complexWithOddIndex2(complex4) {
      const len = Math.floor(complex4.length / 4);
      const real2 = new Float32Array(len);
      const imag2 = new Float32Array(len);
      for (let i = 2; i < complex4.length; i += 4) {
        real2[Math.floor(i / 4)] = complex4[i];
        imag2[Math.floor(i / 4)] = complex4[i + 1];
      }
      return {real: real2, imag: imag2};
    }
    function getComplexWithIndex2(complex4, index2) {
      const real2 = complex4[index2 * 2];
      const imag2 = complex4[index2 * 2 + 1];
      return {real: real2, imag: imag2};
    }
    function assignToTypedArray2(data2, real2, imag2, index2) {
      data2[index2 * 2] = real2;
      data2[index2 * 2 + 1] = imag2;
    }
    function exponents2(n, inverse) {
      const real2 = new Float32Array(n / 2);
      const imag2 = new Float32Array(n / 2);
      for (let i = 0; i < Math.ceil(n / 2); i++) {
        const x = (inverse ? 2 : -2) * Math.PI * (i / n);
        real2[i] = Math.cos(x);
        imag2[i] = Math.sin(x);
      }
      return {real: real2, imag: imag2};
    }
    function exponent2(k, n, inverse) {
      const x = (inverse ? 2 : -2) * Math.PI * (k / n);
      const real2 = Math.cos(x);
      const imag2 = Math.sin(x);
      return {real: real2, imag: imag2};
    }
    /**
     * @license
     * Copyright 2018 Google LLC. All Rights Reserved.
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     * http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     * =============================================================================
     */
    function castTensor2(x, dtype, backend3) {
      if (dtype === "complex64") {
        if (x.dtype === "complex64") {
          return x.clone();
        }
        const zerosTensor = zeros3(x.shape);
        const floatX = cast7(x, "float32");
        const result = backend3.complex(floatX, zerosTensor);
        zerosTensor.dispose();
        floatX.dispose();
        return result;
      }
      if (!hasEncodingLoss2(x.dtype, dtype)) {
        return ENGINE2.makeTensorFromDataId(x.dataId, x.shape, dtype);
      }
      if (x.dtype === "complex64") {
        const real2 = backend3.real(x);
        const result = cast7(real2, dtype);
        real2.dispose();
        return result;
      }
      if (dtype === "int32") {
        return backend3.int(x);
      } else if (dtype === "bool") {
        const zero = scalar3(0, x.dtype);
        const result = backend3.notEqual(x, zero);
        zero.dispose();
        return result;
      } else {
        throw new Error(`Error in Cast: failed to cast ${x.dtype} to ${dtype}`);
      }
    }
    function reshapeTensor2(x, shape) {
      return ENGINE2.makeTensorFromDataId(x.dataId, shape, x.dtype);
    }
    function linspaceImpl2(start, stop, num) {
      const step4 = (stop - start) / (num - 1);
      const values = makeZerosTypedArray2(num, "float32");
      values[0] = start;
      for (let i = 1; i < values.length; i++) {
        values[i] = values[i - 1] + step4;
      }
      return tensor1d3(values, "float32");
    }
    var backend_util = /* @__PURE__ */ Object.freeze({
      __proto__: null,
      slice_util,
      segment_util,
      castTensor: castTensor2,
      reshapeTensor: reshapeTensor2,
      linspaceImpl: linspaceImpl2,
      upcastType: upcastType2,
      axesAreInnerMostDims: axesAreInnerMostDims2,
      combineLocations: combineLocations2,
      computeOutAndReduceShapes: computeOutAndReduceShapes2,
      expandShapeToKeepDim: expandShapeToKeepDim2,
      assertAxesAreInnerMostDims: assertAxesAreInnerMostDims2,
      getAxesPermutation: getAxesPermutation2,
      getUndoAxesPermutation: getUndoAxesPermutation2,
      getInnerMostAxes: getInnerMostAxes2,
      getBroadcastDims: getBroadcastDims2,
      getReductionAxes: getReductionAxes2,
      assertAndGetBroadcastShape: assertAndGetBroadcastShape2,
      assertParamsConsistent: assertParamsConsistent2,
      computeOutShape: computeOutShape$1,
      computeDilation2DInfo: computeDilation2DInfo2,
      computePool2DInfo: computePool2DInfo2,
      computePool3DInfo: computePool3DInfo2,
      computeConv2DInfo: computeConv2DInfo2,
      computeConv3DInfo: computeConv3DInfo2,
      computeDefaultPad: computeDefaultPad2,
      tupleValuesAreOne: tupleValuesAreOne2,
      eitherStridesOrDilationsAreOne: eitherStridesOrDilationsAreOne2,
      convertConv2DDataFormat: convertConv2DDataFormat2,
      getFusedDyActivation: getFusedDyActivation2,
      getFusedBiasGradient: getFusedBiasGradient2,
      applyActivation: applyActivation2,
      shouldFuse: shouldFuse2,
      PARALLELIZE_THRESHOLD: PARALLELIZE_THRESHOLD2,
      computeOptimalWindowSize: computeOptimalWindowSize2,
      getImageCenter: getImageCenter2,
      getReshaped: getReshaped2,
      getPermuted: getPermuted2,
      getReshapedPermuted: getReshapedPermuted2,
      getSliceBeginCoords: getSliceBeginCoords2,
      getSliceSize: getSliceSize2,
      prepareAndValidate: prepareAndValidate2,
      validateUpdateShape: validateUpdateShape2,
      validateInput: validateInput2,
      calculateShapes: calculateShapes2,
      SELU_SCALEALPHA: SELU_SCALEALPHA2,
      SELU_SCALE: SELU_SCALE2,
      ERF_P: ERF_P2,
      ERF_A1: ERF_A12,
      ERF_A2: ERF_A22,
      ERF_A3: ERF_A32,
      ERF_A4: ERF_A42,
      ERF_A5: ERF_A52,
      warn: warn2,
      log: log$1,
      mergeRealAndImagArrays: mergeRealAndImagArrays2,
      splitRealAndImagArrays: splitRealAndImagArrays2,
      complexWithEvenIndex: complexWithEvenIndex2,
      complexWithOddIndex: complexWithOddIndex2,
      getComplexWithIndex: getComplexWithIndex2,
      assignToTypedArray: assignToTypedArray2,
      exponents: exponents2,
      exponent: exponent2,
      prepareSplitSize: prepareSplitSize2
    });
    /**
     * @license
     * Copyright 2018 Google LLC. All Rights Reserved.
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     * http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     * =============================================================================
     */
    function split$1(x, sizeSplits, axis) {
      const begin = new Array(x.rank).fill(0);
      const size = x.shape.slice();
      return sizeSplits.map((s) => {
        const sliceSize = [...size];
        sliceSize[axis] = s;
        const sliceT = slice2(x, begin, sliceSize);
        begin[axis] += s;
        return sliceT;
      });
    }
    /**
     * @license
     * Copyright 2019 Google LLC. All Rights Reserved.
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     * http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     * =============================================================================
     */
    function tile$1(xBuf, reps) {
      const newShape = new Array(xBuf.rank);
      for (let i = 0; i < newShape.length; i++) {
        newShape[i] = xBuf.shape[i] * reps[i];
      }
      const result = buffer2(newShape, xBuf.dtype);
      for (let i = 0; i < result.values.length; ++i) {
        const newLoc = result.indexToLoc(i);
        const originalLoc = new Array(xBuf.rank);
        for (let j = 0; j < originalLoc.length; j++) {
          originalLoc[j] = newLoc[j] % xBuf.shape[j];
        }
        const originalIndex = xBuf.locToIndex(originalLoc);
        result.values[i] = xBuf.values[originalIndex];
      }
      return result.toTensor();
    }
    /**
     * @license
     * Copyright 2018 Google LLC. All Rights Reserved.
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     * http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     * =============================================================================
     */
    function topkImpl(x, xShape, xDtype, k, sorted) {
      const lastDim = xShape[xShape.length - 1];
      const [batch, size] = [x.length / lastDim, lastDim];
      const allTopKVals = getTypedArrayFromDType2(xDtype, batch * k);
      const allTopKIndices = getTypedArrayFromDType2("int32", batch * k);
      for (let b = 0; b < batch; b++) {
        const offset = b * size;
        const vals = x.subarray(offset, offset + size);
        const valAndInd = [];
        for (let i = 0; i < vals.length; i++) {
          valAndInd.push({value: vals[i], index: i});
        }
        valAndInd.sort((a, b2) => b2.value - a.value);
        const outOffset = b * k;
        const topKVals = allTopKVals.subarray(outOffset, outOffset + k);
        const topKIndices = allTopKIndices.subarray(outOffset, outOffset + k);
        for (let i = 0; i < k; i++) {
          topKVals[i] = valAndInd[i].value;
          topKIndices[i] = valAndInd[i].index;
        }
      }
      const outputShape = xShape.slice();
      outputShape[outputShape.length - 1] = k;
      return [
        tensor6(allTopKVals, outputShape, xDtype),
        tensor6(allTopKIndices, outputShape, "int32")
      ];
    }
    /**
     * @license
     * Copyright 2020 Google LLC. All Rights Reserved.
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     * http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     * =============================================================================
     */
    var kernel_impls = /* @__PURE__ */ Object.freeze({
      __proto__: null,
      nonMaxSuppressionV3Impl,
      nonMaxSuppressionV4Impl,
      nonMaxSuppressionV5Impl,
      split: split$1,
      tile: tile$1,
      topkImpl,
      whereImpl
    });
    /**
     * @license
     * Copyright 2020 Google Inc. All Rights Reserved.
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     * http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     * =============================================================================
     */
    /**
     * @license
     * Copyright 2020 Google LLC. All Rights Reserved.
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     * http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     * =============================================================================
     */
    const absGradConfig = {
      kernelName: Abs3,
      inputsToSave: ["x"],
      gradFunc: (dy, saved) => {
        const [x] = saved;
        return {x: () => mul3(dy, step3(cast7(x, "float32"), -1))};
      }
    };
    /**
     * @license
     * Copyright 2020 Google LLC. All Rights Reserved.
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     * http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     * =============================================================================
     */
    const acosGradConfig = {
      kernelName: Acos,
      inputsToSave: ["x"],
      gradFunc: (dy, saved) => {
        const [x] = saved;
        return {
          x: () => {
            const a = square(cast7(x, "float32"));
            const b = sqrt(sub(scalar3(1), a));
            return neg(div(dy, b));
          }
        };
      }
    };
    /**
     * @license
     * Copyright 2020 Google LLC. All Rights Reserved.
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     * http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     * =============================================================================
     */
    const acoshGradConfig = {
      kernelName: Acosh,
      inputsToSave: ["x"],
      gradFunc: (dy, saved) => {
        const [x] = saved;
        return {
          x: () => {
            const a = sqrt(sub(square(cast7(x, "float32")), 1));
            return div(dy, a);
          }
        };
      }
    };
    /**
     * @license
     * Copyright 2020 Google LLC. All Rights Reserved.
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     * http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     * =============================================================================
     */
    const addGradConfig = {
      kernelName: Add3,
      inputsToSave: ["a", "b"],
      gradFunc: (dy, saved) => {
        const [a, b] = saved;
        const outShape = assertAndGetBroadcastShape2(a.shape, b.shape);
        const derA = () => {
          let res = dy;
          const reduceAxes = getReductionAxes2(a.shape, outShape);
          if (reduceAxes.length > 0) {
            res = sum$1(res, reduceAxes);
          }
          return reshape5(res, a.shape);
        };
        const derB = () => {
          let res = dy;
          const reduceAxes = getReductionAxes2(b.shape, outShape);
          if (reduceAxes.length > 0) {
            res = sum$1(res, reduceAxes);
          }
          return reshape5(res, b.shape);
        };
        return {a: derA, b: derB};
      }
    };
    /**
     * @license
     * Copyright 2020 Google LLC. All Rights Reserved.
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     * http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     * =============================================================================
     */
    const addNGradConfig = {
      kernelName: AddN3,
      saveAllInputs: true,
      gradFunc: (dy, saved) => {
        const ders = {};
        saved.forEach((_, i) => {
          ders[i] = () => dy.clone();
        });
        return ders;
      }
    };
    /**
     * @license
     * Copyright 2020 Google Inc. All Rights Reserved.
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     * http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     * =============================================================================
     */
    const argMaxGradConfig = {
      kernelName: ArgMax3,
      inputsToSave: ["x"],
      gradFunc: (dy, saved) => {
        const [x] = saved;
        return {x: () => zerosLike2(x)};
      }
    };
    /**
     * @license
     * Copyright 2020 Google Inc. All Rights Reserved.
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     * http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     * =============================================================================
     */
    const argMinGradConfig = {
      kernelName: ArgMin,
      inputsToSave: ["x"],
      gradFunc: (dy, saved) => {
        const [x] = saved;
        return {x: () => zerosLike2(x)};
      }
    };
    /**
     * @license
     * Copyright 2020 Google LLC. All Rights Reserved.
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     * http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     * =============================================================================
     */
    const asinGradConfig = {
      kernelName: Asin,
      inputsToSave: ["x"],
      gradFunc: (dy, saved) => {
        const [x] = saved;
        return {x: () => div(dy, sqrt(sub(scalar3(1), square(cast7(x, "float32")))))};
      }
    };
    /**
     * @license
     * Copyright 2020 Google LLC. All Rights Reserved.
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     * http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     * =============================================================================
     */
    const asinhGradConfig = {
      kernelName: Asinh,
      inputsToSave: ["x"],
      gradFunc: (dy, saved) => {
        const [x] = saved;
        return {
          x: () => {
            const a = sqrt(add$1(scalar3(1), square(cast7(x, "float32"))));
            return div(dy, a);
          }
        };
      }
    };
    /**
     * @license
     * Copyright 2020 Google LLC. All Rights Reserved.
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     * http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     * =============================================================================
     */
    const atan2GradConfig = {
      kernelName: Atan2,
      inputsToSave: ["a", "b"],
      gradFunc: (dy, saved) => {
        const [a, b] = saved;
        const outShape = assertAndGetBroadcastShape2(a.shape, b.shape);
        const derA = () => {
          const d = add$1(square(a), square(b));
          let res = mul3(dy, div(b, d));
          const reduceAxes = getReductionAxes2(a.shape, outShape);
          if (reduceAxes.length > 0) {
            res = sum$1(res, reduceAxes);
          }
          return reshape5(res, a.shape);
        };
        const derB = () => {
          const d = add$1(square(a), square(b));
          let res = neg(mul3(dy, div(a, d)));
          const reduceAxes = getReductionAxes2(b.shape, outShape);
          if (reduceAxes.length > 0) {
            res = sum$1(res, reduceAxes);
          }
          return reshape5(res, b.shape);
        };
        return {a: derA, b: derB};
      }
    };
    /**
     * @license
     * Copyright 2020 Google LLC. All Rights Reserved.
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     * http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     * =============================================================================
     */
    const atanGradConfig = {
      kernelName: Atan,
      inputsToSave: ["x"],
      gradFunc: (dy, saved) => {
        const [x] = saved;
        return {x: () => div(dy, add$1(square(cast7(x, "float32")), 1))};
      }
    };
    /**
     * @license
     * Copyright 2020 Google LLC. All Rights Reserved.
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     * http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     * =============================================================================
     */
    const atanhGradConfig = {
      kernelName: Atanh,
      inputsToSave: ["x"],
      gradFunc: (dy, saved) => {
        const [x] = saved;
        return {x: () => div(dy, sub(scalar3(1), square(cast7(x, "float32"))))};
      }
    };
    /**
     * @license
     * Copyright 2020 Google LLC. All Rights Reserved.
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     * http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     * =============================================================================
     */
    function avgPool3dBackprop_(dy, input2, filterSize, strides, dilations = [1, 1, 1], pad3, dimRoundingMode) {
      const $dy = convertToTensor2(dy, "dy", "avgPool3dBackprop");
      const $input = convertToTensor2(input2, "input", "avgPool3dBackprop");
      let dy5D = $dy;
      let input5D = $input;
      let reshapedTo5D = false;
      if ($input.rank === 4) {
        reshapedTo5D = true;
        dy5D = reshape5($dy, [1, $dy.shape[0], $dy.shape[1], $dy.shape[2], $dy.shape[3]]);
        input5D = reshape5($input, [
          1,
          $input.shape[0],
          $input.shape[1],
          $input.shape[2],
          $input.shape[3]
        ]);
      }
      assert2(dy5D.rank === 5, () => `Error in avgPool3dBackprop: dy must be rank 5 but got rank ${dy5D.rank}.`);
      assert2(input5D.rank === 5, () => `Error in avgPool3dBackprop: input must be rank 5 but got rank ${input5D.rank}.`);
      assert2(eitherStridesOrDilationsAreOne2(strides, dilations), () => `Error in avgPool3dBackprop: Either strides or dilations must be 1. Got strides ${strides} and dilations '${dilations}'`);
      if (dimRoundingMode != null) {
        assert2(isInt2(pad3), () => `Error in maxPool3dBackprop: pad must be an integer when using, dimRoundingMode ${dimRoundingMode} but got pad ${pad3}.`);
      }
      const forward = (backend3) => {
        const convInfo = computePool3DInfo2(input5D.shape, filterSize, strides, dilations, pad3, dimRoundingMode);
        return backend3.avgPool3dBackprop(dy5D, input5D, convInfo);
      };
      const inputs = {dy: dy5D, input: input5D};
      const attrs = {filterSize, strides, dilations, pad: pad3, dimRoundingMode};
      const res = ENGINE2.runKernelFunc(forward, inputs, null, AvgPool3DBackprop, attrs);
      if (reshapedTo5D) {
        return reshape5(res, [res.shape[1], res.shape[2], res.shape[3], res.shape[4]]);
      }
      return res;
    }
    const avgPool3dBackprop = op2({avgPool3dBackprop_});
    /**
     * @license
     * Copyright 2020 Google LLC. All Rights Reserved.
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     * http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     * =============================================================================
     */
    const avgPool3DGradConfig = {
      kernelName: AvgPool3D,
      inputsToSave: ["x"],
      gradFunc: (dy, saved, attrs) => {
        const [x] = saved;
        const {filterSize, strides, dilations, pad: pad3, dimRoundingMode} = attrs;
        const $dilations = dilations == null ? [1, 1, 1] : dilations;
        return {
          x: () => avgPool3dBackprop(dy, x, filterSize, strides, $dilations, pad3, dimRoundingMode)
        };
      }
    };
    /**
     * @license
     * Copyright 2020 Google LLC. All Rights Reserved.
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     * http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     * =============================================================================
     */
    function avgPoolBackprop_(dy, input2, filterSize, strides, pad3) {
      const $dy = convertToTensor2(dy, "dy", "avgPoolBackprop");
      const $input = convertToTensor2(input2, "input", "avgPoolBackprop");
      assert2($input.rank === $dy.rank, () => `Rank of input (${$input.rank}) does not match rank of dy (${$dy.rank})`);
      let input4D = $input;
      let dy4D = $dy;
      let reshapedTo4D = false;
      if ($input.rank === 3) {
        reshapedTo4D = true;
        input4D = reshape5($input, [1, $input.shape[0], $input.shape[1], $input.shape[2]]);
        dy4D = reshape5($dy, [1, $dy.shape[0], $dy.shape[1], $dy.shape[2]]);
      }
      assert2(dy4D.rank === 4, () => `Error in avgPoolBackprop: dy must be rank 4 but got rank ${dy4D.rank}.`);
      assert2(input4D.rank === 4, () => `Error in avgPoolBackprop: input must be rank 4 but got rank ${input4D.rank}.`);
      const forward = (backend3) => {
        const convInfo = computePool2DInfo2(input4D.shape, filterSize, strides, 1, pad3);
        return backend3.avgPoolBackprop(dy4D, input4D, convInfo);
      };
      const inputs = {dy: dy4D, input: input4D};
      const attrs = {filterSize, strides, pad: pad3};
      const res = ENGINE2.runKernelFunc(forward, inputs, null, AvgPoolBackprop, attrs);
      if (reshapedTo4D) {
        return reshape5(res, [res.shape[1], res.shape[2], res.shape[3]]);
      }
      return res;
    }
    const avgPoolBackprop = op2({avgPoolBackprop_});
    /**
     * @license
     * Copyright 2020 Google LLC. All Rights Reserved.
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     * http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     * =============================================================================
     */
    const avgPoolGradConfig = {
      kernelName: AvgPool3,
      inputsToSave: ["x"],
      gradFunc: (dy, saved, attrs) => {
        const [x] = saved;
        const {filterSize, strides, pad: pad3} = attrs;
        return {
          x: () => avgPoolBackprop(dy, x, filterSize, strides, pad3)
        };
      }
    };
    /**
     * @license
     * Copyright 2020 Google LLC. All Rights Reserved.
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     * http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     * =============================================================================
     */
    const batchMatMulGradConfig = {
      kernelName: BatchMatMul3,
      inputsToSave: ["a", "b"],
      gradFunc: (dy, saved, attrs) => {
        const [a, b] = saved;
        const {transposeA, transposeB} = attrs;
        if (!transposeA && !transposeB) {
          return {
            a: () => matMul(dy, b, false, true),
            b: () => matMul(a, dy, true, false)
          };
        } else if (!transposeA && transposeB) {
          return {
            a: () => matMul(dy, b, false, false),
            b: () => matMul(dy, a, true, false)
          };
        } else if (transposeA && !transposeB) {
          return {
            a: () => matMul(b, dy, false, true),
            b: () => matMul(a, dy, false, false)
          };
        } else {
          return {
            a: () => matMul(b, dy, true, true),
            b: () => matMul(dy, a, true, true)
          };
        }
      }
    };
    /**
     * @license
     * Copyright 2020 Google LLC. All Rights Reserved.
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     * http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     * =============================================================================
     */
    const batchToSpaceNDGradConfig = {
      kernelName: BatchToSpaceND,
      gradFunc: (dy, saved, attrs) => {
        const {blockShape, crops} = attrs;
        return {x: () => spaceToBatchND(dy, blockShape, crops)};
      }
    };
    /**
     * @license
     * Copyright 2020 Google LLC. All Rights Reserved.
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     * http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     * =============================================================================
     */
    const broadcastToGradConfig = {
      kernelName: BroadcastTo,
      gradFunc: (dy, saved, attrs) => {
        const broadCastToAttrs = attrs;
        const inputShape = broadCastToAttrs.inputShape;
        const outputShape = broadCastToAttrs.shape;
        const reps = Array.from(outputShape);
        for (let i = inputShape.length - 1; i >= 0; i--) {
          if (inputShape[i] === outputShape[i]) {
            reps[i] = 1;
          } else if (inputShape[i] !== 1) {
            throw new Error(`broadcastTo(): [${inputShape}] cannot be broadcast to [${outputShape}].`);
          }
        }
        const axes = [];
        for (let i = 0; i < reps.length; i++) {
          if (reps[i] > 1) {
            axes.push(i);
          }
        }
        return {x: () => sum$1(dy, axes, true)};
      }
    };
    /**
     * @license
     * Copyright 2020 Google LLC. All Rights Reserved.
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     * http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     * =============================================================================
     */
    const castGradConfig = {
      kernelName: Cast5,
      gradFunc: (dy) => {
        return {x: () => dy.clone()};
      }
    };
    /**
     * @license
     * Copyright 2020 Google LLC. All Rights Reserved.
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     * http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     * =============================================================================
     */
    const ceilGradConfig = {
      kernelName: Ceil,
      gradFunc: (dy) => {
        return {x: () => zerosLike2(dy)};
      }
    };
    /**
     * @license
     * Copyright 2020 Google LLC. All Rights Reserved.
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     * http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     * =============================================================================
     */
    const clipByValueGradConfig = {
      kernelName: ClipByValue3,
      inputsToSave: ["x"],
      gradFunc: (dy, saved, attrs) => {
        const [x] = saved;
        const {clipValueMin, clipValueMax} = attrs;
        return {
          x: () => where(logicalAnd(greaterEqual(x, clipValueMin), lessEqual(x, clipValueMax)), dy, zerosLike2(dy))
        };
      }
    };
    /**
     * @license
     * Copyright 2020 Google LLC. All Rights Reserved.
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     * http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     * =============================================================================
     */
    const concatGradConfig = {
      kernelName: Concat3,
      saveAllInputs: true,
      gradFunc: (dy, saved, attrs) => {
        const shapes = saved.map((t) => t.shape);
        const {axis} = attrs;
        const $axis = parseAxisParam2(axis, saved[0].shape)[0];
        const sizeSplits = shapes.map((s) => s[$axis]);
        const derTensors = split2(dy, sizeSplits, $axis);
        return derTensors.map((t) => () => t);
      }
    };
    /**
     * @license
     * Copyright 2020 Google LLC. All Rights Reserved.
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     * http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     * =============================================================================
     */
    const conv2DGradConfig = {
      kernelName: Conv2D3,
      inputsToSave: ["x", "filter"],
      gradFunc: (dy, saved, attrs) => {
        const [x4D, $filter] = saved;
        const {dilations, strides, pad: pad3, dataFormat} = attrs;
        assert2(tupleValuesAreOne2(dilations), () => `Error in gradient of conv2D: dilation rates greater than 1 are not yet supported in gradients. Got dilations '${dilations}'`);
        return {
          x: () => conv2DBackpropInput2(x4D.shape, dy, $filter, strides, pad3, dataFormat),
          filter: () => conv2DBackpropFilter(x4D, dy, $filter.shape, strides, pad3, dataFormat)
        };
      }
    };
    /**
     * @license
     * Copyright 2020 Google LLC. All Rights Reserved.
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     * http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     * =============================================================================
     */
    const conv2DBackpropInputGradConfig = {
      kernelName: Conv2DBackpropInput3,
      inputsToSave: ["dy", "filter"],
      gradFunc: (ddx, saved, attrs) => {
        const [dy, filter] = saved;
        const {strides, pad: pad3, dataFormat, dimRoundingMode} = attrs;
        return {
          dy: () => conv2d2(ddx, filter, strides, pad3, dataFormat, 1, dimRoundingMode),
          filter: () => conv2DBackpropFilter(ddx, dy, filter.shape, strides, pad3, dataFormat, dimRoundingMode)
        };
      }
    };
    /**
     * @license
     * Copyright 2020 Google LLC. All Rights Reserved.
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     * http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     * =============================================================================
     */
    function conv3DBackpropFilter_(x, dy, filterShape, strides, pad3) {
      let x5D = x;
      if (x.rank === 4) {
        x5D = reshape5(x, [1, x.shape[0], x.shape[1], x.shape[2], x.shape[3]]);
      }
      let dy5D = dy;
      if (dy5D.rank === 4) {
        dy5D = reshape5(dy, [1, dy.shape[0], dy.shape[1], dy.shape[2], dy.shape[3]]);
      }
      assert2(x5D.rank === 5, () => `Error in conv3dDerFilter: input must be rank 5, but got shape ${x5D.shape}.`);
      assert2(dy5D.rank === 5, () => `Error in conv3dDerFilter: dy must be rank 5, but got shape ${dy5D.shape}.`);
      assert2(filterShape.length === 5, () => `Error in conv3dDerFilter: filterShape must be length 5, but got ${filterShape}.`);
      assert2(x5D.shape[4] === filterShape[3], () => `Error in conv3dDerFilter: depth of input ${x5D.shape[4]}) must match input depth in filter (${filterShape[3]}.`);
      assert2(dy5D.shape[4] === filterShape[4], () => `Error in conv3dDerFilter: depth of dy (${dy5D.shape[4]}) must match output depth for filter (${filterShape[4]}).`);
      const forward = (backend3) => {
        const dilations = 1;
        const convInfo = computeConv3DInfo2(x5D.shape, filterShape, strides, dilations, pad3);
        return backend3.conv3dDerFilter(x5D, dy5D, convInfo);
      };
      const inputs = {x: x5D, dy: dy5D};
      const attrs = {strides, pad: pad3, filterShape};
      return ENGINE2.runKernelFunc(forward, inputs, null, Conv3DBackpropFilterV2, attrs);
    }
    const conv3DBackpropFilter = op2({conv3DBackpropFilter_});
    /**
     * @license
     * Copyright 2020 Google LLC. All Rights Reserved.
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     * http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     * =============================================================================
     */
    const conv3DGradConfig = {
      kernelName: Conv3D,
      inputsToSave: ["x", "filter"],
      gradFunc: (dy, saved, attrs) => {
        const {dilations, strides, pad: pad3} = attrs;
        assert2(tupleValuesAreOne2(dilations), () => `Error in gradient of conv3D: dilation rates greater than 1 are not yet supported in gradients. Got dilations '${dilations}'`);
        const [x5D, $filter] = saved;
        return {
          x: () => conv3DBackpropInput(x5D.shape, dy, $filter, strides, pad3),
          filter: () => conv3DBackpropFilter(x5D, dy, $filter.shape, strides, pad3)
        };
      }
    };
    /**
     * @license
     * Copyright 2020 Google LLC. All Rights Reserved.
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     * http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     * =============================================================================
     */
    const cosGradConfig = {
      kernelName: Cos3,
      inputsToSave: ["x"],
      gradFunc: (dy, saved) => {
        const [x] = saved;
        return {x: () => mul3(neg(sin(cast7(x, "float32"))), dy)};
      }
    };
    /**
     * @license
     * Copyright 2020 Google LLC. All Rights Reserved.
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     * http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     * =============================================================================
     */
    const coshGradConfig = {
      kernelName: Cosh,
      inputsToSave: ["x"],
      gradFunc: (dy, saved) => {
        const [x] = saved;
        return {x: () => mul3(sinh(cast7(x, "float32")), dy)};
      }
    };
    /**
     * @license
     * Copyright 2020 Google LLC. All Rights Reserved.
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     * http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     * =============================================================================
     */
    const cumsumGradConfig = {
      kernelName: Cumsum3,
      inputsToSave: ["x"],
      gradFunc: (dy, saved, attrs) => {
        const [x] = saved;
        const {axis, exclusive, reverse: reverse3} = attrs;
        return {
          x: () => {
            const permutation = getAxesPermutation2([axis], x.rank);
            let out = cumsum2(dy, axis, exclusive, !reverse3);
            if (permutation != null) {
              out = transpose4(out, permutation);
            }
            return out;
          }
        };
      }
    };
    /**
     * @license
     * Copyright 2020 Google LLC. All Rights Reserved.
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     * http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     * =============================================================================
     */
    const depthwiseConv2dNativeGradConfig = {
      kernelName: DepthwiseConv2dNative3,
      inputsToSave: ["x", "filter"],
      gradFunc: (dy, saved, attrs) => {
        const {dilations, strides, pad: pad3, dimRoundingMode} = attrs;
        const $dilations = dilations == null ? [1, 1] : dilations;
        assert2(tupleValuesAreOne2($dilations), () => `Error in gradient of depthwiseConv2dNative: dilation rates greater than 1 are not yet supported. Got dilations '${$dilations}'`);
        const [x, filter] = saved;
        assert2(x.rank === 4, () => `Error in gradient of depthwiseConv2dNative: input must be rank 4, but got rank ${x.rank}.`);
        assert2(filter.rank === 4, () => `Error in gradient of depthwiseConv2dNative: filter must be rank 4, but got rank ${filter.rank}.`);
        assert2(x.shape[3] === filter.shape[2], () => `Error in gradient of depthwiseConv2d: number of input channels (${x.shape[3]}) must match the inChannels dimension in filter ${filter.shape[2]}.`);
        assert2(eitherStridesOrDilationsAreOne2(strides, $dilations), () => `Error in gradient of depthwiseConv2d: Either strides or dilations must be  1. Got strides ${strides} and dilations '${$dilations}'.`);
        if (dimRoundingMode != null) {
          assert2(isInt2(pad3), () => `Error in depthwiseConv2d: pad must be an integer when using, dimRoundingMode ${dimRoundingMode} but got pad ${pad3}.`);
        }
        return {
          x: () => depthwiseConv2dNativeBackpropInput(x.shape, dy, filter, strides, pad3, dilations, dimRoundingMode),
          filter: () => depthwiseConv2dNativeBackpropFilter(x, dy, filter.shape, strides, pad3, dilations, dimRoundingMode)
        };
      }
    };
    /**
     * @license
     * Copyright 2020 Google LLC. All Rights Reserved.
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     * http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     * =============================================================================
     */
    const dilation2dGradConfig = {
      kernelName: Dilation2D,
      inputsToSave: ["x", "filter"],
      gradFunc: (dy, saved, attrs) => {
        const [x, filter] = saved;
        const inputInputs = {x, filter, dy};
        const filterInputs = {x, filter, dy};
        return {
          x: () => ENGINE2.runKernel(Dilation2DBackpropInput, inputInputs, attrs),
          filter: () => ENGINE2.runKernel(Dilation2DBackpropFilter, filterInputs, attrs)
        };
      }
    };
    /**
     * @license
     * Copyright 2020 Google LLC. All Rights Reserved.
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     * http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     * =============================================================================
     */
    const divGradConfig = {
      kernelName: Div3,
      inputsToSave: ["a", "b"],
      gradFunc: (dy, saved) => {
        const [a, b] = saved;
        const outShape = assertAndGetBroadcastShape2(a.shape, b.shape);
        const derA = () => {
          const res = div(dy, cast7(b, "float32"));
          const reduceAxes = getReductionAxes2(a.shape, outShape);
          if (reduceAxes.length > 0) {
            return reshape5(sum$1(res, reduceAxes), a.shape);
          }
          return res;
        };
        const derB = () => {
          let res = mul3(dy, cast7(a, "float32"));
          const reduceAxes = getReductionAxes2(b.shape, outShape);
          if (reduceAxes.length > 0) {
            res = reshape5(sum$1(res, reduceAxes), b.shape);
          }
          const tmp = square(b);
          return neg(div(res, cast7(tmp, "float32")));
        };
        return {a: derA, b: derB};
      }
    };
    /**
     * @license
     * Copyright 2020 Google LLC. All Rights Reserved.
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     * http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     * =============================================================================
     */
    const eluGradConfig = {
      kernelName: Elu2,
      outputsToSave: [true],
      gradFunc: (dy, saved) => {
        const [y] = saved;
        const backPropKernelFunc = (backend3) => {
          return backend3.eluDer(dy, y);
        };
        const inputs = {dy, y};
        return {
          x: () => ENGINE2.runKernelFunc(backPropKernelFunc, inputs, null, EluGrad)
        };
      }
    };
    /**
     * @license
     * Copyright 2020 Google LLC. All Rights Reserved.
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     * http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     * =============================================================================
     */
    const erfGradConfig = {
      kernelName: Erf,
      inputsToSave: ["x"],
      gradFunc: (dy, saved) => {
        const [x] = saved;
        const a = mul3(exp(neg(square(x))), 2 / Math.sqrt(Math.PI));
        return {x: () => mul3(dy, a)};
      }
    };
    /**
     * @license
     * Copyright 2020 Google LLC. All Rights Reserved.
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     * http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     * =============================================================================
     */
    const expGradConfig = {
      kernelName: Exp3,
      outputsToSave: [true],
      gradFunc: (dy, saved) => {
        const [y] = saved;
        return {x: () => mul3(dy, y)};
      }
    };
    /**
     * @license
     * Copyright 2020 Google LLC. All Rights Reserved.
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     * http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     * =============================================================================
     */
    const expm1GradConfig = {
      kernelName: Expm1,
      inputsToSave: ["x"],
      gradFunc: (dy, saved) => {
        const [x] = saved;
        return {x: () => mul3(dy, exp(x))};
      }
    };
    /**
     * @license
     * Copyright 2020 Google LLC. All Rights Reserved.
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     * http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     * =============================================================================
     */
    const floorGradConfig = {
      kernelName: Floor,
      gradFunc: (dy) => {
        return {x: () => zerosLike2(dy)};
      }
    };
    /**
     * @license
     * Copyright 2020 Google LLC. All Rights Reserved.
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     * http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     * =============================================================================
     */
    const floorDivGradConfig = {
      kernelName: FloorDiv3,
      inputsToSave: ["a", "b"],
      gradFunc: (dy, saved) => {
        const [a, b] = saved;
        const outShape = assertAndGetBroadcastShape2(a.shape, b.shape);
        const derA = () => {
          const res = div(dy, cast7(b, "float32"));
          const reduceAxes = getReductionAxes2(a.shape, outShape);
          if (reduceAxes.length > 0) {
            return reshape5(sum$1(res, reduceAxes), a.shape);
          }
          return res;
        };
        const derB = () => {
          let res = mul3(dy, cast7(a, "float32"));
          const reduceAxes = getReductionAxes2(b.shape, outShape);
          if (reduceAxes.length > 0) {
            res = reshape5(sum$1(res, reduceAxes), b.shape);
          }
          const tmp = square(b);
          return neg(div(res, cast7(tmp, "float32")));
        };
        return {a: derA, b: derB};
      }
    };
    /**
     * @license
     * Copyright 2020 Google LLC. All Rights Reserved.
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     * http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     * =============================================================================
     */
    const fusedBatchNormGradConfig = {
      kernelName: FusedBatchNorm3,
      inputsToSave: ["x", "mean", "variance", "scale"],
      gradFunc: (dy, saved, attrs) => {
        const {varianceEpsilon} = attrs;
        const [x, mean2, variance2, scale2] = saved;
        const scaleValue = scale2 == null ? scalar3(1) : scale2;
        const reductionAxes = getReductionAxes2(mean2.shape, x.shape);
        const tileShape = [];
        if (mean2.rank === 1) {
          for (let i = 0; i < x.shape.length - 1; ++i) {
            tileShape.push(x.shape[i]);
          }
          tileShape.push(1);
        }
        const xMinusMean = sub(x, mean2);
        const dyTimesScaleValue = mul3(dy, scaleValue);
        const oneOverSqrtVariance = rsqrt(add$1(variance2, scalar3(varianceEpsilon)));
        const minusHalfRCube = mul3(mul3(mul3(oneOverSqrtVariance, oneOverSqrtVariance), oneOverSqrtVariance), scalar3(-0.5));
        const derX = () => {
          if (mean2.rank === 1) {
            return reshape5(mul3(mul3(dy, tile2(reshape5(oneOverSqrtVariance, [1, 1, 1, mean2.shape[0]]), tileShape)), scaleValue), x.shape);
          } else {
            return reshape5(mul3(mul3(dy, oneOverSqrtVariance), scaleValue), x.shape);
          }
        };
        const derMean = () => {
          let meanDer = mul3(mul3(oneOverSqrtVariance, scalar3(-1)), dyTimesScaleValue);
          if (mean2.rank === 1) {
            meanDer = sum$1(meanDer, reductionAxes);
          }
          return reshape5(meanDer, mean2.shape);
        };
        const derVariance = () => {
          let varianceDer = mul3(mul3(minusHalfRCube, xMinusMean), dyTimesScaleValue);
          if (mean2.rank === 1) {
            varianceDer = sum$1(varianceDer, reductionAxes);
          }
          return reshape5(varianceDer, mean2.shape);
        };
        const derScale = () => {
          const xMinusMean2TimesRsqrt = mul3(xMinusMean, oneOverSqrtVariance);
          let scaleDer = mul3(dy, xMinusMean2TimesRsqrt);
          if (mean2.rank === 1) {
            scaleDer = sum$1(scaleDer, reductionAxes);
          }
          return reshape5(scaleDer, mean2.shape);
        };
        const derOffset = () => {
          let offsetDer = dy;
          if (mean2.rank === 1) {
            offsetDer = sum$1(offsetDer, reductionAxes);
          }
          return reshape5(offsetDer, mean2.shape);
        };
        return {
          x: derX,
          mean: derMean,
          variance: derVariance,
          scale: derScale,
          offset: derOffset
        };
      }
    };
    /**
     * @license
     * Copyright 2020 Google LLC. All Rights Reserved.
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     * http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     * =============================================================================
     */
    const gatherGradConfig = {
      kernelName: GatherV23,
      inputsToSave: ["x", "indices"],
      gradFunc: (dy, saved, attrs) => {
        const [x, indices] = saved;
        const {axis} = attrs;
        const parsedAxis = parseAxisParam2(axis, x.shape)[0];
        const derX = () => {
          const paramsShape = x.shape;
          const indicesSize = indices.size;
          const outerShape = paramsShape.slice(0, parsedAxis);
          const outerDims = outerShape.length;
          const innerShape = paramsShape.slice(axis, paramsShape.length).slice(1);
          const innerDims = innerShape.length;
          const outerAxesIndices = arrayRange(0, outerDims);
          const innerAxesIndices = arrayRange(outerDims + 1, outerDims + 1 + innerDims);
          const valuesShape = arrayConcat([outerShape, [indicesSize], innerShape]);
          const values = reshape5(dy, valuesShape);
          const reshapedIndices = reshape5(indices, [indicesSize]);
          const transposeDims = arrayConcat([[outerDims], outerAxesIndices, innerAxesIndices]);
          const valuesTranspose = transpose4(values, transposeDims);
          let paramsGrad = unsortedSegmentSum(valuesTranspose, reshapedIndices, x.shape[parsedAxis]);
          const invertTransposeDims = getUndoAxesPermutation2(transposeDims);
          paramsGrad = transpose4(paramsGrad, invertTransposeDims);
          return paramsGrad;
        };
        return {x: derX, indices: () => indices};
      }
    };
    function arrayRange(start, stop) {
      const result = [];
      for (let i = start; i < stop; ++i) {
        result.push(i);
      }
      return result;
    }
    function arrayConcat(arrays) {
      const result = [];
      for (let i = 0; i < arrays.length; ++i) {
        for (let j = 0; j < arrays[i].length; ++j) {
          result.push(arrays[i][j]);
        }
      }
      return result;
    }
    /**
     * @license
     * Copyright 2020 Google LLC. All Rights Reserved.
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     * http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     * =============================================================================
     */
    const greaterEqualGradConfig = {
      kernelName: GreaterEqual3,
      inputsToSave: ["a", "b"],
      gradFunc: (dy, saved) => {
        const [a, b] = saved;
        return {a: () => zerosLike2(a), b: () => zerosLike2(b)};
      }
    };
    /**
     * @license
     * Copyright 2020 Google LLC. All Rights Reserved.
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     * http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     * =============================================================================
     */
    const identityGradConfig = {
      kernelName: Identity5,
      gradFunc: (dy) => {
        return {x: () => cast7(dy, "float32")};
      }
    };
    /**
     * @license
     * Copyright 2020 Google LLC. All Rights Reserved.
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     * http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     * =============================================================================
     */
    const isFiniteGradConfig = {
      kernelName: IsFinite,
      gradFunc: (dy) => {
        return {x: () => zerosLike2(dy)};
      }
    };
    /**
     * @license
     * Copyright 2020 Google LLC. All Rights Reserved.
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     * http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     * =============================================================================
     */
    const isInfGradConfig = {
      kernelName: IsInf,
      gradFunc: (dy) => {
        return {x: () => zerosLike2(dy)};
      }
    };
    /**
     * @license
     * Copyright 2020 Google LLC. All Rights Reserved.
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     * http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     * =============================================================================
     */
    const isNanGradConfig = {
      kernelName: IsNan,
      gradFunc: (dy) => {
        return {x: () => zerosLike2(dy)};
      }
    };
    /**
     * @license
     * Copyright 2020 Google LLC. All Rights Reserved.
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     * http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     * =============================================================================
     */
    const log1pGradConfig = {
      kernelName: Log1p,
      inputsToSave: ["x"],
      gradFunc: (dy, saved) => {
        const [x] = saved;
        return {x: () => div(dy, add$1(x, 1))};
      }
    };
    /**
     * @license
     * Copyright 2020 Google LLC. All Rights Reserved.
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     * http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     * =============================================================================
     */
    const logGradConfig = {
      kernelName: Log3,
      inputsToSave: ["x"],
      gradFunc: (dy, saved) => {
        const [x] = saved;
        return {x: () => div(dy, cast7(x, "float32"))};
      }
    };
    /**
     * @license
     * Copyright 2020 Google LLC. All Rights Reserved.
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     * http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     * =============================================================================
     */
    const logSoftmaxGradConfig = {
      kernelName: LogSoftmax,
      inputsToSave: [],
      outputsToSave: [true],
      gradFunc: (dy, saved, attrs) => {
        const [value] = saved;
        const {axis} = attrs;
        return {
          logits: () => {
            const keepDims = true;
            const softmax3 = exp(value);
            return sub(dy, mul3(sum$1(dy, axis, keepDims), softmax3));
          }
        };
      }
    };
    /**
     * @license
     * Copyright 2020 Google LLC. All Rights Reserved.
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     * http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     * =============================================================================
     */
    function localResponseNormalizationBackprop_(x, y, dy, depthRadius = 5, bias = 1, alpha = 1, beta = 0.5) {
      const forward = (backend3) => backend3.LRNGrad(dy, x, y, depthRadius, bias, alpha, beta);
      const inputs = {x, y, dy};
      const attrs = {depthRadius, bias, alpha, beta};
      return ENGINE2.runKernelFunc(forward, inputs, null, LRNBackprop, attrs);
    }
    const localResponseNormalizationBackprop = op2({localResponseNormalizationBackprop_});
    /**
     * @license
     * Copyright 2020 Google LLC. All Rights Reserved.
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     * http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     * =============================================================================
     */
    const lrnGradConfig = {
      kernelName: LRN,
      inputsToSave: ["x"],
      outputsToSave: [true],
      gradFunc: (dy, saved, attrs) => {
        const [x, y] = saved;
        const {depthRadius, bias, alpha, beta} = attrs;
        return {
          x: () => localResponseNormalizationBackprop(x, y, dy, depthRadius, bias, alpha, beta)
        };
      }
    };
    /**
     * @license
     * Copyright 2020 Google LLC. All Rights Reserved.
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     * http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     * =============================================================================
     */
    function gradForMinAndMax(dy, y, xOrig, origAxes) {
      if (y.rank < xOrig.rank) {
        y = reshape5(y, expandShapeToKeepDim2(y.shape, origAxes));
      }
      if (dy.rank < xOrig.rank) {
        dy = reshape5(dy, expandShapeToKeepDim2(dy.shape, origAxes));
      }
      return {
        x: () => {
          const dx = mul3(dy, cast7(equal(xOrig, y), dy.dtype));
          return dx;
        }
      };
    }
    /**
     * @license
     * Copyright 2020 Google LLC. All Rights Reserved.
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     * http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     * =============================================================================
     */
    const maxGradConfig = {
      kernelName: Max3,
      inputsToSave: ["x"],
      outputsToSave: [true],
      gradFunc: (dy, saved, attrs) => {
        const maxAttrs = attrs;
        const {reductionIndices} = maxAttrs;
        const x = saved[0];
        const y = saved[1];
        const origAxes = parseAxisParam2(reductionIndices, x.shape);
        const maxGrad = gradForMinAndMax(dy, y, x, origAxes);
        return {
          x: () => {
            return maxGrad["x"]();
          }
        };
      }
    };
    /**
     * @license
     * Copyright 2020 Google LLC. All Rights Reserved.
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     * http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     * =============================================================================
     */
    const maximumGradConfig = {
      kernelName: Maximum3,
      inputsToSave: ["a", "b"],
      gradFunc: (dy, saved) => {
        const [a, b] = saved;
        const derA = () => mul3(dy, cast7(greaterEqual(a, b), "float32"));
        const derB = () => mul3(dy, cast7(less(a, b), "float32"));
        return {a: derA, b: derB};
      }
    };
    /**
     * @license
     * Copyright 2020 Google LLC. All Rights Reserved.
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     * http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     * =============================================================================
     */
    function maxPool3dBackprop_(dy, input2, output, filterSize, strides, dilations = [1, 1, 1], pad3, dimRoundingMode) {
      const $dy = convertToTensor2(dy, "dy", "maxPool3dBackprop");
      const $input = convertToTensor2(input2, "input", "maxPool3dBackprop");
      const $output = convertToTensor2(output, "output", "maxPool3dBackprop");
      let dy5D = $dy;
      let input5D = $input;
      let output5D = $output;
      let reshapedTo5D = false;
      if ($input.rank === 4) {
        reshapedTo5D = true;
        dy5D = reshape5($dy, [1, $dy.shape[0], $dy.shape[1], $dy.shape[2], $dy.shape[3]]);
        input5D = reshape5($input, [
          1,
          $input.shape[0],
          $input.shape[1],
          $input.shape[2],
          $input.shape[3]
        ]);
        output5D = reshape5($output, [
          1,
          $output.shape[0],
          $output.shape[1],
          $output.shape[2],
          $output.shape[3]
        ]);
      }
      assert2(dy5D.rank === 5, () => `Error in maxPool3dBackprop: dy must be rank 5 but got rank ${dy5D.rank}.`);
      assert2(input5D.rank === 5, () => `Error in maxPool3dBackprop: input must be rank 5 but got rank ${input5D.rank}.`);
      assert2(output5D.rank === 5, () => `Error in maxPool3dBackprop: output must be rank 5 but got rank ${output5D.rank}.`);
      assert2(eitherStridesOrDilationsAreOne2(strides, dilations), () => `Error in maxPool3dBackprop: Either strides or dilations must be 1. Got strides ${strides} and dilations '${dilations}'`);
      if (dimRoundingMode != null) {
        assert2(isInt2(pad3), () => `Error in maxPool3dBackprop: pad must be an integer when using, dimRoundingMode ${dimRoundingMode} but got pad ${pad3}.`);
      }
      const forward = (backend3) => {
        const convInfo = computePool3DInfo2(input5D.shape, filterSize, strides, dilations, pad3, dimRoundingMode);
        return backend3.maxPool3dBackprop(dy5D, input5D, output5D, convInfo);
      };
      const inputs = {dy: dy5D, input: input5D, output: output5D};
      const attrs = {filterSize, strides, dilations, pad: pad3, dimRoundingMode};
      const res = ENGINE2.runKernelFunc(forward, inputs, null, MaxPool3DBackprop, attrs);
      if (reshapedTo5D) {
        return reshape5(res, [res.shape[1], res.shape[2], res.shape[3], res.shape[4]]);
      }
      return res;
    }
    const maxPool3dBackprop = op2({maxPool3dBackprop_});
    /**
     * @license
     * Copyright 2020 Google LLC. All Rights Reserved.
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     * http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     * =============================================================================
     */
    const maxPool3DGradConfig = {
      kernelName: MaxPool3D,
      inputsToSave: ["x"],
      outputsToSave: [true],
      gradFunc: (dy, saved, attrs) => {
        const [x, y] = saved;
        const {filterSize, strides, dilations, pad: pad3, dimRoundingMode} = attrs;
        const $dilations = dilations == null ? [1, 1, 1] : dilations;
        return {
          x: () => maxPool3dBackprop(dy, x, y, filterSize, strides, $dilations, pad3, dimRoundingMode)
        };
      }
    };
    /**
     * @license
     * Copyright 2020 Google LLC. All Rights Reserved.
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     * http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     * =============================================================================
     */
    function maxPoolBackprop_(dy, input2, output, filterSize, strides, pad3, dimRoundingMode) {
      const $dy = convertToTensor2(dy, "dy", "maxPoolBackprop");
      const $input = convertToTensor2(input2, "input", "maxPoolBackprop");
      const $output = convertToTensor2(output, "output", "maxPoolBackprop");
      assert2($input.rank === $dy.rank, () => `Rank of input (${$input.rank}) does not match rank of dy (${$dy.rank})`);
      assert2($dy.rank === 4, () => `Error in maxPoolBackprop: dy must be rank 4 but got rank ${$dy.rank}.`);
      assert2($input.rank === 4, () => `Error in maxPoolBackprop: input must be rank 4 but got rank ${$input.rank}.`);
      if (dimRoundingMode != null) {
        assert2(isInt2(pad3), () => `Error in maxPoolBackprop: pad must be an integer when using, dimRoundingMode ${dimRoundingMode} but got pad ${pad3}.`);
      }
      const forward = (backend3) => {
        const convInfo = computePool2DInfo2($input.shape, filterSize, strides, 1, pad3, dimRoundingMode);
        return backend3.maxPoolBackprop($dy, $input, $output, convInfo);
      };
      const inputs = {dy: $dy, input: $input, output: $output};
      const attrs = {filterSize, strides, pad: pad3, dimRoundingMode};
      return ENGINE2.runKernelFunc(forward, inputs, null, MaxPoolBackprop, attrs);
    }
    const maxPoolBackprop = op2({maxPoolBackprop_});
    /**
     * @license
     * Copyright 2020 Google LLC. All Rights Reserved.
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     * http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     * =============================================================================
     */
    const maxPoolGradConfig = {
      kernelName: MaxPool3,
      inputsToSave: ["x"],
      outputsToSave: [true],
      gradFunc: (dy, saved, attrs) => {
        const [x, y] = saved;
        const {filterSize, strides, pad: pad3} = attrs;
        return {
          x: () => maxPoolBackprop(dy, x, y, filterSize, strides, pad3)
        };
      }
    };
    /**
     * @license
     * Copyright 2020 Google LLC. All Rights Reserved.
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     * http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     * =============================================================================
     */
    const minGradConfig = {
      kernelName: Min3,
      inputsToSave: ["x"],
      outputsToSave: [true],
      gradFunc: (dy, saved, attrs) => {
        const minAttrs = attrs;
        const {axis} = minAttrs;
        const [x, y] = saved;
        const origAxes = parseAxisParam2(axis, x.shape);
        const minGrad = gradForMinAndMax(dy, y, x, origAxes);
        return {
          x: () => {
            return minGrad["x"]();
          }
        };
      }
    };
    /**
     * @license
     * Copyright 2020 Google LLC. All Rights Reserved.
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     * http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     * =============================================================================
     */
    const minimumGradConfig = {
      kernelName: Minimum3,
      inputsToSave: ["a", "b"],
      gradFunc: (dy, saved) => {
        const [a, b] = saved;
        const derA = () => mul3(dy, cast7(lessEqual(a, b), "float32"));
        const derB = () => mul3(dy, cast7(greater(a, b), "float32"));
        return {a: derA, b: derB};
      }
    };
    /**
     * @license
     * Copyright 2020 Google LLC. All Rights Reserved.
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     * http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     * =============================================================================
     */
    const mirrorPadGradConfig = {
      kernelName: MirrorPad,
      inputsToSave: ["x"],
      gradFunc: (dy, saved, attrs) => {
        const x = saved[0];
        const {paddings} = attrs;
        const begin = paddings.map((p2) => p2[0]);
        return {x: () => slice2(dy, begin, x.shape)};
      }
    };
    /**
     * @license
     * Copyright 2020 Google LLC. All Rights Reserved.
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     * http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     * =============================================================================
     */
    const modGradConfig = {
      kernelName: Mod,
      inputsToSave: ["a", "b"],
      gradFunc: (dy, saved) => {
        const [a, b] = saved;
        const outShape = assertAndGetBroadcastShape2(a.shape, b.shape);
        const derA = () => {
          const reduceAxes = getReductionAxes2(a.shape, outShape);
          if (reduceAxes.length > 0) {
            return reshape5(sum$1(dy, reduceAxes), a.shape);
          }
          return dy;
        };
        const derB = () => {
          const res = mul3(dy, neg(floor(div(a, b))));
          const reduceAxes = getReductionAxes2(b.shape, outShape);
          if (reduceAxes.length > 0) {
            return reshape5(sum$1(res, reduceAxes), b.shape);
          }
          return res;
        };
        return {a: derA, b: derB};
      }
    };
    /**
     * @license
     * Copyright 2020 Google LLC. All Rights Reserved.
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     * http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     * =============================================================================
     */
    const multiplyGradConfig = {
      kernelName: Multiply3,
      inputsToSave: ["a", "b"],
      gradFunc: (dy, saved) => {
        const [a, b] = saved;
        const outShape = assertAndGetBroadcastShape2(a.shape, b.shape);
        const derA = () => {
          const res = mul3(dy, cast7(b, "float32"));
          const reduceAxes = getReductionAxes2(a.shape, outShape);
          if (reduceAxes.length > 0) {
            return reshape5(sum$1(res, reduceAxes), a.shape);
          }
          return res;
        };
        const derB = () => {
          const res = mul3(dy, cast7(a, "float32"));
          const reduceAxes = getReductionAxes2(b.shape, outShape);
          if (reduceAxes.length > 0) {
            return reshape5(sum$1(res, reduceAxes), b.shape);
          }
          return res;
        };
        return {a: derA, b: derB};
      }
    };
    /**
     * @license
     * Copyright 2020 Google LLC. All Rights Reserved.
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     * http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     * =============================================================================
     */
    const negateGradConfig = {
      kernelName: Negate3,
      gradFunc: (dy) => {
        return {x: () => neg(dy)};
      }
    };
    /**
     * @license
     * Copyright 2020 Google LLC. All Rights Reserved.
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     * http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     * =============================================================================
     */
    const oneHotGradConfig = {
      kernelName: OneHot3,
      inputsToSave: ["indices"],
      gradFunc: (dy, saved) => {
        const indices = saved[0];
        return {indices: () => zeros3(indices.shape, "float32")};
      }
    };
    /**
     * @license
     * Copyright 2020 Google LLC. All Rights Reserved.
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     * http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     * =============================================================================
     */
    const onesLikeGradConfig = {
      kernelName: OnesLike3,
      gradFunc: (dy) => {
        return {x: () => zerosLike2(dy)};
      }
    };
    /**
     * @license
     * Copyright 2020 Google LLC. All Rights Reserved.
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     * http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     * =============================================================================
     */
    const padV2GradConfig = {
      kernelName: PadV23,
      inputsToSave: ["x"],
      gradFunc: (dy, saved, attrs) => {
        const x = saved[0];
        const {paddings} = attrs;
        const begin = paddings.map((p2) => p2[0]);
        return {x: () => slice2(dy, begin, x.shape)};
      }
    };
    /**
     * @license
     * Copyright 2020 Google LLC. All Rights Reserved.
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     * http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     * =============================================================================
     */
    const powGradConfig = {
      kernelName: Pow3,
      inputsToSave: ["a", "b"],
      outputsToSave: [true],
      gradFunc: (dy, saved) => {
        const [a, b, y] = saved;
        const base2 = a;
        const exp2 = b;
        const outShape = assertAndGetBroadcastShape2(base2.shape, exp2.shape);
        const derBase = () => {
          const expFloat = cast7(exp2, "float32");
          let res = mul3(dy, mul3(expFloat, pow(base2, sub(expFloat, scalar3(1)))));
          const reduceAxes = getReductionAxes2(base2.shape, outShape);
          if (reduceAxes.length > 0) {
            res = sum$1(res, reduceAxes);
          }
          return reshape5(res, base2.shape);
        };
        const derExp = () => {
          const condition = greater(base2, 0);
          const logBase = where(condition, log22(base2), zerosLike2(base2));
          let res = mul3(dy, mul3(y, logBase));
          const reduceAxes = getReductionAxes2(exp2.shape, outShape);
          if (reduceAxes.length > 0) {
            res = sum$1(res, reduceAxes);
          }
          return reshape5(res, exp2.shape);
        };
        return {a: derBase, b: derExp};
      }
    };
    /**
     * @license
     * Copyright 2020 Google LLC. All Rights Reserved.
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     * http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     * =============================================================================
     */
    const preluGradConfig = {
      kernelName: Prelu3,
      inputsToSave: ["x", "alpha"],
      gradFunc: (dy, saved) => {
        const [x, alpha] = saved;
        const mask = greater(x, 0);
        return {
          x: () => where(mask, dy, mul3(dy, alpha)),
          alpha: () => {
            let res = where(mask, zerosLike2(dy), mul3(dy, x));
            const reduceAxes = getReductionAxes2(alpha.shape, dy.shape);
            if (reduceAxes.length > 0) {
              res = sum$1(res, reduceAxes);
            }
            return reshape5(res, alpha.shape);
          }
        };
      }
    };
    /**
     * @license
     * Copyright 2020 Google LLC. All Rights Reserved.
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     * http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     * =============================================================================
     */
    const reciprocalGradConfig = {
      kernelName: Reciprocal,
      inputsToSave: ["x"],
      gradFunc: (dy, saved) => {
        const [x] = saved;
        return {x: () => div(dy, neg(square(x)))};
      }
    };
    /**
     * @license
     * Copyright 2020 Google LLC. All Rights Reserved.
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     * http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     * =============================================================================
     */
    const relu6GradConfig = {
      kernelName: Relu63,
      inputsToSave: ["x"],
      gradFunc: (dy, saved) => {
        const [x] = saved;
        const mask = mul3(lessEqual(x, 6), step3(x));
        return {x: () => mul3(dy, cast7(mask, "float32"))};
      }
    };
    /**
     * @license
     * Copyright 2020 Google LLC. All Rights Reserved.
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     * http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     * =============================================================================
     */
    const reluGradConfig = {
      kernelName: Relu3,
      inputsToSave: ["x"],
      gradFunc: (dy, saved) => {
        const [x] = saved;
        return {x: () => mul3(dy, cast7(step3(x), "float32"))};
      }
    };
    /**
     * @license
     * Copyright 2020 Google Inc. All Rights Reserved.
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     * http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     * =============================================================================
     */
    const reshapeGradConfig = {
      kernelName: Reshape6,
      inputsToSave: ["x"],
      gradFunc: (dy, saved) => {
        const [x] = saved;
        return {x: () => reshape5(dy, x.shape)};
      }
    };
    /**
     * @license
     * Copyright 2020 Google LLC. All Rights Reserved.
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     * http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     * =============================================================================
     */
    const resizeBilinearGradConfig = {
      kernelName: ResizeBilinear3,
      inputsToSave: ["images"],
      gradFunc: (dy, saved, attrs) => {
        const [images] = saved;
        const backPropKernelFunc = (backend3) => {
          const {alignCorners} = attrs;
          return backend3.resizeBilinearBackprop(dy, images, alignCorners);
        };
        const inputs = {images};
        const imagesDer = () => ENGINE2.runKernelFunc(backPropKernelFunc, inputs, null, ResizeBilinearGrad, attrs);
        return {images: imagesDer};
      }
    };
    /**
     * @license
     * Copyright 2020 Google LLC. All Rights Reserved.
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     * http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     * =============================================================================
     */
    const resizeNearestNeighborGradConfig = {
      kernelName: ResizeNearestNeighbor,
      inputsToSave: ["images"],
      gradFunc: (dy, saved, attrs) => {
        const [images] = saved;
        const backPropKernelFunc = (backend3) => {
          const {alignCorners} = attrs;
          return backend3.resizeNearestNeighborBackprop(dy, images, alignCorners);
        };
        const inputs = {images};
        const imagesDer = () => ENGINE2.runKernelFunc(backPropKernelFunc, inputs, null, ResizeNearestNeighborGrad, attrs);
        return {images: imagesDer};
      }
    };
    /**
     * @license
     * Copyright 2020 Google LLC. All Rights Reserved.
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     * http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     * =============================================================================
     */
    const reverseGradConfig = {
      kernelName: Reverse3,
      gradFunc: (dy, saved, attrs) => {
        const {dims} = attrs;
        const axes = parseAxisParam2(dims, dy.shape);
        return {x: () => reverse2(dy, axes)};
      }
    };
    /**
     * @license
     * Copyright 2020 Google LLC. All Rights Reserved.
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     * http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     * =============================================================================
     */
    const roundGradConfig = {
      kernelName: Round,
      gradFunc: (dy) => {
        return {x: () => zerosLike2(dy)};
      }
    };
    /**
     * @license
     * Copyright 2020 Google LLC. All Rights Reserved.
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     * http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     * =============================================================================
     */
    const rsqrtGradConfig = {
      kernelName: Rsqrt3,
      inputsToSave: ["x"],
      gradFunc: (dy, saved) => {
        const [x] = saved;
        return {x: () => neg(div(dy, mul3(pow(x, 1.5), 2)))};
      }
    };
    /**
     * @license
     * Copyright 2020 Google LLC. All Rights Reserved.
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     * http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     * =============================================================================
     */
    const selectV2PoolGradConfig = {
      kernelName: SelectV23,
      inputsToSave: ["condition"],
      gradFunc: (dy, saved) => {
        const [condition] = saved;
        return {
          condition: () => cast7(zerosLike2(condition), "float32"),
          t: () => mul3(dy, cast7(condition, dy.dtype)),
          e: () => mul3(dy, cast7(logicalNot(condition), dy.dtype))
        };
      }
    };
    /**
     * @license
     * Copyright 2020 Google LLC. All Rights Reserved.
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     * http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     * =============================================================================
     */
    const seluGradConfig = {
      kernelName: Selu,
      inputsToSave: ["x"],
      gradFunc: (dy, saved) => {
        const [x] = saved;
        return {
          x: () => {
            const mask = greater(x, scalar3(0));
            const scaleAlpha2 = scalar3(SELU_SCALEALPHA2);
            const scale2 = scalar3(SELU_SCALE2);
            const greaterThanZeroDer = mul3(dy, scale2);
            const lessEqualZeroDer = mul3(mul3(dy, scaleAlpha2), exp(cast7(x, "float32")));
            return where(mask, greaterThanZeroDer, lessEqualZeroDer);
          }
        };
      }
    };
    /**
     * @license
     * Copyright 2020 Google LLC. All Rights Reserved.
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     * http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     * =============================================================================
     */
    const sigmoidGradConfig = {
      kernelName: Sigmoid3,
      outputsToSave: [true],
      gradFunc: (dy, saved) => {
        const [y] = saved;
        return {x: () => mul3(dy, mul3(y, sub(scalar3(1), y)))};
      }
    };
    /**
     * @license
     * Copyright 2020 Google LLC. All Rights Reserved.
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     * http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     * =============================================================================
     */
    const signGradConfig = {
      kernelName: Sign,
      gradFunc: (dy) => {
        return {x: () => zerosLike2(dy)};
      }
    };
    /**
     * @license
     * Copyright 2020 Google LLC. All Rights Reserved.
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     * http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     * =============================================================================
     */
    const sinGradConfig = {
      kernelName: Sin3,
      inputsToSave: ["x"],
      gradFunc: (dy, saved) => {
        const [x] = saved;
        return {x: () => mul3(cos(cast7(x, "float32")), dy)};
      }
    };
    /**
     * @license
     * Copyright 2020 Google LLC. All Rights Reserved.
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     * http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     * =============================================================================
     */
    const sinhGradConfig = {
      kernelName: Sinh,
      inputsToSave: ["x"],
      gradFunc: (dy, saved) => {
        const [x] = saved;
        return {x: () => mul3(cosh(cast7(x, "float32")), dy)};
      }
    };
    /**
     * @license
     * Copyright 2020 Google LLC. All Rights Reserved.
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     * http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     * =============================================================================
     */
    const sliceGradConfig = {
      kernelName: Slice6,
      inputsToSave: ["x"],
      gradFunc: (dy, saved, attrs) => {
        const [x] = saved;
        const {begin, size} = attrs;
        const inputShape = x.shape;
        const [begin_, size_] = parseSliceParams2(x, begin, size);
        const paddings = [];
        for (let i = 0; i < dy.rank; i++) {
          paddings.push([begin_[i], inputShape[i] - begin_[i] - size_[i]]);
        }
        return {x: () => pad2(dy, paddings)};
      }
    };
    /**
     * @license
     * Copyright 2020 Google LLC. All Rights Reserved.
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     * http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     * =============================================================================
     */
    const softmaxGradConfig = {
      kernelName: Softmax3,
      outputsToSave: [true],
      gradFunc: (dy, saved, attrs) => {
        const [y] = saved;
        const {dim} = attrs;
        const keepDims = true;
        const dyTimesY = mul3(dy, y);
        return {
          logits: () => sub(dyTimesY, mul3(sum$1(dyTimesY, [dim], keepDims), y))
        };
      }
    };
    /**
     * @license
     * Copyright 2020 Google LLC. All Rights Reserved.
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     * http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     * =============================================================================
     */
    const softplusGradConfig = {
      kernelName: Softplus,
      inputsToSave: ["x"],
      gradFunc: (dy, saved) => {
        const [x] = saved;
        return {x: () => mul3(dy, sigmoid2(x))};
      }
    };
    /**
     * @license
     * Copyright 2020 Google LLC. All Rights Reserved.
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     * http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     * =============================================================================
     */
    const spaceToBatchNDGradConfig = {
      kernelName: SpaceToBatchND,
      gradFunc: (dy, saved, attrs) => {
        const {blockShape, paddings} = attrs;
        return {x: () => batchToSpaceND(dy, blockShape, paddings)};
      }
    };
    /**
     * @license
     * Copyright 2020 Google LLC. All Rights Reserved.
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     * http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     * =============================================================================
     */
    const splitVGradConfig = {
      kernelName: SplitV2,
      gradFunc: (dy, saved, attrs) => {
        const {axis} = attrs;
        return {x: () => concat2(dy, axis)};
      }
    };
    /**
     * @license
     * Copyright 2020 Google LLC. All Rights Reserved.
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     * http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     * =============================================================================
     */
    const sqrtGradConfig = {
      kernelName: Sqrt3,
      inputsToSave: ["x"],
      gradFunc: (dy, saved) => {
        const [x] = saved;
        return {x: () => div(dy, mul3(sqrt(cast7(x, "float32")), 2))};
      }
    };
    /**
     * @license
     * Copyright 2019 Google LLC. All Rights Reserved.
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     * http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     * =============================================================================
     */
    const squareGradConfig = {
      kernelName: Square3,
      inputsToSave: ["x"],
      gradFunc: (dy, saved) => {
        const [x] = saved;
        return {x: () => mul3(dy, mul3(cast7(x, "float32"), 2))};
      }
    };
    /**
     * @license
     * Copyright 2020 Google LLC. All Rights Reserved.
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     * http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     * =============================================================================
     */
    const squaredDifferenceGradConfig = {
      kernelName: SquaredDifference3,
      inputsToSave: ["a", "b"],
      gradFunc: (dy, saved) => {
        const [a, b] = saved;
        const two = scalar3(2);
        const derA = () => mul3(dy, mul3(two, sub(a, b)));
        const derB = () => mul3(dy, mul3(two, sub(b, a)));
        return {a: derA, b: derB};
      }
    };
    /**
     * @license
     * Copyright 2020 Google LLC. All Rights Reserved.
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     * http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     * =============================================================================
     */
    const stepGradConfig = {
      kernelName: Step2,
      gradFunc: (dy) => {
        return {x: () => zerosLike2(dy)};
      }
    };
    /**
     * @license
     * Copyright 2020 Google LLC. All Rights Reserved.
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     * http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     * =============================================================================
     */
    const subGradConfig = {
      kernelName: Sub3,
      inputsToSave: ["a", "b"],
      gradFunc: (dy, saved) => {
        const [a, b] = saved;
        const outShape = assertAndGetBroadcastShape2(a.shape, b.shape);
        const derA = () => {
          let res = dy;
          const reduceAxes = getReductionAxes2(a.shape, outShape);
          if (reduceAxes.length > 0) {
            res = sum$1(res, reduceAxes);
          }
          return reshape5(res, a.shape);
        };
        const derB = () => {
          let res = dy;
          const reduceAxes = getReductionAxes2(b.shape, outShape);
          if (reduceAxes.length > 0) {
            res = sum$1(res, reduceAxes);
          }
          return reshape5(neg(res), b.shape);
        };
        return {a: derA, b: derB};
      }
    };
    /**
     * @license
     * Copyright 2020 Google Inc. All Rights Reserved.
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     * http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     * =============================================================================
     */
    const sumGradConfig = {
      kernelName: Sum3,
      inputsToSave: ["x"],
      gradFunc: (dy, saved, attrs) => {
        const [x] = saved;
        const expandedDyShape = x.shape.slice();
        const {axis} = attrs;
        const axes = parseAxisParam2(axis, x.shape);
        axes.forEach((axis2) => {
          expandedDyShape[axis2] = 1;
        });
        const expandedDy = reshape5(dy, expandedDyShape);
        const derX = mul3(expandedDy, ones$1(x.shape, "float32"));
        return {x: () => derX};
      }
    };
    /**
     * @license
     * Copyright 2020 Google LLC. All Rights Reserved.
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     * http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     * =============================================================================
     */
    const tanGradConfig = {
      kernelName: Tan,
      inputsToSave: ["x"],
      gradFunc: (dy, saved) => {
        const [x] = saved;
        return {x: () => div(dy, square(cos(x)))};
      }
    };
    /**
     * @license
     * Copyright 2020 Google LLC. All Rights Reserved.
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     * http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     * =============================================================================
     */
    const tanhGradConfig = {
      kernelName: Tanh3,
      outputsToSave: [true],
      gradFunc: (dy, saved) => {
        const [y] = saved;
        return {x: () => mul3(sub(scalar3(1), square(y)), dy)};
      }
    };
    /**
     * @license
     * Copyright 2020 Google LLC. All Rights Reserved.
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     * http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     * =============================================================================
     */
    const tileGradConfig = {
      kernelName: Tile3,
      inputsToSave: ["x"],
      gradFunc: (dy, saved, attrs) => {
        const [x] = saved;
        const {reps} = attrs;
        const derX = () => {
          let xGrad = zerosLike2(x);
          if (x.rank === 1) {
            for (let i = 0; i < reps[0]; ++i) {
              xGrad = add$1(xGrad, slice2(dy, [i * x.shape[0]], [x.shape[0]]));
            }
          } else if (x.rank === 2) {
            for (let i = 0; i < reps[0]; ++i) {
              for (let j = 0; j < reps[1]; ++j) {
                xGrad = add$1(xGrad, slice2(dy, [i * x.shape[0], j * x.shape[1]], [
                  x.shape[0],
                  x.shape[1]
                ]));
              }
            }
          } else if (x.rank === 3) {
            for (let i = 0; i < reps[0]; ++i) {
              for (let j = 0; j < reps[1]; ++j) {
                for (let k = 0; k < reps[2]; ++k) {
                  xGrad = add$1(xGrad, slice2(dy, [i * x.shape[0], j * x.shape[1], k * x.shape[2]], [x.shape[0], x.shape[1], x.shape[2]]));
                }
              }
            }
          } else if (x.rank === 4) {
            for (let i = 0; i < reps[0]; ++i) {
              for (let j = 0; j < reps[1]; ++j) {
                for (let k = 0; k < reps[2]; ++k) {
                  for (let l = 0; l < reps[3]; ++l) {
                    xGrad = add$1(xGrad, slice2(dy, [
                      i * x.shape[0],
                      j * x.shape[1],
                      k * x.shape[2],
                      l * x.shape[3]
                    ], [x.shape[0], x.shape[1], x.shape[2], x.shape[3]]));
                  }
                }
              }
            }
          } else {
            throw new Error(`Gradient for tile operation is not implemented for rank-${x.rank} tensors yet.`);
          }
          return xGrad;
        };
        return {x: derX};
      }
    };
    /**
     * @license
     * Copyright 2020 Google LLC. All Rights Reserved.
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     * http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     * =============================================================================
     */
    const transposeGradConfig = {
      kernelName: Transpose5,
      gradFunc: (dy, saved, attrs) => {
        const transposeAttrs = attrs;
        const {perm} = transposeAttrs;
        const undoPerm = getUndoAxesPermutation2(perm);
        return {x: () => transpose4(dy, undoPerm)};
      }
    };
    /**
     * @license
     * Copyright 2020 Google Inc. All Rights Reserved.
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     * http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     * =============================================================================
     */
    const unpackGradConfig = {
      kernelName: Unpack3,
      gradFunc: (dy, saved, attrs) => {
        const unpackAttrs = attrs;
        const {axis} = unpackAttrs;
        return {value: () => stack(dy, axis)};
      }
    };
    /**
     * @license
     * Copyright 2020 Google LLC. All Rights Reserved.
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     * http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     * =============================================================================
     */
    const unsortedSegmentSumGradConfig = {
      kernelName: UnsortedSegmentSum,
      inputsToSave: ["segmentIds"],
      gradFunc: (dy, saved) => {
        const [segmentIds] = saved;
        const derX = () => {
          return gatherDropNegatives(dy, segmentIds);
        };
        return {x: derX};
      }
    };
    function gatherDropNegatives(x, indices) {
      const zeroClippedIndices = maximum(indices, zerosLike2(indices));
      const gathered = gather(x, zeroClippedIndices);
      let isPositive = greaterEqual(indices, scalar3(0, "int32"));
      const numIters = gathered.rank - isPositive.rank;
      for (let i = 0; i < numIters; ++i) {
        isPositive = expandDims(isPositive, i + 1);
      }
      isPositive = logicalAnd(isPositive, ones$1(gathered.shape, "bool"));
      const zeroSlice = zerosLike2(gathered);
      return where(isPositive, gathered, zeroSlice);
    }
    /**
     * @license
     * Copyright 2020 Google LLC. All Rights Reserved.
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     * http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     * =============================================================================
     */
    const zerosLikeGradConfig = {
      kernelName: ZerosLike3,
      gradFunc: (dy) => {
        return {x: () => zerosLike2(dy)};
      }
    };
    /**
     * @license
     * Copyright 2020 Google LLC. All Rights Reserved.
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     * http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     * =============================================================================
     */
    const gradConfigs = [
      absGradConfig,
      acosGradConfig,
      acoshGradConfig,
      addGradConfig,
      addNGradConfig,
      argMaxGradConfig,
      argMinGradConfig,
      asinGradConfig,
      asinhGradConfig,
      atan2GradConfig,
      atanGradConfig,
      atanhGradConfig,
      avgPool3DGradConfig,
      avgPoolGradConfig,
      batchMatMulGradConfig,
      batchToSpaceNDGradConfig,
      broadcastToGradConfig,
      castGradConfig,
      ceilGradConfig,
      clipByValueGradConfig,
      concatGradConfig,
      conv2DBackpropInputGradConfig,
      conv2DGradConfig,
      conv3DGradConfig,
      cosGradConfig,
      coshGradConfig,
      cumsumGradConfig,
      depthwiseConv2dNativeGradConfig,
      dilation2dGradConfig,
      divGradConfig,
      eluGradConfig,
      erfGradConfig,
      expGradConfig,
      expm1GradConfig,
      floorDivGradConfig,
      floorGradConfig,
      fusedBatchNormGradConfig,
      gatherGradConfig,
      greaterEqualGradConfig,
      identityGradConfig,
      isFiniteGradConfig,
      isInfGradConfig,
      isNanGradConfig,
      log1pGradConfig,
      logGradConfig,
      logSoftmaxGradConfig,
      lrnGradConfig,
      maxGradConfig,
      maxGradConfig,
      maximumGradConfig,
      maxPool3DGradConfig,
      maxPoolGradConfig,
      minGradConfig,
      minimumGradConfig,
      mirrorPadGradConfig,
      modGradConfig,
      multiplyGradConfig,
      negateGradConfig,
      oneHotGradConfig,
      onesLikeGradConfig,
      padV2GradConfig,
      padV2GradConfig,
      powGradConfig,
      preluGradConfig,
      reciprocalGradConfig,
      relu6GradConfig,
      reluGradConfig,
      reshapeGradConfig,
      resizeBilinearGradConfig,
      resizeNearestNeighborGradConfig,
      reverseGradConfig,
      roundGradConfig,
      rsqrtGradConfig,
      selectV2PoolGradConfig,
      seluGradConfig,
      sigmoidGradConfig,
      signGradConfig,
      sinGradConfig,
      sinhGradConfig,
      sliceGradConfig,
      softmaxGradConfig,
      softplusGradConfig,
      spaceToBatchNDGradConfig,
      spaceToBatchNDGradConfig,
      splitVGradConfig,
      splitVGradConfig,
      sqrtGradConfig,
      squaredDifferenceGradConfig,
      squareGradConfig,
      stepGradConfig,
      subGradConfig,
      sumGradConfig,
      tanGradConfig,
      tanhGradConfig,
      tileGradConfig,
      transposeGradConfig,
      unpackGradConfig,
      unsortedSegmentSumGradConfig,
      zerosLikeGradConfig
    ];
    for (const gradientConfig of gradConfigs) {
      registerGradient(gradientConfig);
    }
    /**
     * @license
     * Copyright 2020 Google LLC. All Rights Reserved.
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     * http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     * =============================================================================
     */
    Tensor2.prototype.abs = function() {
      this.throwIfDisposed();
      return abs(this);
    };
    /**
     * @license
     * Copyright 2020 Google LLC. All Rights Reserved.
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     * http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     * =============================================================================
     */
    Tensor2.prototype.acos = function() {
      this.throwIfDisposed();
      return acos(this);
    };
    /**
     * @license
     * Copyright 2020 Google LLC. All Rights Reserved.
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     * http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     * =============================================================================
     */
    Tensor2.prototype.acosh = function() {
      this.throwIfDisposed();
      return acosh(this);
    };
    /**
     * @license
     * Copyright 2020 Google LLC. All Rights Reserved.
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     * http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     * =============================================================================
     */
    Tensor2.prototype.addStrict = function(x) {
      this.throwIfDisposed();
      return addStrict(this, x);
    };
    /**
     * @license
     * Copyright 2020 Google LLC. All Rights Reserved.
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     * http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     * =============================================================================
     */
    Tensor2.prototype.add = function(b) {
      this.throwIfDisposed();
      return add$1(this, b);
    };
    /**
     * @license
     * Copyright 2020 Google LLC. All Rights Reserved.
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     * http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     * =============================================================================
     */
    Tensor2.prototype.all = function(axis, keepDims) {
      this.throwIfDisposed();
      return all(this, axis, keepDims);
    };
    /**
     * @license
     * Copyright 2020 Google LLC. All Rights Reserved.
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     * http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     * =============================================================================
     */
    Tensor2.prototype.any = function(axis, keepDims) {
      this.throwIfDisposed();
      return any(this, axis, keepDims);
    };
    /**
     * @license
     * Copyright 2020 Google LLC. All Rights Reserved.
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     * http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     * =============================================================================
     */
    Tensor2.prototype.argMax = function(axis) {
      this.throwIfDisposed();
      return argMax(this, axis);
    };
    /**
     * @license
     * Copyright 2020 Google LLC. All Rights Reserved.
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     * http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     * =============================================================================
     */
    Tensor2.prototype.argMin = function(axis) {
      this.throwIfDisposed();
      return argMin(this, axis);
    };
    /**
     * @license
     * Copyright 2020 Google LLC. All Rights Reserved.
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     * http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     * =============================================================================
     */
    Tensor2.prototype.asScalar = function() {
      this.throwIfDisposed();
      assert2(this.size === 1, () => "The array must have only 1 element.");
      return reshape5(this, []);
    };
    /**
     * @license
     * Copyright 2020 Google LLC. All Rights Reserved.
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     * http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     * =============================================================================
     */
    Tensor2.prototype.asType = function(dtype) {
      this.throwIfDisposed();
      return cast7(this, dtype);
    };
    /**
     * @license
     * Copyright 2020 Google LLC. All Rights Reserved.
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     * http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     * =============================================================================
     */
    Tensor2.prototype.as1D = function() {
      this.throwIfDisposed();
      return reshape5(this, [this.size]);
    };
    /**
     * @license
     * Copyright 2020 Google LLC. All Rights Reserved.
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     * http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     * =============================================================================
     */
    Tensor2.prototype.as2D = function(rows, columns) {
      this.throwIfDisposed();
      return reshape5(this, [rows, columns]);
    };
    /**
     * @license
     * Copyright 2020 Google LLC. All Rights Reserved.
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     * http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     * =============================================================================
     */
    Tensor2.prototype.as3D = function(rows, columns, depth) {
      this.throwIfDisposed();
      return reshape5(this, [rows, columns, depth]);
    };
    /**
     * @license
     * Copyright 2020 Google LLC. All Rights Reserved.
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     * http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     * =============================================================================
     */
    Tensor2.prototype.as4D = function(rows, columns, depth, depth2) {
      this.throwIfDisposed();
      return reshape5(this, [rows, columns, depth, depth2]);
    };
    /**
     * @license
     * Copyright 2020 Google LLC. All Rights Reserved.
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     * http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     * =============================================================================
     */
    Tensor2.prototype.as5D = function(rows, columns, depth, depth2, depth3) {
      this.throwIfDisposed();
      return reshape5(this, [rows, columns, depth, depth2, depth3]);
    };
    /**
     * @license
     * Copyright 2020 Google LLC. All Rights Reserved.
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     * http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     * =============================================================================
     */
    Tensor2.prototype.asin = function() {
      this.throwIfDisposed();
      return asin(this);
    };
    /**
     * @license
     * Copyright 2020 Google LLC. All Rights Reserved.
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     * http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     * =============================================================================
     */
    Tensor2.prototype.asinh = function() {
      this.throwIfDisposed();
      return asinh(this);
    };
    /**
     * @license
     * Copyright 2020 Google LLC. All Rights Reserved.
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     * http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     * =============================================================================
     */
    Tensor2.prototype.atan = function() {
      this.throwIfDisposed();
      return atan(this);
    };
    /**
     * @license
     * Copyright 2020 Google LLC. All Rights Reserved.
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     * http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     * =============================================================================
     */
    Tensor2.prototype.atan2 = function(b) {
      this.throwIfDisposed();
      return atan2(this, b);
    };
    /**
     * @license
     * Copyright 2020 Google LLC. All Rights Reserved.
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     * http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     * =============================================================================
     */
    Tensor2.prototype.atanh = function() {
      this.throwIfDisposed();
      return atanh(this);
    };
    /**
     * @license
     * Copyright 2020 Google LLC. All Rights Reserved.
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     * http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     * =============================================================================
     */
    Tensor2.prototype.avgPool = function(filterSize, strides, pad3, dimRoundingMode) {
      this.throwIfDisposed();
      return avgPool2(this, filterSize, strides, pad3, dimRoundingMode);
    };
    /**
     * @license
     * Copyright 2020 Google LLC. All Rights Reserved.
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     * http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     * =============================================================================
     */
    Tensor2.prototype.batchToSpaceND = function(blockShape, crops) {
      this.throwIfDisposed();
      return batchToSpaceND(this, blockShape, crops);
    };
    /**
     * @license
     * Copyright 2020 Google LLC. All Rights Reserved.
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     * http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     * =============================================================================
     */
    Tensor2.prototype.batchNorm = function(mean2, variance2, offset, scale2, varianceEpsilon) {
      this.throwIfDisposed();
      return batchNorm(this, mean2, variance2, offset, scale2, varianceEpsilon);
    };
    /**
     * @license
     * Copyright 2020 Google LLC. All Rights Reserved.
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     * http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     * =============================================================================
     */
    Tensor2.prototype.broadcastTo = function(shape) {
      this.throwIfDisposed();
      return broadcastTo(this, shape);
    };
    /**
     * @license
     * Copyright 2020 Google LLC. All Rights Reserved.
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     * http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     * =============================================================================
     */
    Tensor2.prototype.cast = function(dtype) {
      this.throwIfDisposed();
      return cast7(this, dtype);
    };
    /**
     * @license
     * Copyright 2020 Google LLC. All Rights Reserved.
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     * http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     * =============================================================================
     */
    Tensor2.prototype.ceil = function() {
      this.throwIfDisposed();
      return ceil(this);
    };
    /**
     * @license
     * Copyright 2020 Google LLC. All Rights Reserved.
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     * http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     * =============================================================================
     */
    Tensor2.prototype.clipByValue = function(min3, max3) {
      this.throwIfDisposed();
      return clipByValue(this, min3, max3);
    };
    /**
     * @license
     * Copyright 2020 Google LLC. All Rights Reserved.
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     * http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     * =============================================================================
     */
    Tensor2.prototype.concat = function(x, axis) {
      this.throwIfDisposed();
      if (x instanceof Tensor2) {
        x = [x];
      }
      return concat2([this, ...x], axis);
    };
    /**
     * @license
     * Copyright 2020 Google LLC. All Rights Reserved.
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     * http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     * =============================================================================
     */
    Tensor2.prototype.conv1d = function(filter, stride, pad3, dataFormat, dilation, dimRoundingMode) {
      this.throwIfDisposed();
      return conv1d(this, filter, stride, pad3, dataFormat, dilation, dimRoundingMode);
    };
    /**
     * @license
     * Copyright 2020 Google LLC. All Rights Reserved.
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     * http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     * =============================================================================
     */
    Tensor2.prototype.conv2dTranspose = function(filter, outputShape, strides, pad3, dimRoundingMode) {
      this.throwIfDisposed();
      return conv2dTranspose(this, filter, outputShape, strides, pad3, dimRoundingMode);
    };
    /**
     * @license
     * Copyright 2020 Google LLC. All Rights Reserved.
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     * http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     * =============================================================================
     */
    Tensor2.prototype.conv2d = function(filter, strides, pad3, dataFormat, dilations, dimRoundingMode) {
      this.throwIfDisposed();
      return conv2d2(this, filter, strides, pad3, dataFormat, dilations, dimRoundingMode);
    };
    /**
     * @license
     * Copyright 2020 Google LLC. All Rights Reserved.
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     * http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     * =============================================================================
     */
    Tensor2.prototype.cos = function() {
      this.throwIfDisposed();
      return cos(this);
    };
    /**
     * @license
     * Copyright 2020 Google LLC. All Rights Reserved.
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     * http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     * =============================================================================
     */
    Tensor2.prototype.cosh = function() {
      this.throwIfDisposed();
      return cosh(this);
    };
    /**
     * @license
     * Copyright 2020 Google LLC. All Rights Reserved.
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     * http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     * =============================================================================
     */
    Tensor2.prototype.cumsum = function(axis, exclusive, reverse3) {
      this.throwIfDisposed();
      return cumsum2(this, axis, exclusive, reverse3);
    };
    /**
     * @license
     * Copyright 2020 Google LLC. All Rights Reserved.
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     * http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     * =============================================================================
     */
    Tensor2.prototype.depthToSpace = function(blockSize, dataFormat) {
      this.throwIfDisposed();
      return depthToSpace2(this, blockSize, dataFormat);
    };
    /**
     * @license
     * Copyright 2020 Google LLC. All Rights Reserved.
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     * http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     * =============================================================================
     */
    Tensor2.prototype.depthwiseConv2D = function(filter, strides, pad3, dataFormat, dilations, dimRoundingMode) {
      deprecationWarn2("depthwiseConv2D is deprecated, use depthwiseConv2d instead");
      this.throwIfDisposed();
      return depthwiseConv2d2(this, filter, strides, pad3, dataFormat, dilations, dimRoundingMode);
    };
    /**
     * @license
     * Copyright 2020 Google LLC. All Rights Reserved.
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     * http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     * =============================================================================
     */
    Tensor2.prototype.depthwiseConv2d = function(filter, strides, pad3, dataFormat, dilations, dimRoundingMode) {
      this.throwIfDisposed();
      return depthwiseConv2d2(this, filter, strides, pad3, dataFormat, dilations, dimRoundingMode);
    };
    /**
     * @license
     * Copyright 2020 Google LLC. All Rights Reserved.
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     * http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     * =============================================================================
     */
    Tensor2.prototype.dilation2d = function(filter, strides, pad3, dilations, dataFormat) {
      this.throwIfDisposed();
      return dilation2d(this, filter, strides, pad3, dilations, dataFormat);
    };
    /**
     * @license
     * Copyright 2020 Google LLC. All Rights Reserved.
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     * http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     * =============================================================================
     */
    Tensor2.prototype.divNoNan = function(b) {
      this.throwIfDisposed();
      return divNoNan(this, b);
    };
    /**
     * @license
     * Copyright 2020 Google LLC. All Rights Reserved.
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     * http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     * =============================================================================
     */
    Tensor2.prototype.divStrict = function(x) {
      this.throwIfDisposed();
      return divStrict(this, x);
    };
    /**
     * @license
     * Copyright 2020 Google LLC. All Rights Reserved.
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     * http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     * =============================================================================
     */
    Tensor2.prototype.div = function(b) {
      this.throwIfDisposed();
      return div(this, b);
    };
    /**
     * @license
     * Copyright 2020 Google LLC. All Rights Reserved.
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     * http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     * =============================================================================
     */
    Tensor2.prototype.dot = function(b) {
      this.throwIfDisposed();
      return dot2(this, b);
    };
    /**
     * @license
     * Copyright 2020 Google LLC. All Rights Reserved.
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     * http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     * =============================================================================
     */
    Tensor2.prototype.elu = function() {
      this.throwIfDisposed();
      return elu3(this);
    };
    /**
     * @license
     * Copyright 2020 Google LLC. All Rights Reserved.
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     * http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     * =============================================================================
     */
    Tensor2.prototype.equalStrict = function(x) {
      this.throwIfDisposed();
      return equalStrict(this, x);
    };
    /**
     * @license
     * Copyright 2020 Google LLC. All Rights Reserved.
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     * http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     * =============================================================================
     */
    Tensor2.prototype.equal = function(b) {
      this.throwIfDisposed();
      return equal(this, b);
    };
    /**
     * @license
     * Copyright 2020 Google LLC. All Rights Reserved.
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     * http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     * =============================================================================
     */
    Tensor2.prototype.erf = function() {
      this.throwIfDisposed();
      return erf(this);
    };
    /**
     * @license
     * Copyright 2020 Google LLC. All Rights Reserved.
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     * http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     * =============================================================================
     */
    Tensor2.prototype.exp = function() {
      this.throwIfDisposed();
      return exp(this);
    };
    /**
     * @license
     * Copyright 2020 Google LLC. All Rights Reserved.
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     * http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     * =============================================================================
     */
    Tensor2.prototype.expandDims = function(axis) {
      this.throwIfDisposed();
      return expandDims(this, axis);
    };
    /**
     * @license
     * Copyright 2020 Google LLC. All Rights Reserved.
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     * http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     * =============================================================================
     */
    Tensor2.prototype.expm1 = function() {
      this.throwIfDisposed();
      return expm1(this);
    };
    /**
     * @license
     * Copyright 2020 Google LLC. All Rights Reserved.
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     * http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     * =============================================================================
     */
    Tensor2.prototype.fft = function() {
      this.throwIfDisposed();
      return fft(this);
    };
    /**
     * @license
     * Copyright 2020 Google LLC. All Rights Reserved.
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     * http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     * =============================================================================
     */
    Tensor2.prototype.flatten = function() {
      this.throwIfDisposed();
      return reshape5(this, [this.size]);
    };
    /**
     * @license
     * Copyright 2020 Google LLC. All Rights Reserved.
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     * http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     * =============================================================================
     */
    Tensor2.prototype.floor = function() {
      this.throwIfDisposed();
      return floor(this);
    };
    /**
     * @license
     * Copyright 2020 Google LLC. All Rights Reserved.
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     * http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     * =============================================================================
     */
    Tensor2.prototype.floorDiv = function(b) {
      this.throwIfDisposed();
      return floorDiv(this, b);
    };
    /**
     * @license
     * Copyright 2020 Google LLC. All Rights Reserved.
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     * http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     * =============================================================================
     */
    Tensor2.prototype.gather = function(indices, axis) {
      this.throwIfDisposed();
      return gather(this, indices, axis);
    };
    /**
     * @license
     * Copyright 2020 Google LLC. All Rights Reserved.
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     * http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     * =============================================================================
     */
    Tensor2.prototype.greaterEqualStrict = function(x) {
      this.throwIfDisposed();
      return greaterEqualStrict(this, x);
    };
    /**
     * @license
     * Copyright 2020 Google LLC. All Rights Reserved.
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     * http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     * =============================================================================
     */
    Tensor2.prototype.greaterEqual = function(b) {
      this.throwIfDisposed();
      return greaterEqual(this, b);
    };
    /**
     * @license
     * Copyright 2020 Google LLC. All Rights Reserved.
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     * http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     * =============================================================================
     */
    Tensor2.prototype.greaterStrict = function(x) {
      this.throwIfDisposed();
      return greaterStrict(this, x);
    };
    /**
     * @license
     * Copyright 2020 Google LLC. All Rights Reserved.
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     * http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     * =============================================================================
     */
    Tensor2.prototype.greater = function(b) {
      this.throwIfDisposed();
      return greater(this, b);
    };
    /**
     * @license
     * Copyright 2020 Google LLC. All Rights Reserved.
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     * http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     * =============================================================================
     */
    Tensor2.prototype.ifft = function() {
      this.throwIfDisposed();
      return ifft(this);
    };
    /**
     * @license
     * Copyright 2020 Google LLC. All Rights Reserved.
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     * http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     * =============================================================================
     */
    Tensor2.prototype.irfft = function() {
      this.throwIfDisposed();
      return irfft(this);
    };
    /**
     * @license
     * Copyright 2020 Google LLC. All Rights Reserved.
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     * http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     * =============================================================================
     */
    Tensor2.prototype.isFinite = function() {
      this.throwIfDisposed();
      return isFinite$1(this);
    };
    /**
     * @license
     * Copyright 2020 Google LLC. All Rights Reserved.
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     * http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     * =============================================================================
     */
    Tensor2.prototype.isInf = function() {
      this.throwIfDisposed();
      return isInf(this);
    };
    /**
     * @license
     * Copyright 2020 Google LLC. All Rights Reserved.
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     * http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     * =============================================================================
     */
    Tensor2.prototype.isNaN = function() {
      this.throwIfDisposed();
      return isNaN$1(this);
    };
    /**
     * @license
     * Copyright 2020 Google LLC. All Rights Reserved.
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     * http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     * =============================================================================
     */
    Tensor2.prototype.leakyRelu = function(alpha) {
      this.throwIfDisposed();
      return leakyRelu(this, alpha);
    };
    /**
     * @license
     * Copyright 2020 Google LLC. All Rights Reserved.
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     * http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     * =============================================================================
     */
    Tensor2.prototype.lessEqualStrict = function(x) {
      this.throwIfDisposed();
      return lessEqualStrict(this, x);
    };
    /**
     * @license
     * Copyright 2020 Google LLC. All Rights Reserved.
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     * http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     * =============================================================================
     */
    Tensor2.prototype.lessEqual = function(b) {
      this.throwIfDisposed();
      return lessEqual(this, b);
    };
    /**
     * @license
     * Copyright 2020 Google LLC. All Rights Reserved.
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     * http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     * =============================================================================
     */
    Tensor2.prototype.lessStrict = function(x) {
      this.throwIfDisposed();
      return lessStrict(this, x);
    };
    /**
     * @license
     * Copyright 2020 Google LLC. All Rights Reserved.
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     * http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     * =============================================================================
     */
    Tensor2.prototype.less = function(b) {
      this.throwIfDisposed();
      return less(this, b);
    };
    /**
     * @license
     * Copyright 2020 Google LLC. All Rights Reserved.
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     * http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     * =============================================================================
     */
    Tensor2.prototype.localResponseNormalization = function(depthRadius, bias, alpha, beta) {
      this.throwIfDisposed();
      return localResponseNormalization(this, depthRadius, bias, alpha, beta);
    };
    /**
     * @license
     * Copyright 2020 Google LLC. All Rights Reserved.
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     * http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     * =============================================================================
     */
    Tensor2.prototype.logSigmoid = function() {
      this.throwIfDisposed();
      return logSigmoid(this);
    };
    /**
     * @license
     * Copyright 2020 Google LLC. All Rights Reserved.
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     * http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     * =============================================================================
     */
    Tensor2.prototype.logSoftmax = function(axis) {
      this.throwIfDisposed();
      return logSoftmax(this, axis);
    };
    /**
     * @license
     * Copyright 2020 Google LLC. All Rights Reserved.
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     * http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     * =============================================================================
     */
    Tensor2.prototype.logSumExp = function(axis, keepDims) {
      this.throwIfDisposed();
      return logSumExp(this, axis, keepDims);
    };
    /**
     * @license
     * Copyright 2020 Google LLC. All Rights Reserved.
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     * http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     * =============================================================================
     */
    Tensor2.prototype.log = function() {
      this.throwIfDisposed();
      return log22(this);
    };
    /**
     * @license
     * Copyright 2020 Google LLC. All Rights Reserved.
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     * http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     * =============================================================================
     */
    Tensor2.prototype.log1p = function() {
      this.throwIfDisposed();
      return log1p(this);
    };
    /**
     * @license
     * Copyright 2020 Google LLC. All Rights Reserved.
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     * http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     * =============================================================================
     */
    Tensor2.prototype.logicalAnd = function(b) {
      this.throwIfDisposed();
      return logicalAnd(this, b);
    };
    /**
     * @license
     * Copyright 2020 Google LLC. All Rights Reserved.
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     * http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     * =============================================================================
     */
    Tensor2.prototype.logicalNot = function() {
      this.throwIfDisposed();
      return logicalNot(this);
    };
    /**
     * @license
     * Copyright 2020 Google LLC. All Rights Reserved.
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     * http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     * =============================================================================
     */
    Tensor2.prototype.logicalOr = function(b) {
      this.throwIfDisposed();
      return logicalOr(this, b);
    };
    /**
     * @license
     * Copyright 2020 Google LLC. All Rights Reserved.
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     * http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     * =============================================================================
     */
    Tensor2.prototype.logicalXor = function(b) {
      this.throwIfDisposed();
      return logicalXor(this, b);
    };
    /**
     * @license
     * Copyright 2020 Google LLC. All Rights Reserved.
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     * http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     * =============================================================================
     */
    Tensor2.prototype.matMul = function(b, transposeA, transposeB) {
      this.throwIfDisposed();
      return matMul(this, b, transposeA, transposeB);
    };
    /**
     * @license
     * Copyright 2020 Google LLC. All Rights Reserved.
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     * http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     * =============================================================================
     */
    Tensor2.prototype.maxPool = function(filterSize, strides, pad3, dimRoundingMode) {
      this.throwIfDisposed();
      return maxPool2(this, filterSize, strides, pad3, dimRoundingMode);
    };
    /**
     * @license
     * Copyright 2020 Google LLC. All Rights Reserved.
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     * http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     * =============================================================================
     */
    Tensor2.prototype.max = function(axis, keepDims) {
      this.throwIfDisposed();
      return max2(this, axis, keepDims);
    };
    /**
     * @license
     * Copyright 2020 Google LLC. All Rights Reserved.
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     * http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     * =============================================================================
     */
    Tensor2.prototype.maximumStrict = function(x) {
      this.throwIfDisposed();
      return maximumStrict(this, x);
    };
    /**
     * @license
     * Copyright 2020 Google LLC. All Rights Reserved.
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     * http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     * =============================================================================
     */
    Tensor2.prototype.maximum = function(b) {
      this.throwIfDisposed();
      return maximum(this, b);
    };
    /**
     * @license
     * Copyright 2020 Google LLC. All Rights Reserved.
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     * http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     * =============================================================================
     */
    Tensor2.prototype.mean = function(axis, keepDims) {
      this.throwIfDisposed();
      return mean(this, axis, keepDims);
    };
    /**
     * @license
     * Copyright 2020 Google LLC. All Rights Reserved.
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     * http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     * =============================================================================
     */
    Tensor2.prototype.min = function(axis, keepDims) {
      this.throwIfDisposed();
      return min2(this, axis, keepDims);
    };
    /**
     * @license
     * Copyright 2020 Google LLC. All Rights Reserved.
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     * http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     * =============================================================================
     */
    Tensor2.prototype.minimumStrict = function(x) {
      this.throwIfDisposed();
      return minimumStrict(this, x);
    };
    /**
     * @license
     * Copyright 2020 Google LLC. All Rights Reserved.
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     * http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     * =============================================================================
     */
    Tensor2.prototype.minimum = function(b) {
      this.throwIfDisposed();
      return minimum(this, b);
    };
    /**
     * @license
     * Copyright 2020 Google LLC. All Rights Reserved.
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     * http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     * =============================================================================
     */
    Tensor2.prototype.mirrorPad = function(paddings, mode) {
      this.throwIfDisposed();
      return mirrorPad(this, paddings, mode);
    };
    /**
     * @license
     * Copyright 2020 Google LLC. All Rights Reserved.
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     * http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     * =============================================================================
     */
    Tensor2.prototype.modStrict = function(x) {
      this.throwIfDisposed();
      return modStrict(this, x);
    };
    /**
     * @license
     * Copyright 2020 Google LLC. All Rights Reserved.
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     * http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     * =============================================================================
     */
    Tensor2.prototype.mod = function(b) {
      this.throwIfDisposed();
      return mod(this, b);
    };
    /**
     * @license
     * Copyright 2020 Google LLC. All Rights Reserved.
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     * http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     * =============================================================================
     */
    Tensor2.prototype.mulStrict = function(x) {
      this.throwIfDisposed();
      return mulStrict(this, x);
    };
    /**
     * @license
     * Copyright 2020 Google LLC. All Rights Reserved.
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     * http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     * =============================================================================
     */
    Tensor2.prototype.mul = function(b) {
      this.throwIfDisposed();
      return mul3(this, b);
    };
    /**
     * @license
     * Copyright 2020 Google LLC. All Rights Reserved.
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     * http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     * =============================================================================
     */
    Tensor2.prototype.neg = function() {
      this.throwIfDisposed();
      return neg(this);
    };
    /**
     * @license
     * Copyright 2020 Google LLC. All Rights Reserved.
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     * http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     * =============================================================================
     */
    Tensor2.prototype.norm = function(ord, axis, keepDims) {
      this.throwIfDisposed();
      return norm(this, ord, axis, keepDims);
    };
    /**
     * @license
     * Copyright 2020 Google LLC. All Rights Reserved.
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     * http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     * =============================================================================
     */
    Tensor2.prototype.notEqualStrict = function(x) {
      this.throwIfDisposed();
      return notEqualStrict(this, x);
    };
    /**
     * @license
     * Copyright 2020 Google LLC. All Rights Reserved.
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     * http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     * =============================================================================
     */
    Tensor2.prototype.notEqual = function(b) {
      this.throwIfDisposed();
      return notEqual(this, b);
    };
    /**
     * @license
     * Copyright 2020 Google LLC. All Rights Reserved.
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     * http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     * =============================================================================
     */
    Tensor2.prototype.oneHot = function(depth, onValue = 1, offValue = 0) {
      this.throwIfDisposed();
      return oneHot2(this, depth, onValue, offValue);
    };
    /**
     * @license
     * Copyright 2020 Google LLC. All Rights Reserved.
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     * http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     * =============================================================================
     */
    Tensor2.prototype.onesLike = function() {
      this.throwIfDisposed();
      return onesLike2(this);
    };
    /**
     * @license
     * Copyright 2020 Google LLC. All Rights Reserved.
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     * http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     * =============================================================================
     */
    Tensor2.prototype.pad = function(paddings, constantValue) {
      this.throwIfDisposed();
      return pad2(this, paddings, constantValue);
    };
    /**
     * @license
     * Copyright 2020 Google LLC. All Rights Reserved.
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     * http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     * =============================================================================
     */
    Tensor2.prototype.pool = function(windowShape, poolingType, padding, dilationRate, strides) {
      this.throwIfDisposed();
      return pool(this, windowShape, poolingType, padding, dilationRate, strides);
    };
    /**
     * @license
     * Copyright 2020 Google LLC. All Rights Reserved.
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     * http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     * =============================================================================
     */
    Tensor2.prototype.powStrict = function(exp2) {
      this.throwIfDisposed();
      return powStrict(this, exp2);
    };
    /**
     * @license
     * Copyright 2020 Google LLC. All Rights Reserved.
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     * http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     * =============================================================================
     */
    Tensor2.prototype.pow = function(exp2) {
      this.throwIfDisposed();
      return pow(this, exp2);
    };
    /**
     * @license
     * Copyright 2020 Google LLC. All Rights Reserved.
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     * http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     * =============================================================================
     */
    Tensor2.prototype.prelu = function(alpha) {
      this.throwIfDisposed();
      return prelu4(this, alpha);
    };
    /**
     * @license
     * Copyright 2020 Google LLC. All Rights Reserved.
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     * http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     * =============================================================================
     */
    Tensor2.prototype.prod = function(axis, keepDims) {
      this.throwIfDisposed();
      return prod(this, axis, keepDims);
    };
    /**
     * @license
     * Copyright 2020 Google LLC. All Rights Reserved.
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     * http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     * =============================================================================
     */
    Tensor2.prototype.reciprocal = function() {
      this.throwIfDisposed();
      return reciprocal(this);
    };
    /**
     * @license
     * Copyright 2020 Google LLC. All Rights Reserved.
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     * http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     * =============================================================================
     */
    Tensor2.prototype.relu = function() {
      this.throwIfDisposed();
      return relu3(this);
    };
    /**
     * @license
     * Copyright 2020 Google LLC. All Rights Reserved.
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     * http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     * =============================================================================
     */
    Tensor2.prototype.relu6 = function() {
      this.throwIfDisposed();
      return relu63(this);
    };
    /**
     * @license
     * Copyright 2020 Google LLC. All Rights Reserved.
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     * http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     * =============================================================================
     */
    Tensor2.prototype.reshapeAs = function(x) {
      this.throwIfDisposed();
      return reshape5(this, x.shape);
    };
    /**
     * @license
     * Copyright 2020 Google LLC. All Rights Reserved.
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     * http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     * =============================================================================
     */
    Tensor2.prototype.reshape = function(shape) {
      this.throwIfDisposed();
      return reshape5(this, shape);
    };
    /**
     * @license
     * Copyright 2020 Google LLC. All Rights Reserved.
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     * http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     * =============================================================================
     */
    Tensor2.prototype.resizeBilinear = function(newShape2D, alignCorners) {
      this.throwIfDisposed();
      return resizeBilinear2(this, newShape2D, alignCorners);
    };
    /**
     * @license
     * Copyright 2020 Google LLC. All Rights Reserved.
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     * http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     * =============================================================================
     */
    Tensor2.prototype.resizeNearestNeighbor = function(newShape2D, alignCorners) {
      this.throwIfDisposed();
      return resizeNearestNeighbor(this, newShape2D, alignCorners);
    };
    /**
     * @license
     * Copyright 2020 Google LLC. All Rights Reserved.
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     * http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     * =============================================================================
     */
    Tensor2.prototype.reverse = function(axis) {
      this.throwIfDisposed();
      return reverse2(this, axis);
    };
    /**
     * @license
     * Copyright 2020 Google LLC. All Rights Reserved.
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     * http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     * =============================================================================
     */
    Tensor2.prototype.rfft = function() {
      this.throwIfDisposed();
      return rfft(this);
    };
    /**
     * @license
     * Copyright 2020 Google LLC. All Rights Reserved.
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     * http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     * =============================================================================
     */
    Tensor2.prototype.round = function() {
      this.throwIfDisposed();
      return round(this);
    };
    /**
     * @license
     * Copyright 2020 Google LLC. All Rights Reserved.
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     * http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     * =============================================================================
     */
    Tensor2.prototype.rsqrt = function() {
      this.throwIfDisposed();
      return rsqrt(this);
    };
    /**
     * @license
     * Copyright 2020 Google LLC. All Rights Reserved.
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     * http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     * =============================================================================
     */
    Tensor2.prototype.selu = function() {
      this.throwIfDisposed();
      return selu(this);
    };
    /**
     * @license
     * Copyright 2020 Google LLC. All Rights Reserved.
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     * http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     * =============================================================================
     */
    Tensor2.prototype.separableConv2d = function(depthwiseFilter, pointwiseFilter, strides, pad3, dilation, dataFormat) {
      this.throwIfDisposed();
      return separableConv2d(this, depthwiseFilter, pointwiseFilter, strides, pad3, dilation, dataFormat);
    };
    /**
     * @license
     * Copyright 2020 Google LLC. All Rights Reserved.
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     * http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     * =============================================================================
     */
    Tensor2.prototype.sigmoid = function() {
      this.throwIfDisposed();
      return sigmoid2(this);
    };
    /**
     * @license
     * Copyright 2020 Google LLC. All Rights Reserved.
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     * http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     * =============================================================================
     */
    Tensor2.prototype.sign = function() {
      this.throwIfDisposed();
      return sign(this);
    };
    /**
     * @license
     * Copyright 2020 Google LLC. All Rights Reserved.
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     * http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     * =============================================================================
     */
    Tensor2.prototype.sin = function() {
      this.throwIfDisposed();
      return sin(this);
    };
    /**
     * @license
     * Copyright 2020 Google LLC. All Rights Reserved.
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     * http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     * =============================================================================
     */
    Tensor2.prototype.sinh = function() {
      this.throwIfDisposed();
      return sinh(this);
    };
    /**
     * @license
     * Copyright 2020 Google LLC. All Rights Reserved.
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     * http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     * =============================================================================
     */
    Tensor2.prototype.slice = function(begin, size) {
      this.throwIfDisposed();
      return slice2(this, begin, size);
    };
    /**
     * @license
     * Copyright 2020 Google LLC. All Rights Reserved.
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     * http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     * =============================================================================
     */
    Tensor2.prototype.softmax = function(dim) {
      this.throwIfDisposed();
      return softmax2(this, dim);
    };
    /**
     * @license
     * Copyright 2020 Google LLC. All Rights Reserved.
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     * http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     * =============================================================================
     */
    Tensor2.prototype.softplus = function() {
      this.throwIfDisposed();
      return softplus(this);
    };
    /**
     * @license
     * Copyright 2020 Google LLC. All Rights Reserved.
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     * http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     * =============================================================================
     */
    Tensor2.prototype.spaceToBatchND = function(blockShape, paddings) {
      this.throwIfDisposed();
      return spaceToBatchND(this, blockShape, paddings);
    };
    /**
     * @license
     * Copyright 2020 Google LLC. All Rights Reserved.
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     * http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     * =============================================================================
     */
    Tensor2.prototype.split = function(numOrSizeSplits, axis) {
      this.throwIfDisposed();
      return split2(this, numOrSizeSplits, axis);
    };
    /**
     * @license
     * Copyright 2020 Google LLC. All Rights Reserved.
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     * http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     * =============================================================================
     */
    Tensor2.prototype.sqrt = function() {
      this.throwIfDisposed();
      return sqrt(this);
    };
    /**
     * @license
     * Copyright 2020 Google LLC. All Rights Reserved.
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     * http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     * =============================================================================
     */
    Tensor2.prototype.square = function() {
      this.throwIfDisposed();
      return square(this);
    };
    /**
     * @license
     * Copyright 2020 Google LLC. All Rights Reserved.
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     * http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     * =============================================================================
     */
    Tensor2.prototype.squaredDifference = function(b) {
      this.throwIfDisposed();
      return squaredDifference(this, b);
    };
    /**
     * @license
     * Copyright 2020 Google LLC. All Rights Reserved.
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     * http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     * =============================================================================
     */
    Tensor2.prototype.squaredDifferenceStrict = function(x) {
      this.throwIfDisposed();
      return squaredDifferenceStrict(this, x);
    };
    /**
     * @license
     * Copyright 2020 Google LLC. All Rights Reserved.
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     * http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     * =============================================================================
     */
    Tensor2.prototype.squeeze = function(axis) {
      this.throwIfDisposed();
      return squeeze(this, axis);
    };
    /**
     * @license
     * Copyright 2020 Google LLC. All Rights Reserved.
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     * http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     * =============================================================================
     */
    Tensor2.prototype.stack = function(x, axis) {
      this.throwIfDisposed();
      const tensorsToBeStacked = x instanceof Tensor2 ? [this, x] : [this, ...x];
      return stack(tensorsToBeStacked, axis);
    };
    /**
     * @license
     * Copyright 2020 Google LLC. All Rights Reserved.
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     * http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     * =============================================================================
     */
    Tensor2.prototype.step = function(alpha) {
      this.throwIfDisposed();
      return step3(this, alpha);
    };
    /**
     * @license
     * Copyright 2020 Google LLC. All Rights Reserved.
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     * http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     * =============================================================================
     */
    Tensor2.prototype.stridedSlice = function(begin, end, strides, beginMask, endMask, ellipsisMask, newAxisMask, shrinkAxisMask) {
      this.throwIfDisposed();
      return stridedSlice2(this, begin, end, strides, beginMask, endMask, ellipsisMask, newAxisMask, shrinkAxisMask);
    };
    /**
     * @license
     * Copyright 2020 Google LLC. All Rights Reserved.
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     * http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     * =============================================================================
     */
    Tensor2.prototype.subStrict = function(x) {
      this.throwIfDisposed();
      return subStrict(this, x);
    };
    /**
     * @license
     * Copyright 2020 Google LLC. All Rights Reserved.
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     * http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     * =============================================================================
     */
    Tensor2.prototype.sub = function(b) {
      this.throwIfDisposed();
      return sub(this, b);
    };
    /**
     * @license
     * Copyright 2020 Google LLC. All Rights Reserved.
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     * http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     * =============================================================================
     */
    Tensor2.prototype.sum = function(axis, keepDims) {
      this.throwIfDisposed();
      return sum$1(this, axis, keepDims);
    };
    /**
     * @license
     * Copyright 2020 Google LLC. All Rights Reserved.
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     * http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     * =============================================================================
     */
    Tensor2.prototype.tan = function() {
      this.throwIfDisposed();
      return tan(this);
    };
    /**
     * @license
     * Copyright 2020 Google LLC. All Rights Reserved.
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     * http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     * =============================================================================
     */
    Tensor2.prototype.tanh = function() {
      this.throwIfDisposed();
      return tanh$1(this);
    };
    /**
     * @license
     * Copyright 2020 Google LLC. All Rights Reserved.
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     * http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     * =============================================================================
     */
    Tensor2.prototype.tile = function(reps) {
      this.throwIfDisposed();
      return tile2(this, reps);
    };
    /**
     * @license
     * Copyright 2020 Google LLC. All Rights Reserved.
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     * http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     * =============================================================================
     */
    Tensor2.prototype.toBool = function() {
      this.throwIfDisposed();
      return cast7(this, "bool");
    };
    /**
     * @license
     * Copyright 2020 Google LLC. All Rights Reserved.
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     * http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     * =============================================================================
     */
    Tensor2.prototype.toFloat = function() {
      this.throwIfDisposed();
      return cast7(this, "float32");
    };
    /**
     * @license
     * Copyright 2020 Google LLC. All Rights Reserved.
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     * http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     * =============================================================================
     */
    Tensor2.prototype.toInt = function() {
      this.throwIfDisposed();
      return cast7(this, "int32");
    };
    /**
     * @license
     * Copyright 2020 Google LLC. All Rights Reserved.
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     * http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     * =============================================================================
     */
    Tensor2.prototype.topk = function(k, sorted) {
      this.throwIfDisposed();
      return topk(this, k, sorted);
    };
    /**
     * @license
     * Copyright 2020 Google LLC. All Rights Reserved.
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     * http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     * =============================================================================
     */
    Tensor2.prototype.transpose = function(perm) {
      this.throwIfDisposed();
      return transpose4(this, perm);
    };
    /**
     * @license
     * Copyright 2020 Google LLC. All Rights Reserved.
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     * http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     * =============================================================================
     */
    Tensor2.prototype.unique = function(axis) {
      this.throwIfDisposed();
      return unique(this, axis);
    };
    /**
     * @license
     * Copyright 2020 Google LLC. All Rights Reserved.
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     * http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     * =============================================================================
     */
    Tensor2.prototype.unsortedSegmentSum = function(segmentIds, numSegments) {
      this.throwIfDisposed();
      return unsortedSegmentSum(this, segmentIds, numSegments);
    };
    /**
     * @license
     * Copyright 2020 Google LLC. All Rights Reserved.
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     * http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     * =============================================================================
     */
    Tensor2.prototype.unstack = function(axis) {
      this.throwIfDisposed();
      return unstack(this, axis);
    };
    /**
     * @license
     * Copyright 2020 Google LLC. All Rights Reserved.
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     * http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     * =============================================================================
     */
    Tensor2.prototype.where = function(condition, x) {
      this.throwIfDisposed();
      return where(condition, this, x);
    };
    /**
     * @license
     * Copyright 2020 Google LLC. All Rights Reserved.
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     * http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     * =============================================================================
     */
    Tensor2.prototype.zerosLike = function() {
      this.throwIfDisposed();
      return zerosLike2(this);
    };
    /**
     * @license
     * Copyright 2020 Google LLC. All Rights Reserved.
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     * http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     * =============================================================================
     */
    /**
     * @license
     * Copyright 2017 Google LLC. All Rights Reserved.
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     * http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     * =============================================================================
     */
    /**
     * @license
     * Copyright 2018 Google LLC
     *
     * Use of this source code is governed by an MIT-style
     * license that can be found in the LICENSE file or at
     * https://opensource.org/licenses/MIT.
     * =============================================================================
     */
    let _epsilon;
    function epsilon() {
      if (_epsilon == null) {
        _epsilon = backend2().epsilon();
      }
      return _epsilon;
    }
    function setEpsilon(e) {
      _epsilon = e;
    }
    function imageDataFormat() {
      return "channelsLast";
    }
    /**
     * @license
     * Copyright 2018 Google LLC
     *
     * Use of this source code is governed by an MIT-style
     * license that can be found in the LICENSE file or at
     * https://opensource.org/licenses/MIT.
     * =============================================================================
     */
    class AttributeError extends Error {
      constructor(message) {
        super(message);
        Object.setPrototypeOf(this, AttributeError.prototype);
      }
    }
    class RuntimeError extends Error {
      constructor(message) {
        super(message);
        Object.setPrototypeOf(this, RuntimeError.prototype);
      }
    }
    class ValueError extends Error {
      constructor(message) {
        super(message);
        Object.setPrototypeOf(this, ValueError.prototype);
      }
    }
    class NotImplementedError extends Error {
      constructor(message) {
        super(message);
        Object.setPrototypeOf(this, NotImplementedError.prototype);
      }
    }
    class AssertionError extends Error {
      constructor(message) {
        super(message);
        Object.setPrototypeOf(this, AssertionError.prototype);
      }
    }
    class IndexError extends Error {
      constructor(message) {
        super(message);
        Object.setPrototypeOf(this, IndexError.prototype);
      }
    }
    /**
     * @license
     * Copyright 2018 Google LLC
     *
     * Use of this source code is governed by an MIT-style
     * license that can be found in the LICENSE file or at
     * https://opensource.org/licenses/MIT.
     * =============================================================================
     */
    function pyListRepeat(value, numValues) {
      if (Array.isArray(value)) {
        let newArray = [];
        for (let i = 0; i < numValues; i++) {
          newArray = newArray.concat(value);
        }
        return newArray;
      } else {
        const newArray = new Array(numValues);
        newArray.fill(value);
        return newArray;
      }
    }
    function assert$1(val, message) {
      if (!val) {
        throw new AssertionError(message);
      }
    }
    function count(array2, refernce) {
      let counter = 0;
      for (const item of array2) {
        if (item === refernce) {
          counter++;
        }
      }
      return counter;
    }
    function singletonOrArray(xs) {
      if (xs.length === 1) {
        return xs[0];
      }
      return xs;
    }
    function toList(x) {
      if (Array.isArray(x)) {
        return x;
      }
      return [x];
    }
    function objectListUid(objs) {
      const objectList = toList(objs);
      let retVal = "";
      for (const obj of objectList) {
        if (obj.id == null) {
          throw new ValueError(`Object ${obj} passed to objectListUid without an id`);
        }
        if (retVal !== "") {
          retVal = retVal + ", ";
        }
        retVal = `${retVal}${Math.abs(obj.id)}`;
      }
      return retVal;
    }
    function toSnakeCase(name) {
      const intermediate = name.replace(/(.)([A-Z][a-z0-9]+)/g, "$1_$2");
      const insecure = intermediate.replace(/([a-z])([A-Z])/g, "$1_$2").toLowerCase();
      if (insecure[0] !== "_") {
        return insecure;
      }
      return "private" + insecure;
    }
    function toCamelCase(identifier) {
      if (identifier.length <= 1) {
        return identifier;
      }
      if (identifier.indexOf("_") === -1) {
        return identifier;
      }
      return identifier.replace(/[_]+(\w|$)/g, (m, p1) => p1.toUpperCase());
    }
    let _GLOBAL_CUSTOM_OBJECTS = {};
    function serializeKerasObject(instance2) {
      if (instance2 === null || instance2 === void 0) {
        return null;
      }
      const dict = {};
      dict["className"] = instance2.getClassName();
      dict["config"] = instance2.getConfig();
      return dict;
    }
    function convertNDArrayScalarsInConfig(config2) {
      if (config2 == null || typeof config2 !== "object") {
        return;
      } else if (Array.isArray(config2)) {
        config2.forEach((configItem) => convertNDArrayScalarsInConfig(configItem));
      } else {
        const fields = Object.keys(config2);
        for (const field of fields) {
          const value = config2[field];
          if (value != null && typeof value === "object") {
            if (!Array.isArray(value) && value["type"] === "ndarray" && typeof value["value"] === "number") {
              config2[field] = value["value"];
            } else {
              convertNDArrayScalarsInConfig(value);
            }
          }
        }
      }
    }
    function deserializeKerasObject(identifier, moduleObjects = {}, customObjects = {}, printableModuleName = "object", fastWeightInit = false) {
      if (typeof identifier === "string") {
        const functionName = identifier;
        let fn;
        if (functionName in customObjects) {
          fn = customObjects[functionName];
        } else if (functionName in _GLOBAL_CUSTOM_OBJECTS) {
          fn = _GLOBAL_CUSTOM_OBJECTS[functionName];
        } else {
          fn = moduleObjects[functionName];
          if (fn == null) {
            throw new ValueError(`Unknown ${printableModuleName}: ${identifier}. This may be due to one of the following reasons:
1. The ${printableModuleName} is defined in Python, in which case it needs to be ported to TensorFlow.js or your JavaScript code.
2. The custom ${printableModuleName} is defined in JavaScript, but is not registered properly with tf.serialization.registerClass().`);
          }
        }
        return fn;
      } else {
        const config2 = identifier;
        if (config2["className"] == null || config2["config"] == null) {
          throw new ValueError(`${printableModuleName}: Improper config format: ${JSON.stringify(config2)}.
'className' and 'config' must set.`);
        }
        const className = config2["className"];
        let cls, fromConfig;
        if (className in customObjects) {
          [cls, fromConfig] = customObjects[className];
        } else if (className in _GLOBAL_CUSTOM_OBJECTS) {
          [cls, fromConfig] = _GLOBAL_CUSTOM_OBJECTS["className"];
        } else if (className in moduleObjects) {
          [cls, fromConfig] = moduleObjects[className];
        }
        if (cls == null) {
          throw new ValueError(`Unknown ${printableModuleName}: ${className}. This may be due to one of the following reasons:
1. The ${printableModuleName} is defined in Python, in which case it needs to be ported to TensorFlow.js or your JavaScript code.
2. The custom ${printableModuleName} is defined in JavaScript, but is not registered properly with tf.serialization.registerClass().`);
        }
        if (fromConfig != null) {
          const customObjectsCombined = {};
          for (const key of Object.keys(_GLOBAL_CUSTOM_OBJECTS)) {
            customObjectsCombined[key] = _GLOBAL_CUSTOM_OBJECTS[key];
          }
          for (const key of Object.keys(customObjects)) {
            customObjectsCombined[key] = customObjects[key];
          }
          const nestedConfig = config2["config"];
          nestedConfig["customObjects"] = customObjectsCombined;
          const backupCustomObjects = Object.assign({}, _GLOBAL_CUSTOM_OBJECTS);
          for (const key of Object.keys(customObjects)) {
            _GLOBAL_CUSTOM_OBJECTS[key] = customObjects[key];
          }
          convertNDArrayScalarsInConfig(config2["config"]);
          const returnObj = fromConfig(cls, config2["config"], customObjects, fastWeightInit);
          _GLOBAL_CUSTOM_OBJECTS = Object.assign({}, backupCustomObjects);
          return returnObj;
        } else {
          const backupCustomObjects = Object.assign({}, _GLOBAL_CUSTOM_OBJECTS);
          for (const key of Object.keys(customObjects)) {
            _GLOBAL_CUSTOM_OBJECTS[key] = customObjects[key];
          }
          const returnObj = new cls(config2["config"]);
          _GLOBAL_CUSTOM_OBJECTS = Object.assign({}, backupCustomObjects);
          return returnObj;
        }
      }
    }
    function numberCompare(a, b) {
      return a < b ? -1 : a > b ? 1 : 0;
    }
    function reverseNumberCompare(a, b) {
      return -1 * numberCompare(a, b);
    }
    function stringToDType(dtype) {
      switch (dtype) {
        case "float32":
          return "float32";
        default:
          throw new ValueError(`Invalid dtype: ${dtype}`);
      }
    }
    function stringsEqual(xs, ys) {
      if (xs == null || ys == null) {
        return xs === ys;
      }
      if (xs.length !== ys.length) {
        return false;
      }
      for (let i = 0; i < xs.length; ++i) {
        if (xs[i] !== ys[i]) {
          return false;
        }
      }
      return true;
    }
    function unique$1(xs) {
      if (xs == null) {
        return xs;
      }
      const out = [];
      for (const x of xs) {
        if (out.indexOf(x) === -1) {
          out.push(x);
        }
      }
      return out;
    }
    function isObjectEmpty(obj) {
      if (obj == null) {
        throw new ValueError(`Invalid value in obj: ${JSON.stringify(obj)}`);
      }
      for (const key in obj) {
        if (obj.hasOwnProperty(key)) {
          return false;
        }
      }
      return true;
    }
    function checkStringTypeUnionValue(values, label, value) {
      if (value == null) {
        return;
      }
      if (values.indexOf(value) < 0) {
        throw new ValueError(`${value} is not a valid ${label}.  Valid values are ${values} or null/undefined.`);
      }
    }
    function checkArrayTypeAndLength(x, expectedType, minLength = 0, maxLength = Infinity) {
      assert$1(minLength >= 0);
      assert$1(maxLength >= minLength);
      return Array.isArray(x) && x.length >= minLength && x.length <= maxLength && x.every((e) => typeof e === expectedType);
    }
    function assertPositiveInteger(value, name) {
      if (Array.isArray(value)) {
        assert2(value.length > 0, () => `${name} is unexpectedly an empty array.`);
        value.forEach((v, i) => assertPositiveInteger(v, `element ${i + 1} of ${name}`));
      } else {
        assert2(Number.isInteger(value) && value > 0, () => `Expected ${name} to be a positive integer, but got ${formatAsFriendlyString(value)}.`);
      }
    }
    function formatAsFriendlyString(value) {
      if (value === null) {
        return "null";
      } else if (Array.isArray(value)) {
        return "[" + value.map((v) => formatAsFriendlyString(v)).join(",") + "]";
      } else if (typeof value === "string") {
        return `"${value}"`;
      } else {
        return `${value}`;
      }
    }
    function debounce(f, waitMs) {
      let lastTime = now3();
      let lastResult;
      const f2 = (...args) => {
        const now$1 = now3();
        if (now$1 - lastTime < waitMs) {
          return lastResult;
        }
        lastTime = now$1;
        lastResult = f(...args);
        return lastResult;
      };
      return f2;
    }
    function mapActivationToFusedKernel(activationName) {
      if (activationName === "relu") {
        return "relu";
      }
      if (activationName === "linear") {
        return "linear";
      }
      if (activationName === "elu") {
        return "elu";
      }
      return null;
    }
    function getCartesianProductOfValues(...arrayOfValues) {
      assert$1(arrayOfValues.length > 0, "arrayOfValues is empty");
      for (const values of arrayOfValues) {
        assert$1(Array.isArray(values), "one of the values is not an array");
        assert$1(values.length > 0, "one of the values is empty");
      }
      return arrayOfValues.reduce((products, values) => {
        if (products.length === 0) {
          return values.map((value) => [value]);
        }
        return values.map((value) => {
          return products.map((prevValue) => [...prevValue, value]);
        }).reduce((flattenedProduct, unflattenedProduct) => {
          return flattenedProduct.concat(unflattenedProduct);
        }, []);
      }, []);
    }
    /**
     * @license
     * Copyright 2018 Google LLC
     *
     * Use of this source code is governed by an MIT-style
     * license that can be found in the LICENSE file or at
     * https://opensource.org/licenses/MIT.
     * =============================================================================
     */
    function calcL2Norms(w, axis) {
      return tidy(() => sqrt(sum$1(mul3(w, w), axis, true)));
    }
    class Constraint extends Serializable {
      getConfig() {
        return {};
      }
    }
    class MaxNorm extends Constraint {
      constructor(args) {
        super();
        this.defaultMaxValue = 2;
        this.defaultAxis = 0;
        this.maxValue = args.maxValue != null ? args.maxValue : this.defaultMaxValue;
        this.axis = args.axis != null ? args.axis : this.defaultAxis;
      }
      apply(w) {
        return tidy(() => {
          const norms = calcL2Norms(w, this.axis);
          const desired = clipByValue(norms, 0, this.maxValue);
          return mul3(w, div(desired, add$1(epsilon(), norms)));
        });
      }
      getConfig() {
        return {maxValue: this.maxValue, axis: this.axis};
      }
    }
    MaxNorm.className = "MaxNorm";
    registerClass(MaxNorm);
    class UnitNorm extends Constraint {
      constructor(args) {
        super();
        this.defaultAxis = 0;
        this.axis = args.axis != null ? args.axis : this.defaultAxis;
      }
      apply(w) {
        return tidy(() => div(w, add$1(epsilon(), calcL2Norms(w, this.axis))));
      }
      getConfig() {
        return {axis: this.axis};
      }
    }
    UnitNorm.className = "UnitNorm";
    registerClass(UnitNorm);
    class NonNeg extends Constraint {
      apply(w) {
        return relu3(w);
      }
    }
    NonNeg.className = "NonNeg";
    registerClass(NonNeg);
    class MinMaxNorm extends Constraint {
      constructor(args) {
        super();
        this.defaultMinValue = 0;
        this.defaultMaxValue = 1;
        this.defaultRate = 1;
        this.defaultAxis = 0;
        this.minValue = args.minValue != null ? args.minValue : this.defaultMinValue;
        this.maxValue = args.maxValue != null ? args.maxValue : this.defaultMaxValue;
        this.rate = args.rate != null ? args.rate : this.defaultRate;
        this.axis = args.axis != null ? args.axis : this.defaultAxis;
      }
      apply(w) {
        return tidy(() => {
          const norms = calcL2Norms(w, this.axis);
          const desired = add$1(mul3(this.rate, clipByValue(norms, this.minValue, this.maxValue)), mul3(1 - this.rate, norms));
          return mul3(w, div(desired, add$1(epsilon(), norms)));
        });
      }
      getConfig() {
        return {
          minValue: this.minValue,
          maxValue: this.maxValue,
          rate: this.rate,
          axis: this.axis
        };
      }
    }
    MinMaxNorm.className = "MinMaxNorm";
    registerClass(MinMaxNorm);
    const CONSTRAINT_IDENTIFIER_REGISTRY_SYMBOL_MAP = {
      maxNorm: "MaxNorm",
      minMaxNorm: "MinMaxNorm",
      nonNeg: "NonNeg",
      unitNorm: "UnitNorm"
    };
    function serializeConstraint(constraint) {
      return serializeKerasObject(constraint);
    }
    function deserializeConstraint(config2, customObjects = {}) {
      return deserializeKerasObject(config2, SerializationMap.getMap().classNameMap, customObjects, "constraint");
    }
    function getConstraint(identifier) {
      if (identifier == null) {
        return null;
      }
      if (typeof identifier === "string") {
        const className = identifier in CONSTRAINT_IDENTIFIER_REGISTRY_SYMBOL_MAP ? CONSTRAINT_IDENTIFIER_REGISTRY_SYMBOL_MAP[identifier] : identifier;
        const config2 = {className, config: {}};
        return deserializeConstraint(config2);
      } else if (identifier instanceof Constraint) {
        return identifier;
      } else {
        return deserializeConstraint(identifier);
      }
    }
    /**
     * @license
     * Copyright 2018 Google LLC
     *
     * Use of this source code is governed by an MIT-style
     * license that can be found in the LICENSE file or at
     * https://opensource.org/licenses/MIT.
     * =============================================================================
     */
    function maxNorm(args) {
      return new MaxNorm(args);
    }
    function unitNorm(args) {
      return new UnitNorm(args);
    }
    function nonNeg() {
      return new NonNeg();
    }
    function minMaxNorm(config2) {
      return new MinMaxNorm(config2);
    }
    var exports_constraints = /* @__PURE__ */ Object.freeze({
      __proto__: null,
      maxNorm,
      unitNorm,
      nonNeg,
      minMaxNorm
    });
    /**
     * @license
     * Copyright 2018 Google LLC
     *
     * Use of this source code is governed by an MIT-style
     * license that can be found in the LICENSE file or at
     * https://opensource.org/licenses/MIT.
     * =============================================================================
     */
    const VALID_DATA_FORMAT_VALUES = ["channelsFirst", "channelsLast"];
    const VALID_PADDING_MODE_VALUES = ["valid", "same", "causal"];
    const VALID_POOL_MODE_VALUES = ["max", "avg"];
    const VALID_BIDIRECTIONAL_MERGE_MODES = ["sum", "mul", "concat", "ave"];
    const VALID_SAMPLE_WEIGHT_MODES = ["temporal"];
    /**
     * @license
     * Copyright 2018 Google LLC
     *
     * Use of this source code is governed by an MIT-style
     * license that can be found in the LICENSE file or at
     * https://opensource.org/licenses/MIT.
     * =============================================================================
     */
    const nameMap = new Map();
    function checkDataFormat(value) {
      checkStringTypeUnionValue(VALID_DATA_FORMAT_VALUES, "DataFormat", value);
    }
    function checkPaddingMode(value) {
      checkStringTypeUnionValue(VALID_PADDING_MODE_VALUES, "PaddingMode", value);
    }
    function checkPoolMode(value) {
      checkStringTypeUnionValue(VALID_POOL_MODE_VALUES, "PoolMode", value);
    }
    const _nameScopeStack = [];
    const _nameScopeDivider = "/";
    function nameScope(name, fn) {
      _nameScopeStack.push(name);
      try {
        const val = fn();
        _nameScopeStack.pop();
        return val;
      } catch (e) {
        _nameScopeStack.pop();
        throw e;
      }
    }
    function currentNameScopePrefix() {
      if (_nameScopeStack.length === 0) {
        return "";
      } else {
        return _nameScopeStack.join(_nameScopeDivider) + _nameScopeDivider;
      }
    }
    function getScopedTensorName(tensorName) {
      if (!isValidTensorName(tensorName)) {
        throw new Error("Not a valid tensor name: '" + tensorName + "'");
      }
      return currentNameScopePrefix() + tensorName;
    }
    function getUniqueTensorName(scopedName) {
      if (!isValidTensorName(scopedName)) {
        throw new Error("Not a valid tensor name: '" + scopedName + "'");
      }
      if (!nameMap.has(scopedName)) {
        nameMap.set(scopedName, 0);
      }
      const index2 = nameMap.get(scopedName);
      nameMap.set(scopedName, nameMap.get(scopedName) + 1);
      if (index2 > 0) {
        const result = `${scopedName}_${index2}`;
        nameMap.set(result, 1);
        return result;
      } else {
        return scopedName;
      }
    }
    const tensorNameRegex = new RegExp(/^[A-Za-z0-9][-A-Za-z0-9\._\/]*$/);
    function isValidTensorName(name) {
      return !!name.match(tensorNameRegex);
    }
    /**
     * @license
     * Copyright 2018 Google LLC
     *
     * Use of this source code is governed by an MIT-style
     * license that can be found in the LICENSE file or at
     * https://opensource.org/licenses/MIT.
     * =============================================================================
     */
    function isInteger(x) {
      return x === parseInt(x.toString(), 10);
    }
    function arrayProd(array2, begin, end) {
      if (begin == null) {
        begin = 0;
      }
      if (end == null) {
        end = array2.length;
      }
      let prod2 = 1;
      for (let i = begin; i < end; ++i) {
        prod2 *= array2[i];
      }
      return prod2;
    }
    function toArray1D(array2) {
      array2 = Array.isArray(array2) ? new Float32Array(array2) : array2;
      return tensor1d3(array2);
    }
    function min$1(array2) {
      return min2(toArray1D(array2)).dataSync()[0];
    }
    function max$1(array2) {
      return max2(toArray1D(array2)).dataSync()[0];
    }
    function sum$2(array2) {
      return sum$1(toArray1D(array2)).dataSync()[0];
    }
    function mean$2(array2) {
      return sum$2(array2) / array2.length;
    }
    function variance(array2) {
      const demeaned = sub(toArray1D(array2), scalar3(mean$2(array2)));
      const sumSquare = sum$1(mul3(demeaned, demeaned)).dataSync()[0];
      return sumSquare / array2.length;
    }
    function median(array2) {
      const arraySorted = array2.slice().sort((a, b) => a - b);
      const lowIdx = Math.floor((arraySorted.length - 1) / 2);
      const highIdx = Math.ceil((arraySorted.length - 1) / 2);
      if (lowIdx === highIdx) {
        return arraySorted[lowIdx];
      }
      return (arraySorted[lowIdx] + arraySorted[highIdx]) / 2;
    }
    function range$1(begin, end) {
      if (end < begin) {
        throw new ValueError(`end (${end}) < begin (${begin}) is forbidden.`);
      }
      const out = [];
      for (let i = begin; i < end; ++i) {
        out.push(i);
      }
      return out;
    }
    /**
     * @license
     * Copyright 2018 Google LLC
     *
     * Use of this source code is governed by an MIT-style
     * license that can be found in the LICENSE file or at
     * https://opensource.org/licenses/MIT.
     * =============================================================================
     */
    let backend$1 = "webgl";
    function setBackend$1(requestedBackend) {
      setBackend(requestedBackend);
      backend$1 = requestedBackend;
    }
    function getBackend$1() {
      return backend$1;
    }
    function isBackendSymbolic() {
      return false;
    }
    function countParams(x) {
      const shape = x.shape;
      if (shape.length > 0) {
        return shape.reduce((a, b) => a * b);
      } else {
        return 1;
      }
    }
    function cast$1(x, dtype) {
      return x.asType(dtype);
    }
    function expandDims$1(x, axis = -1) {
      const outShape = x.shape.slice();
      if (axis < 0) {
        axis = outShape.length + axis + 1;
      }
      outShape.splice(axis, 0, 1);
      return x.reshape(outShape);
    }
    function repeat(x, n) {
      return tidy(() => {
        if (x.shape.length !== 2) {
          throw new ValueError(`repeat() expects a rank-2 tensor, but received a rank-${x.shape.length} tensor.`);
        }
        const y = expandDims$1(x, 1);
        return tile$2(y, [1, n, 1]);
      });
    }
    function flatten$1(x) {
      const newShape = [arrayProd(x.shape)];
      return x.reshape(newShape);
    }
    function batchFlatten(x) {
      if (x.rank <= 1) {
        throw new ValueError(`batchFlatten requires a minimum rank of 2. Got rank: ${x.rank}.`);
      }
      const newShape = [x.shape[0], arrayProd(x.shape, 1)];
      return x.reshape(newShape);
    }
    function sliceAlongFirstAxis(array2, start, size) {
      return tidy(() => {
        switch (array2.rank) {
          case 1:
            return slice1d(array2, start, size);
          case 2:
            return slice2d2(array2, [start, 0], [size, array2.shape[1]]);
          case 3:
            return slice3d2(array2, [start, 0, 0], [size, array2.shape[1], array2.shape[2]]);
          case 4:
            return slice4d2(array2, [start, 0, 0, 0], [size, array2.shape[1], array2.shape[2], array2.shape[3]]);
          case 5:
            return slice2(array2, [start, 0, 0, 0, 0], [
              size,
              array2.shape[1],
              array2.shape[2],
              array2.shape[3],
              array2.shape[4]
            ]);
          case 6:
            return slice2(array2, [start, 0, 0, 0, 0, 0], [
              size,
              array2.shape[1],
              array2.shape[2],
              array2.shape[3],
              array2.shape[4],
              array2.shape[5]
            ]);
          default:
            throw new ValueError(`sliceAlongFirstAxis() received an unsupported tensor rank: ${array2.rank}`);
        }
      });
    }
    function sliceAlongLastAxis(array2, start, size) {
      return tidy(() => {
        switch (array2.rank) {
          case 1:
            return slice1d(array2, start, size);
          case 2:
            return slice2d2(array2, [0, start], [array2.shape[0], size]);
          case 3:
            return slice3d2(array2, [0, 0, start], [array2.shape[0], array2.shape[1], size]);
          case 4:
            return slice4d2(array2, [0, 0, 0, start], [array2.shape[0], array2.shape[1], array2.shape[2], size]);
          default:
            throw new ValueError(`sliceAlongLastAxis() received an unsupported tensor rank: ${array2.rank}`);
        }
      });
    }
    function sliceAlongAxis(array2, start, size, axis) {
      return tidy(() => {
        switch (array2.rank) {
          case 1:
            return slice1d(array2, start, size);
          case 2:
            switch (axis) {
              case 1:
                return sliceAlongFirstAxis(array2, start, size);
              case 2:
                return sliceAlongLastAxis(array2, start, size);
              default:
                throw new ValueError(`The axis is not within the rank of the tensor ${axis}`);
            }
          case 3:
            switch (axis) {
              case 1:
                return sliceAlongFirstAxis(array2, start, size);
              case 2:
                return slice3d2(array2, [0, start, 0], [array2.shape[0], size, array2.shape[2]]);
              case 3:
                return sliceAlongLastAxis(array2, start, size);
              default:
                throw new ValueError(`The axis is not within the rank of the tensor ${axis}`);
            }
          case 4:
            switch (axis) {
              case 1:
                return sliceAlongFirstAxis(array2, start, size);
              case 2:
                return slice4d2(array2, [0, start, 0, 0], [array2.shape[0], size, array2.shape[2], array2.shape[3]]);
              case 3:
                return slice4d2(array2, [0, 0, start, 0], [array2.shape[0], array2.shape[1], size, array2.shape[3]]);
              case 4:
                return sliceAlongLastAxis(array2, start, size);
              default:
                throw new ValueError(`The axis is not within the rank of the tensor ${axis}`);
            }
          default:
            throw new ValueError(`sliceAlongLastAxis() received an unsupported tensor rank: ${array2.rank}`);
        }
      });
    }
    function concatenate(tensors, axis = -1) {
      let rank;
      if (axis < 0) {
        rank = tensors[0].rank;
        if (rank !== 0) {
          axis = rank;
        } else {
          axis = 0;
        }
      }
      if (axis === tensors[0].rank) {
        axis = -1;
      }
      return concat2(tensors, axis);
    }
    function concatAlongFirstAxis(a, b) {
      switch (a.rank) {
        case 1:
          return concat1d([a, b]);
        case 2:
          return concat2d([a, b], 0);
        case 3:
          return concat3d([a, b], 0);
        case 4:
          return concat4d([a, b], 0);
        default:
          throw new ValueError(`concatAlongFirstAxis() received an unsupported tensor rank: ${a.rank}`);
      }
    }
    function tile$2(x, n) {
      if (!Array.isArray(n)) {
        n = [n];
      }
      if (x.rank !== n.length) {
        throw new ValueError(`The length of input n (${n.length}) does not match the number of dimensions in input x (${x.rank})`);
      }
      return tile2(x, n);
    }
    function randomNormal$1(shape, mean2 = 0, stddev = 1, dtype, seed) {
      return randomNormal(shape, mean2, stddev, dtype, seed);
    }
    function dot$1(a, b, activation2, bias) {
      if (a.rank < 2 || b.rank < 2) {
        throw new NotImplementedError(`dot requires both inputs to be rank >= 2 but got x shape = ${a.shape} and y shape = ${b.shape}`);
      }
      if (b.rank >= 3) {
        const xLastDim = a.shape.slice(-1)[0];
        const ySecondLastDim = b.shape.slice(-2)[0];
        if (xLastDim !== ySecondLastDim) {
          throw new NotImplementedError(`If rank y >= 3, then the second last dim of y must equal the last dim of x but got x shape = ${a.shape} and  y shape = ${b.shape}`);
        }
      }
      if (a.rank === 2 && b.rank === 2) {
        const transposeA = false;
        const transposeB = false;
        return matMul$1({
          a,
          b,
          transposeA,
          transposeB,
          bias: bias ? reshapeBias(a.rank, bias, imageDataFormat()) : null,
          activation: activation2
        });
      } else {
        const aFirstDims = a.shape.slice();
        const aLastDim = aFirstDims.pop();
        a = a.reshape([-1, aLastDim]);
        const bShape = b.shape.slice();
        const bLastDim = bShape.pop();
        const ySecondLastDim = bShape.pop();
        const yOtherDims = [...bShape, bLastDim];
        const perm = Array.from({length: b.rank}, (_, i) => {
          if (i === 0) {
            return b.rank - 2;
          } else if (i <= b.rank - 2) {
            return i - 1;
          }
          return i;
        });
        b = b.transpose(perm).reshape([ySecondLastDim, -1]);
        const outputShape = [...aFirstDims, ...yOtherDims];
        const transposeA = false;
        const transposeB = false;
        return matMul$1({
          a,
          b,
          transposeA,
          transposeB,
          bias: bias ? reshapeBias(a.rank, bias, imageDataFormat()) : null,
          activation: activation2
        }).reshape(outputShape);
      }
    }
    function sign$1(x) {
      return tidy(() => {
        const zerosLikeX = zerosLike2(x);
        const onesLikeX = onesLike2(x);
        return where(equal(x, zerosLikeX), zerosLikeX, where(greater(x, zerosLike2(x)), onesLikeX, mul3(-1, onesLikeX)));
      });
    }
    function oneHot$1(indices, numClasses) {
      return tidy(() => {
        if (indices.rank !== 1) {
          throw new Error("Only 1D one-hot tensors are supported in the deeplearn backend, at present.");
        }
        indices = indices.toInt();
        return oneHot2(indices, numClasses).toFloat();
      });
    }
    function gather$1(reference, indices, axis) {
      return tidy(() => {
        if (Array.isArray(indices)) {
          indices = tensor1d3(indices, "int32");
        } else {
          indices = indices.toInt();
        }
        return gather(reference, indices, axis);
      });
    }
    function square$1(x) {
      return mul3(x, x);
    }
    function pow$1(x, a) {
      return tidy(() => {
        if (typeof a === "number") {
          a = scalar3(Math.round(a), "int32");
        }
        if (a.dtype !== "int32") {
          throw new NotImplementedError(`Non-int32 dtype (${a.dtype}) is not supported by pow() yet`);
        }
        return pow(x, a);
      });
    }
    function reshapeBias(xRank, bias, dataFormat) {
      const biasShape = bias.shape;
      if (bias.rank !== 1 && bias.rank !== xRank) {
        throw new ValueError(`Unexpected bias dimensions: ${bias.rank}; expected it to be 1 or ${xRank}`);
      }
      if (xRank === 5) {
        if (dataFormat === "channelsFirst") {
          if (biasShape.length === 1) {
            return bias.reshape([1, biasShape[0], 1, 1, 1]);
          } else {
            return bias.reshape([1, biasShape[3], biasShape[0], biasShape[1], biasShape[2]]);
          }
        } else if (dataFormat === "channelsLast") {
          if (biasShape.length === 1) {
            return bias.reshape([1, 1, 1, 1, biasShape[0]]);
          } else {
            return bias.reshape([1].concat(biasShape));
          }
        }
      } else if (xRank === 4) {
        if (dataFormat === "channelsFirst") {
          if (biasShape.length === 1) {
            return bias.reshape([1, biasShape[0], 1, 1]);
          } else {
            return bias.reshape([1, biasShape[2], biasShape[0], biasShape[1]]);
          }
        } else if (dataFormat === "channelsLast") {
          if (biasShape.length === 1) {
            return bias.reshape([1, 1, 1, biasShape[0]]);
          } else {
            return bias.reshape([1].concat(biasShape));
          }
        }
      } else if (xRank === 3) {
        if (dataFormat === "channelsFirst") {
          if (biasShape.length === 1) {
            return bias.reshape([1, biasShape[0], 1]);
          } else {
            return bias.reshape([1, biasShape[1], biasShape[0]]);
          }
        } else if (dataFormat === "channelsLast") {
          if (biasShape.length === 1) {
            return bias.reshape([1, 1, biasShape[0]]);
          } else {
            return bias.reshape([1].concat(biasShape));
          }
        }
      } else if (xRank < 3) {
        return bias;
      }
      throw new ValueError(`Unsupported input rank by biasAdd: ${bias.rank}`);
    }
    function biasAdd(x, bias, dataFormat) {
      return tidy(() => {
        if (dataFormat == null) {
          dataFormat = imageDataFormat();
        }
        checkDataFormat(dataFormat);
        return x.add(reshapeBias(x.rank, bias, dataFormat));
      });
    }
    function elu$1(x, alpha = 1) {
      if (alpha !== 1) {
        throw new NotImplementedError(`Support for alpha values other than 1 (${alpha}) is not implemented yet.`);
      }
      return elu3(x);
    }
    function softsign(x) {
      return tidy(() => div(x, abs(x).add(1)));
    }
    function dropout$1(x, level, noiseShape, seed) {
      return tidy(() => dropout(x, level, noiseShape, seed));
    }
    function hardSigmoid(x) {
      return tidy(() => {
        const y = add$1(0.5, mul3(0.2, x));
        return clipByValue(y, 0, 1);
      });
    }
    function inTrainPhase(x, alt, training = false) {
      return training ? x() : alt();
    }
    /**
     * @license
     * Copyright 2018 Google LLC
     *
     * Use of this source code is governed by an MIT-style
     * license that can be found in the LICENSE file or at
     * https://opensource.org/licenses/MIT.
     * =============================================================================
     */
    const VALID_FAN_MODE_VALUES = ["fanIn", "fanOut", "fanAvg"];
    const VALID_DISTRIBUTION_VALUES = ["normal", "uniform", "truncatedNormal"];
    const initializerClassNames = [
      "Zeros",
      "Ones",
      "Constant",
      "RandomNormal",
      "RandomUniform",
      "TruncatedNormal",
      "VarianceScaling",
      "Orthogonal",
      "Identity"
    ];
    /**
     * @license
     * Copyright 2018 Google LLC
     *
     * Use of this source code is governed by an MIT-style
     * license that can be found in the LICENSE file or at
     * https://opensource.org/licenses/MIT.
     * =============================================================================
     */
    function checkFanMode(value) {
      checkStringTypeUnionValue(VALID_FAN_MODE_VALUES, "FanMode", value);
    }
    function checkDistribution(value) {
      checkStringTypeUnionValue(VALID_DISTRIBUTION_VALUES, "Distribution", value);
    }
    class Initializer extends Serializable {
      fromConfigUsesCustomObjects() {
        return false;
      }
      getConfig() {
        return {};
      }
    }
    class Zeros extends Initializer {
      apply(shape, dtype) {
        return zeros3(shape, dtype);
      }
    }
    Zeros.className = "Zeros";
    registerClass(Zeros);
    class Ones extends Initializer {
      apply(shape, dtype) {
        return ones$1(shape, dtype);
      }
    }
    Ones.className = "Ones";
    registerClass(Ones);
    class Constant extends Initializer {
      constructor(args) {
        super();
        if (typeof args !== "object") {
          throw new ValueError(`Expected argument of type ConstantConfig but got ${args}`);
        }
        if (args.value === void 0) {
          throw new ValueError(`config must have value set but got ${args}`);
        }
        this.value = args.value;
      }
      apply(shape, dtype) {
        return tidy(() => mul3(scalar3(this.value), ones$1(shape, dtype)));
      }
      getConfig() {
        return {
          value: this.value
        };
      }
    }
    Constant.className = "Constant";
    registerClass(Constant);
    class RandomUniform extends Initializer {
      constructor(args) {
        super();
        this.DEFAULT_MINVAL = -0.05;
        this.DEFAULT_MAXVAL = 0.05;
        this.minval = args.minval || this.DEFAULT_MINVAL;
        this.maxval = args.maxval || this.DEFAULT_MAXVAL;
        this.seed = args.seed;
      }
      apply(shape, dtype) {
        return randomUniform(shape, this.minval, this.maxval, dtype);
      }
      getConfig() {
        return {minval: this.minval, maxval: this.maxval, seed: this.seed};
      }
    }
    RandomUniform.className = "RandomUniform";
    registerClass(RandomUniform);
    class RandomNormal extends Initializer {
      constructor(args) {
        super();
        this.DEFAULT_MEAN = 0;
        this.DEFAULT_STDDEV = 0.05;
        this.mean = args.mean || this.DEFAULT_MEAN;
        this.stddev = args.stddev || this.DEFAULT_STDDEV;
        this.seed = args.seed;
      }
      apply(shape, dtype) {
        dtype = dtype || "float32";
        if (dtype !== "float32" && dtype !== "int32") {
          throw new NotImplementedError(`randomNormal does not support dType ${dtype}.`);
        }
        return randomNormal$1(shape, this.mean, this.stddev, dtype, this.seed);
      }
      getConfig() {
        return {mean: this.mean, stddev: this.stddev, seed: this.seed};
      }
    }
    RandomNormal.className = "RandomNormal";
    registerClass(RandomNormal);
    class TruncatedNormal extends Initializer {
      constructor(args) {
        super();
        this.DEFAULT_MEAN = 0;
        this.DEFAULT_STDDEV = 0.05;
        this.mean = args.mean || this.DEFAULT_MEAN;
        this.stddev = args.stddev || this.DEFAULT_STDDEV;
        this.seed = args.seed;
      }
      apply(shape, dtype) {
        dtype = dtype || "float32";
        if (dtype !== "float32" && dtype !== "int32") {
          throw new NotImplementedError(`truncatedNormal does not support dType ${dtype}.`);
        }
        return truncatedNormal(shape, this.mean, this.stddev, dtype, this.seed);
      }
      getConfig() {
        return {mean: this.mean, stddev: this.stddev, seed: this.seed};
      }
    }
    TruncatedNormal.className = "TruncatedNormal";
    registerClass(TruncatedNormal);
    class Identity$1 extends Initializer {
      constructor(args) {
        super();
        this.gain = args.gain != null ? args.gain : 1;
      }
      apply(shape, dtype) {
        return tidy(() => {
          if (shape.length !== 2 || shape[0] !== shape[1]) {
            throw new ValueError("Identity matrix initializer can only be used for 2D square matrices.");
          } else {
            return mul3(this.gain, eye(shape[0]));
          }
        });
      }
      getConfig() {
        return {gain: this.gain};
      }
    }
    Identity$1.className = "Identity";
    registerClass(Identity$1);
    function computeFans(shape, dataFormat = "channelsLast") {
      let fanIn;
      let fanOut;
      checkDataFormat(dataFormat);
      if (shape.length === 2) {
        fanIn = shape[0];
        fanOut = shape[1];
      } else if ([3, 4, 5].indexOf(shape.length) !== -1) {
        if (dataFormat === "channelsFirst") {
          const receptiveFieldSize = arrayProd(shape, 2);
          fanIn = shape[1] * receptiveFieldSize;
          fanOut = shape[0] * receptiveFieldSize;
        } else if (dataFormat === "channelsLast") {
          const receptiveFieldSize = arrayProd(shape, 0, shape.length - 2);
          fanIn = shape[shape.length - 2] * receptiveFieldSize;
          fanOut = shape[shape.length - 1] * receptiveFieldSize;
        }
      } else {
        const shapeProd = arrayProd(shape);
        fanIn = Math.sqrt(shapeProd);
        fanOut = Math.sqrt(shapeProd);
      }
      return [fanIn, fanOut];
    }
    class VarianceScaling extends Initializer {
      constructor(args) {
        super();
        if (args.scale < 0) {
          throw new ValueError(`scale must be a positive float. Got: ${args.scale}`);
        }
        this.scale = args.scale == null ? 1 : args.scale;
        this.mode = args.mode == null ? "fanIn" : args.mode;
        checkFanMode(this.mode);
        this.distribution = args.distribution == null ? "normal" : args.distribution;
        checkDistribution(this.distribution);
        this.seed = args.seed;
      }
      apply(shape, dtype) {
        const fans = computeFans(shape);
        const fanIn = fans[0];
        const fanOut = fans[1];
        let scale2 = this.scale;
        if (this.mode === "fanIn") {
          scale2 /= Math.max(1, fanIn);
        } else if (this.mode === "fanOut") {
          scale2 /= Math.max(1, fanOut);
        } else {
          scale2 /= Math.max(1, (fanIn + fanOut) / 2);
        }
        if (this.distribution === "normal") {
          const stddev = Math.sqrt(scale2);
          dtype = dtype || "float32";
          if (dtype !== "float32" && dtype !== "int32") {
            throw new NotImplementedError(`${this.getClassName()} does not support dType ${dtype}.`);
          }
          return truncatedNormal(shape, 0, stddev, dtype, this.seed);
        } else {
          const limit = Math.sqrt(3 * scale2);
          return randomUniform(shape, -limit, limit, dtype);
        }
      }
      getConfig() {
        return {
          scale: this.scale,
          mode: this.mode,
          distribution: this.distribution,
          seed: this.seed
        };
      }
    }
    VarianceScaling.className = "VarianceScaling";
    registerClass(VarianceScaling);
    class GlorotUniform extends VarianceScaling {
      constructor(args) {
        super({
          scale: 1,
          mode: "fanAvg",
          distribution: "uniform",
          seed: args == null ? null : args.seed
        });
      }
      getClassName() {
        return VarianceScaling.className;
      }
    }
    GlorotUniform.className = "GlorotUniform";
    registerClass(GlorotUniform);
    class GlorotNormal extends VarianceScaling {
      constructor(args) {
        super({
          scale: 1,
          mode: "fanAvg",
          distribution: "normal",
          seed: args == null ? null : args.seed
        });
      }
      getClassName() {
        return VarianceScaling.className;
      }
    }
    GlorotNormal.className = "GlorotNormal";
    registerClass(GlorotNormal);
    class HeNormal extends VarianceScaling {
      constructor(args) {
        super({
          scale: 2,
          mode: "fanIn",
          distribution: "normal",
          seed: args == null ? null : args.seed
        });
      }
      getClassName() {
        return VarianceScaling.className;
      }
    }
    HeNormal.className = "HeNormal";
    registerClass(HeNormal);
    class HeUniform extends VarianceScaling {
      constructor(args) {
        super({
          scale: 2,
          mode: "fanIn",
          distribution: "uniform",
          seed: args == null ? null : args.seed
        });
      }
      getClassName() {
        return VarianceScaling.className;
      }
    }
    HeUniform.className = "HeUniform";
    registerClass(HeUniform);
    class LeCunNormal extends VarianceScaling {
      constructor(args) {
        super({
          scale: 1,
          mode: "fanIn",
          distribution: "normal",
          seed: args == null ? null : args.seed
        });
      }
      getClassName() {
        return VarianceScaling.className;
      }
    }
    LeCunNormal.className = "LeCunNormal";
    registerClass(LeCunNormal);
    class LeCunUniform extends VarianceScaling {
      constructor(args) {
        super({
          scale: 1,
          mode: "fanIn",
          distribution: "uniform",
          seed: args == null ? null : args.seed
        });
      }
      getClassName() {
        return VarianceScaling.className;
      }
    }
    LeCunUniform.className = "LeCunNormal";
    registerClass(LeCunUniform);
    class Orthogonal extends Initializer {
      constructor(args) {
        super();
        this.DEFAULT_GAIN = 1;
        this.gain = args.gain == null ? this.DEFAULT_GAIN : args.gain;
        this.seed = args.seed;
        if (this.seed != null) {
          throw new NotImplementedError("Random seed is not implemented for Orthogonal Initializer yet.");
        }
      }
      apply(shape, dtype) {
        return tidy(() => {
          if (shape.length < 2) {
            throw new NotImplementedError("Shape must be at least 2D.");
          }
          if (shape[0] * shape[1] > 2e3) {
            console.warn(`Orthogonal initializer is being called on a matrix with more than 2000 (${shape[0] * shape[1]}) elements: Slowness may result.`);
          }
          const normalizedShape = shape[0] > shape[1] ? [shape[1], shape[0]] : shape;
          const a = randomNormal$1(normalizedShape, 0, 1, "float32");
          let q = linalg.gramSchmidt(a);
          if (shape[0] > shape[1]) {
            q = q.transpose();
          }
          return mul3(this.gain, q);
        });
      }
      getConfig() {
        return {
          gain: this.gain,
          seed: this.seed
        };
      }
    }
    Orthogonal.className = "Orthogonal";
    registerClass(Orthogonal);
    const INITIALIZER_IDENTIFIER_REGISTRY_SYMBOL_MAP = {
      constant: "Constant",
      glorotNormal: "GlorotNormal",
      glorotUniform: "GlorotUniform",
      heNormal: "HeNormal",
      heUniform: "HeUniform",
      identity: "Identity",
      leCunNormal: "LeCunNormal",
      leCunUniform: "LeCunUniform",
      ones: "Ones",
      orthogonal: "Orthogonal",
      randomNormal: "RandomNormal",
      randomUniform: "RandomUniform",
      truncatedNormal: "TruncatedNormal",
      varianceScaling: "VarianceScaling",
      zeros: "Zeros"
    };
    function deserializeInitializer(config2, customObjects = {}) {
      return deserializeKerasObject(config2, SerializationMap.getMap().classNameMap, customObjects, "initializer");
    }
    function serializeInitializer(initializer) {
      return serializeKerasObject(initializer);
    }
    function getInitializer(identifier) {
      if (typeof identifier === "string") {
        const className = identifier in INITIALIZER_IDENTIFIER_REGISTRY_SYMBOL_MAP ? INITIALIZER_IDENTIFIER_REGISTRY_SYMBOL_MAP[identifier] : identifier;
        if (className === "GlorotNormal") {
          return new GlorotNormal();
        } else if (className === "GlorotUniform") {
          return new GlorotUniform();
        } else if (className === "HeNormal") {
          return new HeNormal();
        } else if (className === "HeUniform") {
          return new HeUniform();
        } else if (className === "LeCunNormal") {
          return new LeCunNormal();
        } else if (className === "LeCunUniform") {
          return new LeCunUniform();
        } else {
          const config2 = {};
          config2["className"] = className;
          config2["config"] = {};
          return deserializeInitializer(config2);
        }
      } else if (identifier instanceof Initializer) {
        return identifier;
      } else {
        return deserializeInitializer(identifier);
      }
    }
    /**
     * @license
     * Copyright 2018 Google LLC
     *
     * Use of this source code is governed by an MIT-style
     * license that can be found in the LICENSE file or at
     * https://opensource.org/licenses/MIT.
     * =============================================================================
     */
    function zeros$1() {
      return new Zeros();
    }
    function ones$2() {
      return new Ones();
    }
    function constant(args) {
      return new Constant(args);
    }
    function randomUniform$1(args) {
      return new RandomUniform(args);
    }
    function randomNormal$2(args) {
      return new RandomNormal(args);
    }
    function truncatedNormal$1(args) {
      return new TruncatedNormal(args);
    }
    function identity2(args) {
      return new Identity$1(args);
    }
    function varianceScaling(config2) {
      return new VarianceScaling(config2);
    }
    function glorotUniform(args) {
      return new GlorotUniform(args);
    }
    function glorotNormal(args) {
      return new GlorotNormal(args);
    }
    function heNormal(args) {
      return new HeNormal(args);
    }
    function heUniform(args) {
      return new HeUniform(args);
    }
    function leCunNormal(args) {
      return new LeCunNormal(args);
    }
    function leCunUniform(args) {
      return new LeCunUniform(args);
    }
    function orthogonal(args) {
      return new Orthogonal(args);
    }
    var exports_initializers = /* @__PURE__ */ Object.freeze({
      __proto__: null,
      zeros: zeros$1,
      ones: ones$2,
      constant,
      randomUniform: randomUniform$1,
      randomNormal: randomNormal$2,
      truncatedNormal: truncatedNormal$1,
      identity: identity2,
      varianceScaling,
      glorotUniform,
      glorotNormal,
      heNormal,
      heUniform,
      leCunNormal,
      leCunUniform,
      orthogonal
    });
    /**
     * @license
     * Copyright 2018 Google LLC
     *
     * Use of this source code is governed by an MIT-style
     * license that can be found in the LICENSE file or at
     * https://opensource.org/licenses/MIT.
     * =============================================================================
     */
    let _nextUniqueTensorId = 0;
    function getNextUniqueTensorId() {
      return _nextUniqueTensorId++;
    }
    const _uidPrefixes = {};
    function getUid(prefix = "") {
      if (!(prefix in _uidPrefixes)) {
        _uidPrefixes[prefix] = 0;
      }
      _uidPrefixes[prefix] += 1;
      return prefix + _uidPrefixes[prefix].toString();
    }
    /**
     * @license
     * Copyright 2018 Google LLC
     *
     * Use of this source code is governed by an MIT-style
     * license that can be found in the LICENSE file or at
     * https://opensource.org/licenses/MIT.
     * =============================================================================
     */
    function isArrayOfShapes(x) {
      return Array.isArray(x) && Array.isArray(x[0]);
    }
    function normalizeShapeList(x) {
      if (x.length === 0) {
        return [];
      }
      if (!Array.isArray(x[0])) {
        return [x];
      }
      return x;
    }
    function getExactlyOneTensor(xs) {
      let x;
      if (Array.isArray(xs)) {
        if (xs.length !== 1) {
          throw new ValueError(`Expected Tensor length to be 1; got ${xs.length}`);
        }
        x = xs[0];
      } else {
        x = xs;
      }
      return x;
    }
    function getExactlyOneShape(shapes) {
      if (Array.isArray(shapes) && Array.isArray(shapes[0])) {
        if (shapes.length === 1) {
          shapes = shapes;
          return shapes[0];
        } else {
          throw new ValueError(`Expected exactly 1 Shape; got ${shapes.length}`);
        }
      } else {
        return shapes;
      }
    }
    /**
     * @license
     * Copyright 2018 Google LLC
     *
     * Use of this source code is governed by an MIT-style
     * license that can be found in the LICENSE file or at
     * https://opensource.org/licenses/MIT.
     * =============================================================================
     */
    function countParamsInWeights(weights) {
      let count2 = 0;
      for (const weight of weights) {
        if (weight.shape.length === 0) {
          count2 += 1;
        } else {
          count2 += weight.shape.reduce((a, b) => a * b);
        }
      }
      return count2;
    }
    /**
     * @license
     * Copyright 2018 Google LLC
     *
     * Use of this source code is governed by an MIT-style
     * license that can be found in the LICENSE file or at
     * https://opensource.org/licenses/MIT.
     * =============================================================================
     */
    const DEFAULT_VARIABLE_NAME_PREFIX = "Variable";
    class LayerVariable {
      constructor(val, dtype = "float32", name = DEFAULT_VARIABLE_NAME_PREFIX, trainable = true, constraint = null) {
        this.dtype = dtype == null ? "float32" : dtype;
        this.shape = val.shape;
        this.id = getNextUniqueTensorId();
        name = name == null ? DEFAULT_VARIABLE_NAME_PREFIX : name;
        this.originalName = getScopedTensorName(name);
        this.name = getUniqueTensorName(this.originalName);
        this.trainable_ = trainable;
        this.constraint = constraint;
        this.val = variable(val, this.trainable_, this.name, this.dtype);
      }
      read() {
        this.assertNotDisposed();
        return this.val;
      }
      write(newVal) {
        this.assertNotDisposed();
        checkShapesMatch(this.val, newVal);
        if (this.val.id !== newVal.id) {
          this.val.assign(newVal);
          if (this.constraint != null) {
            this.val.assign(this.constraint.apply(this.val));
          }
        }
        return this;
      }
      dispose() {
        this.assertNotDisposed();
        this.val.dispose();
      }
      assertNotDisposed() {
        if (this.val.isDisposed) {
          throw new Error(`LayersVariable ${this.name} is already disposed.`);
        }
      }
      get trainable() {
        return this.trainable_;
      }
      set trainable(trainable) {
        this.trainable_ = trainable;
        this.val.trainable = trainable;
      }
    }
    function checkShapesMatch(x, y) {
      if (x.shape.toString() !== y.shape.toString()) {
        throw new Error("Shape mismatch: " + JSON.stringify(x.shape) + " vs. " + JSON.stringify(y.shape));
      }
    }
    function variable$1(x, dtype, name, constraint) {
      return new LayerVariable(x, dtype, name, true, constraint);
    }
    function zerosVariable(shape, dtype, name) {
      return new LayerVariable(zeros3(shape), dtype, name);
    }
    function zerosLike$1(x, dtype, name) {
      return new LayerVariable(zerosLike2(x), dtype, name);
    }
    function onesVariable(shape, dtype, name) {
      const allocated = ones$1(shape);
      return new LayerVariable(allocated, dtype, name);
    }
    function onesLike$1(x, dtype, name) {
      const allocated = onesLike2(x);
      return new LayerVariable(allocated, dtype, name);
    }
    function eyeVariable(size, dtype, name) {
      return new LayerVariable(eye(size), dtype, name);
    }
    function randomUniformVariable(shape, minval, maxval, dtype, seed, name = "randomUniform") {
      return new LayerVariable(randomUniform(shape, minval, maxval, dtype), dtype, name);
    }
    function truncatedNormalVariable(shape, mean2 = 0, stddev = 1, dtype, seed, name = "truncatedNormal") {
      dtype = dtype || "float32";
      if (dtype !== "float32" && dtype !== "int32") {
        throw new NotImplementedError(`randomNormal does not support dType ${dtype}.`);
      }
      return new LayerVariable(truncatedNormal(shape, mean2, stddev, dtype, seed), dtype, name);
    }
    function randomNormalVariable(shape, mean2 = 0, stddev = 1, dtype, seed, name = "randomNormal") {
      dtype = dtype || "float32";
      if (dtype !== "float32" && dtype !== "int32") {
        throw new NotImplementedError(`randomNormalVariable does not support dType ${dtype}.`);
      }
      return new LayerVariable(randomNormal(shape, mean2, stddev, dtype, seed), dtype, name);
    }
    function update(x, xNew) {
      return x.write(xNew);
    }
    function updateAdd(x, increment) {
      return x.write(add$1(x.read(), increment));
    }
    function updateSub(x, decrement) {
      return x.write(sub(x.read(), decrement));
    }
    function batchGetValue(xs) {
      return xs.map((x) => x.read());
    }
    function batchSetValue(variablesAndValues) {
      variablesAndValues.forEach((variableAndValue) => {
        const variable2 = variableAndValue[0];
        variable2.write(variableAndValue[1]);
      });
    }
    function gradients(lossFn, variables) {
      const variableList = variables.map((variable2) => variable2.read());
      const valudAndGrads = variableGrads(lossFn, variableList);
      return variables.map((variable2) => valudAndGrads.grads[variable2.name]);
    }
    /**
     * @license
     * Copyright 2018 Google LLC
     *
     * Use of this source code is governed by an MIT-style
     * license that can be found in the LICENSE file or at
     * https://opensource.org/licenses/MIT.
     * =============================================================================
     */
    class InputSpec {
      constructor(args) {
        this.dtype = args.dtype;
        this.shape = args.shape;
        if (args.shape != null) {
          this.ndim = args.shape.length;
        } else {
          this.ndim = args.ndim;
        }
        this.maxNDim = args.maxNDim;
        this.minNDim = args.minNDim;
        this.axes = args.axes || {};
      }
    }
    class SymbolicTensor {
      constructor(dtype, shape, sourceLayer, inputs, callArgs, name, outputTensorIndex) {
        this.dtype = dtype;
        this.shape = shape;
        this.sourceLayer = sourceLayer;
        this.inputs = inputs;
        this.callArgs = callArgs;
        this.outputTensorIndex = outputTensorIndex;
        this.id = getNextUniqueTensorId();
        if (name != null) {
          this.originalName = getScopedTensorName(name);
          this.name = getUniqueTensorName(this.originalName);
        }
        this.rank = shape.length;
      }
    }
    let _nextNodeID = 0;
    class Node {
      constructor(args, callArgs) {
        this.callArgs = callArgs;
        this.id = _nextNodeID++;
        this.outboundLayer = args.outboundLayer;
        this.inboundLayers = args.inboundLayers;
        this.nodeIndices = args.nodeIndices;
        this.tensorIndices = args.tensorIndices;
        this.inputTensors = args.inputTensors;
        this.outputTensors = args.outputTensors;
        this.inputMasks = args.inputMasks;
        this.outputMasks = args.outputMasks;
        this.inputShapes = args.inputShapes;
        this.outputShapes = args.outputShapes;
        for (const layer of args.inboundLayers) {
          if (layer != null) {
            layer.outboundNodes.push(this);
          }
        }
        args.outboundLayer.inboundNodes.push(this);
      }
      getConfig() {
        const inboundNames = [];
        for (const layer of this.inboundLayers) {
          if (layer != null) {
            inboundNames.push(layer.name);
          } else {
            inboundNames.push(null);
          }
        }
        return {
          outboundLayer: this.outboundLayer ? this.outboundLayer.name : null,
          inboundLayers: inboundNames,
          nodeIndices: this.nodeIndices,
          tensorIndices: this.tensorIndices
        };
      }
    }
    let _nextLayerID = 0;
    class Layer extends Serializable {
      constructor(args = {}) {
        super();
        this._callHook = null;
        this._addedWeightNames = [];
        this._stateful = false;
        this.id = _nextLayerID++;
        this.activityRegularizer = null;
        this.inputSpec = null;
        this.supportsMasking = false;
        this._trainableWeights = [];
        this._nonTrainableWeights = [];
        this._losses = [];
        this._updates = [];
        this._built = false;
        this.inboundNodes = [];
        this.outboundNodes = [];
        let name = args.name;
        if (!name) {
          const prefix = this.getClassName();
          name = toSnakeCase(prefix) + "_" + getUid(prefix);
        }
        this.name = name;
        this.trainable_ = args.trainable == null ? true : args.trainable;
        if (args.inputShape != null || args.batchInputShape != null) {
          let batchInputShape;
          if (args.batchInputShape != null) {
            batchInputShape = args.batchInputShape;
          } else if (args.inputShape != null) {
            let batchSize = null;
            if (args.batchSize != null) {
              batchSize = args.batchSize;
            }
            batchInputShape = [batchSize].concat(args.inputShape);
          }
          this.batchInputShape = batchInputShape;
          let dtype = args.dtype;
          if (dtype == null) {
            dtype = args.inputDType;
          }
          if (dtype == null) {
            dtype = "float32";
          }
          this.dtype = dtype;
        }
        if (args.weights != null) {
          this.initialWeights = args.weights;
        } else {
          this.initialWeights = null;
        }
        this._refCount = null;
        this.fastWeightInitDuringBuild = false;
      }
      static nodeKey(layer, nodeIndex) {
        return layer.name + "_ib-" + nodeIndex.toString();
      }
      getNodeAtIndex(nodeIndex, attrName) {
        if (this.inboundNodes.length === 0) {
          throw new RuntimeError(`The layer has never been called and thus has no defined ${attrName}.`);
        }
        if (this.inboundNodes.length <= nodeIndex) {
          throw new ValueError(`Asked to get ${attrName} at node ${nodeIndex}, but the layer has only ${this.inboundNodes.length} inbound nodes.`);
        }
        return this.inboundNodes[nodeIndex];
      }
      getInputAt(nodeIndex) {
        return singletonOrArray(this.getNodeAtIndex(nodeIndex, "input").inputTensors);
      }
      getOutputAt(nodeIndex) {
        return singletonOrArray(this.getNodeAtIndex(nodeIndex, "output").outputTensors);
      }
      get input() {
        if (this.inboundNodes.length > 1) {
          throw new AttributeError(`Layer ${this.name} has multiple inbound nodes, hence the notion of "layer input" is ill-defined. Use \`getInputAt(nodeIndex)\` instead.`);
        } else if (this.inboundNodes.length === 0) {
          throw new AttributeError(`Layer ${this.name} is not connected, no input to return.`);
        }
        return singletonOrArray(this.getNodeAtIndex(0, "input").inputTensors);
      }
      get output() {
        if (this.inboundNodes.length === 0) {
          throw new AttributeError(`Layer ${this.name} has no inbound nodes.`);
        }
        if (this.inboundNodes.length > 1) {
          throw new AttributeError(`Layer ${this.name} has multiple inbound nodes, hence the notion of "layer output" is ill-defined. Use \`getOutputAt(nodeIndex)\` instead.`);
        }
        return singletonOrArray(this.getNodeAtIndex(0, "output").outputTensors);
      }
      get losses() {
        return this._losses;
      }
      calculateLosses() {
        return this.losses.map((lossFn) => lossFn());
      }
      get updates() {
        return this._updates;
      }
      get built() {
        return this._built;
      }
      set built(built) {
        this._built = built;
      }
      get trainable() {
        return this.trainable_;
      }
      set trainable(trainable) {
        this._trainableWeights.forEach((w) => w.trainable = trainable);
        this.trainable_ = trainable;
      }
      get trainableWeights() {
        if (this.trainable_) {
          return this._trainableWeights.filter((w) => w.trainable);
        } else {
          return [];
        }
      }
      set trainableWeights(weights) {
        this._trainableWeights = weights;
      }
      get nonTrainableWeights() {
        if (this.trainable) {
          return this._trainableWeights.filter((w) => !w.trainable).concat(this._nonTrainableWeights);
        } else {
          return this._trainableWeights.concat(this._nonTrainableWeights);
        }
      }
      set nonTrainableWeights(weights) {
        this._nonTrainableWeights = weights;
      }
      get weights() {
        return this.trainableWeights.concat(this.nonTrainableWeights);
      }
      get stateful() {
        return this._stateful;
      }
      resetStates() {
        if (!this.stateful) {
          throw new Error("Cannot call the resetStates() method of a non-stateful Layer object.");
        }
      }
      assertInputCompatibility(inputs) {
        inputs = toList(inputs);
        if (this.inputSpec == null || this.inputSpec.length === 0) {
          return;
        }
        const inputSpec = toList(this.inputSpec);
        if (inputs.length !== inputSpec.length) {
          throw new ValueError(`Layer ${this.name} expects ${inputSpec.length} inputs, but it received ${inputs.length} input tensors. Input received: ${inputs}`);
        }
        for (let inputIndex = 0; inputIndex < inputs.length; inputIndex++) {
          const x = inputs[inputIndex];
          const spec = inputSpec[inputIndex];
          if (spec == null) {
            continue;
          }
          const ndim = x.rank;
          if (spec.ndim != null) {
            if (ndim !== spec.ndim) {
              throw new ValueError(`Input ${inputIndex} is incompatible with layer ${this.name}: expected ndim=${spec.ndim}, found ndim=${ndim}`);
            }
          }
          if (spec.maxNDim != null) {
            if (ndim > spec.maxNDim) {
              throw new ValueError(`Input ${inputIndex} is incompatible with layer ${this.name}: expected max_ndim=${spec.maxNDim}, found ndim=${ndim}`);
            }
          }
          if (spec.minNDim != null) {
            if (ndim < spec.minNDim) {
              throw new ValueError(`Input ${inputIndex} is incompatible with layer ${this.name}: expected min_ndim=${spec.minNDim}, found ndim=${ndim}.`);
            }
          }
          if (spec.dtype != null) {
            if (x.dtype !== spec.dtype) {
              throw new ValueError(`Input ${inputIndex} is incompatible with layer ${this.name} : expected dtype=${spec.dtype}, found dtype=${x.dtype}.`);
            }
          }
          if (spec.axes) {
            const xShape = x.shape;
            for (const key in spec.axes) {
              const axis = Number(key);
              const value = spec.axes[key];
              const xShapeAtAxis = axis >= 0 ? xShape[axis] : xShape[xShape.length + axis];
              if (value != null && [value, null].indexOf(xShapeAtAxis) === -1) {
                throw new ValueError(`Input ${inputIndex} is incompatible with layer ${this.name}: expected axis ${axis} of input shape to have value ${value} but got shape ${xShape}.`);
              }
            }
          }
          if (spec.shape != null) {
            for (let i = 0; i < spec.shape.length; ++i) {
              const specDim = spec.shape[i];
              const dim = x.shape[i];
              if (specDim != null && dim != null) {
                if (specDim !== dim) {
                  throw new ValueError(`Input ${inputIndex} is incompatible with layer ${this.name}: expected shape=${spec.shape}, found shape=${x.shape}.`);
                }
              }
            }
          }
        }
      }
      call(inputs, kwargs) {
        return inputs;
      }
      invokeCallHook(inputs, kwargs) {
        if (this._callHook != null) {
          this._callHook(inputs, kwargs);
        }
      }
      setCallHook(callHook) {
        this._callHook = callHook;
      }
      clearCallHook() {
        this._callHook = null;
      }
      apply(inputs, kwargs) {
        kwargs = kwargs || {};
        this.assertNotDisposed();
        const inputsList = toList(inputs);
        let allAreSymbolic = true;
        for (const input2 of inputsList) {
          if (!(input2 instanceof SymbolicTensor)) {
            allAreSymbolic = false;
            break;
          }
        }
        let noneAreSymbolic = true;
        for (const input2 of inputsList) {
          if (input2 instanceof SymbolicTensor) {
            noneAreSymbolic = false;
            break;
          }
        }
        if (allAreSymbolic === noneAreSymbolic) {
          throw new ValueError("Arguments to apply() must be all SymbolicTensors or all Tensors");
        }
        return nameScope(this.name, () => {
          if (!this.built) {
            this.assertInputCompatibility(inputs);
            const inputShapes = [];
            for (const xElem of toList(inputs)) {
              inputShapes.push(xElem.shape);
            }
            this.build(singletonOrArray(inputShapes));
            this.built = true;
            if (this.initialWeights) {
              this.setWeights(this.initialWeights);
            }
            if (this._refCount === null && noneAreSymbolic) {
              this._refCount = 1;
            }
          }
          this.assertInputCompatibility(inputs);
          if (noneAreSymbolic) {
            let output = this.call(inputs, kwargs);
            const outputList = toList(output);
            const outputListCopy = [];
            for (let x of outputList) {
              if (inputsList.indexOf(x) !== -1) {
                x = x.clone();
              }
              outputListCopy.push(x);
            }
            output = singletonOrArray(outputListCopy);
            if (this.activityRegularizer != null) {
              throw new NotImplementedError("Layer invocation in the presence of activity regularizer(s) is not supported yet.");
            }
            return output;
          } else {
            const inputShape = collectInputShape(inputs);
            const outputShape = this.computeOutputShape(inputShape);
            let output;
            const outputDType = guessOutputDType(inputs);
            this.warnOnIncompatibleInputShape(Array.isArray(inputs) ? inputShape[0] : inputShape);
            if (outputShape != null && outputShape.length > 0 && Array.isArray(outputShape[0])) {
              output = outputShape.map((shape, index2) => new SymbolicTensor(outputDType, shape, this, toList(inputs), kwargs, this.name, index2));
            } else {
              output = new SymbolicTensor(outputDType, outputShape, this, toList(inputs), kwargs, this.name);
            }
            this.addInboundNode(inputs, output, null, null, inputShape, outputShape, kwargs);
            this._refCount++;
            if (this.activityRegularizer != null) {
              throw new NotImplementedError("Layer invocation in the presence of activity regularizer(s) is not supported yet.");
            }
            return output;
          }
        });
      }
      warnOnIncompatibleInputShape(inputShape) {
        if (this.batchInputShape == null) {
          return;
        } else if (inputShape.length !== this.batchInputShape.length) {
          console.warn(`The rank of the input tensor provided (shape: ${JSON.stringify(inputShape)}) does not match that of the batchInputShape (${JSON.stringify(this.batchInputShape)}) of the layer ${this.name}`);
        } else {
          let dimMismatch = false;
          this.batchInputShape.forEach((dimension, i) => {
            if (dimension != null && inputShape[i] != null && inputShape[i] !== dimension) {
              dimMismatch = true;
            }
          });
          if (dimMismatch) {
            console.warn(`The shape of the input tensor (${JSON.stringify(inputShape)}) does not match the expectation of layer ${this.name}: ${JSON.stringify(this.batchInputShape)}`);
          }
        }
      }
      get outputShape() {
        if (this.inboundNodes == null || this.inboundNodes.length === 0) {
          throw new AttributeError(`The layer ${this.name} has never been called and thus has no defined output shape.`);
        }
        const allOutputShapes = [];
        for (const node of this.inboundNodes) {
          const shapeString = JSON.stringify(node.outputShapes);
          if (allOutputShapes.indexOf(shapeString) === -1) {
            allOutputShapes.push(shapeString);
          }
        }
        if (allOutputShapes.length === 1) {
          const outputShapes = this.inboundNodes[0].outputShapes;
          if (Array.isArray(outputShapes) && Array.isArray(outputShapes[0]) && outputShapes.length === 1) {
            return outputShapes[0];
          } else {
            return outputShapes;
          }
        } else {
          throw new AttributeError(`The layer ${this.name} has multiple inbound nodes with different output shapes. Hence the notion of "output shape" is ill-defined for the layer.`);
        }
      }
      countParams() {
        if (!this.built) {
          throw new RuntimeError(`You tried to call countParams() on ${this.name}, but the layer is not built yet. Build it first by calling build(batchInputShape).`);
        }
        return countParamsInWeights(this.weights);
      }
      build(inputShape) {
        this.built = true;
      }
      getWeights(trainableOnly = false) {
        return batchGetValue(trainableOnly ? this.trainableWeights : this.weights);
      }
      setWeights(weights) {
        tidy(() => {
          const params = this.weights;
          if (params.length !== weights.length) {
            throw new ValueError(`You called setWeights(weights) on layer "${this.name}" with a weight list of length ${weights.length}, but the layer was expecting ${params.length} weights. Provided weights: ${weights}...`);
          }
          if (params.length === 0) {
            return;
          }
          const weightValueTuples = [];
          const paramValues = batchGetValue(params);
          for (let i = 0; i < paramValues.length; ++i) {
            const pv = paramValues[i];
            const p2 = params[i];
            const w = weights[i];
            if (!arraysEqual2(pv.shape, w.shape)) {
              throw new ValueError(`Layer weight shape ${pv.shape} not compatible with provided weight shape ${w.shape}`);
            }
            weightValueTuples.push([p2, w]);
          }
          batchSetValue(weightValueTuples);
        });
      }
      addWeight(name, shape, dtype, initializer, regularizer, trainable, constraint) {
        if (this._addedWeightNames.indexOf(name) !== -1) {
          throw new ValueError(`Duplicate weight name ${name} for layer ${this.name}`);
        }
        this._addedWeightNames.push(name);
        if (dtype == null) {
          dtype = "float32";
        }
        if (this.fastWeightInitDuringBuild) {
          initializer = getInitializer("zeros");
        }
        const initValue = initializer.apply(shape, dtype);
        const weight = new LayerVariable(initValue, dtype, name, trainable, constraint);
        initValue.dispose();
        if (regularizer != null) {
          this.addLoss(() => regularizer.apply(weight.read()));
        }
        if (trainable == null) {
          trainable = true;
        }
        if (trainable) {
          this._trainableWeights.push(weight);
        } else {
          this._nonTrainableWeights.push(weight);
        }
        return weight;
      }
      setFastWeightInitDuringBuild(value) {
        this.fastWeightInitDuringBuild = value;
      }
      addLoss(losses2) {
        if (losses2 == null || Array.isArray(losses2) && losses2.length === 0) {
          return;
        }
        losses2 = toList(losses2);
        if (this._losses !== void 0 && this._losses !== null) {
          this.losses.push(...losses2);
        }
      }
      computeOutputShape(inputShape) {
        return inputShape;
      }
      computeMask(inputs, mask) {
        if (!this.supportsMasking) {
          if (mask != null) {
            if (Array.isArray(mask)) {
              mask.forEach((maskElement) => {
                if (maskElement != null) {
                  throw new TypeError(`Layer ${this.name} does not support masking, but was passed an inputMask.`);
                }
              });
            } else {
              throw new TypeError(`Layer ${this.name} does not support masking, but was passed an inputMask.`);
            }
          }
          return null;
        }
        return mask;
      }
      addInboundNode(inputTensors, outputTensors, inputMasks, outputMasks, inputShapes, outputShapes, kwargs = null) {
        const inputTensorList = toList(inputTensors);
        outputTensors = toList(outputTensors);
        inputMasks = toList(inputMasks);
        outputMasks = toList(outputMasks);
        inputShapes = normalizeShapeList(inputShapes);
        outputShapes = normalizeShapeList(outputShapes);
        const inboundLayers = [];
        const nodeIndices = [];
        const tensorIndices = [];
        for (const x of inputTensorList) {
          inboundLayers.push(x.sourceLayer);
          nodeIndices.push(x.nodeIndex);
          tensorIndices.push(x.tensorIndex);
        }
        new Node({
          outboundLayer: this,
          inboundLayers,
          nodeIndices,
          tensorIndices,
          inputTensors: inputTensorList,
          outputTensors,
          inputMasks,
          outputMasks,
          inputShapes,
          outputShapes
        }, kwargs);
        for (let i = 0; i < outputTensors.length; i++) {
          outputTensors[i].sourceLayer = this;
          outputTensors[i].nodeIndex = this.inboundNodes.length - 1;
          outputTensors[i].tensorIndex = i;
        }
      }
      getConfig() {
        const config2 = {name: this.name, trainable: this.trainable};
        if (this.batchInputShape != null) {
          config2["batchInputShape"] = this.batchInputShape;
        }
        if (this.dtype != null) {
          config2["dtype"] = this.dtype;
        }
        return config2;
      }
      disposeWeights() {
        this.weights.forEach((weight) => weight.dispose());
        return this.weights.length;
      }
      assertNotDisposed() {
        if (this._refCount === 0) {
          throw new Error(`Layer '${this.name}' is already disposed.`);
        }
      }
      dispose() {
        if (!this.built) {
          throw new Error(`Cannot dispose Layer ${this.name} because it has not been built yet.`);
        }
        if (this._refCount === null) {
          throw new Error(`Cannot dispose Layer ${this.name} because it has not been used yet.`);
        }
        this.assertNotDisposed();
        let numDisposedVariables = 0;
        if (--this._refCount === 0) {
          numDisposedVariables = this.disposeWeights();
        }
        return {refCountAfterDispose: this._refCount, numDisposedVariables};
      }
    }
    function collectInputShape(inputTensors) {
      inputTensors = toList(inputTensors);
      const shapes = [];
      for (const x of inputTensors) {
        shapes.push(x.shape);
      }
      return singletonOrArray(shapes);
    }
    function guessOutputDType(inputTensors) {
      return "float32";
    }
    function getSourceInputs(tensor7, layer, nodeIndex) {
      if (layer == null || nodeIndex != null && nodeIndex > 0) {
        layer = tensor7.sourceLayer;
        nodeIndex = tensor7.nodeIndex;
      }
      if (layer.inboundNodes.length === 0) {
        return [tensor7];
      } else {
        const node = layer.inboundNodes[nodeIndex];
        if (node.inboundLayers.length === 0) {
          return node.inputTensors;
        } else {
          const sourceTensors = [];
          for (let i = 0; i < node.inboundLayers.length; i++) {
            const x = node.inputTensors[i];
            const layer2 = node.inboundLayers[i];
            const nodeIndex2 = node.nodeIndices[i];
            const previousSources = getSourceInputs(x, layer2, nodeIndex2);
            for (const x2 of previousSources) {
              if (sourceTensors.indexOf(x2) === -1) {
                sourceTensors.push(x2);
              }
            }
          }
          return sourceTensors;
        }
      }
    }
    /**
     * @license
     * Copyright 2018 Google LLC
     *
     * Use of this source code is governed by an MIT-style
     * license that can be found in the LICENSE file or at
     * https://opensource.org/licenses/MIT.
     * =============================================================================
     */
    class InputLayer extends Layer {
      constructor(args) {
        super({
          dtype: args.dtype,
          name: args.name != null ? args.name : getUid("input").toString()
        });
        if (args.batchSize == null) {
          args.batchSize = null;
        }
        if (args.sparse == null) {
          args.sparse = false;
        }
        this.trainable = false;
        this.built = true;
        this.sparse = args.sparse;
        if (args.inputShape != null && args.batchInputShape != null) {
          throw new ValueError("Only provide the inputShape OR batchInputShape argument to inputLayer, not both at the same time.");
        }
        let batchInputShape = args.batchInputShape;
        if (batchInputShape == null) {
          if (args.inputShape == null) {
            throw new ValueError("An InputLayer should be passed either a `batchInputShape` or an `inputShape`.");
          } else {
            batchInputShape = [args.batchSize].concat(args.inputShape);
          }
        } else {
          if (args.batchSize != null) {
            throw new ValueError("Cannot specify batchSize if batchInputShape is specified when creating an InputLayer.");
          }
        }
        const dtype = args.dtype || "float32";
        this.batchInputShape = batchInputShape;
        this.dtype = dtype;
        this.inputSpec = [{shape: batchInputShape}];
        const inputTensor = new SymbolicTensor(this.dtype, this.batchInputShape, this, [], {}, this.name);
        inputTensor.nodeIndex = 0;
        inputTensor.tensorIndex = 0;
        new Node({
          outboundLayer: this,
          inboundLayers: [],
          nodeIndices: [],
          tensorIndices: [],
          inputTensors: [inputTensor],
          outputTensors: [inputTensor],
          inputMasks: [null],
          outputMasks: [null],
          inputShapes: [batchInputShape],
          outputShapes: [batchInputShape]
        });
      }
      apply(inputs, kwargs) {
        throw new ValueError(`Cannot pass any input to an InputLayer's apply() method. InputLayer name: ${this.name}`);
      }
      dispose() {
        return {refCountAfterDispose: this._refCount, numDisposedVariables: 0};
      }
      getConfig() {
        return {
          batchInputShape: this.batchInputShape,
          dtype: this.dtype,
          sparse: this.sparse,
          name: this.name
        };
      }
    }
    InputLayer.className = "InputLayer";
    registerClass(InputLayer);
    function Input(config2) {
      if (config2.batchShape == null && config2.shape == null) {
        throw new Error("Please provide to Input either a `shape` or a `batchShape` argument. Note that `shape` does not include the batch dimension.");
      }
      if (config2.batchShape != null && config2.shape != null) {
        throw new ValueError("Please provide either a `shape` or `batchShape` argument to Input, but not both.");
      }
      let batchShape = config2.batchShape;
      if (config2.shape != null && batchShape == null) {
        batchShape = [null].concat(config2.shape);
      }
      let dtype = config2.dtype;
      if (dtype == null) {
        dtype = "float32";
      }
      const inputLayer2 = new InputLayer({
        batchInputShape: batchShape,
        name: config2.name,
        dtype,
        sparse: config2.sparse
      });
      const outputs = inputLayer2.inboundNodes[0].outputTensors;
      return outputs[0];
    }
    /**
     * @license
     * Copyright 2018 Google LLC
     *
     * Use of this source code is governed by an MIT-style
     * license that can be found in the LICENSE file or at
     * https://opensource.org/licenses/MIT.
     * =============================================================================
     */
    async function resolveScalarsInLogs(logs) {
      if (logs == null) {
        return;
      }
      const promises = [];
      const keys = [];
      const scalarsToDispose = [];
      for (const key in logs) {
        const value = logs[key];
        if (typeof value !== "number") {
          const valueScalar = value;
          promises.push(valueScalar.data());
          keys.push(key);
          scalarsToDispose.push(valueScalar);
        }
      }
      if (promises.length > 0) {
        const values = await Promise.all(promises);
        for (let i = 0; i < values.length; ++i) {
          logs[keys[i]] = values[i][0];
        }
        dispose(scalarsToDispose);
      }
    }
    function disposeTensorsInLogs(logs) {
      if (logs == null) {
        return;
      }
      for (const key in logs) {
        const value = logs[key];
        if (typeof value !== "number") {
          value.dispose();
        }
      }
    }
    /**
     * @license
     * Copyright 2018 Google LLC
     *
     * Use of this source code is governed by an MIT-style
     * license that can be found in the LICENSE file or at
     * https://opensource.org/licenses/MIT.
     * =============================================================================
     */
    var ModelLoggingVerbosity;
    (function(ModelLoggingVerbosity2) {
      ModelLoggingVerbosity2[ModelLoggingVerbosity2["SILENT"] = 0] = "SILENT";
      ModelLoggingVerbosity2[ModelLoggingVerbosity2["VERBOSE"] = 1] = "VERBOSE";
    })(ModelLoggingVerbosity || (ModelLoggingVerbosity = {}));
    const DEFAULT_YIELD_EVERY_MS = 125;
    class BaseCallback {
      constructor() {
        this.validationData = null;
      }
      setParams(params) {
        this.params = params;
      }
      async onEpochBegin(epoch, logs) {
      }
      async onEpochEnd(epoch, logs) {
      }
      async onBatchBegin(batch, logs) {
      }
      async onBatchEnd(batch, logs) {
      }
      async onTrainBegin(logs) {
      }
      async onTrainEnd(logs) {
      }
      setModel(model2) {
      }
    }
    class CallbackList {
      constructor(callbacks2, queueLength = 10) {
        if (callbacks2 == null) {
          callbacks2 = [];
        }
        this.callbacks = callbacks2;
        this.queueLength = queueLength;
      }
      append(callback) {
        this.callbacks.push(callback);
      }
      setParams(params) {
        for (const callback of this.callbacks) {
          callback.setParams(params);
        }
      }
      setModel(model2) {
        for (const callback of this.callbacks) {
          callback.setModel(model2);
        }
      }
      async onEpochBegin(epoch, logs) {
        if (logs == null) {
          logs = {};
        }
        for (const callback of this.callbacks) {
          await callback.onEpochBegin(epoch, logs);
        }
      }
      async onEpochEnd(epoch, logs) {
        if (logs == null) {
          logs = {};
        }
        for (const callback of this.callbacks) {
          await callback.onEpochEnd(epoch, logs);
        }
      }
      async onBatchBegin(batch, logs) {
        if (logs == null) {
          logs = {};
        }
        for (const callback of this.callbacks) {
          await callback.onBatchBegin(batch, logs);
        }
      }
      async onBatchEnd(batch, logs) {
        if (logs == null) {
          logs = {};
        }
        for (const callback of this.callbacks) {
          await callback.onBatchEnd(batch, logs);
        }
      }
      async onTrainBegin(logs) {
        if (logs == null) {
          logs = {};
        }
        for (const callback of this.callbacks) {
          await callback.onTrainBegin(logs);
        }
      }
      async onTrainEnd(logs) {
        if (logs == null) {
          logs = {};
        }
        for (const callback of this.callbacks) {
          await callback.onTrainEnd(logs);
        }
      }
    }
    class BaseLogger extends BaseCallback {
      constructor() {
        super();
      }
      async onEpochBegin(epoch) {
        this.seen = 0;
        this.totals = {};
      }
      async onBatchEnd(batch, logs) {
        if (logs == null) {
          logs = {};
        }
        const batchSize = logs["size"] == null ? 0 : logs["size"];
        this.seen += batchSize;
        for (const key in logs) {
          const value = logs[key];
          if (typeof value === "number") {
            if (!this.totals.hasOwnProperty(key)) {
              this.totals[key] = 0;
            }
            this.totals[key] = this.totals[key] + value * batchSize;
          } else {
            let oldTotalsToDispose;
            if (key in this.totals) {
              oldTotalsToDispose = this.totals[key];
            } else {
              this.totals[key] = 0;
            }
            const total = tidy(() => add$1(this.totals[key], mul3(value, batchSize)));
            this.totals[key] = total;
            if (oldTotalsToDispose != null) {
              oldTotalsToDispose.dispose();
            }
          }
        }
      }
      async onEpochEnd(epoch, logs) {
        if (logs != null) {
          for (const key of this.params["metrics"]) {
            if (this.totals[key] == null) {
              continue;
            }
            if (typeof this.totals[key] === "number") {
              logs[key] = this.totals[key] / this.seen;
            } else {
              tidy(() => {
                const log3 = mul3(div(1, this.seen), this.totals[key]);
                logs[key] = log3;
                this.totals[key].dispose();
                keep(logs[key]);
              });
            }
          }
        }
      }
    }
    class History extends BaseCallback {
      async onTrainBegin(logs) {
        this.epoch = [];
        this.history = {};
      }
      async onEpochEnd(epoch, logs) {
        if (logs == null) {
          logs = {};
        }
        this.epoch.push(epoch);
        for (const key in logs) {
          if (this.history[key] == null) {
            this.history[key] = [];
          }
          this.history[key].push(logs[key]);
        }
      }
      async syncData() {
        const promises = [];
        const keys = [];
        const indices = [];
        for (const key in this.history) {
          const valueArray = this.history[key];
          for (let i = 0; i < valueArray.length; ++i) {
            if (typeof valueArray[i] !== "number") {
              const valueScalar = valueArray[i];
              promises.push(valueScalar.data());
              keys.push(key);
              indices.push(i);
            }
          }
        }
        const values = await Promise.all(promises);
        for (let n = 0; n < values.length; ++n) {
          const tensorToDispose = this.history[keys[n]][indices[n]];
          tensorToDispose.dispose();
          this.history[keys[n]][indices[n]] = values[n][0];
        }
      }
    }
    class CustomCallback extends BaseCallback {
      constructor(args, yieldEvery) {
        super();
        this.currentEpoch = 0;
        this.yieldEvery = yieldEvery || "auto";
        if (this.yieldEvery === "auto") {
          this.yieldEvery = DEFAULT_YIELD_EVERY_MS;
        }
        if (this.yieldEvery === "never" && args.onYield != null) {
          throw new Error("yieldEvery is `never` but you provided an `onYield` callback. Either change `yieldEvery` or remove the callback");
        }
        if (isNumber2(this.yieldEvery)) {
          this.maybeWait = debounce(this.maybeWait.bind(this), this.yieldEvery);
        }
        this.trainBegin = args.onTrainBegin;
        this.trainEnd = args.onTrainEnd;
        this.epochBegin = args.onEpochBegin;
        this.epochEnd = args.onEpochEnd;
        this.batchBegin = args.onBatchBegin;
        this.batchEnd = args.onBatchEnd;
        this.yield = args.onYield;
      }
      async maybeWait(epoch, batch, logs) {
        const ps = [];
        if (this.yield != null) {
          await resolveScalarsInLogs(logs);
          ps.push(this.yield(epoch, batch, logs));
        }
        ps.push(nextFrame());
        await Promise.all(ps);
      }
      async onEpochBegin(epoch, logs) {
        this.currentEpoch = epoch;
        if (this.epochBegin != null) {
          await resolveScalarsInLogs(logs);
          await this.epochBegin(epoch, logs);
        }
      }
      async onEpochEnd(epoch, logs) {
        const ps = [];
        if (this.epochEnd != null) {
          await resolveScalarsInLogs(logs);
          ps.push(this.epochEnd(epoch, logs));
        }
        if (this.yieldEvery === "epoch") {
          ps.push(nextFrame());
        }
        await Promise.all(ps);
      }
      async onBatchBegin(batch, logs) {
        if (this.batchBegin != null) {
          await resolveScalarsInLogs(logs);
          await this.batchBegin(batch, logs);
        }
      }
      async onBatchEnd(batch, logs) {
        const ps = [];
        if (this.batchEnd != null) {
          await resolveScalarsInLogs(logs);
          ps.push(this.batchEnd(batch, logs));
        }
        if (this.yieldEvery === "batch") {
          ps.push(nextFrame());
        } else if (isNumber2(this.yieldEvery)) {
          ps.push(this.maybeWait(this.currentEpoch, batch, logs));
        }
        await Promise.all(ps);
      }
      async onTrainBegin(logs) {
        if (this.trainBegin != null) {
          await resolveScalarsInLogs(logs);
          await this.trainBegin(logs);
        }
      }
      async onTrainEnd(logs) {
        if (this.trainEnd != null) {
          await resolveScalarsInLogs(logs);
          await this.trainEnd(logs);
        }
      }
    }
    function standardizeCallbacks(callbacks2, yieldEvery) {
      if (callbacks2 == null) {
        callbacks2 = {};
      }
      if (callbacks2 instanceof BaseCallback) {
        return [callbacks2];
      }
      if (Array.isArray(callbacks2) && callbacks2[0] instanceof BaseCallback) {
        return callbacks2;
      }
      const callbackConfigs = toList(callbacks2);
      return callbackConfigs.map((callbackConfig) => new CustomCallback(callbackConfig, yieldEvery));
    }
    class CallbackConstructorRegistry {
      constructor() {
      }
      static registerCallbackConstructor(verbosityLevel, callbackConstructor) {
        assert2(verbosityLevel >= 0 && Number.isInteger(verbosityLevel), () => `Verbosity level is expected to be an integer >= 0, but got ${verbosityLevel}`);
        CallbackConstructorRegistry.checkForDuplicate(callbackConstructor);
        if (CallbackConstructorRegistry.constructors[verbosityLevel] == null) {
          CallbackConstructorRegistry.constructors[verbosityLevel] = [];
        }
        CallbackConstructorRegistry.constructors[verbosityLevel].push(callbackConstructor);
      }
      static checkForDuplicate(callbackConstructor) {
        for (const levelName in CallbackConstructorRegistry.constructors) {
          const constructors = CallbackConstructorRegistry.constructors[+levelName];
          constructors.forEach((ctor) => {
            if (ctor === callbackConstructor) {
              throw new ValueError("Duplicate callback constructor.");
            }
          });
        }
      }
      static clear() {
        CallbackConstructorRegistry.constructors = {};
      }
      static createCallbacks(verbosityLevel) {
        const constructors = [];
        for (const levelName in CallbackConstructorRegistry.constructors) {
          const level = +levelName;
          if (verbosityLevel >= level) {
            constructors.push(...CallbackConstructorRegistry.constructors[level]);
          }
        }
        return constructors.map((ctor) => new ctor());
      }
    }
    CallbackConstructorRegistry.constructors = {};
    function configureCallbacks(callbacks2, verbose, epochs, initialEpoch, numTrainSamples, stepsPerEpoch, batchSize, doValidation, callbackMetrics) {
      const history = new History();
      const actualCallbacks = [
        new BaseLogger(),
        ...CallbackConstructorRegistry.createCallbacks(verbose)
      ];
      if (callbacks2 != null) {
        actualCallbacks.push(...callbacks2);
      }
      actualCallbacks.push(history);
      const callbackList = new CallbackList(actualCallbacks);
      callbackList.setParams({
        epochs,
        initialEpoch,
        samples: numTrainSamples,
        steps: stepsPerEpoch,
        batchSize,
        verbose,
        doValidation,
        metrics: callbackMetrics
      });
      return {callbackList, history};
    }
    /**
     * @license
     * Copyright 2018 Google LLC
     *
     * Use of this source code is governed by an MIT-style
     * license that can be found in the LICENSE file or at
     * https://opensource.org/licenses/MIT.
     * =============================================================================
     */
    function deserialize(config2, customObjects = {}, fastWeightInit = false) {
      return deserializeKerasObject(config2, SerializationMap.getMap().classNameMap, customObjects, "layer", fastWeightInit);
    }
    /**
     * @license
     * Copyright 2018 Google LLC
     *
     * Use of this source code is governed by an MIT-style
     * license that can be found in the LICENSE file or at
     * https://opensource.org/licenses/MIT.
     * =============================================================================
     */
    function l2Normalize(x, axis) {
      return tidy(() => {
        if (x.dtype !== "float32") {
          x = x.asType("float32");
        }
        const squareSum = sum$1(square$1(x), axis, true);
        const epsilonTensor = fill2(squareSum.shape, epsilon());
        const norm2 = sqrt(maximum(squareSum, epsilonTensor));
        return div(x, norm2);
      });
    }
    function meanSquaredError$1(yTrue, yPred) {
      return tidy(() => mean(square$1(sub(yPred, yTrue)), -1));
    }
    function meanAbsoluteError(yTrue, yPred) {
      return tidy(() => mean(abs(sub(yPred, yTrue)), -1));
    }
    function meanAbsolutePercentageError(yTrue, yPred) {
      return tidy(() => {
        const diff = sub(yTrue, yPred);
        const clippedTrue = clipByValue(abs(yTrue), epsilon(), Number.MAX_VALUE);
        const absResult = abs(div(diff, clippedTrue));
        return mul3(100, mean(absResult, -1));
      });
    }
    function meanSquaredLogarithmicError(yTrue, yPred) {
      return tidy(() => {
        const clippedPred = clipByValue(yPred, epsilon(), Number.MAX_VALUE);
        const firstLog = log22(add$1(1, clippedPred));
        const clippedTrue = clipByValue(yTrue, epsilon(), Number.MAX_VALUE);
        const secondLog = log22(add$1(1, clippedTrue));
        return mean(square$1(sub(firstLog, secondLog)), -1);
      });
    }
    function squaredHinge(yTrue, yPred) {
      return tidy(() => {
        const maxResult = maximum(0, sub(1, mul3(yTrue, yPred)));
        return mean(square$1(maxResult), -1);
      });
    }
    function hinge(yTrue, yPred) {
      return tidy(() => {
        const maxResult = maximum(0, sub(1, mul3(yTrue, yPred)));
        return mean(maxResult, -1);
      });
    }
    function categoricalHinge(yTrue, yPred) {
      return tidy(() => {
        const pos = sum$1(mul3(yTrue, yPred), -1);
        const neg2 = max2(mul3(sub(1, yTrue), yPred), -1);
        return maximum(0, add$1(1, sub(neg2, pos)));
      });
    }
    function logcosh(yTrue, yPred) {
      return tidy(() => {
        const log222 = Math.log(2);
        const predictionDiff = sub(yPred, yTrue);
        const logcoshResult = sub(add$1(predictionDiff, softplus(mul3(-2, predictionDiff))), log222);
        return mean(logcoshResult, -1);
      });
    }
    function categoricalCrossentropy(target, output, fromLogits = false) {
      return tidy(() => {
        if (fromLogits) {
          output = softmax2(output);
        } else {
          const outputSum = sum$1(output, output.shape.length - 1, true);
          output = div(output, outputSum);
        }
        output = clipByValue(output, epsilon(), 1 - epsilon());
        return neg(sum$1(mul3(target.toFloat(), log22(output)), output.shape.length - 1));
      });
    }
    function sparseCategoricalCrossentropy(target, output, fromLogits = false) {
      return tidy(() => {
        const flatTarget = floor(flatten$1(target)).toInt();
        output = clipByValue(output, epsilon(), 1 - epsilon());
        const outputShape = output.shape;
        const oneHotTarget = oneHot2(flatTarget, outputShape[outputShape.length - 1]).reshape(outputShape);
        return categoricalCrossentropy(oneHotTarget, output, fromLogits);
      });
    }
    function sigmoidCrossEntropyWithLogits(labels, logits) {
      if (!arraysEqual2(labels.shape, logits.shape)) {
        throw new ValueError(`logits and labels must have the same shape, but got shapes ${JSON.stringify(labels.shape)} and ${JSON.stringify(logits.shape)}`);
      }
      return tidy(() => {
        const reluLogits = logits.relu();
        const negAbsLogits = logits.abs().neg();
        return reluLogits.sub(logits.mul(labels)).add(negAbsLogits.exp().log1p());
      });
    }
    function binaryCrossentropy(yTrue, yPred) {
      return tidy(() => {
        let y;
        y = clipByValue(yPred, epsilon(), 1 - epsilon());
        y = log22(div(y, sub(1, y)));
        return mean(sigmoidCrossEntropyWithLogits(yTrue, y), -1);
      });
    }
    function kullbackLeiblerDivergence(yTrue, yPred) {
      return tidy(() => {
        const clippedTrue = clipByValue(yTrue, epsilon(), 1);
        const clippedPred = clipByValue(yPred, epsilon(), 1);
        return sum$1(mul3(yTrue, log22(div(clippedTrue, clippedPred))), -1);
      });
    }
    function poisson(yTrue, yPred) {
      return tidy(() => {
        const logPred = log22(add$1(epsilon(), yPred));
        return mean(sub(yPred, mul3(yTrue, logPred)), -1);
      });
    }
    function cosineProximity(yTrue, yPred) {
      return tidy(() => {
        const trueNormalized = l2Normalize(yTrue, -1);
        const predNormalized = l2Normalize(yPred, -1);
        const trueXPred = mul3(trueNormalized, predNormalized);
        return neg(sum$1(trueXPred, -1));
      });
    }
    const mse = meanSquaredError$1;
    const MSE = meanSquaredError$1;
    const mae = meanAbsoluteError;
    const MAE = meanAbsoluteError;
    const mape = meanAbsolutePercentageError;
    const MAPE = meanAbsolutePercentageError;
    const msle = meanSquaredLogarithmicError;
    const MSLE = meanSquaredLogarithmicError;
    const kld = kullbackLeiblerDivergence;
    const KLD = kullbackLeiblerDivergence;
    const cosine = cosineProximity;
    const lossesMap = {
      meanSquaredError: meanSquaredError$1,
      meanAbsoluteError,
      meanAbsolutePercentageError,
      meanSquaredLogarithmicError,
      squaredHinge,
      hinge,
      categoricalHinge,
      logcosh,
      categoricalCrossentropy,
      sparseCategoricalCrossentropy,
      binaryCrossentropy,
      kullbackLeiblerDivergence,
      poisson,
      cosineProximity
    };
    function get(identifierOrFn) {
      if (typeof identifierOrFn === "string") {
        if (identifierOrFn in lossesMap) {
          return lossesMap[identifierOrFn];
        }
        let errMsg = `Unknown loss ${identifierOrFn}`;
        if (identifierOrFn.toLowerCase().includes("softmaxcrossentropy")) {
          errMsg = `Unknown loss ${identifierOrFn}. Use "categoricalCrossentropy" as the string name for tf.losses.softmaxCrossEntropy`;
        }
        throw new ValueError(errMsg);
      } else {
        return identifierOrFn;
      }
    }
    /**
     * @license
     * Copyright 2018 Google LLC
     *
     * Use of this source code is governed by an MIT-style
     * license that can be found in the LICENSE file or at
     * https://opensource.org/licenses/MIT.
     * =============================================================================
     */
    function binaryAccuracy(yTrue, yPred) {
      return tidy(() => {
        const threshold2 = mul3(0.5, onesLike2(yPred));
        const yPredThresholded = cast$1(greater(yPred, threshold2), yTrue.dtype);
        return mean(equal(yTrue, yPredThresholded), -1);
      });
    }
    function categoricalAccuracy(yTrue, yPred) {
      return tidy(() => cast$1(equal(argMax(yTrue, -1), argMax(yPred, -1)), "float32"));
    }
    function truePositives(yTrue, yPred) {
      return tidy(() => {
        return logicalAnd(yTrue.equal(1), yPred.equal(1)).sum().cast("float32");
      });
    }
    function falseNegatives(yTrue, yPred) {
      return tidy(() => {
        return logicalAnd(yTrue.equal(1), yPred.equal(0)).sum().cast("float32");
      });
    }
    function falsePositives(yTrue, yPred) {
      return tidy(() => {
        return logicalAnd(yTrue.equal(0), yPred.equal(1)).sum().cast("float32");
      });
    }
    function precision(yTrue, yPred) {
      return tidy(() => {
        const tp = truePositives(yTrue, yPred);
        const fp = falsePositives(yTrue, yPred);
        const denominator = tp.add(fp);
        return where(greater(denominator, 0), tp.div(denominator), 0).cast("float32");
      });
    }
    function recall(yTrue, yPred) {
      return tidy(() => {
        const tp = truePositives(yTrue, yPred);
        const fn = falseNegatives(yTrue, yPred);
        const denominator = tp.add(fn);
        return where(greater(denominator, 0), tp.div(denominator), 0).cast("float32");
      });
    }
    function binaryCrossentropy$1(yTrue, yPred) {
      return binaryCrossentropy(yTrue, yPred);
    }
    function sparseCategoricalAccuracy(yTrue, yPred) {
      if (yTrue.rank === yPred.rank) {
        yTrue = yTrue.squeeze([yTrue.rank - 1]);
      }
      yPred = yPred.argMax(-1);
      if (yPred.dtype !== yTrue.dtype) {
        yPred = yPred.asType(yTrue.dtype);
      }
      return equal(yTrue, yPred).asType("float32");
    }
    function topKCategoricalAccuracy(yTrue, yPred) {
      throw new NotImplementedError();
    }
    function sparseTopKCategoricalAccuracy(yTrue, yPred) {
      throw new NotImplementedError();
    }
    const mse$1 = meanSquaredError$1;
    const MSE$1 = meanSquaredError$1;
    const mae$1 = meanAbsoluteError;
    const MAE$1 = meanAbsoluteError;
    const mape$1 = meanAbsolutePercentageError;
    const MAPE$1 = meanAbsolutePercentageError;
    const categoricalCrossentropy$1 = categoricalCrossentropy;
    const cosine$1 = cosineProximity;
    const sparseCategoricalCrossentropy$1 = sparseCategoricalCrossentropy;
    const metricsMap = {
      binaryAccuracy,
      categoricalAccuracy,
      precision,
      categoricalCrossentropy: categoricalCrossentropy$1,
      sparseCategoricalCrossentropy: sparseCategoricalCrossentropy$1,
      mse: mse$1,
      MSE: MSE$1,
      mae: mae$1,
      MAE: MAE$1,
      mape: mape$1,
      MAPE: MAPE$1,
      cosine: cosine$1
    };
    function get$1(identifier) {
      if (typeof identifier === "string" && identifier in metricsMap) {
        return metricsMap[identifier];
      } else if (typeof identifier !== "string" && identifier != null) {
        return identifier;
      } else {
        throw new ValueError(`Unknown metric ${identifier}`);
      }
    }
    function getLossOrMetricName(fn) {
      assert$1(fn !== null, `Unknown LossOrMetricFn ${fn}`);
      if (typeof fn === "string") {
        return fn;
      } else {
        let fnName;
        for (const key of Object.keys(lossesMap)) {
          if (lossesMap[key] === fn) {
            fnName = key;
            break;
          }
        }
        if (fnName !== void 0) {
          return fnName;
        }
        for (const key of Object.keys(metricsMap)) {
          if (metricsMap[key] === fn) {
            fnName = key;
            break;
          }
        }
        if (fnName !== void 0) {
          return fnName;
        }
        return fn.name;
      }
    }
    /**
     * @license
     * Copyright 2018 Google LLC
     *
     * Use of this source code is governed by an MIT-style
     * license that can be found in the LICENSE file or at
     * https://opensource.org/licenses/MIT.
     * =============================================================================
     */
    function getOptimizer(identifier) {
      const optimizerMap = {
        Adagrad: () => train.adagrad(0.01),
        Adadelta: () => train.adadelta(1, 0.95, epsilon()),
        Adam: () => train.adam(1e-3, 0.9, 0.999, epsilon()),
        Adamax: () => train.adamax(2e-3, 0.9, 0.999, epsilon(), 0),
        RMSProp: () => train.rmsprop(1e-3, 0.9, 0, epsilon()),
        SGD: () => train.sgd(0.01)
      };
      optimizerMap["adagrad"] = optimizerMap["Adagrad"];
      optimizerMap["adadelta"] = optimizerMap["Adadelta"];
      optimizerMap["adam"] = optimizerMap["Adam"];
      optimizerMap["adamax"] = optimizerMap["Adamax"];
      optimizerMap["rmsprop"] = optimizerMap["RMSProp"];
      optimizerMap["sgd"] = optimizerMap["SGD"];
      if (identifier in optimizerMap) {
        return optimizerMap[identifier]();
      }
      throw new ValueError(`Unknown Optimizer ${identifier}`);
    }
    /**
     * @license
     * Copyright 2019 Google LLC
     *
     * Use of this source code is governed by an MIT-style
     * license that can be found in the LICENSE file or at
     * https://opensource.org/licenses/MIT.
     * =============================================================================
     */
    const MAX_USER_DEFINED_METADATA_SERIALIZED_LENGTH = 1 * 1024 * 1024;
    function checkUserDefinedMetadata(userDefinedMetadata, modelName, checkSize = false) {
      if (userDefinedMetadata == null || typeof userDefinedMetadata !== "object" || Object.getPrototypeOf(userDefinedMetadata) !== Object.prototype || !plainObjectCheck(userDefinedMetadata)) {
        throw new Error("User-defined metadata is expected to be a JSON object, but is not.");
      }
      if (checkSize) {
        const out = JSON.stringify(userDefinedMetadata);
        if (out.length > MAX_USER_DEFINED_METADATA_SERIALIZED_LENGTH) {
          console.warn(`User-defined metadata of model "${modelName}" is too large in size (length=${out.length} when serialized). It is not recommended to store such large objects in user-defined metadata. Please make sure its serialized length is <= ${MAX_USER_DEFINED_METADATA_SERIALIZED_LENGTH}.`);
        }
      }
    }
    function plainObjectCheck(x) {
      if (x === null) {
        return true;
      } else if (typeof x === "object") {
        if (Object.getPrototypeOf(x) === Object.prototype) {
          const keys = Object.keys(x);
          for (const key of keys) {
            if (typeof key !== "string") {
              return false;
            }
            if (!plainObjectCheck(x[key])) {
              return false;
            }
          }
          return true;
        } else {
          if (Array.isArray(x)) {
            for (const item of x) {
              if (!plainObjectCheck(item)) {
                return false;
              }
            }
            return true;
          } else {
            return false;
          }
        }
      } else {
        const xType = typeof x;
        return xType === "string" || xType === "number" || xType === "boolean";
      }
    }
    /**
     * @license
     * Copyright 2018 Google LLC
     *
     * Use of this source code is governed by an MIT-style
     * license that can be found in the LICENSE file or at
     * https://opensource.org/licenses/MIT.
     * =============================================================================
     */
    function printSummary(model2, lineLength, positions, printFn = console.log) {
      const sequentialLike = isModelSequentialLike(model2);
      const toDisplay = ["Layer (type)", "Output shape", "Param #"];
      if (sequentialLike) {
        lineLength = lineLength || 65;
        positions = positions || [0.45, 0.85, 1];
      } else {
        lineLength = lineLength || 98;
        positions = positions || [0.33, 0.55, 0.67, 1];
      }
      if (positions[positions.length - 1] <= 1) {
        positions = positions.map((p2) => Math.floor(lineLength * p2));
      }
      let relevantNodes;
      if (!sequentialLike) {
        toDisplay.push("Receives inputs");
        relevantNodes = [];
        for (const depth in model2.nodesByDepth) {
          relevantNodes.push(...model2.nodesByDepth[depth]);
        }
      }
      printFn("_".repeat(lineLength));
      printRow(toDisplay, positions, printFn);
      printFn("=".repeat(lineLength));
      const layers = model2.layers;
      for (let i = 0; i < layers.length; ++i) {
        if (sequentialLike) {
          printLayerSummary(layers[i], positions, printFn);
        } else {
          printLayerSummaryWithConnections(layers[i], positions, relevantNodes, printFn);
        }
        printFn((i === layers.length - 1 ? "=" : "_").repeat(lineLength));
      }
      model2.checkTrainableWeightsConsistency();
      const trainableCount = countTrainableParams(model2);
      const nonTrainableCount = countParamsInWeights(model2.nonTrainableWeights);
      printFn(`Total params: ${trainableCount + nonTrainableCount}`);
      printFn(`Trainable params: ${trainableCount}`);
      printFn(`Non-trainable params: ${nonTrainableCount}`);
      printFn("_".repeat(lineLength));
    }
    function countTrainableParams(model2) {
      let trainableCount;
      if (model2.collectedTrainableWeights != null) {
        trainableCount = countParamsInWeights(model2.collectedTrainableWeights);
      } else {
        trainableCount = countParamsInWeights(model2.trainableWeights);
      }
      return trainableCount;
    }
    function isModelSequentialLike(model2) {
      let sequentialLike = true;
      const nodesByDepth = [];
      const nodes = [];
      for (const depth in model2.nodesByDepth) {
        nodesByDepth.push(model2.nodesByDepth[depth]);
      }
      for (const depthNodes of nodesByDepth) {
        if (depthNodes.length > 1 || depthNodes.length === 1 && depthNodes[0].inboundLayers.length > 1) {
          sequentialLike = false;
          break;
        }
        nodes.push(...depthNodes);
      }
      if (sequentialLike) {
        for (const layer of model2.layers) {
          let flag = false;
          for (const node of layer.inboundNodes) {
            if (nodes.indexOf(node) !== -1) {
              if (flag) {
                sequentialLike = false;
                break;
              } else {
                flag = true;
              }
            }
          }
          if (!sequentialLike) {
            break;
          }
        }
      }
      return sequentialLike;
    }
    function printRow(fields, positions, printFn = console.log) {
      let line = "";
      for (let i = 0; i < fields.length; ++i) {
        if (i > 0) {
          line = line.slice(0, line.length - 1) + " ";
        }
        line += fields[i];
        line = line.slice(0, positions[i]);
        line += " ".repeat(positions[i] - line.length);
      }
      printFn(line);
    }
    function printLayerSummary(layer, positions, printFn) {
      let outputShape;
      try {
        outputShape = JSON.stringify(layer.outputShape);
      } catch (err) {
        outputShape = "multiple";
      }
      const name = layer.name;
      const className = layer.getClassName();
      const fields = [`${name} (${className})`, outputShape, layer.countParams().toString()];
      printRow(fields, positions, printFn);
    }
    function printLayerSummaryWithConnections(layer, positions, relevantNodes, printFn) {
      let outputShape;
      try {
        outputShape = JSON.stringify(layer.outputShape);
      } catch (err) {
        outputShape = "multiple";
      }
      const connections = [];
      for (const node of layer.inboundNodes) {
        if (relevantNodes != null && relevantNodes.length > 0 && relevantNodes.indexOf(node) === -1) {
          continue;
        }
        for (let i = 0; i < node.inboundLayers.length; ++i) {
          const inboundLayer = node.inboundLayers[i].name;
          const inboundLayerIndex = node.nodeIndices[i];
          const inboundTensorIndex = node.tensorIndices[i];
          connections.push(`${inboundLayer}[${inboundLayerIndex}][${inboundTensorIndex}]`);
        }
      }
      const name = layer.name;
      const className = layer.getClassName();
      const firstConnection = connections.length === 0 ? "" : connections[0];
      const fields = [
        `${name} (${className})`,
        outputShape,
        layer.countParams().toString(),
        firstConnection
      ];
      printRow(fields, positions, printFn);
      for (let i = 1; i < connections.length; ++i) {
        printRow(["", "", "", connections[i]], positions, printFn);
      }
    }
    /**
     * @license
     * Copyright 2018 Google LLC
     *
     * Use of this source code is governed by an MIT-style
     * license that can be found in the LICENSE file or at
     * https://opensource.org/licenses/MIT.
     * =============================================================================
     */
    function isArrayItemInputOrOutputName(key, index2, value) {
      return (key === "inboundNodes" || key === "outputLayers" || key === "inputLayers") && index2 === 0 && typeof value === "string";
    }
    function convertPythonicToTs(pythonicConfig, key) {
      if (pythonicConfig === null) {
        return null;
      } else if (typeof pythonicConfig === "string") {
        return toCamelCase(pythonicConfig);
      } else if (typeof pythonicConfig === "number" || typeof pythonicConfig === "boolean") {
        return pythonicConfig;
      } else if (pythonicConfig instanceof Array) {
        const tsArray = [];
        const arrayLength = pythonicConfig.length;
        for (let i = 0; i < arrayLength; ++i) {
          const item = pythonicConfig[i];
          if (isArrayItemInputOrOutputName(key, i, item)) {
            tsArray.push(item);
          } else {
            tsArray.push(convertPythonicToTs(item, key));
          }
        }
        return tsArray;
      } else {
        const tsDict = {};
        for (const pythonicKey of Object.keys(pythonicConfig)) {
          const pythonicValue = pythonicConfig[pythonicKey];
          if (pythonicKey === "name" && typeof pythonicValue === "string") {
            tsDict[pythonicKey] = pythonicValue;
          } else {
            const tsKey = toCamelCase(pythonicKey);
            tsDict[tsKey] = convertPythonicToTs(pythonicValue, tsKey);
          }
        }
        return tsDict;
      }
    }
    function convertTsToPythonic(tsConfig, key) {
      if (tsConfig === null || tsConfig === void 0) {
        return null;
      } else if (typeof tsConfig === "string") {
        return toSnakeCase(tsConfig);
      } else if (typeof tsConfig === "number" || typeof tsConfig === "boolean") {
        return tsConfig;
      } else if (tsConfig instanceof Array) {
        const pyArray = [];
        const arrayLength = tsConfig.length;
        for (let i = 0; i < arrayLength; ++i) {
          const item = tsConfig[i];
          if (isArrayItemInputOrOutputName(key, i, item)) {
            pyArray.push(item);
          } else {
            pyArray.push(convertTsToPythonic(item, key));
          }
        }
        return pyArray;
      } else {
        const pyDict = {};
        for (const tsKey of Object.keys(tsConfig)) {
          const tsValue = tsConfig[tsKey];
          const pyKey = toSnakeCase(tsKey);
          if ((tsKey === "name" || tsKey === "className") && typeof tsValue === "string") {
            pyDict[pyKey] = tsValue;
          } else {
            pyDict[pyKey] = convertTsToPythonic(tsValue, tsKey);
          }
        }
        return pyDict;
      }
    }
    /** @license See the LICENSE file. */
    const version$1 = "2.7.0";
    /**
     * @license
     * Copyright 2018 Google LLC
     *
     * Use of this source code is governed by an MIT-style
     * license that can be found in the LICENSE file or at
     * https://opensource.org/licenses/MIT.
     * =============================================================================
     */
    function assertFeedCompatibility(key, val) {
      if (key.dtype == null || key.dtype === val.dtype) {
        return val;
      }
      try {
        return cast7(val, key.dtype);
      } catch (err) {
        throw new ValueError(`The dtype of the feed (${val.dtype}) can not be cast to the dtype of the key '${key.name}' (${key.dtype}).`);
      }
    }
    class FeedDict {
      constructor(feeds) {
        this.id2Value = {};
        this.id2Mask = {};
        this.name2Id = {};
        if (feeds instanceof FeedDict) {
          for (const id in feeds.id2Value) {
            this.id2Value[id] = feeds.id2Value[id];
            if (id in feeds.id2Mask) {
              this.id2Mask[id] = feeds.id2Mask[id];
            }
          }
        } else {
          if (feeds == null) {
            return;
          }
          for (const feed of feeds) {
            this.add(feed.key, feed.value);
          }
        }
      }
      add(key, value, mask) {
        if (this.id2Value[key.id] == null) {
          this.id2Value[key.id] = assertFeedCompatibility(key, value);
          this.name2Id[key.name] = key.id;
          if (mask != null) {
            this.id2Mask[key.id] = mask;
          }
        } else {
          throw new ValueError(`Duplicate key: name=${key.name}, id=${key.id}`);
        }
        return this;
      }
      addFeed(feed) {
        this.add(feed.key, feed.value);
      }
      hasKey(key) {
        return this.id2Value[key.id] != null;
      }
      names() {
        return Object.keys(this.name2Id);
      }
      getValue(key) {
        if (key instanceof SymbolicTensor) {
          if (this.id2Value[key.id] == null) {
            throw new ValueError(`Nonexistent key: ${key.name}`);
          } else {
            return this.id2Value[key.id];
          }
        } else {
          const id = this.name2Id[key];
          if (id == null) {
            throw new ValueError(`Feed dict has no SymbolicTensor name: ${key}`);
          }
          return this.id2Value[id];
        }
      }
      getMask(key) {
        if (key instanceof SymbolicTensor) {
          if (this.id2Value[key.id] == null) {
            throw new ValueError(`Nonexistent key: ${key.name}`);
          } else {
            return this.id2Mask[key.id];
          }
        } else {
          const id = this.name2Id[key];
          if (id == null) {
            throw new ValueError(`Feed dict has no SymbolicTensor name: ${key}`);
          }
          return this.id2Mask[id];
        }
      }
      disposeMasks() {
        if (this.id2Mask != null) {
          dispose(this.id2Mask);
        }
      }
    }
    const cachedSorted = {};
    const cachedRecipientCounts = {};
    function execute(fetches, feedDict, kwargs, probe) {
      const training = kwargs == null ? false : kwargs["training"];
      const arrayFetches = Array.isArray(fetches);
      const fetchArray = arrayFetches ? fetches : [fetches];
      const outputNames = fetchArray.map((t) => t.name);
      const finalOutputs = [];
      const feedNames = feedDict.names();
      for (const outputName of outputNames) {
        if (feedNames.indexOf(outputName) !== -1) {
          finalOutputs.push(feedDict.getValue(outputName));
        } else {
          finalOutputs.push(null);
        }
      }
      if (probe != null) {
        probe.maxNumTensors = -Infinity;
        probe.minNumTensors = Infinity;
      }
      const fetchAndFeedKey = outputNames.join(",") + "|" + feedDict.names().join(",");
      let sorted;
      let recipientCounts;
      if (cachedSorted[fetchAndFeedKey] == null) {
        const out = getTopologicalSortAndRecipientCounts(fetchArray, feedDict);
        sorted = out.sorted;
        recipientCounts = out.recipientCounts;
        cachedSorted[fetchAndFeedKey] = sorted;
        cachedRecipientCounts[fetchAndFeedKey] = recipientCounts;
      }
      sorted = cachedSorted[fetchAndFeedKey];
      recipientCounts = {};
      if (!training) {
        Object.assign(recipientCounts, cachedRecipientCounts[fetchAndFeedKey]);
      }
      const internalFeedDict = new FeedDict(feedDict);
      for (let i = 0; i < sorted.length; ++i) {
        if (probe != null) {
          const numTensors = memory().numTensors;
          if (numTensors > probe.maxNumTensors) {
            probe.maxNumTensors = numTensors;
          }
          if (numTensors < probe.minNumTensors) {
            probe.minNumTensors = numTensors;
          }
        }
        const symbolic = sorted[i];
        const srcLayer = symbolic.sourceLayer;
        if (srcLayer instanceof InputLayer) {
          continue;
        }
        const inputValues = [];
        const inputMasks = [];
        const tensorsToDispose = [];
        let maskExists = false;
        for (const input2 of symbolic.inputs) {
          const value = internalFeedDict.getValue(input2);
          const mask = internalFeedDict.getMask(input2);
          inputValues.push(value);
          inputMasks.push(mask);
          if (mask != null) {
            maskExists = true;
          }
          if (!training) {
            recipientCounts[input2.name]--;
            if (recipientCounts[input2.name] === 0 && !feedDict.hasKey(input2) && outputNames.indexOf(input2.name) === -1 && !value.isDisposed && input2.sourceLayer.stateful !== true) {
              tensorsToDispose.push(value);
            }
          }
        }
        if (maskExists) {
          kwargs = kwargs || {};
          kwargs["mask"] = inputMasks[0];
        }
        const outputTensors = toList(srcLayer.apply(inputValues, kwargs));
        let outputMask = null;
        if (srcLayer.supportsMasking) {
          outputMask = srcLayer.computeMask(inputValues, inputMasks);
        }
        const layerOutputs = getNodeOutputs(symbolic);
        const outputSymbolicTensors = Array.isArray(layerOutputs) ? layerOutputs : [layerOutputs];
        for (let i2 = 0; i2 < outputSymbolicTensors.length; ++i2) {
          if (!internalFeedDict.hasKey(outputSymbolicTensors[i2])) {
            internalFeedDict.add(outputSymbolicTensors[i2], outputTensors[i2], Array.isArray(outputMask) ? outputMask[0] : outputMask);
          }
          const index2 = outputNames.indexOf(outputSymbolicTensors[i2].name);
          if (index2 !== -1) {
            finalOutputs[index2] = outputTensors[i2];
          }
        }
        if (!training) {
          dispose(tensorsToDispose);
        }
      }
      internalFeedDict.disposeMasks();
      return arrayFetches ? finalOutputs : finalOutputs[0];
    }
    function getTopologicalSortAndRecipientCounts(fetches, feedDict) {
      assert2(fetches != null && fetches.length > 0, () => `Expected at least one fetch, got none`);
      let finalSorted = [];
      let finalRecipientMap = {};
      if (fetches.length === 1) {
        const out = getTopologicalSortAndRecipientCountsForOneFetch(fetches[0], feedDict);
        finalSorted = out.sorted;
        finalRecipientMap = out.recipientMap;
      } else {
        const visited = new Set();
        for (const fetch3 of fetches) {
          const {sorted, recipientMap} = getTopologicalSortAndRecipientCountsForOneFetch(fetch3, feedDict);
          for (const symbolicTensor of sorted) {
            if (!visited.has(symbolicTensor.name)) {
              finalSorted.push(symbolicTensor);
              visited.add(symbolicTensor.name);
            }
          }
          for (const name in recipientMap) {
            if (finalRecipientMap[name] == null) {
              finalRecipientMap[name] = new Set();
            }
            recipientMap[name].forEach((recipient) => finalRecipientMap[name].add(recipient));
          }
        }
      }
      return {
        sorted: finalSorted,
        recipientCounts: recipientMap2Counts(finalRecipientMap)
      };
    }
    function recipientMap2Counts(recipientMap) {
      const recipientCounts = {};
      for (const name in recipientMap) {
        recipientCounts[name] = recipientMap[name].size;
      }
      return recipientCounts;
    }
    function getTopologicalSortAndRecipientCountsForOneFetch(fetch3, feedDict) {
      const visited = new Set();
      const sorted = [];
      const recipientMap = {};
      for (const key of feedDict.names()) {
        visited.add(key);
      }
      const stack2 = [];
      const marks = [];
      stack2.push(fetch3);
      while (stack2.length > 0) {
        const top = stack2[stack2.length - 1];
        if (visited.has(top.name)) {
          stack2.pop();
          continue;
        }
        const topIsMarked = marks[marks.length - 1] === stack2.length - 1;
        if (top.inputs.length === 0 || topIsMarked) {
          stack2.pop();
          sorted.push(top);
          visited.add(top.name);
          if (topIsMarked) {
            marks.pop();
          }
        } else {
          marks.push(stack2.length - 1);
          for (const input2 of top.inputs) {
            if (recipientMap[input2.name] == null) {
              recipientMap[input2.name] = new Set();
            }
            recipientMap[input2.name].add(top.name);
            if (visited.has(input2.name)) {
              continue;
            }
            stack2.push(input2);
          }
        }
      }
      return {sorted, recipientMap};
    }
    function getNodeOutputs(fetch3) {
      let layerOutputs;
      if (fetch3.sourceLayer.inboundNodes.length === 1) {
        layerOutputs = fetch3.sourceLayer.output;
      } else {
        let nodeIndex = null;
        for (let i = 0; i < fetch3.sourceLayer.inboundNodes.length; ++i) {
          for (const outputTensor of fetch3.sourceLayer.inboundNodes[i].outputTensors) {
            if (outputTensor.id === fetch3.id) {
              nodeIndex = i;
              break;
            }
          }
        }
        layerOutputs = fetch3.sourceLayer.getOutputAt(nodeIndex);
      }
      return layerOutputs;
    }
    /**
     * @license
     * Copyright 2018 Google LLC
     *
     * Use of this source code is governed by an MIT-style
     * license that can be found in the LICENSE file or at
     * https://opensource.org/licenses/MIT.
     * =============================================================================
     */
    class Container extends Layer {
      constructor(args) {
        super({});
        this.containerNodes = new Set();
        this.name = args.name;
        if (this.name == null) {
          const prefix = this.getClassName().toLowerCase();
          this.name = getUid(prefix);
        }
        this.supportsMasking = false;
        this.trainable_ = true;
        if (Array.isArray(args.inputs)) {
          this.inputs = args.inputs.slice();
        } else {
          this.inputs = [args.inputs];
        }
        if (Array.isArray(args.outputs)) {
          this.outputs = args.outputs.slice();
        } else {
          this.outputs = [args.outputs];
        }
        if (unique$1(this.inputs).length !== this.inputs.length) {
          throw new ValueError(`The list of inputs passed to the model is redundant. All inputs should only appear once. Found: ${this.inputs.map((x) => x.name)}`);
        }
        if (unique$1(this.outputs).length !== this.outputs.length) {
          console.warn(`The list of outputs passed to the model is redundant. All outputs should only appear once. Found: ${this.outputs.map((x) => x.name)}`);
        }
        this.inputLayers = [];
        this.inputLayersNodeIndices = [];
        this.inputLayersTensorIndices = [];
        this.outputLayers = [];
        this.outputLayersNodeIndices = [];
        this.outputLayersTensorIndices = [];
        this.layers = [];
        this.internalContainerRefs = [];
        for (const x of this.outputs) {
          const layer = x.sourceLayer;
          const nodeIndex = x.nodeIndex;
          const tensorIndex = x.tensorIndex;
          this.outputLayers.push(layer);
          this.outputLayersNodeIndices.push(nodeIndex);
          this.outputLayersTensorIndices.push(tensorIndex);
        }
        for (const x of this.inputs) {
          const layer = x.sourceLayer;
          const nodeIndex = x.nodeIndex;
          const tensorIndex = x.tensorIndex;
          assert$1(nodeIndex === 0, "input layer has >1 nodes");
          assert$1(tensorIndex === 0, "input layer has >1 tensors");
          this.inputLayers.push(layer);
          this.inputLayersNodeIndices.push(nodeIndex);
          this.inputLayersTensorIndices.push(tensorIndex);
        }
        this.inputNames = [];
        this.outputNames = [];
        this.feedInputShapes = [];
        this.feedInputNames = [];
        this.feedOutputNames = [];
        for (let i = 0; i < this.inputLayers.length; i++) {
          const layer = this.inputLayers[i];
          if (!(layer instanceof InputLayer)) {
            throw new TypeError(`Input layers to a LayersModel must be InputLayer objects. Received inputs: ${args.inputs}. Input ${i} (0-based) originates from layer type ${layer.getClassName()}.`);
          }
          this.inputNames.push(layer.name);
          this.feedInputShapes.push(layer.batchInputShape);
          this.feedInputNames.push(layer.name);
        }
        for (const layer of this.outputLayers) {
          this.outputNames.push(layer.name);
        }
        this.internalInputShapes = this.inputs.map((x) => x.shape);
        this.internalOutputShapes = this.outputs.map((x) => x.shape);
        const nodesDepths = {};
        const nodeIDToNode = {};
        const layersDepths = {};
        const layerIDToLayer = {};
        const layerIndices = {};
        const nodesInDecreasingDepth = [];
        const buildMapOfGraph = (tensor7, finishedNodes2, nodesInProgress2, layer, nodeIndex, tensorIndex) => {
          if (layer == null || nodeIndex == null || tensorIndex == null) {
            layer = tensor7.sourceLayer;
            nodeIndex = tensor7.nodeIndex;
            tensorIndex = tensor7.tensorIndex;
          }
          const node = layer.inboundNodes[nodeIndex];
          if (nodesInProgress2.indexOf(node) !== -1) {
            throw new RuntimeError(`The tensor ${tensor7.name} at layer "${layer.name}" is part of a cycle.`);
          }
          if (finishedNodes2.indexOf(node) !== -1) {
            return;
          }
          this.containerNodes.add(Container.nodeKey(layer, nodeIndex));
          if (!(layer.id in layerIndices)) {
            layerIndices[layer.id] = Object.keys(layerIndices).length;
          }
          if (nodesInProgress2.indexOf(node) === -1) {
            nodesInProgress2.push(node);
          }
          const numInboundLayers = node.inboundLayers.length;
          for (let i = 0; i < numInboundLayers; i++) {
            const x = node.inputTensors[i];
            const layer2 = node.inboundLayers[i];
            const nodeIndex2 = node.nodeIndices[i];
            const tensorIndex2 = node.tensorIndices[i];
            buildMapOfGraph(x, finishedNodes2, nodesInProgress2, layer2, nodeIndex2, tensorIndex2);
          }
          finishedNodes2.push(node);
          while (nodesInProgress2.indexOf(node) >= 0) {
            nodesInProgress2.splice(nodesInProgress2.indexOf(node), 1);
          }
          nodesInDecreasingDepth.push(node);
        };
        const finishedNodes = [];
        const nodesInProgress = [];
        for (const x of this.outputs) {
          buildMapOfGraph(x, finishedNodes, nodesInProgress);
        }
        const reversedNodesInDecreasingDepth = nodesInDecreasingDepth.slice().reverse();
        for (const node of reversedNodesInDecreasingDepth) {
          nodeIDToNode[node.id] = node;
          if (!(node.id in nodesDepths)) {
            nodesDepths[node.id] = 0;
          }
          let depth = nodesDepths[node.id];
          const previousDepth = layersDepths[node.outboundLayer.id] == null ? 0 : layersDepths[node.outboundLayer.id];
          depth = Math.max(depth, previousDepth);
          layersDepths[node.outboundLayer.id] = depth;
          layerIDToLayer[node.outboundLayer.id] = node.outboundLayer;
          nodesDepths[node.id] = depth;
          for (let i = 0; i < node.inboundLayers.length; i++) {
            const inboundLayer = node.inboundLayers[i];
            const nodeIndex = node.nodeIndices[i];
            const inboundNode = inboundLayer.inboundNodes[nodeIndex];
            const previousDepth2 = nodesDepths[inboundNode.id] == null ? 0 : nodesDepths[inboundNode.id];
            nodesDepths[inboundNode.id] = Math.max(depth + 1, previousDepth2);
            nodeIDToNode[inboundNode.id] = inboundNode;
          }
        }
        const nodesByDepth = {};
        for (const nodeID in nodesDepths) {
          const depth = nodesDepths[nodeID];
          if (!(depth in nodesByDepth)) {
            nodesByDepth[depth] = [];
          }
          nodesByDepth[depth].push(nodeIDToNode[nodeID]);
        }
        const layersByDepth = {};
        for (const layerID in layersDepths) {
          const depth = layersDepths[layerID];
          if (!(depth in layersByDepth)) {
            layersByDepth[depth] = [];
          }
          layersByDepth[depth].push(layerIDToLayer[layerID]);
        }
        let depthKeys = Object.keys(layersByDepth).map((x) => parseInt(x, 10)).sort(reverseNumberCompare);
        this.layers = [];
        for (const depth of depthKeys) {
          const layersForDepth = layersByDepth[depth];
          layersForDepth.sort((a, b) => {
            const aIndex = layerIndices[a.id];
            const bIndex = layerIndices[b.id];
            if (aIndex < bIndex) {
              return -1;
            }
            if (aIndex > bIndex) {
              return 1;
            }
            return 0;
          });
          for (const layer of layersForDepth) {
            if (layer instanceof Container) {
              this.internalContainerRefs.push(layer);
            }
            this.layers.push(layer);
          }
        }
        this.layersByDepth = layersByDepth;
        depthKeys = Object.keys(nodesByDepth).map((x) => parseInt(x, 10)).sort(reverseNumberCompare);
        const computableTensors = this.inputs.slice();
        const layersWithCompleteInput = [];
        for (const depth of depthKeys) {
          for (const node of nodesByDepth[depth]) {
            const layer = node.outboundLayer;
            if (layer != null) {
              for (const x of node.inputTensors) {
                if (computableTensors.indexOf(x) === -1) {
                  throw new RuntimeError(`Graph disconnected: cannot obtain value for tensor ${x} at layer "${layer.name}". The following previous layers were accessed without issue: ${layersWithCompleteInput}`);
                }
              }
              for (const x of node.outputTensors) {
                computableTensors.push(x);
              }
              layersWithCompleteInput.push(layer.name);
            }
          }
        }
        this.nodesByDepth = nodesByDepth;
        const allNames = this.layers.map((x) => x.name);
        for (const name of allNames) {
          const numOccurrences = allNames.filter((x) => x === name).length;
          if (numOccurrences !== 1) {
            throw new RuntimeError(`The name "${name}" is used ${numOccurrences} times in the model. All layer names should be unique. Layer names: ` + JSON.stringify(allNames));
          }
        }
        this.outboundNodes = [];
        this.inboundNodes = [];
        new Node({
          outboundLayer: this,
          inboundLayers: [],
          nodeIndices: [],
          tensorIndices: [],
          inputTensors: this.inputs,
          outputTensors: this.outputs,
          inputMasks: this.inputs.map((x) => null),
          outputMasks: this.outputs.map((x) => null),
          inputShapes: this.inputs.map((x) => x.shape),
          outputShapes: this.outputs.map((x) => x.shape)
        });
        this.built = true;
        this._refCount = 1;
      }
      assertNotDisposed() {
        if (this._refCount === 0) {
          throw new Error(`Container '${this.name}' is already disposed.`);
        }
      }
      dispose() {
        this.assertNotDisposed();
        const result = {refCountAfterDispose: null, numDisposedVariables: 0};
        if (--this._refCount === 0) {
          for (const layer of this.layers) {
            result.numDisposedVariables += layer.dispose().numDisposedVariables;
          }
          for (const container of this.internalContainerRefs) {
            result.numDisposedVariables += container.dispose().numDisposedVariables;
          }
        }
        result.refCountAfterDispose = this._refCount;
        return result;
      }
      get trainable() {
        return this.trainable_;
      }
      set trainable(trainable) {
        this.layers.forEach((layer) => {
          layer._trainableWeights.forEach((w) => w.trainable = trainable);
        });
        this.trainable_ = trainable;
      }
      get trainableWeights() {
        if (this._trainableWeights.length > 0) {
          throw new ValueError("Container instance unexpectedly contains _trainableWeights.The trainable weights of a Container are a union of the trainable weights of its consituent Layers. Its own _trainableWeights must remain an empty Array.");
        }
        if (!this.trainable) {
          return [];
        }
        let weights = [];
        for (const layer of this.layers) {
          weights = weights.concat(layer.trainableWeights);
        }
        return weights;
      }
      get nonTrainableWeights() {
        const weights = [];
        for (const layer of this.layers) {
          weights.push(...layer.nonTrainableWeights);
        }
        if (!this.trainable) {
          const trainableWeights = [];
          for (const layer of this.layers) {
            trainableWeights.push(...layer.trainableWeights);
          }
          return trainableWeights.concat(weights);
        }
        return weights;
      }
      get weights() {
        return this.trainableWeights.concat(this.nonTrainableWeights);
      }
      loadWeights(weights, strict = true) {
        const nameToWeight = {};
        let totalWeightsCount = 0;
        for (const layer of this.layers) {
          for (const weight of layer.weights) {
            if (nameToWeight[weight.originalName] != null) {
              throw new ValueError(`Duplicate weight name: ${weight.originalName}`);
            }
            nameToWeight[weight.originalName] = weight;
            totalWeightsCount++;
          }
        }
        const weightValueTuples = [];
        for (const name in weights) {
          let validatedName = name;
          if (nameToWeight[name] == null) {
            const tokens = name.split("/");
            const shortenNameArray = tokens.slice(0, -2).concat([tokens[tokens.length - 1]]);
            validatedName = shortenNameArray.join("/");
          }
          if (nameToWeight[validatedName] != null) {
            weightValueTuples.push([nameToWeight[validatedName], weights[name]]);
          } else if (strict) {
            throw new ValueError(`Provided weight data has no target variable: ${name}`);
          }
          delete nameToWeight[validatedName];
        }
        if (strict) {
          const unsetNames = [];
          for (const name in nameToWeight) {
            unsetNames.push(name);
          }
          if (unsetNames.length > 0) {
            throw new ValueError(`${unsetNames.length} of ${totalWeightsCount} weights are not set: ${unsetNames}`);
          }
        }
        batchSetValue(weightValueTuples);
      }
      updatedConfig() {
        const theConfig = this.getConfig();
        const modelConfig = {};
        modelConfig["className"] = this.getClassName();
        modelConfig["config"] = theConfig;
        modelConfig["kerasVersion"] = `tfjs-layers ${version$1}`;
        modelConfig["backend"] = "TensorFlow.js";
        return modelConfig;
      }
      toJSON(unused, returnString = true) {
        const modelConfig = convertTsToPythonic(this.updatedConfig());
        return returnString ? JSON.stringify(modelConfig) : modelConfig;
      }
      call(inputs, kwargs) {
        return tidy(() => {
          inputs = toList(inputs);
          const feedDict = new FeedDict();
          for (let i = 0; i < this.inputs.length; ++i) {
            feedDict.add(this.inputs[i], inputs[i]);
          }
          return execute(this.outputs, feedDict, kwargs);
        });
      }
      computeMask(inputs, mask) {
        return tidy(() => {
          inputs = toList(inputs);
          let masks;
          if (mask == null) {
            masks = pyListRepeat(null, inputs.length);
          } else {
            masks = toList(mask);
          }
          return this.runInternalGraph(inputs, masks)[1];
        });
      }
      computeOutputShape(inputShape) {
        const inputShapes = normalizeShapeList(inputShape);
        if (inputShapes.length !== this.inputLayers.length) {
          throw new ValueError(`Invalid inputShape argument ${inputShape}: model has ${this.inputLayers.length} tensor inputs.`);
        }
        const layersToOutputShapes = {};
        for (let i = 0; i < inputShapes.length; i++) {
          const layer = this.inputLayers[i];
          const inputShape2 = inputShapes[i];
          const shapeKey = layer.name + "_0_0";
          layersToOutputShapes[shapeKey] = inputShape2;
        }
        const depthKeys = Object.keys(this.nodesByDepth).map((x) => parseInt(x, 10)).sort(reverseNumberCompare);
        if (depthKeys.length > 1) {
          for (const depth of depthKeys) {
            const nodes = this.nodesByDepth[depth];
            for (const node of nodes) {
              const layer = node.outboundLayer;
              if (this.inputLayers.map((x) => x.id).indexOf(layer.id) !== -1) {
                continue;
              }
              const inputShapes2 = [];
              for (let j = 0; j < node.inboundLayers.length; j++) {
                const inboundLayer = node.inboundLayers[j];
                const nodeIndex2 = node.nodeIndices[j];
                const tensorIndex = node.tensorIndices[j];
                const shapeKey = `${inboundLayer.name}_${nodeIndex2}_${tensorIndex}`;
                const inputShape2 = layersToOutputShapes[shapeKey];
                inputShapes2.push(inputShape2);
              }
              const outputShape = layer.computeOutputShape(singletonOrArray(inputShapes2));
              const outputShapes2 = normalizeShapeList(outputShape);
              const nodeIndex = layer.inboundNodes.indexOf(node);
              for (let j = 0; j < outputShapes2.length; j++) {
                const shapeKey = `${layer.name}_${nodeIndex}_${j}`;
                layersToOutputShapes[shapeKey] = outputShapes2[j];
              }
            }
          }
        }
        const outputShapes = [];
        const outputShapeKeys = [];
        for (let i = 0; i < this.outputLayers.length; i++) {
          const layer = this.outputLayers[i];
          const nodeIndex = this.outputLayersNodeIndices[i];
          const tensorIndex = this.outputLayersTensorIndices[i];
          const shapeKey = `${layer.name}_${nodeIndex}_${tensorIndex}`;
          outputShapeKeys.push(shapeKey);
        }
        for (let i = 0; i < outputShapeKeys.length; i++) {
          const key = outputShapeKeys[i];
          assert$1(key in layersToOutputShapes);
          outputShapes.push(layersToOutputShapes[key]);
        }
        return singletonOrArray(outputShapes);
      }
      runInternalGraph(inputs, masks) {
        if (masks == null) {
          masks = pyListRepeat(null, inputs.length);
        }
        const tensorMap = {};
        for (let i = 0; i < this.inputs.length; ++i) {
          const x = this.inputs[i];
          const y = inputs[i];
          const mask = masks[i];
          tensorMap[x.id] = [y, mask];
        }
        const depthKeys = Object.keys(this.nodesByDepth).map((x) => parseInt(x, 10)).sort(reverseNumberCompare);
        for (const depth of depthKeys) {
          const nodes = this.nodesByDepth[depth];
          for (const node of nodes) {
            const layer = node.outboundLayer;
            const referenceInputTensors = node.inputTensors;
            const referenceOutputTensors = node.outputTensors;
            const computedData = new Array();
            for (const x of referenceInputTensors) {
              if (x.id in tensorMap) {
                computedData.push(tensorMap[x.id]);
              }
            }
            if (computedData.length === referenceInputTensors.length) {
              let kwargs = {};
              let computedTensors;
              let computedMasks;
              let outputTensors2;
              let outputMasks2;
              if (node.callArgs != null) {
                kwargs = node.callArgs;
              }
              if (computedData.length === 1) {
                const [computedTensor, computedMask] = computedData[0];
                if (kwargs["mask"] == null) {
                  kwargs["mask"] = computedMask;
                }
                outputTensors2 = toList(layer.call(computedTensor, kwargs));
                outputMasks2 = toList(layer.computeMask(computedTensor, computedMask));
                computedTensors = [computedTensor];
                computedMasks = [computedMask];
              } else {
                computedTensors = computedData.map((x) => x[0]);
                computedMasks = computedData.map((x) => x[1]);
                if (kwargs["mask"] == null) {
                  kwargs["mask"] = computedMasks;
                }
                outputTensors2 = toList(layer.call(computedTensors, kwargs));
                outputMasks2 = toList(layer.computeMask(computedTensors, computedMasks));
              }
              if (layer.activityRegularizer) {
                throw new NotImplementedError("LayersModel invocation with concrete Tensor value(s) in the presence of activity regularizer(s) is not supported yet.");
              }
              for (let i = 0; i < referenceOutputTensors.length; ++i) {
                const x = referenceOutputTensors[i];
                const y = outputTensors2[i];
                const mask = outputMasks2[i];
                tensorMap[x.id] = [y, mask];
              }
            }
          }
        }
        const outputTensors = [];
        const outputMasks = [];
        const outputShapes = [];
        for (const x of this.outputs) {
          assert$1(x.id in tensorMap, `Could not compute output ${x.name} : ${x.id}`);
          const [tensor7, mask] = tensorMap[x.id];
          outputShapes.push(tensor7.shape);
          outputTensors.push(tensor7);
          outputMasks.push(mask);
        }
        return [outputTensors, outputMasks, outputShapes];
      }
      buildNodeConversionMap(layers) {
        const nodeConversionMap = {};
        let keptNodes;
        for (const layer of this.layers) {
          keptNodes = layer instanceof Container ? 1 : 0;
          for (let originalNodeIndex = 0; originalNodeIndex < layer.inboundNodes.length; originalNodeIndex++) {
            const nodeKey = Container.nodeKey(layer, originalNodeIndex);
            if (this.containerNodes.has(nodeKey)) {
              nodeConversionMap[nodeKey] = keptNodes;
              keptNodes += 1;
            }
          }
        }
        return nodeConversionMap;
      }
      getLayer(name, index2) {
        if (index2 != null) {
          if (this.layers.length <= index2) {
            throw new ValueError(`Was asked to retrieve layer at index ${index2}, but model only has ${this.layers.length} layer(s).`);
          } else {
            return this.layers[index2];
          }
        } else {
          if (name == null) {
            throw new ValueError("Provide either a layer name or layer index");
          }
        }
        for (const layer of this.layers) {
          if (layer.name === name) {
            return layer;
          }
        }
        throw new ValueError(`No such layer: ${name}`);
      }
      calculateLosses() {
        return tidy(() => {
          const losses2 = [];
          for (const layer of this.layers) {
            for (let nodeIndex = 0; nodeIndex < layer.inboundNodes.length; ++nodeIndex) {
              const nodeKey = Container.nodeKey(layer, nodeIndex);
              if (this.containerNodes.has(nodeKey)) {
                losses2.push(...layer.calculateLosses());
              }
            }
          }
          return losses2;
        });
      }
      getConfig() {
        const config2 = {name: this.name};
        const nodeConversionMap = this.buildNodeConversionMap(this.layers);
        const layerConfigs = [];
        for (const layer of this.layers) {
          const layerClassName = layer.getClassName();
          const layerConfig = layer.getConfig();
          const filteredInboundNodes = [];
          for (let originalNodeIndex = 0; originalNodeIndex < layer.inboundNodes.length; originalNodeIndex++) {
            const node = layer.inboundNodes[originalNodeIndex];
            const nodeKey = Container.nodeKey(layer, originalNodeIndex);
            let kwargs = {};
            if (this.containerNodes.has(nodeKey)) {
              if (node.callArgs) {
                try {
                  JSON.stringify(node.callArgs);
                  kwargs = node.callArgs;
                } catch (err) {
                  console.warn(`Layer ${layer.name} was passed non-serializable keyword arguments: ${node.callArgs}. They will not be included in the serialized model (and thus will be missing at deserialization time).`);
                  kwargs = {};
                }
              }
              if (node.inboundLayers.length > 0) {
                const nodeData = [];
                for (let i = 0; i < node.inboundLayers.length; i++) {
                  const inboundLayer = node.inboundLayers[i];
                  const nodeIndex = node.nodeIndices[i];
                  const tensorIndex = node.tensorIndices[i];
                  const nodeKey2 = Container.nodeKey(inboundLayer, nodeIndex);
                  let newNodeIndex = nodeConversionMap[nodeKey2];
                  if (newNodeIndex == null) {
                    newNodeIndex = 0;
                  }
                  nodeData.push([inboundLayer.name, newNodeIndex, tensorIndex, kwargs]);
                }
                filteredInboundNodes.push(nodeData);
              }
            }
          }
          const dict = {};
          dict["name"] = layer.name;
          dict["className"] = layerClassName;
          dict["config"] = layerConfig;
          dict["inboundNodes"] = filteredInboundNodes;
          layerConfigs.push(dict);
        }
        config2["layers"] = layerConfigs;
        const modelInputs = [];
        for (let i = 0; i < this.inputLayers.length; i++) {
          const layer = this.inputLayers[i];
          const nodeIndex = this.inputLayersNodeIndices[i];
          const nodeKey = Container.nodeKey(layer, nodeIndex);
          if (!this.containerNodes.has(nodeKey)) {
            continue;
          }
          let newNodeIndex = nodeConversionMap[nodeKey];
          if (newNodeIndex === null || newNodeIndex === void 0) {
            newNodeIndex = 0;
          }
          const tensorIndex = this.inputLayersTensorIndices[i];
          modelInputs.push([layer.name, newNodeIndex, tensorIndex]);
        }
        config2["inputLayers"] = modelInputs;
        const modelOutputs = [];
        for (let i = 0; i < this.outputLayers.length; i++) {
          const layer = this.outputLayers[i];
          const nodeIndex = this.outputLayersNodeIndices[i];
          const nodeKey = Container.nodeKey(layer, nodeIndex);
          if (!this.containerNodes.has(nodeKey)) {
            continue;
          }
          let newNodeIndex = nodeConversionMap[nodeKey];
          if (newNodeIndex === null || newNodeIndex === void 0) {
            newNodeIndex = 0;
          }
          const tensorIndex = this.outputLayersTensorIndices[i];
          modelOutputs.push([layer.name, newNodeIndex, tensorIndex]);
        }
        config2["outputLayers"] = modelOutputs;
        return config2;
      }
      static fromConfig(cls, config2, customObjects = {}, fastWeightInit = false) {
        const createdLayers = {};
        const unprocessedNodes = {};
        function addUnprocessedNode(layer, nodeData) {
          if (!(layer.name in unprocessedNodes)) {
            unprocessedNodes[layer.name] = [nodeData];
          } else {
            unprocessedNodes[layer.name].push(nodeData);
          }
        }
        function processNode(layer, nodeData) {
          const inputTensors2 = [];
          let kwargs;
          for (const inputData of nodeData) {
            const inboundLayerName = inputData[0];
            const inboundNodeIndex = inputData[1];
            const inboundTensorIndex = inputData[2];
            kwargs = inputData[3] == null ? {} : inputData[3];
            if (!(inboundLayerName in createdLayers)) {
              addUnprocessedNode(layer, nodeData);
              return;
            }
            const inboundLayer = createdLayers[inboundLayerName];
            if (inboundLayer.inboundNodes.length <= inboundNodeIndex) {
              addUnprocessedNode(layer, nodeData);
              return;
            }
            const inboundNode = inboundLayer.inboundNodes[inboundNodeIndex];
            inputTensors2.push(inboundNode.outputTensors[inboundTensorIndex]);
          }
          if (inputTensors2.length > 0) {
            layer.apply(singletonOrArray(inputTensors2), kwargs);
          }
        }
        function processLayer(layerData) {
          const layerName = layerData["name"];
          const layer = deserialize(layerData, config2["customObjects"] != null ? config2["customObjects"] : {});
          layer.setFastWeightInitDuringBuild(fastWeightInit);
          createdLayers[layerName] = layer;
          const inboundNodesData = layerData["inboundNodes"];
          inboundNodesData.forEach((nodeData) => {
            if (!(nodeData instanceof Array)) {
              throw new ValueError(`Corrupted configuration, expected array for nodeData: ${nodeData}`);
            }
            addUnprocessedNode(layer, nodeData);
          });
        }
        const name = config2["name"];
        const layersFromConfig = config2["layers"];
        for (const layerData of layersFromConfig) {
          processLayer(layerData);
        }
        while (!isObjectEmpty(unprocessedNodes)) {
          for (const layerData of layersFromConfig) {
            const layer = createdLayers[layerData["name"]];
            if (layer.name in unprocessedNodes) {
              const currentUnprocessedNodesForLayer = unprocessedNodes[layer.name];
              delete unprocessedNodes[layer.name];
              for (const nodeData of currentUnprocessedNodesForLayer) {
                processNode(layer, nodeData);
              }
            }
          }
        }
        const inputTensors = [];
        const outputTensors = [];
        const inputLayersFromConfig = config2["inputLayers"];
        for (const layerData of inputLayersFromConfig) {
          const layerName = layerData[0];
          const nodeIndex = layerData[1];
          const tensorIndex = layerData[2];
          assert$1(layerName in createdLayers);
          const layer = createdLayers[layerName];
          const layerOutputTensors = layer.inboundNodes[nodeIndex].outputTensors;
          inputTensors.push(layerOutputTensors[tensorIndex]);
        }
        const outputLayersFromConfig = config2["outputLayers"];
        for (const layerData of outputLayersFromConfig) {
          const layerName = layerData[0];
          const nodeIndex = layerData[1];
          const tensorIndex = layerData[2];
          assert$1(layerName in createdLayers);
          const layer = createdLayers[layerName];
          const layerOutputTensors = layer.inboundNodes[nodeIndex].outputTensors;
          outputTensors.push(layerOutputTensors[tensorIndex]);
        }
        return new cls({inputs: inputTensors, outputs: outputTensors, name});
      }
      get stateful() {
        if (this._stateful) {
          throw new ValueError("Container instance unexpectedly has _stateful = true. The statefulness of a Container is determined by the Layers it contains. Its _stateful property must remain the default false.");
        }
        for (const layer of this.layers) {
          if (layer.stateful) {
            return true;
          }
        }
        return false;
      }
      resetStates() {
        tidy(() => {
          this.layers.forEach((layer) => {
            if (layer.stateful) {
              layer.resetStates();
            }
          });
        });
      }
    }
    /**
     * @license
     * Copyright 2018 Google LLC
     *
     * Use of this source code is governed by an MIT-style
     * license that can be found in the LICENSE file or at
     * https://opensource.org/licenses/MIT.
     * =============================================================================
     */
    function standardizeSampleOrClassWeights(xWeight, outputNames, weightType) {
      const numOutputs = outputNames.length;
      if (xWeight == null || Array.isArray(xWeight) && xWeight.length === 0) {
        return outputNames.map((name) => null);
      }
      if (numOutputs === 1) {
        if (Array.isArray(xWeight) && xWeight.length === 1) {
          return xWeight;
        } else if (typeof xWeight === "object" && outputNames[0] in xWeight) {
          return [xWeight[outputNames[0]]];
        } else {
          return [xWeight];
        }
      }
      if (Array.isArray(xWeight)) {
        if (xWeight.length !== numOutputs) {
          throw new Error(`Provided ${weightType} is an array of ${xWeight.length} element(s), but the model has ${numOutputs} outputs. Make sure a set of weights is provided for each model output.`);
        }
        return xWeight;
      } else if (typeof xWeight === "object" && Object.keys(xWeight).length > 0 && typeof xWeight[Object.keys(xWeight)[0]] === "object") {
        const output = [];
        outputNames.forEach((outputName) => {
          if (outputName in xWeight) {
            output.push(xWeight[outputName]);
          } else {
            output.push(null);
          }
        });
        return output;
      } else {
        throw new Error(`The model has multiple (${numOutputs}) outputs, so ${weightType} must be either an array with ${numOutputs} elements or an object with ${outputNames} keys. Provided ${weightType} not understood: ${JSON.stringify(xWeight)}`);
      }
    }
    function standardizeClassWeights(classWeight, outputNames) {
      return standardizeSampleOrClassWeights(classWeight, outputNames, "classWeight");
    }
    function standardizeSampleWeights(classWeight, outputNames) {
      return standardizeSampleOrClassWeights(classWeight, outputNames, "sampleWeight");
    }
    async function standardizeWeights(y, sampleWeight, classWeight, sampleWeightMode) {
      if (sampleWeight != null || sampleWeightMode != null) {
        throw new Error("Support sampleWeight is not implemented yet");
      }
      if (classWeight != null) {
        const yClasses = tidy(() => {
          if (y.shape.length === 1) {
            return y.clone();
          } else if (y.shape.length === 2) {
            if (y.shape[1] > 1) {
              const axis = 1;
              return y.argMax(axis);
            } else if (y.shape[1] === 1) {
              return y.reshape([y.shape[0]]);
            } else {
              throw new Error(`Encountered unexpected last-dimension size (${y.shape[1]}) during handling of class weights. The size is expected to be >= 1.`);
            }
          } else {
            throw new Error(`Unexpected rank of target (y) tensor (${y.rank}) during handling of class weights. The rank is expected to be 1 or 2.`);
          }
        });
        const yClassIndices = Array.from(await yClasses.data());
        dispose(yClasses);
        const classSampleWeight = [];
        yClassIndices.forEach((classIndex) => {
          if (classWeight[classIndex] == null) {
            throw new Error(`classWeight must contain all classes in the training data. The class ${classIndex} exists in the data but not in classWeight`);
          } else {
            classSampleWeight.push(classWeight[classIndex]);
          }
        });
        return tensor1d3(classSampleWeight, "float32");
      } else {
        return null;
      }
    }
    function computeWeightedLoss$1(losses2, sampleWeights) {
      return mul3(losses2, sampleWeights);
    }
    /**
     * @license
     * Copyright 2018 Google LLC
     *
     * Use of this source code is governed by an MIT-style
     * license that can be found in the LICENSE file or at
     * https://opensource.org/licenses/MIT.
     * =============================================================================
     */
    const DEFAULT_VALIDATION_BATCH_SIZE = 32;
    function standardizeDataIteratorOutput(model2, iteratorOut) {
      let xs;
      let ys;
      const iteratorOutObj = iteratorOut;
      xs = iteratorOutObj["xs"];
      ys = iteratorOutObj["ys"];
      assert2(xs != null && ys != null, () => `A Dataset iterator for fitDataset() is expected to generate objects of the form \`{xs: xVal, ys: yVal}\`, where the two values may be \`tf.Tensor\`, an array of Tensors, or a map of string to Tensor.  The provided Dataset instead generates ${iteratorOut}`);
      const flattenedXs = flattenTensorOrArrayOrMap("input", model2.inputNames, xs);
      const flattenedYs = flattenTensorOrArrayOrMap("output", model2.outputNames, ys);
      const batchSize = flattenedXs[0].shape[0];
      assert2(flattenedXs.length === model2.inputs.length, () => `LayersModel has ${model2.inputs.length} inputs, but the dataset provides ${flattenedXs.length} inputs.  (Expected input keys: ${JSON.stringify(model2.inputNames)})`);
      assert2(flattenedYs.length === model2.outputs.length, () => `LayersModel has ${model2.outputs.length} outputs, but the dataset provides ${flattenedYs.length} outputs.  (Expected output keys: ${JSON.stringify(model2.outputNames)})`);
      for (let xIndex = 0; xIndex < flattenedXs.length; xIndex++) {
        assert2(flattenedXs[xIndex].shape[0] === batchSize, () => `Batch size mismatch: input ${model2.inputNames[xIndex]} has ${flattenedXs[xIndex].shape[0]}; expected  ${batchSize} based on input ${model2.inputNames[0]}.`);
      }
      for (let yIndex = 0; yIndex < flattenedYs.length; yIndex++) {
        assert2(flattenedYs[yIndex].shape[0] === batchSize, () => `Batch size mismatch: output ${model2.outputNames[yIndex]} has ${flattenedYs[yIndex].shape[0]}; expected  ${batchSize} based on input ${model2.inputNames[0]}.`);
      }
      return {xs: flattenedXs, ys: flattenedYs};
    }
    function flattenTensorOrArrayOrMap(inputOrOutput, names, values) {
      if (values instanceof Tensor2) {
        return [values];
      } else if (Array.isArray(values)) {
        assert2(values.length === names.length, () => `Received an array of ${values.length} Tensors, but expected ${names.length} to match the ${inputOrOutput} keys ${names}.`);
        return values;
      } else {
        const result = [];
        for (const name of names) {
          if (values[name] == null) {
            throw new ValueError(`The feature data generated by the dataset lacks the required ${inputOrOutput} key '${name}'.`);
          }
          result.push(values[name]);
        }
        return result;
      }
    }
    function standardizeTensorValidationData(data2) {
      if (data2.length === 3) {
        throw new NotImplementedError("Validation with sample weights is not implemented yet.");
      }
      return {xs: data2[0], ys: data2[1]};
    }
    async function fitDataset(model2, dataset, args) {
      const hasBatchesPerEpoch = args.batchesPerEpoch != null;
      assert2(model2.optimizer != null, () => "You must compile a model before training/testing. Use LayersModel.compile(modelCompileConfig).");
      assert2(args != null, () => `For fitDataset(), the 2nd argument (config) is required, but it is not provided in this call.`);
      assert2(args.epochs != null && args.epochs > 0 && Number.isInteger(args.epochs), () => `For fitDataset(), config.epochs is expected to be a positive integer, but got ${args.epochs}`);
      assert2(!hasBatchesPerEpoch || args.batchesPerEpoch > 0 && Number.isInteger(args.batchesPerEpoch), () => `For fitDataset(), config.batchesPerEpoch is expected to be a positive integer if specified, but got ${args.batchesPerEpoch}`);
      assert2(args["validationSplit"] == null, () => "`validationSplit` is not supported by `fitDataset()`. Use validationData instead.");
      if (model2.isTraining) {
        throw new Error("Cannot start training because another fit() call is ongoing.");
      }
      model2.isTraining = true;
      try {
        const doValidation = args.validationData != null;
        let valXs;
        let valYs;
        if (doValidation) {
          if (isDatasetObject(args.validationData)) {
            assert2(args.validationBatches == null || args.validationBatches > 0 && Number.isInteger(args.validationBatches), () => `For fitDataset() with dataset-based validation, config.validationBatches is expected not to be provided, or to be a positive integer, but got ${args.validationBatches}`);
          } else {
            const validationData = standardizeTensorValidationData(args.validationData);
            valXs = validationData.xs;
            valYs = validationData.ys;
          }
        }
        const trainFunction = model2.makeTrainFunction();
        const outLabels = model2.getDedupedMetricsNames();
        let callbackMetrics;
        if (doValidation) {
          callbackMetrics = outLabels.slice().concat(outLabels.map((n) => "val_" + n));
        } else {
          callbackMetrics = outLabels.slice();
        }
        const callbacks2 = standardizeCallbacks(args.callbacks, args.yieldEvery);
        const verbose = args.verbose == null ? 1 : args.verbose;
        const {callbackList, history} = configureCallbacks(callbacks2, verbose, args.epochs, null, null, getStepsPerEpoch(dataset, args), null, doValidation, callbackMetrics);
        callbackList.setModel(model2);
        model2.history = history;
        await callbackList.onTrainBegin();
        model2.stopTraining_ = false;
        let epoch = args.initialEpoch == null ? 0 : args.initialEpoch;
        let dataIterator = await dataset.iterator();
        while (epoch < args.epochs) {
          const epochLogs = {};
          await callbackList.onEpochBegin(epoch);
          let stepsDone = 0;
          let batchIndex = 0;
          if (!hasBatchesPerEpoch) {
            dataIterator = await dataset.iterator();
          }
          while (hasBatchesPerEpoch ? stepsDone < args.batchesPerEpoch : true) {
            const iteratorOut = await dataIterator.next();
            if (hasBatchesPerEpoch && iteratorOut.done) {
              console.warn(`You provided \`batchesPerEpoch\` as ${args.batchesPerEpoch}, but your dataset iterator ran out of data after ${stepsDone} batches; interrupting training. Make sure that your dataset can generate at least \`batchesPerEpoch * epochs\` batches (in this case, ${args.batchesPerEpoch * args.epochs} batches). You may need to use the repeat() function when building your dataset.`);
              break;
            }
            if (iteratorOut.value != null) {
              const {xs, ys} = standardizeDataIteratorOutput(model2, iteratorOut.value);
              const batchLogs = {};
              batchLogs["batch"] = batchIndex;
              batchLogs["size"] = xs[0].shape[0];
              await callbackList.onBatchBegin(batchIndex, batchLogs);
              const sampleWeights = [];
              if (args.classWeight != null) {
                const standardClassWeights = standardizeClassWeights(args.classWeight, model2.outputNames);
                for (let i = 0; i < standardClassWeights.length; ++i) {
                  sampleWeights.push(await standardizeWeights(ys[i], null, standardClassWeights[i]));
                }
              }
              const ins = xs.concat(ys).concat(sampleWeights);
              const outs = trainFunction(ins);
              dispose(ins);
              for (let i = 0; i < outLabels.length; ++i) {
                const label = outLabels[i];
                const out = outs[i];
                batchLogs[label] = out;
                keep(out);
              }
              await callbackList.onBatchEnd(batchIndex, batchLogs);
              disposeTensorsInLogs(batchLogs);
              batchIndex++;
              stepsDone++;
            }
            if (hasBatchesPerEpoch ? stepsDone >= args.batchesPerEpoch : iteratorOut.done) {
              if (doValidation) {
                let valOuts;
                if (isDatasetObject(args.validationData)) {
                  valOuts = toList(await model2.evaluateDataset(args.validationData, {batches: args.validationBatches}));
                } else {
                  valOuts = toList(model2.evaluate(valXs, valYs, {
                    batchSize: args.validationBatchSize == null ? DEFAULT_VALIDATION_BATCH_SIZE : args.validationBatchSize,
                    verbose: 0
                  }));
                }
                for (let i = 0; i < model2.metricsNames.length; ++i) {
                  epochLogs[`val_${model2.metricsNames[i]}`] = valOuts[i];
                }
              }
              break;
            }
            if (model2.stopTraining_) {
              break;
            }
          }
          await callbackList.onEpochEnd(epoch, epochLogs);
          epoch++;
          if (model2.stopTraining_) {
            break;
          }
        }
        await callbackList.onTrainEnd();
        await model2.history.syncData();
        return model2.history;
      } finally {
        model2.isTraining = false;
      }
    }
    function getStepsPerEpoch(dataset, args) {
      let stepsPerEpoch = null;
      if (args.batchesPerEpoch != null) {
        stepsPerEpoch = args.batchesPerEpoch;
      } else if (Number.isFinite(dataset.size)) {
        stepsPerEpoch = dataset.size;
      }
      return stepsPerEpoch;
    }
    function isDatasetObject(dataset) {
      return typeof dataset.iterator === "function";
    }
    function isLazyIteratorObject(iterator) {
      return typeof iterator.next === "function";
    }
    async function evaluateDataset(model2, dataset, args) {
      args = args || {};
      const hasBatches = args.batches != null;
      const f = model2.testFunction;
      let outs = [];
      if (args.verbose > 0) {
        throw new NotImplementedError("Verbose mode is not implemented yet.");
      }
      assert2(!hasBatches || args.batches > 0 && Number.isInteger(args.batches), () => `Test loop expects \`batches\` to be a positive integer, but received ${JSON.stringify(args.batches)}`);
      const dataIterator = isLazyIteratorObject(dataset) ? dataset : await dataset.iterator();
      let numExamples = 0;
      let batch = 0;
      while (hasBatches ? batch < args.batches : true) {
        const iteratorOut = await dataIterator.next();
        outs = tidy(() => {
          if (iteratorOut.value) {
            const {xs, ys} = standardizeDataIteratorOutput(model2, iteratorOut.value);
            const xsAndYs = xs.concat(ys);
            const batchOuts = tidy(() => f(xsAndYs));
            dispose(xsAndYs);
            if (batch === 0) {
              for (let i = 0; i < batchOuts.length; ++i) {
                outs.push(scalar3(0));
              }
            }
            const batchSize = xsAndYs[0].shape[0];
            for (let i = 0; i < batchOuts.length; ++i) {
              const batchOut = batchOuts[i];
              const oldScalar = outs[i];
              outs[i] = tidy(() => add$1(outs[i], mul3(batchSize, batchOut)));
              if (batch > 0) {
                dispose(oldScalar);
              }
            }
            dispose(batchOuts);
            numExamples += batchSize;
            ++batch;
          }
          return outs;
        });
        if (iteratorOut.done) {
          if (hasBatches) {
            console.warn(`Your dataset iterator ran out of data during evaluateDataset(). Interrupting evalution. Make sure that your dataset can generate at least \`batches\` batches (in this case, ${args.batches} batches). You may need to use the repeat() function when building your dataset.`);
          }
          break;
        }
      }
      for (let i = 0; i < outs.length; ++i) {
        const oldScalar = outs[i];
        outs[i] = div(outs[i], numExamples);
        dispose(oldScalar);
      }
      return singletonOrArray(outs);
    }
    /**
     * @license
     * Copyright 2018 Google LLC
     *
     * Use of this source code is governed by an MIT-style
     * license that can be found in the LICENSE file or at
     * https://opensource.org/licenses/MIT.
     * =============================================================================
     */
    function checkBatchSize(batchSize) {
      assert2(batchSize > 0 && Number.isInteger(batchSize), () => `batchSize is required to be a positive integer, but got ${batchSize}`);
    }
    function sliceArrays(arrays, start, stop) {
      if (arrays == null) {
        return [null];
      } else if (Array.isArray(arrays)) {
        return arrays.map((array2) => sliceAlongFirstAxis(array2, start, stop - start));
      } else {
        return sliceAlongFirstAxis(arrays, start, stop - start);
      }
    }
    function sliceArraysByIndices(arrays, indices) {
      return tidy(() => {
        if (arrays == null) {
          return null;
        } else if (Array.isArray(arrays)) {
          return arrays.map((array2) => sliceArraysByIndices(array2, indices));
        } else {
          return gather$1(arrays, indices.dtype === "int32" ? indices : indices.toInt());
        }
      });
    }
    function makeBatches(size, batchSize) {
      const output = [];
      let batchStart = 0;
      let batchEnd = null;
      while (batchStart < size) {
        batchEnd = batchStart + batchSize;
        if (batchEnd >= size) {
          batchEnd = size;
        }
        output.push([batchStart, batchEnd]);
        batchStart = batchEnd;
      }
      return output;
    }
    async function fitLoop(model2, f, ins, outLabels, batchSize, epochs, verbose, callbacks2, valF, valIns, shuffle$1, callbackMetrics, initialEpoch, stepsPerEpoch, validationSteps) {
      if (batchSize == null) {
        batchSize = 32;
      }
      if (epochs == null) {
        epochs = 1;
      }
      if (shuffle$1 == null) {
        shuffle$1 = true;
      }
      if (initialEpoch == null) {
        initialEpoch = 0;
      }
      let doValidation = false;
      if (valF != null && valIns != null) {
        doValidation = true;
      }
      if (validationSteps != null) {
        doValidation = true;
        if (stepsPerEpoch == null) {
          throw new ValueError("Can only use `validationSteps` when doing step-wise training, i.e., `stepsPerEpoch` must be set.");
        }
      }
      const numTrainSamples = model2.checkNumSamples(ins, batchSize, stepsPerEpoch, "steps_per_epoch");
      let indexArray;
      if (numTrainSamples != null) {
        indexArray = range$1(0, numTrainSamples);
      }
      if (verbose == null) {
        verbose = 1;
      }
      const {callbackList, history} = configureCallbacks(callbacks2, verbose, epochs, initialEpoch, numTrainSamples, stepsPerEpoch, batchSize, doValidation, callbackMetrics);
      callbackList.setModel(model2);
      model2.history = history;
      await callbackList.onTrainBegin();
      model2.stopTraining_ = false;
      for (let epoch = initialEpoch; epoch < epochs; ++epoch) {
        await callbackList.onEpochBegin(epoch);
        const epochLogs = {};
        if (stepsPerEpoch != null) {
          throw new NotImplementedError("stepsPerEpoch mode is not implemented yet.");
        } else {
          if (shuffle$1 === "batch") {
            throw new NotImplementedError("batch shuffling is not implemneted yet");
          } else if (shuffle$1) {
            shuffle2(indexArray);
          }
          const epochIndexArray1D = tensor1d3(indexArray);
          const batches = makeBatches(numTrainSamples, batchSize);
          for (let batchIndex = 0; batchIndex < batches.length; ++batchIndex) {
            const batchLogs = {};
            await callbackList.onBatchBegin(batchIndex, batchLogs);
            tidy(() => {
              const batchStart = batches[batchIndex][0];
              const batchEnd = batches[batchIndex][1];
              const batchIds = sliceAlongFirstAxis(epochIndexArray1D, batchStart, batchEnd - batchStart);
              batchLogs["batch"] = batchIndex;
              batchLogs["size"] = batchEnd - batchStart;
              const insBatch = sliceArraysByIndices(ins, batchIds);
              const outs = f(insBatch);
              for (let i = 0; i < outLabels.length; ++i) {
                const label = outLabels[i];
                const out = outs[i];
                batchLogs[label] = out;
                keep(out);
              }
              if (batchIndex === batches.length - 1) {
                if (doValidation) {
                  const valOuts = model2.testLoop(valF, valIns, batchSize);
                  for (let i = 0; i < outLabels.length; ++i) {
                    const label = outLabels[i];
                    const out = valOuts[i];
                    keep(out);
                    epochLogs["val_" + label] = out;
                  }
                }
              }
            });
            await callbackList.onBatchEnd(batchIndex, batchLogs);
            disposeTensorsInLogs(batchLogs);
            if (model2.stopTraining_) {
              break;
            }
          }
          epochIndexArray1D.dispose();
        }
        await callbackList.onEpochEnd(epoch, epochLogs);
        if (model2.stopTraining_) {
          break;
        }
      }
      await callbackList.onTrainEnd();
      await model2.history.syncData();
      return model2.history;
    }
    async function fitTensors(model2, x, y, args = {}) {
      if (model2.isTraining) {
        throw new Error("Cannot start training because another fit() call is ongoing.");
      }
      model2.isTraining = true;
      let inputs;
      let targets;
      let inputValX;
      let inputValY;
      let valX;
      let valY;
      let sampleWeights;
      try {
        const batchSize = args.batchSize == null ? 32 : args.batchSize;
        checkBatchSize(batchSize);
        const checkBatchAxis = false;
        const standardizedOuts = await model2.standardizeUserData(x, y, args.sampleWeight, args.classWeight, checkBatchAxis, batchSize);
        inputs = standardizedOuts[0];
        targets = standardizedOuts[1];
        sampleWeights = standardizedOuts[2];
        let doValidation = false;
        let valIns;
        if (args.validationData != null && args.validationData.length > 0) {
          doValidation = true;
          if (args.validationData.length === 2) {
            inputValX = args.validationData[0];
            inputValY = args.validationData[1];
          } else if (args.validationData.length === 3) {
            throw new NotImplementedError("validationData including sample weights is not supported yet.");
          } else {
            throw new ValueError(`When passing validation data, it must contain 2 (valX, valY) or 3 (valX, valY, valSampleWeight) items; ${args.validationData} is invalid.`);
          }
          const checkBatchAxis2 = true;
          const valStandardized = await model2.standardizeUserData(inputValX, inputValY, null, null, checkBatchAxis2, batchSize);
          valX = valStandardized[0];
          valY = valStandardized[1];
          valIns = valX.concat(valY);
        } else if (args.validationSplit != null && args.validationSplit > 0 && args.validationSplit < 1) {
          doValidation = true;
          const splitAt = Math.floor(inputs[0].shape[0] * (1 - args.validationSplit));
          const originalBatchSize = inputs[0].shape[0];
          valX = sliceArrays(inputs, splitAt, originalBatchSize);
          inputs = sliceArrays(inputs, 0, splitAt);
          valY = sliceArrays(targets, splitAt, originalBatchSize);
          targets = sliceArrays(targets, 0, splitAt);
          valIns = valX.concat(valY);
        } else if (args.validationSteps != null) {
          doValidation = true;
        }
        const ins = inputs.concat(targets).concat(sampleWeights);
        model2.checkTrainableWeightsConsistency();
        const trainFunction = model2.makeTrainFunction();
        const outLabels = model2.getDedupedMetricsNames();
        let valFunction;
        let callbackMetrics;
        if (doValidation) {
          model2.makeTestFunction();
          valFunction = model2.testFunction;
          callbackMetrics = outLabels.slice().concat(outLabels.map((n) => "val_" + n));
        } else {
          valFunction = null;
          valIns = [];
          callbackMetrics = outLabels.slice();
        }
        const callbacks2 = standardizeCallbacks(args.callbacks, args.yieldEvery);
        const out = await fitLoop(model2, trainFunction, ins, outLabels, batchSize, args.epochs, args.verbose, callbacks2, valFunction, valIns, args.shuffle, callbackMetrics, args.initialEpoch, null, null);
        return out;
      } finally {
        model2.isTraining = false;
        disposeNewTensors(inputs, x);
        disposeNewTensors(targets, y);
        disposeNewTensors(valX, inputValX);
        disposeNewTensors(valY, inputValY);
        if (sampleWeights != null) {
          dispose(sampleWeights);
        }
      }
    }
    function ensureTensorsRank2OrHigher(tensors) {
      const outs = [];
      if (tensors instanceof Tensor2) {
        tensors = [tensors];
      }
      for (let i = 0; i < tensors.length; ++i) {
        const tensor7 = tensors[i];
        if (tensor7.rank === 1) {
          outs.push(expandDims$1(tensor7, 1));
        } else if (tensor7.rank === 0) {
          throw new Error("Expected tensor to be at least 1D, but received a 0D tensor (scalar).");
        } else {
          outs.push(tensor7);
        }
      }
      return outs;
    }
    function disposeNewTensors(tensors, refTensors) {
      if (tensors == null) {
        return;
      }
      const oldTensorIds = [];
      if (refTensors instanceof Tensor2) {
        oldTensorIds.push(refTensors.id);
      } else if (Array.isArray(refTensors)) {
        refTensors.forEach((t) => oldTensorIds.push(t.id));
      } else if (refTensors != null) {
        for (const name in refTensors) {
          const oldTensor = refTensors[name];
          oldTensorIds.push(oldTensor.id);
        }
      }
      const tensorsToDispose = [];
      if (tensors instanceof Tensor2) {
        if (oldTensorIds.indexOf(tensors.id) === -1) {
          tensorsToDispose.push(tensors);
        }
      } else if (Array.isArray(tensors)) {
        tensors.forEach((t) => {
          if (oldTensorIds.indexOf(t.id) === -1) {
            tensorsToDispose.push(t);
          }
        });
      } else if (tensors != null) {
        for (const name in tensors) {
          const tensor7 = tensors[name];
          if (oldTensorIds.indexOf(tensor7.id) === -1) {
            tensorsToDispose.push(tensor7);
          }
        }
      }
      tensorsToDispose.forEach((t) => {
        if (!t.isDisposed) {
          t.dispose();
        }
      });
    }
    /**
     * @license
     * Copyright 2018 Google LLC
     *
     * Use of this source code is governed by an MIT-style
     * license that can be found in the LICENSE file or at
     * https://opensource.org/licenses/MIT.
     * =============================================================================
     */
    function isDataTensor(x) {
      return x instanceof Tensor2;
    }
    function isDataArray(x) {
      return Array.isArray(x);
    }
    function isDataDict(x) {
      return !isDataTensor(x) && !isDataArray(x);
    }
    function standardizeInputData(data2, names, shapes, checkBatchAxis = true, exceptionPrefix = "") {
      if (names == null || names.length === 0) {
        if (data2 != null) {
          let gotUnexpectedData = false;
          if (isDataArray(data2) && data2.length > 0) {
            gotUnexpectedData = true;
          } else if (isDataDict(data2)) {
            for (const key in data2) {
              if (data2.hasOwnProperty(key)) {
                gotUnexpectedData = true;
                break;
              }
            }
          } else {
            gotUnexpectedData = true;
          }
          if (gotUnexpectedData) {
            throw new ValueError(`Error when checking model ${exceptionPrefix} expected no data, but got ${data2}`);
          }
        }
        return [];
      }
      if (data2 == null) {
        return names.map((name) => null);
      }
      let arrays;
      if (isDataDict(data2)) {
        data2 = data2;
        arrays = [];
        for (const name of names) {
          if (data2[name] == null) {
            throw new ValueError(`No data provided for "${name}". Need data for each key in: ${names}`);
          }
          arrays.push(data2[name]);
        }
      } else if (isDataArray(data2)) {
        data2 = data2;
        if (data2.length !== names.length) {
          throw new ValueError(`Error when checking model ${exceptionPrefix}: the Array of Tensors that you are passing to your model is not the size the model expected. Expected to see ${names.length} Tensor(s), but instead got the following list of Tensor(s): ${data2}`);
        }
        arrays = data2;
      } else {
        data2 = data2;
        if (names.length > 1) {
          throw new ValueError(`The model ${exceptionPrefix} expects ${names.length} Tensor(s), but only received one Tensor. Found: Tensor with shape ${data2.shape}`);
        }
        arrays = [data2];
      }
      arrays = ensureTensorsRank2OrHigher(arrays);
      if (shapes != null) {
        for (let i = 0; i < names.length; ++i) {
          if (shapes[i] == null) {
            continue;
          }
          const array2 = arrays[i];
          if (array2.shape.length !== shapes[i].length) {
            throw new ValueError(`Error when checking ${exceptionPrefix}: expected ${names[i]} to have ${shapes[i].length} dimension(s). but got array with shape ${array2.shape}`);
          }
          for (let j = 0; j < shapes[i].length; ++j) {
            if (j === 0 && !checkBatchAxis) {
              continue;
            }
            const dim = array2.shape[j];
            const refDim = shapes[i][j];
            if (refDim != null && refDim >= 0 && dim !== refDim) {
              throw new ValueError(`Error when checking ${exceptionPrefix}: expected ${names[i]} to have shape [${shapes[i]}], but got array with shape [${array2.shape}].`);
            }
          }
        }
      }
      return arrays;
    }
    function checkArrayLengths(inputs, targets, weights) {
      const setX = unique$1(inputs.map((input2) => input2.shape[0]));
      setX.sort();
      const setY = unique$1(targets.map((target) => target.shape[0]));
      setY.sort();
      if (setX.length > 1) {
        throw new ValueError(`All input Tensors (x) should have the same number of samples. Got array shapes: ${JSON.stringify(inputs.map((input2) => input2.shape))}`);
      }
      if (setY.length > 1) {
        throw new ValueError(`All target Tensors (y) should have the same number of samples. Got array shapes: ${JSON.stringify(targets.map((target) => target.shape))}`);
      }
      if (setX.length > 0 && setY.length > 0 && !arraysEqual2(setX, setY)) {
        throw new ValueError(`Input Tensors should have the same number of samples as target Tensors. Found ${setX[0]} input sample(s) and ${setY[0]} target sample(s).`);
      }
    }
    function checkLossAndTargetCompatibility(targets, lossFns, outputShapes) {
      const keyLosses = [
        meanSquaredError$1,
        binaryCrossentropy,
        categoricalCrossentropy
      ];
      for (let i = 0; i < targets.length; ++i) {
        const y = targets[i];
        const loss = lossFns[i];
        const shape = outputShapes[i];
        if (loss == null) {
          continue;
        }
        if (loss === categoricalCrossentropy) {
          if (y.shape[y.shape.length - 1] === 1) {
            throw new ValueError(`You are passing a target array of shape ${y.shape} while using a loss 'categorical_crossentropy'. 'categorical_crossentropy'expects targets to be binary matrices (1s and 0s) of shape [samples, classes].`);
          }
        }
        if (keyLosses.indexOf(loss) !== -1) {
          const slicedYShape = y.shape.slice(1);
          const slicedShape = shape.slice(1);
          for (let j = 0; j < slicedYShape.length; ++j) {
            const targetDim = slicedYShape[j];
            const outDim = slicedShape[j];
            if (outDim != null && targetDim !== outDim) {
              throw new ValueError(`A target Tensor with shape ${y.shape} was passed for an output of shape ${shape}, while using a loss function that expects targets to have the same shape as the output.`);
            }
          }
        }
      }
    }
    function checkInputData(data2, names, shapes, checkBatchAxis = true, exceptionPrefix = "") {
      let arrays;
      if (Array.isArray(data2)) {
        if (data2.length !== names.length) {
          throw new ValueError(`Error when checking model ${exceptionPrefix}: the Array of Tensors that you are passing to your model is not the size the the model expected. Expected to see ${names.length} Tensor(s), but instead got ${data2.length} Tensors(s).`);
        }
        arrays = data2;
      } else {
        if (names.length > 1) {
          throw new ValueError(`The model expects ${names.length} ${exceptionPrefix} Tensors, but only received one Tensor. Found: array with shape ${JSON.stringify(data2.shape)}.`);
        }
        arrays = [data2];
      }
      if (shapes != null) {
        for (let i = 0; i < names.length; ++i) {
          if (shapes[i] == null) {
            continue;
          }
          const array2 = arrays[i];
          if (array2.shape.length !== shapes[i].length) {
            throw new ValueError(`Error when checking ${exceptionPrefix}: expected ${names[i]} to have ${shapes[i].length} dimension(s), but got array with shape ${JSON.stringify(array2.shape)}`);
          }
          for (let j = 0; j < shapes[i].length; ++j) {
            if (j === 0 && !checkBatchAxis) {
              continue;
            }
            const dim = array2.shape[j];
            const refDim = shapes[i][j];
            if (refDim != null) {
              if (refDim !== dim) {
                throw new ValueError(`Error when checking ${exceptionPrefix}: expected ${names[i]} to have shape ${JSON.stringify(shapes[i])} but got array with shape ${JSON.stringify(array2.shape)}.`);
              }
            }
          }
        }
      }
    }
    function collectMetrics(metrics, outputNames) {
      if (metrics == null || Array.isArray(metrics) && metrics.length === 0) {
        return outputNames.map((name) => []);
      }
      let wrappedMetrics;
      if (typeof metrics === "string" || typeof metrics === "function") {
        wrappedMetrics = [metrics];
      } else if (Array.isArray(metrics) || typeof metrics === "object") {
        wrappedMetrics = metrics;
      } else {
        throw new TypeError(`Type of metrics argument not understood. Expected an string,function, Array, or Object, found: ${metrics}`);
      }
      if (Array.isArray(wrappedMetrics)) {
        return outputNames.map((name) => wrappedMetrics);
      } else {
        const nestedMetrics = [];
        for (const name of outputNames) {
          let outputMetrics = wrappedMetrics.hasOwnProperty(name) ? wrappedMetrics[name] : [];
          if (!Array.isArray(outputMetrics)) {
            outputMetrics = [outputMetrics];
          }
          nestedMetrics.push(outputMetrics);
        }
        return nestedMetrics;
      }
    }
    const LAYERS_MODEL_FORMAT_NAME = "layers-model";
    class LayersModel extends Container {
      constructor(args) {
        super(args);
        this.isTraining = false;
      }
      summary(lineLength, positions, printFn = console.log) {
        if (!this.built) {
          throw new ValueError(`This model has never been called, thus its weights have not been created yet. So no summary can be displayed. Build the model first (e.g., by calling it on some test data).`);
        }
        printSummary(this, lineLength, positions, printFn);
      }
      compile(args) {
        if (args.loss == null) {
          args.loss = [];
        }
        this.loss = args.loss;
        if (typeof args.optimizer === "string") {
          this.optimizer_ = getOptimizer(args.optimizer);
          this.isOptimizerOwned = true;
        } else {
          if (!(args.optimizer instanceof Optimizer)) {
            throw new ValueError(`User-defined optimizer must be an instance of tf.Optimizer.`);
          }
          this.optimizer_ = args.optimizer;
          this.isOptimizerOwned = false;
        }
        let lossFunctions = [];
        if (!Array.isArray(args.loss) && typeof args.loss !== "string" && typeof args.loss !== "function") {
          args.loss = args.loss;
          for (const name in args.loss) {
            if (this.outputNames.indexOf(name) === -1) {
              throw new ValueError(`Unknown entry in loss dictionary: "${name}". Only expected the following keys: ${this.outputNames}`);
            }
          }
          for (const name of this.outputNames) {
            if (args.loss[name] == null) {
              console.warn(`Output "${name}" is missing from loss dictionary. We assume this was done on purpose, and we will not be expecting data to be passed to ${name} during training`);
            }
            lossFunctions.push(get(args.loss[name]));
          }
        } else if (Array.isArray(args.loss)) {
          if (args.loss.length !== this.outputs.length) {
            throw new ValueError(`When passing an Array as loss, it should have one entry per model output. The model has ${this.outputs.length} output(s), but you passed loss=${args.loss}.`);
          }
          const theLosses = args.loss;
          lossFunctions = theLosses.map((l) => get(l));
        } else {
          const lossFunction = get(args.loss);
          this.outputs.forEach((_) => {
            lossFunctions.push(lossFunction);
          });
        }
        this.lossFunctions = lossFunctions;
        this.feedOutputNames = [];
        this.feedOutputShapes = [];
        this.feedLossFns = [];
        for (let i = 0; i < this.outputs.length; ++i) {
          const shape = this.internalOutputShapes[i];
          const name = this.outputNames[i];
          this.feedOutputNames.push(name);
          this.feedOutputShapes.push(shape);
          this.feedLossFns.push(this.lossFunctions[i]);
        }
        const skipTargetIndices = [];
        this.metrics = args.metrics;
        this.metricsNames = ["loss"];
        this.metricsTensors = [];
        nameScope("loss", () => {
          for (let i = 0; i < this.outputs.length; ++i) {
            if (skipTargetIndices.indexOf(i) !== -1) {
              continue;
            }
            const weightedLoss = this.lossFunctions[i];
            if (this.outputs.length > 1) {
              this.metricsTensors.push([weightedLoss, i]);
              this.metricsNames.push(this.outputNames[i] + "_loss");
            }
          }
        });
        const nestedMetrics = collectMetrics(args.metrics, this.outputNames);
        const appendMetric = (outputIndex, metricName, metricTensor) => {
          if (this.outputNames.length > 1) {
            metricName = this.outputNames[outputIndex] + "_" + metricName;
          }
          this.metricsNames.push(metricName);
          this.metricsTensors.push([metricTensor, outputIndex]);
        };
        nameScope("metric", () => {
          for (let i = 0; i < this.outputs.length; ++i) {
            if (skipTargetIndices.indexOf(i) !== -1) {
              continue;
            }
            const outputMetrics = nestedMetrics[i];
            const handleMetrics = (metrics) => {
              const metricNamePrefix = "";
              let metricName;
              let accFn;
              let weightedMetricFn;
              for (const metric of metrics) {
                if (typeof metric === "string" && ["accuracy", "acc", "crossentropy", "ce"].indexOf(metric) !== -1) {
                  const outputShape = this.internalOutputShapes[i];
                  if (outputShape[outputShape.length - 1] === 1 || this.lossFunctions[i] === binaryCrossentropy) {
                    if (["accuracy", "acc"].indexOf(metric) !== -1) {
                      accFn = binaryAccuracy;
                    } else if (["crossentropy", "ce"].indexOf(metric) !== -1) {
                      accFn = binaryCrossentropy$1;
                    }
                  } else if (this.lossFunctions[i] === sparseCategoricalCrossentropy) {
                    if (["accuracy", "acc"].indexOf(metric) !== -1) {
                      accFn = sparseCategoricalAccuracy;
                    } else if (["crossentropy", "ce"].indexOf(metric) !== -1) {
                      accFn = sparseCategoricalCrossentropy$1;
                    }
                  } else {
                    if (["accuracy", "acc"].indexOf(metric) !== -1) {
                      accFn = categoricalAccuracy;
                    } else if (["crossentropy", "ce"].indexOf(metric) !== -1) {
                      accFn = categoricalCrossentropy$1;
                    }
                  }
                  let suffix;
                  if (["accuracy", "acc"].indexOf(metric) !== -1) {
                    suffix = "acc";
                  } else if (["crossentropy", "ce"].indexOf(metric) !== -1) {
                    suffix = "ce";
                  }
                  weightedMetricFn = accFn;
                  metricName = metricNamePrefix + suffix;
                } else {
                  const metricFn = get$1(metric);
                  weightedMetricFn = metricFn;
                  metricName = metricNamePrefix + getLossOrMetricName(metric);
                }
                let metricResult;
                nameScope(metricName, () => {
                  metricResult = weightedMetricFn;
                });
                appendMetric(i, metricName, metricResult);
              }
            };
            handleMetrics(outputMetrics);
          }
        });
        this.collectedTrainableWeights = this.trainableWeights;
      }
      checkTrainableWeightsConsistency() {
        if (this.collectedTrainableWeights == null) {
          return;
        }
        if (this.trainableWeights.length !== this.collectedTrainableWeights.length) {
          console.warn("Discrepancy between trainableweights and collected trainable weights. Did you set `model.trainable` without calling `model.compile()` afterwards?");
        }
      }
      evaluate(x, y, args = {}) {
        const batchSize = args.batchSize == null ? 32 : args.batchSize;
        checkBatchSize(batchSize);
        const checkBatchAxis = true;
        const standardizedOuts = this.standardizeUserDataXY(x, y, checkBatchAxis, batchSize);
        try {
          const ins = standardizedOuts[0].concat(standardizedOuts[1]);
          this.makeTestFunction();
          const f = this.testFunction;
          const testOuts = this.testLoop(f, ins, batchSize, args.verbose, args.steps);
          return singletonOrArray(testOuts);
        } finally {
          disposeNewTensors(standardizedOuts[0], x);
          disposeNewTensors(standardizedOuts[1], y);
        }
      }
      async evaluateDataset(dataset, args) {
        this.makeTestFunction();
        return evaluateDataset(this, dataset, args);
      }
      checkNumSamples(ins, batchSize, steps, stepsName = "steps") {
        let numSamples;
        if (steps != null) {
          numSamples = null;
          if (batchSize != null) {
            throw new ValueError(`If ${stepsName} is set, batchSize must be null or undefined.Got batchSize = ${batchSize}`);
          }
        } else if (ins != null) {
          if (Array.isArray(ins)) {
            numSamples = ins[0].shape[0];
          } else {
            numSamples = ins.shape[0];
          }
        } else {
          throw new ValueError(`Either the input data should have a defined shape, or ${stepsName} shoud be specified.`);
        }
        return numSamples;
      }
      execute(inputs, outputs) {
        if (Array.isArray(outputs) && outputs.length === 0) {
          throw new ValueError("`outputs` is an empty Array, which is not allowed.");
        }
        const outputsIsArray = Array.isArray(outputs);
        const outputNames = outputsIsArray ? outputs : [outputs];
        const outputSymbolicTensors = this.retrieveSymbolicTensors(outputNames);
        const feedDict = new FeedDict();
        if (inputs instanceof Tensor2) {
          inputs = [inputs];
        }
        if (Array.isArray(inputs)) {
          if (inputs.length !== this.inputs.length) {
            throw new ValueError(`The number of inputs provided (${inputs.length}) does not match the number of inputs of this model (${this.inputs.length}).`);
          }
          for (let i = 0; i < this.inputs.length; ++i) {
            feedDict.add(this.inputs[i], inputs[i]);
          }
        } else {
          for (const input2 of this.inputs) {
            const tensorValue = inputs[input2.name];
            if (tensorValue == null) {
              throw new ValueError(`No value is provided for the model's input ${input2.name}`);
            }
            feedDict.add(input2, tensorValue);
          }
        }
        const executeOutputs = execute(outputSymbolicTensors, feedDict);
        return outputsIsArray ? executeOutputs : executeOutputs[0];
      }
      retrieveSymbolicTensors(symbolicTensorNames) {
        const outputSymbolicTensors = pyListRepeat(null, symbolicTensorNames.length);
        let outputsRemaining = symbolicTensorNames.length;
        for (const layer of this.layers) {
          const layerOutputs = Array.isArray(layer.output) ? layer.output : [layer.output];
          const layerOutputNames = layerOutputs.map((output) => output.name);
          for (let i = 0; i < symbolicTensorNames.length; ++i) {
            const index2 = layerOutputNames.indexOf(symbolicTensorNames[i]);
            if (index2 !== -1) {
              outputSymbolicTensors[i] = layerOutputs[index2];
              outputsRemaining--;
            }
            if (outputsRemaining === 0) {
              break;
            }
          }
          if (outputsRemaining === 0) {
            break;
          }
        }
        if (outputsRemaining > 0) {
          const remainingNames = [];
          outputSymbolicTensors.forEach((tensor7, i) => {
            if (tensor7 == null) {
              remainingNames.push(symbolicTensorNames[i]);
            }
          });
          throw new ValueError(`Cannot find SymbolicTensors for output name(s): ${JSON.stringify(remainingNames)}`);
        }
        return outputSymbolicTensors;
      }
      predictLoop(ins, batchSize = 32, verbose = false) {
        return tidy(() => {
          const numSamples = this.checkNumSamples(ins);
          if (verbose) {
            throw new NotImplementedError("Verbose predictLoop() is not implemented yet.");
          }
          const batches = makeBatches(numSamples, batchSize);
          const outsBatches = this.outputs.map((output) => []);
          for (let batchIndex = 0; batchIndex < batches.length; ++batchIndex) {
            const batchOuts = tidy(() => {
              const batchStart = batches[batchIndex][0];
              const batchEnd = batches[batchIndex][1];
              const insBatch = sliceArrays(ins, batchStart, batchEnd);
              const feeds = [];
              if (Array.isArray(insBatch)) {
                for (let i = 0; i < insBatch.length; ++i) {
                  feeds.push({key: this.inputs[i], value: insBatch[i]});
                }
              } else {
                feeds.push({key: this.inputs[0], value: insBatch});
              }
              const feedDict = new FeedDict(feeds);
              return execute(this.outputs, feedDict);
            });
            batchOuts.forEach((batchOut, i) => outsBatches[i].push(batchOut));
          }
          return singletonOrArray(outsBatches.map((batches2) => concat2(batches2, 0)));
        });
      }
      predict(x, args = {}) {
        const xsRank2OrHigher = ensureTensorsRank2OrHigher(x);
        checkInputData(xsRank2OrHigher, this.inputNames, this.feedInputShapes, false);
        try {
          const batchSize = args.batchSize == null ? 32 : args.batchSize;
          checkBatchSize(batchSize);
          return this.predictLoop(xsRank2OrHigher, batchSize);
        } finally {
          disposeNewTensors(xsRank2OrHigher, x);
        }
      }
      predictOnBatch(x) {
        checkInputData(x, this.inputNames, this.feedInputShapes, true);
        const batchSize = (Array.isArray(x) ? x[0] : x).shape[0];
        return this.predictLoop(x, batchSize);
      }
      standardizeUserDataXY(x, y, checkBatchAxis = true, batchSize) {
        if (this.optimizer_ == null) {
          throw new RuntimeError("You must compile a model before training/testing. Use LayersModel.compile(modelCompileArgs).");
        }
        const outputShapes = [];
        for (let i = 0; i < this.feedOutputShapes.length; ++i) {
          const outputShape = this.feedOutputShapes[i];
          const lossFn = this.feedLossFns[i];
          if (lossFn === sparseCategoricalCrossentropy) {
            outputShapes.push(outputShape.slice(0, outputShape.length - 1).concat([1]));
          } else {
            outputShapes.push(outputShape);
          }
        }
        x = standardizeInputData(x, this.feedInputNames, this.feedInputShapes, false, "input");
        y = standardizeInputData(y, this.feedOutputNames, outputShapes, false, "target");
        checkArrayLengths(x, y, null);
        checkLossAndTargetCompatibility(y, this.feedLossFns, this.feedOutputShapes);
        if (this.stateful && batchSize != null && batchSize > 0) {
          if (x[0].shape[0] % batchSize !== 0) {
            throw new ValueError(`In a stateful network, you should only pass inputs with a number of samples that is divisible by the batch size ${batchSize}. Found: ${x[0].shape[0]} sample(s).`);
          }
        }
        return [x, y];
      }
      async standardizeUserData(x, y, sampleWeight, classWeight, checkBatchAxis = true, batchSize) {
        const [standardXs, standardYs] = this.standardizeUserDataXY(x, y, checkBatchAxis, batchSize);
        if (sampleWeight != null) {
          throw new Error("sample weight is not supported yet.");
        }
        let standardSampleWeights = null;
        if (classWeight != null) {
          const classWeights = standardizeClassWeights(classWeight, this.outputNames);
          standardSampleWeights = [];
          for (let i = 0; i < classWeights.length; ++i) {
            standardSampleWeights.push(await standardizeWeights(standardYs[i], null, classWeights[i]));
          }
        }
        return [standardXs, standardYs, standardSampleWeights];
      }
      testLoop(f, ins, batchSize, verbose = 0, steps) {
        return tidy(() => {
          const numSamples = this.checkNumSamples(ins, batchSize, steps, "steps");
          const outs = [];
          if (verbose > 0) {
            throw new NotImplementedError("Verbose mode is not implemented yet.");
          }
          if (steps != null) {
            throw new NotImplementedError("steps mode in testLoop() is not implemented yet");
          } else {
            const batches = makeBatches(numSamples, batchSize);
            const indexArray = tensor1d3(range$1(0, numSamples));
            for (let batchIndex = 0; batchIndex < batches.length; ++batchIndex) {
              const batchStart = batches[batchIndex][0];
              const batchEnd = batches[batchIndex][1];
              const batchIds = sliceAlongFirstAxis(indexArray, batchStart, batchEnd - batchStart);
              const insBatch = sliceArraysByIndices(ins, batchIds);
              const batchOuts = f(insBatch);
              if (batchIndex === 0) {
                for (let i = 0; i < batchOuts.length; ++i) {
                  outs.push(scalar3(0));
                }
              }
              for (let i = 0; i < batchOuts.length; ++i) {
                const batchOut = batchOuts[i];
                outs[i] = add$1(outs[i], mul3(batchEnd - batchStart, batchOut));
              }
            }
            for (let i = 0; i < outs.length; ++i) {
              outs[i] = div(outs[i], numSamples);
            }
          }
          return outs;
        });
      }
      getDedupedMetricsNames() {
        const outLabels = this.metricsNames;
        const dedupedOutLabels = [];
        for (let i = 0; i < outLabels.length; ++i) {
          const label = outLabels[i];
          let newLabel = label;
          if (count(outLabels, label) > 1) {
            const dupIndex = count(outLabels.slice(0, i), label);
            newLabel += `_${dupIndex}`;
          }
          dedupedOutLabels.push(newLabel);
        }
        return dedupedOutLabels;
      }
      makeTrainFunction() {
        return (data2) => {
          const lossValues = [];
          const inputs = data2.slice(0, this.inputs.length);
          const targets = data2.slice(this.inputs.length, this.inputs.length + this.outputs.length);
          const sampleWeights = data2.slice(this.inputs.length + this.outputs.length, this.inputs.length + this.outputs.length * 2);
          const metricsValues = [];
          const totalLossFunction = () => {
            const feeds = [];
            for (let i = 0; i < this.inputs.length; ++i) {
              feeds.push({key: this.inputs[i], value: inputs[i]});
            }
            const feedDict = new FeedDict(feeds);
            const outputs = execute(this.outputs, feedDict, {training: true});
            let totalLoss;
            for (let i = 0; i < this.lossFunctions.length; ++i) {
              const lossFunction = this.lossFunctions[i];
              let loss = lossFunction(targets[i], outputs[i]);
              if (sampleWeights[i] != null) {
                loss = computeWeightedLoss$1(loss, sampleWeights[i]);
              }
              const meanLoss = mean(loss);
              lossValues.push(meanLoss);
              if (i === 0) {
                totalLoss = loss;
              } else {
                totalLoss = add$1(totalLoss, loss);
              }
            }
            for (let i = 0; i < this.metricsTensors.length; ++i) {
              let weightedMetric;
              if (this.outputs.length > 1 && i < this.outputs.length) {
                weightedMetric = lossValues[i];
              } else {
                const metric = this.metricsTensors[i][0];
                const outputIndex = this.metricsTensors[i][1];
                weightedMetric = mean(metric(targets[outputIndex], outputs[outputIndex]));
              }
              keep(weightedMetric);
              metricsValues.push(weightedMetric);
            }
            totalLoss = mean(totalLoss);
            this.calculateLosses().forEach((regularizerLoss) => {
              totalLoss = add$1(totalLoss, regularizerLoss);
            });
            return totalLoss;
          };
          const variables = this.collectedTrainableWeights.map((param) => param.read());
          const returnCost = true;
          const totalLossValue = this.optimizer_.minimize(totalLossFunction, returnCost, variables);
          return [totalLossValue].concat(metricsValues);
        };
      }
      makeTestFunction() {
        this.testFunction = (data2) => {
          return tidy(() => {
            const valOutputs = [];
            let totalLoss;
            const inputs = data2.slice(0, this.inputs.length);
            const targets = data2.slice(this.inputs.length, this.inputs.length + this.outputs.length);
            const feeds = [];
            for (let i = 0; i < this.inputs.length; ++i) {
              feeds.push({key: this.inputs[i], value: inputs[i]});
            }
            const feedDict = new FeedDict(feeds);
            const outputs = execute(this.outputs, feedDict);
            for (let i = 0; i < this.lossFunctions.length; ++i) {
              const lossFunction = this.lossFunctions[i];
              const loss = mean(lossFunction(targets[i], outputs[i]));
              if (i === 0) {
                totalLoss = loss;
              } else {
                totalLoss = add$1(totalLoss, loss);
              }
              valOutputs.push(totalLoss);
            }
            for (let i = 0; i < this.metricsTensors.length; ++i) {
              const metric = this.metricsTensors[i][0];
              const outputIndex = this.metricsTensors[i][1];
              const meanMetric = mean(metric(targets[outputIndex], outputs[outputIndex]));
              valOutputs.push(meanMetric);
            }
            return valOutputs;
          });
        };
      }
      async fit(x, y, args = {}) {
        return fitTensors(this, x, y, args);
      }
      async fitDataset(dataset, args) {
        return fitDataset(this, dataset, args);
      }
      async trainOnBatch(x, y) {
        const standardizeOut = await this.standardizeUserData(x, y);
        const inputs = standardizeOut[0];
        const targets = standardizeOut[1];
        const trainFunction = this.makeTrainFunction();
        const losses2 = trainFunction(inputs.concat(targets));
        const lossValues = [];
        for (const loss of losses2) {
          const v = await loss.data();
          lossValues.push(v[0]);
        }
        dispose(losses2);
        return singletonOrArray(lossValues);
      }
      getNamedWeights(config2) {
        const namedWeights = [];
        const trainableOnly = config2 != null && config2.trainableOnly;
        const weights = trainableOnly ? this.trainableWeights : this.weights;
        const weightValues = this.getWeights(trainableOnly);
        for (let i = 0; i < weights.length; ++i) {
          if (trainableOnly && !weights[i].trainable) {
            continue;
          }
          namedWeights.push({name: weights[i].originalName, tensor: weightValues[i]});
        }
        return namedWeights;
      }
      set stopTraining(stop) {
        this.stopTraining_ = stop;
      }
      get stopTraining() {
        return this.stopTraining_;
      }
      get optimizer() {
        return this.optimizer_;
      }
      set optimizer(optimizer) {
        if (this.optimizer_ !== optimizer) {
          this.optimizer_ = optimizer;
          this.isOptimizerOwned = false;
        }
      }
      dispose() {
        const result = super.dispose();
        if (result.refCountAfterDispose === 0 && this.optimizer != null && this.isOptimizerOwned) {
          const numTensorsBeforeOptmizerDisposal = memory().numTensors;
          this.optimizer_.dispose();
          result.numDisposedVariables += numTensorsBeforeOptmizerDisposal - memory().numTensors;
        }
        return result;
      }
      getLossIdentifiers() {
        let lossNames;
        if (typeof this.loss === "string") {
          lossNames = toSnakeCase(this.loss);
        } else if (Array.isArray(this.loss)) {
          for (const loss of this.loss) {
            if (typeof loss !== "string") {
              throw new Error("Serialization of non-string loss is not supported.");
            }
          }
          lossNames = this.loss.map((name) => toSnakeCase(name));
        } else {
          const outputNames = Object.keys(this.loss);
          lossNames = {};
          const losses2 = this.loss;
          for (const outputName of outputNames) {
            if (typeof losses2[outputName] === "string") {
              lossNames[outputName] = toSnakeCase(losses2[outputName]);
            } else {
              throw new Error("Serialization of non-string loss is not supported.");
            }
          }
        }
        return lossNames;
      }
      getMetricIdentifiers() {
        if (typeof this.metrics === "string" || typeof this.metrics === "function") {
          return [toSnakeCase(getLossOrMetricName(this.metrics))];
        } else if (Array.isArray(this.metrics)) {
          return this.metrics.map((metric) => toSnakeCase(getLossOrMetricName(metric)));
        } else {
          const metricsIdentifiers = {};
          for (const key in this.metrics) {
            metricsIdentifiers[key] = toSnakeCase(getLossOrMetricName(this.metrics[key]));
          }
          return metricsIdentifiers;
        }
      }
      getTrainingConfig() {
        return {
          loss: this.getLossIdentifiers(),
          metrics: this.getMetricIdentifiers(),
          optimizer_config: {
            class_name: this.optimizer.getClassName(),
            config: this.optimizer.getConfig()
          }
        };
      }
      loadTrainingConfig(trainingConfig) {
        if (trainingConfig.weighted_metrics != null) {
          throw new Error("Loading weight_metrics is not supported yet.");
        }
        if (trainingConfig.loss_weights != null) {
          throw new Error("Loading loss_weights is not supported yet.");
        }
        if (trainingConfig.sample_weight_mode != null) {
          throw new Error("Loading sample_weight_mode is not supported yet.");
        }
        const tsConfig = convertPythonicToTs(trainingConfig.optimizer_config);
        const optimizer = deserialize(tsConfig);
        let loss;
        if (typeof trainingConfig.loss === "string") {
          loss = toCamelCase(trainingConfig.loss);
        } else if (Array.isArray(trainingConfig.loss)) {
          loss = trainingConfig.loss.map((lossEntry) => toCamelCase(lossEntry));
        } else if (trainingConfig.loss != null) {
          loss = {};
          for (const key in trainingConfig.loss) {
            loss[key] = toCamelCase(trainingConfig.loss[key]);
          }
        }
        let metrics;
        if (Array.isArray(trainingConfig.metrics)) {
          metrics = trainingConfig.metrics.map((metric) => toCamelCase(metric));
        } else if (trainingConfig.metrics != null) {
          metrics = {};
          for (const key in trainingConfig.metrics) {
            metrics[key] = toCamelCase(trainingConfig.metrics[key]);
          }
        }
        this.compile({loss, metrics, optimizer});
      }
      async save(handlerOrURL, config2) {
        if (typeof handlerOrURL === "string") {
          const handlers = getSaveHandlers(handlerOrURL);
          if (handlers.length === 0) {
            throw new ValueError(`Cannot find any save handlers for URL '${handlerOrURL}'`);
          } else if (handlers.length > 1) {
            throw new ValueError(`Found more than one (${handlers.length}) save handlers for URL '${handlerOrURL}'`);
          }
          handlerOrURL = handlers[0];
        }
        if (handlerOrURL.save == null) {
          throw new ValueError("LayersModel.save() cannot proceed because the IOHandler provided does not have the `save` attribute defined.");
        }
        const weightDataAndSpecs = await encodeWeights(this.getNamedWeights(config2));
        const returnString = false;
        const unusedArg = null;
        const modelConfig = this.toJSON(unusedArg, returnString);
        const modelArtifacts = {
          modelTopology: modelConfig,
          format: LAYERS_MODEL_FORMAT_NAME,
          generatedBy: `TensorFlow.js tfjs-layers v${version$1}`,
          convertedBy: null
        };
        const includeOptimizer = config2 == null ? false : config2.includeOptimizer;
        if (includeOptimizer && this.optimizer != null) {
          modelArtifacts.trainingConfig = this.getTrainingConfig();
          const weightType = "optimizer";
          const {data: optimizerWeightData, specs: optimizerWeightSpecs} = await encodeWeights(await this.optimizer.getWeights(), weightType);
          weightDataAndSpecs.specs.push(...optimizerWeightSpecs);
          weightDataAndSpecs.data = concatenateArrayBuffers([weightDataAndSpecs.data, optimizerWeightData]);
        }
        if (this.userDefinedMetadata != null) {
          const checkSize = true;
          checkUserDefinedMetadata(this.userDefinedMetadata, this.name, checkSize);
          modelArtifacts.userDefinedMetadata = this.userDefinedMetadata;
        }
        modelArtifacts.weightData = weightDataAndSpecs.data;
        modelArtifacts.weightSpecs = weightDataAndSpecs.specs;
        return handlerOrURL.save(modelArtifacts);
      }
      setUserDefinedMetadata(userDefinedMetadata) {
        checkUserDefinedMetadata(userDefinedMetadata, this.name);
        this.userDefinedMetadata = userDefinedMetadata;
      }
      getUserDefinedMetadata() {
        return this.userDefinedMetadata;
      }
    }
    LayersModel.className = "Model";
    registerClass(LayersModel);
    class Functional extends LayersModel {
    }
    Functional.className = "Functional";
    registerClass(Functional);
    /**
     * @license
     * Copyright 2018 Google LLC
     *
     * Use of this source code is governed by an MIT-style
     * license that can be found in the LICENSE file or at
     * https://opensource.org/licenses/MIT.
     * =============================================================================
     */
    async function modelFromJSON(modelAndWeightsConfig, customObjects) {
      if (!("modelTopology" in modelAndWeightsConfig)) {
        modelAndWeightsConfig = {modelTopology: modelAndWeightsConfig};
      }
      modelAndWeightsConfig = modelAndWeightsConfig;
      let modelTopology = modelAndWeightsConfig.modelTopology;
      if (modelTopology["model_config"] != null) {
        modelTopology = modelTopology["model_config"];
      }
      const tsConfig = convertPythonicToTs(modelTopology);
      const model2 = deserialize(tsConfig, customObjects);
      if (modelAndWeightsConfig.weightsManifest != null) {
        const weightValues = await loadWeights(modelAndWeightsConfig.weightsManifest, modelAndWeightsConfig.pathPrefix, model2.weights.map((weight) => weight.originalName));
        const uniqueWeightValues = {};
        for (const weight of model2.weights) {
          uniqueWeightValues[weight.originalName] = weightValues[weight.originalName];
        }
        model2.loadWeights(uniqueWeightValues);
        dispose(weightValues);
      }
      return model2;
    }
    async function loadLayersModelInternal(pathOrIOHandler, options) {
      if (options == null) {
        options = {};
      }
      if (typeof pathOrIOHandler === "string") {
        const handlers = getLoadHandlers(pathOrIOHandler, options);
        if (handlers.length === 0) {
          handlers.push(browserHTTPRequest(pathOrIOHandler, options));
        } else if (handlers.length > 1) {
          throw new ValueError(`Found more than one (${handlers.length}) load handlers for URL '${pathOrIOHandler}'`);
        }
        pathOrIOHandler = handlers[0];
      }
      return loadLayersModelFromIOHandler(pathOrIOHandler, void 0, options);
    }
    async function loadLayersModelFromIOHandler(handler, customObjects, options) {
      if (options == null) {
        options = {};
      }
      if (handler.load == null) {
        throw new ValueError("Cannot proceed with model loading because the IOHandler provided does not have the `load` method implemented.");
      }
      const artifacts = await handler.load();
      let modelTopology = artifacts.modelTopology;
      if (modelTopology["model_config"] != null) {
        modelTopology = modelTopology["model_config"];
      }
      const strict = options.strict == null ? true : options.strict;
      const fastWeightInit = artifacts.weightData != null && artifacts.weightSpecs != null && strict;
      const model2 = deserialize(convertPythonicToTs(modelTopology), customObjects, fastWeightInit);
      const trainingConfig = artifacts.trainingConfig;
      if (trainingConfig != null) {
        model2.loadTrainingConfig(trainingConfig);
      }
      if (artifacts.userDefinedMetadata != null) {
        model2.setUserDefinedMetadata(artifacts.userDefinedMetadata);
      }
      if (artifacts.weightData != null) {
        if (artifacts.weightSpecs == null) {
          throw new ValueError("LayersModel artifacts contains weight data, but not weight specs. Therefore loading of weights cannot proceed.");
        }
        const {modelWeights, optimizerWeights} = decodeModelAndOptimizerWeights(artifacts.weightData, artifacts.weightSpecs);
        model2.loadWeights(modelWeights, strict);
        if (model2.optimizer != null && optimizerWeights.length > 0) {
          await model2.optimizer.setWeights(optimizerWeights);
        }
        dispose(modelWeights);
        dispose(optimizerWeights.map((w) => w.tensor));
      }
      return model2;
    }
    function decodeModelAndOptimizerWeights(buffer3, specs) {
      const name2Tensor = decodeWeights(buffer3, specs);
      const modelWeights = {};
      const optimizerWeights = [];
      specs.forEach((spec) => {
        if (spec.group === "optimizer") {
          optimizerWeights.push({name: spec.name, tensor: name2Tensor[spec.name]});
        } else {
          modelWeights[spec.name] = name2Tensor[spec.name];
        }
      });
      return {modelWeights, optimizerWeights};
    }
    class Sequential extends LayersModel {
      constructor(args) {
        super({inputs: [], outputs: []});
        args = args || {};
        this.trainable = true;
        this.built = false;
        this.name = args.name != null ? args.name : getUid("sequential_");
        if (args.layers != null) {
          for (const layer of args.layers) {
            this.add(layer);
          }
        }
      }
      checkShape(layer) {
        const shape = layer.inboundNodes[0].outputTensors[0].shape;
        if (shape.some((x) => x < 0)) {
          throw new ValueError(`Negative dimension size caused by adding layer ${layer.name} with input shape [${layer.inboundNodes[0].inputTensors[0].shape}]`);
        }
      }
      add(layer) {
        const isLayerModelInstance = layer instanceof Sequential || layer instanceof LayersModel;
        let modelLayer;
        if (isLayerModelInstance) {
          modelLayer = layer;
          if (modelLayer.outputs.length !== 1) {
            throw new ValueError("All layers in a Sequential model should have a single output tensor. For multi-output layers, use the functional API.");
          }
          if (modelLayer.inputs.length !== 1) {
            throw new ValueError("All layers in a Sequential model should have a single input tensor. For multi-input layers, use the functional API.");
          }
        }
        if (this.outputs.length === 0) {
          if (layer.inboundNodes.length === 0) {
            if (layer.batchInputShape == null) {
              throw new ValueError("The first layer in a Sequential model must get an `inputShape` or `batchInputShape` argument.");
            }
            const x = Input({
              batchShape: layer.batchInputShape,
              dtype: layer.dtype,
              name: layer.name + "_input"
            });
            layer.apply(x);
          }
          if (isLayerModelInstance) {
            this.outputs = modelLayer.outputs;
            this.inputs = modelLayer.inputs;
          } else {
            if (layer.inboundNodes.length !== 1) {
              throw new ValueError(`A layer added to a Sequential model must not already be connected somewhere else. LayersModel received layer ${layer.name} which has ${layer.inboundNodes.length} pre-existing inbound connections.`);
            }
            if (layer.inboundNodes[0].outputTensors.length !== 1) {
              throw new ValueError("All layers in a Sequential model should have a single output tensor. For multi-output layers, use the functional API.");
            }
            this.checkShape(layer);
            this.outputs = [layer.inboundNodes[0].outputTensors[0]];
            this.inputs = getSourceInputs(this.outputs[0]);
          }
          this.inboundNodes = [];
          new Node({
            outboundLayer: this,
            inboundLayers: [],
            nodeIndices: [],
            tensorIndices: [],
            inputTensors: this.inputs,
            outputTensors: this.outputs,
            inputMasks: pyListRepeat(null, this.inputs.length),
            outputMasks: [null],
            inputShapes: this.inputs.map((x) => x.shape),
            outputShapes: this.outputs[0].shape
          });
        } else {
          const outputTensor = layer.apply(this.outputs[0]);
          if (Array.isArray(outputTensor)) {
            throw new TypeError("All layers in a Sequential model should have a single output tensor. For multi-output layers, use the functional API.");
          }
          this.checkShape(layer);
          this.outputs = [outputTensor];
          this.inboundNodes[0].outputTensors = this.outputs;
          this.inboundNodes[0].outputShapes = [this.outputs[0].shape];
        }
        this.layers.push(layer);
        this.built = false;
      }
      pop() {
        if (this.layers.length === 0) {
          throw new TypeError("There are no layers in the model.");
        }
        this.layers.pop();
        if (this.layers.length === 0) {
          this.outputs = [];
          this.inboundNodes = [];
          this.outboundNodes = [];
        } else {
          const lastLayerIndex = this.layers.length - 1;
          this.layers[lastLayerIndex].outboundNodes = [];
          this.outputs = [this.layers[lastLayerIndex].output];
          this.inboundNodes[0].outputTensors = this.outputs;
          this.inboundNodes[0].outputShapes = [this.outputs[0].shape];
        }
      }
      call(inputs, kwargs) {
        if (this.model == null) {
          this.build();
        }
        return this.model.call(inputs, kwargs);
      }
      build(inputShape) {
        getExactlyOneShape(inputShape);
        if (this.inputs.length === 0 || this.outputs.length === 0) {
          throw new TypeError("Sequential model cannot be built: model is empty. Add some layers first.");
        }
        this.model = new LayersModel({
          inputs: this.inputs,
          outputs: this.outputs[0],
          name: this.name + "_model"
        });
        this.model.trainable = this.trainable;
        this.supportsMasking = this.model.supportsMasking;
        this.inputLayers = this.model.inputLayers;
        this.inputLayersNodeIndices = this.model.inputLayersNodeIndices;
        this.inputLayersTensorIndices = this.model.inputLayersTensorIndices;
        this.outputLayers = this.model.outputLayers;
        this.outputLayersNodeIndices = this.model.outputLayersNodeIndices;
        this.outputLayersTensorIndices = this.model.outputLayersTensorIndices;
        this.nodesByDepth = this.model.nodesByDepth;
        this.containerNodes = this.model.containerNodes;
        this.outputNames = this.model.outputNames;
        this.inputNames = this.model.inputNames;
        this.built = true;
      }
      countParams() {
        if (!this.built) {
          this.build();
        }
        return super.countParams();
      }
      summary(lineLength, positions, printFn = console.log) {
        if (!this.built) {
          this.build();
        }
        super.summary(lineLength, positions, printFn);
      }
      setWeights(weights) {
        if (this.model == null) {
          this.build();
        }
        this.model.setWeights(weights);
      }
      evaluate(x, y, args = {}) {
        if (!this.built) {
          throw new RuntimeError("The model needs to be compiled before being used.");
        }
        return this.model.evaluate(x, y, args);
      }
      async evaluateDataset(dataset, args) {
        if (!this.built) {
          throw new RuntimeError("The model needs to be compiled before being used.");
        }
        return this.model.evaluateDataset(dataset, args);
      }
      predict(x, args = {}) {
        if (this.model == null) {
          this.build();
        }
        return this.model.predict(x, args);
      }
      predictOnBatch(x) {
        if (this.model == null) {
          this.build();
        }
        return this.model.predictOnBatch(x);
      }
      compile(args) {
        this.build();
        this.model.compile(args);
        this.optimizer_ = this.model.optimizer;
        this.isOptimizerOwned = this.model.isOptimizerOwned;
        this.loss = this.model.loss;
        this.metrics = this.model.metrics;
        this.metricsTensors = this.model.metricsTensors;
        this.metricsNames = this.model.metricsNames;
      }
      get optimizer() {
        return this.model == null ? void 0 : this.model.optimizer;
      }
      set optimizer(optimizer) {
        this.model.optimizer = optimizer;
      }
      async fit(x, y, args = {}) {
        if (!this.built) {
          throw new RuntimeError("The model needs to be compiled before being used.");
        }
        return this.model.fit(x, y, args);
      }
      async fitDataset(dataset, args) {
        if (!this.built) {
          throw new RuntimeError("The model needs to be compiled before being used.");
        }
        return this.model.fitDataset(dataset, args);
      }
      async trainOnBatch(x, y) {
        return this.model.trainOnBatch(x, y);
      }
      static fromConfig(cls, config2, customObjects = {}, fastWeightInit = false) {
        let configArray;
        let extraModelConfig = {};
        if (config2 instanceof Array) {
          if (!(config2[0].className != null) || config2[0]["className"] === "Merge") {
            throw new ValueError("Legacy serialization format not supported yet.");
          }
          configArray = config2;
        } else {
          assert2(config2["layers"] != null, () => `When the config data for a Sequential model is not an Array, it must be an Object that contains the 'layers' field.`);
          configArray = config2["layers"];
          delete config2["layers"];
          extraModelConfig = config2;
        }
        const model2 = new cls(extraModelConfig);
        if (!(model2 instanceof Sequential)) {
          throw new NotImplementedError(`Sequential.fromConfig called on non-Sequential input: ${model2}`);
        }
        for (const conf of configArray) {
          const customObjects2 = void 0;
          const layer = deserialize(conf, customObjects2, fastWeightInit);
          if (fastWeightInit) {
            layer.setFastWeightInitDuringBuild(true);
          }
          model2.add(layer);
        }
        return model2;
      }
      set stopTraining(stop) {
        if (this.model == null) {
          throw new ValueError("Cannot set the stopTraining property of a sequential model before it is compiled.");
        }
        this.model.stopTraining = stop;
      }
      get stopTraining() {
        if (this.model == null) {
          throw new ValueError("Cannot get the stopTraining property of a sequential model before it is compiled.");
        }
        return this.model.stopTraining;
      }
      getConfig() {
        const layers = [];
        for (const layer of this.layers) {
          const dict = {};
          dict["className"] = layer.getClassName();
          dict["config"] = layer.getConfig();
          layers.push(dict);
        }
        return {name: this.name, layers};
      }
    }
    Sequential.className = "Sequential";
    registerClass(Sequential);
    /**
     * @license
     * Copyright 2018 Google LLC
     *
     * Use of this source code is governed by an MIT-style
     * license that can be found in the LICENSE file or at
     * https://opensource.org/licenses/MIT.
     * =============================================================================
     */
    function model(args) {
      return new LayersModel(args);
    }
    function sequential(config2) {
      return new Sequential(config2);
    }
    function loadLayersModel(pathOrIOHandler, options) {
      if (options == null) {
        options = {};
      }
      return loadLayersModelInternal(pathOrIOHandler, options);
    }
    function input(config2) {
      return Input(config2);
    }
    function registerCallbackConstructor(verbosityLevel, callbackConstructor) {
      CallbackConstructorRegistry.registerCallbackConstructor(verbosityLevel, callbackConstructor);
    }
    /**
     * @license
     * Copyright 2018 Google LLC
     *
     * Use of this source code is governed by an MIT-style
     * license that can be found in the LICENSE file or at
     * https://opensource.org/licenses/MIT.
     * =============================================================================
     */
    class Activation extends Serializable {
      getConfig() {
        return {};
      }
    }
    class Elu$1 extends Activation {
      apply(x, alpha = 1) {
        return elu$1(x, alpha);
      }
    }
    Elu$1.className = "elu";
    registerClass(Elu$1);
    class Selu$1 extends Activation {
      apply(x) {
        return selu(x);
      }
    }
    Selu$1.className = "selu";
    registerClass(Selu$1);
    class Relu$1 extends Activation {
      apply(x) {
        return relu3(x);
      }
    }
    Relu$1.className = "relu";
    registerClass(Relu$1);
    class Relu6$1 extends Activation {
      apply(x) {
        return tidy(() => minimum(6, relu3(x)));
      }
    }
    Relu6$1.className = "relu6";
    registerClass(Relu6$1);
    class Linear extends Activation {
      apply(x) {
        return x;
      }
    }
    Linear.className = "linear";
    registerClass(Linear);
    class Sigmoid$1 extends Activation {
      apply(x) {
        return sigmoid2(x);
      }
    }
    Sigmoid$1.className = "sigmoid";
    registerClass(Sigmoid$1);
    class HardSigmoid extends Activation {
      apply(x) {
        return hardSigmoid(x);
      }
    }
    HardSigmoid.className = "hardSigmoid";
    registerClass(HardSigmoid);
    class Softplus$1 extends Activation {
      apply(x) {
        return softplus(x);
      }
    }
    Softplus$1.className = "softplus";
    registerClass(Softplus$1);
    class Softsign extends Activation {
      apply(x) {
        return softsign(x);
      }
    }
    Softsign.className = "softsign";
    registerClass(Softsign);
    class Tanh$1 extends Activation {
      apply(x) {
        return tanh$1(x);
      }
    }
    Tanh$1.className = "tanh";
    registerClass(Tanh$1);
    class Softmax$1 extends Activation {
      apply(x, axis = -1) {
        return softmax2(x, axis);
      }
    }
    Softmax$1.className = "softmax";
    registerClass(Softmax$1);
    class LogSoftmax$1 extends Activation {
      apply(x, axis = -1) {
        return logSoftmax(x, axis);
      }
    }
    LogSoftmax$1.className = "logSoftmax";
    registerClass(LogSoftmax$1);
    class Swish extends Activation {
      apply(x, alpha = 1) {
        return tidy(() => sigmoid2(x.mul(alpha)).mul(x));
      }
    }
    Swish.className = "swish";
    registerClass(Swish);
    function serializeActivation(activation2) {
      return activation2.getClassName();
    }
    function deserializeActivation(config2, customObjects = {}) {
      return deserializeKerasObject(config2, SerializationMap.getMap().classNameMap, customObjects, "activation");
    }
    function getActivation(identifier) {
      if (identifier == null) {
        const config2 = {};
        config2["className"] = "linear";
        config2["config"] = {};
        return deserializeActivation(config2);
      }
      if (typeof identifier === "string") {
        const config2 = {};
        config2["className"] = identifier;
        config2["config"] = {};
        return deserializeActivation(config2);
      } else if (identifier instanceof Activation) {
        return identifier;
      } else {
        return deserializeActivation(identifier);
      }
    }
    /**
     * @license
     * Copyright 2018 Google LLC
     *
     * Use of this source code is governed by an MIT-style
     * license that can be found in the LICENSE file or at
     * https://opensource.org/licenses/MIT.
     * =============================================================================
     */
    function assertObjectArgs(args) {
      if (args != null && typeof args !== "object") {
        throw new Error(`Argument to L1L2 regularizer's constructor is expected to be an object, but received: ${args}`);
      }
    }
    class Regularizer extends Serializable {
    }
    class L1L2 extends Regularizer {
      constructor(args) {
        super();
        assertObjectArgs(args);
        this.l1 = args == null || args.l1 == null ? 0.01 : args.l1;
        this.l2 = args == null || args.l2 == null ? 0.01 : args.l2;
        this.hasL1 = this.l1 !== 0;
        this.hasL2 = this.l2 !== 0;
      }
      apply(x) {
        return tidy(() => {
          let regularization = zeros3([1]);
          if (this.hasL1) {
            regularization = add$1(regularization, sum$1(mul3(this.l1, abs(x))));
          }
          if (this.hasL2) {
            regularization = add$1(regularization, sum$1(mul3(this.l2, square$1(x))));
          }
          return regularization.asScalar();
        });
      }
      getConfig() {
        return {l1: this.l1, l2: this.l2};
      }
      static fromConfig(cls, config2) {
        return new cls({l1: config2["l1"], l2: config2["l2"]});
      }
    }
    L1L2.className = "L1L2";
    registerClass(L1L2);
    function l1(args) {
      assertObjectArgs(args);
      return new L1L2({l1: args != null ? args.l1 : null, l2: 0});
    }
    function l2(args) {
      assertObjectArgs(args);
      return new L1L2({l2: args != null ? args.l2 : null, l1: 0});
    }
    const REGULARIZER_IDENTIFIER_REGISTRY_SYMBOL_MAP = {
      l1l2: "L1L2"
    };
    function serializeRegularizer(constraint) {
      return serializeKerasObject(constraint);
    }
    function deserializeRegularizer(config2, customObjects = {}) {
      return deserializeKerasObject(config2, SerializationMap.getMap().classNameMap, customObjects, "regularizer");
    }
    function getRegularizer(identifier) {
      if (identifier == null) {
        return null;
      }
      if (typeof identifier === "string") {
        const className = identifier in REGULARIZER_IDENTIFIER_REGISTRY_SYMBOL_MAP ? REGULARIZER_IDENTIFIER_REGISTRY_SYMBOL_MAP[identifier] : identifier;
        const config2 = {className, config: {}};
        return deserializeRegularizer(config2);
      } else if (identifier instanceof Regularizer) {
        return identifier;
      } else {
        return deserializeRegularizer(identifier);
      }
    }
    /**
     * @license
     * Copyright 2018 Google LLC
     *
     * Use of this source code is governed by an MIT-style
     * license that can be found in the LICENSE file or at
     * https://opensource.org/licenses/MIT.
     * =============================================================================
     */
    class ReLU extends Layer {
      constructor(args) {
        super(args == null ? {} : args);
        this.supportsMasking = true;
        if (args != null) {
          this.maxValue = args.maxValue;
        }
      }
      call(inputs, kwargs) {
        inputs = getExactlyOneTensor(inputs);
        let output = relu3(inputs);
        if (this.maxValue != null) {
          output = clipByValue(output, 0, this.maxValue);
        }
        return output;
      }
      computeOutputShape(inputShape) {
        return inputShape;
      }
      getConfig() {
        const config2 = {maxValue: this.maxValue};
        const baseConfig = super.getConfig();
        Object.assign(config2, baseConfig);
        return config2;
      }
    }
    ReLU.className = "ReLU";
    registerClass(ReLU);
    class LeakyReLU extends Layer {
      constructor(args) {
        super(args == null ? {} : args);
        this.DEFAULT_ALPHA = 0.3;
        if (args == null) {
          args = {};
        }
        this.alpha = args.alpha == null ? this.DEFAULT_ALPHA : args.alpha;
      }
      call(inputs, kwargs) {
        const x = getExactlyOneTensor(inputs);
        return leakyRelu(x, this.alpha);
      }
      computeOutputShape(inputShape) {
        return inputShape;
      }
      getConfig() {
        const config2 = {alpha: this.alpha};
        const baseConfig = super.getConfig();
        Object.assign(config2, baseConfig);
        return config2;
      }
    }
    LeakyReLU.className = "LeakyReLU";
    registerClass(LeakyReLU);
    class PReLU extends Layer {
      constructor(args) {
        super(args == null ? {} : args);
        this.DEFAULT_ALPHA_INITIALIZER = "zeros";
        if (args == null) {
          args = {};
        }
        this.supportsMasking = true;
        this.alphaInitializer = getInitializer(args.alphaInitializer || this.DEFAULT_ALPHA_INITIALIZER);
        this.alphaRegularizer = getRegularizer(args.alphaRegularizer);
        this.alphaConstraint = getConstraint(args.alphaConstraint);
        if (args.sharedAxes == null) {
          this.sharedAxes = null;
        } else if (Array.isArray(args.sharedAxes)) {
          this.sharedAxes = args.sharedAxes;
        } else if (typeof args.sharedAxes === "number") {
          this.sharedAxes = [args.sharedAxes];
        } else {
          throw new ValueError(`Expected sharedAxes to be a number or an array of numbers, but got ${args.sharedAxes}`);
        }
      }
      build(inputShape) {
        inputShape = getExactlyOneShape(inputShape);
        const paramShape = inputShape.slice(1);
        if (this.sharedAxes != null) {
          for (const i of this.sharedAxes) {
            paramShape[i - 1] = 1;
          }
        }
        this.alpha = this.addWeight("alpha", paramShape, "float32", this.alphaInitializer, this.alphaRegularizer, true, this.alphaConstraint);
        const axes = {};
        if (this.sharedAxes != null) {
          for (let i = 1; i < inputShape.length; ++i) {
            axes[i] = inputShape[i];
          }
        }
        this.inputSpec = [new InputSpec({
          ndim: inputShape.length,
          axes
        })];
        this.built = true;
      }
      call(inputs, kwargs) {
        inputs = getExactlyOneTensor(inputs);
        return prelu4(inputs, this.alpha.read());
      }
      getConfig() {
        const config2 = {
          alphaInitializer: serializeInitializer(this.alphaInitializer),
          alphaRegularizer: serializeRegularizer(this.alphaRegularizer),
          alphaConstraint: serializeConstraint(this.alphaConstraint),
          sharedAxes: this.sharedAxes
        };
        const baseConfig = super.getConfig();
        Object.assign(config2, baseConfig);
        return config2;
      }
    }
    PReLU.className = "PReLU";
    registerClass(PReLU);
    class ELU extends Layer {
      constructor(args) {
        super(args == null ? {} : args);
        this.DEFAULT_ALPHA = 1;
        if (args == null) {
          args = {};
        }
        if (args.alpha != null && args.alpha !== this.DEFAULT_ALPHA) {
          throw new NotImplementedError(`Non-default alpha value (${args.alpha}) is not supported by the ELU layer yet.`);
        }
        this.alpha = args.alpha == null ? this.DEFAULT_ALPHA : args.alpha;
      }
      call(inputs, kwargs) {
        const x = getExactlyOneTensor(inputs);
        return elu3(x);
      }
      computeOutputShape(inputShape) {
        return inputShape;
      }
      getConfig() {
        const config2 = {alpha: this.alpha};
        const baseConfig = super.getConfig();
        Object.assign(config2, baseConfig);
        return config2;
      }
    }
    ELU.className = "ELU";
    registerClass(ELU);
    class ThresholdedReLU extends Layer {
      constructor(args) {
        super(args == null ? {} : args);
        this.DEFAULT_THETA = 1;
        if (args == null) {
          args = {};
        }
        this.theta = args.theta == null ? this.DEFAULT_THETA : args.theta;
      }
      call(inputs, kwargs) {
        const x = getExactlyOneTensor(inputs);
        return x.mul(cast$1(x.greater(this.theta), "float32"));
      }
      computeOutputShape(inputShape) {
        return inputShape;
      }
      getConfig() {
        const config2 = {theta: this.theta};
        const baseConfig = super.getConfig();
        Object.assign(config2, baseConfig);
        return config2;
      }
    }
    ThresholdedReLU.className = "ThresholdedReLU";
    registerClass(ThresholdedReLU);
    class Softmax$2 extends Layer {
      constructor(args) {
        super(args == null ? {} : args);
        this.DEFAULT_AXIS = 1;
        if (args == null) {
          args = {};
        }
        this.softmax = new Softmax$1().apply;
        this.axis = args.axis == null ? this.DEFAULT_AXIS : args.axis;
      }
      call(inputs, kwargs) {
        const x = getExactlyOneTensor(inputs);
        return this.softmax(x, this.axis);
      }
      computeOutputShape(inputShape) {
        return inputShape;
      }
      getConfig() {
        const config2 = {axis: this.axis};
        const baseConfig = super.getConfig();
        Object.assign(config2, baseConfig);
        return config2;
      }
    }
    Softmax$2.className = "Softmax";
    registerClass(Softmax$2);
    /**
     * @license
     * Copyright 2018 Google LLC
     *
     * Use of this source code is governed by an MIT-style
     * license that can be found in the LICENSE file or at
     * https://opensource.org/licenses/MIT.
     * =============================================================================
     */
    function normalizeArray(value, n, name) {
      if (typeof value === "number") {
        return pyListRepeat(value, n);
      } else {
        if (value.length !== n) {
          throw new ValueError(`The ${name} argument must be an integer or tuple of ${n} integers. Received: ${value.length} elements.`);
        }
        for (let i = 0; i < n; ++i) {
          const singleValue = value[i];
          if (!isInteger(singleValue)) {
            throw new ValueError(`The ${name} argument must be an integer or tuple of ${n} integers. Received: ${JSON.stringify(value)} including a non-integer number ${singleValue}`);
          }
        }
        return value;
      }
    }
    function convOutputLength(inputLength, filterSize, padding, stride, dilation = 1) {
      if (inputLength == null) {
        return inputLength;
      }
      const dilatedFilterSize = filterSize + (filterSize - 1) * (dilation - 1);
      let outputLength;
      if (padding === "same") {
        outputLength = inputLength;
      } else {
        outputLength = inputLength - dilatedFilterSize + 1;
      }
      return Math.floor((outputLength + stride - 1) / stride);
    }
    function deconvLength(dimSize, strideSize, kernelSize, padding) {
      if (dimSize == null) {
        return null;
      }
      if (padding === "valid") {
        dimSize = dimSize * strideSize + max$1([kernelSize - strideSize, 0]);
      } else if (padding === "same") {
        dimSize = dimSize * strideSize;
      } else {
        throw new ValueError(`Unsupport padding mode: ${padding}.`);
      }
      return dimSize;
    }
    /**
     * @license
     * Copyright 2018 Google LLC
     *
     * Use of this source code is governed by an MIT-style
     * license that can be found in the LICENSE file or at
     * https://opensource.org/licenses/MIT.
     * =============================================================================
     */
    function preprocessConv2DInput(x, dataFormat) {
      return tidy(() => {
        checkDataFormat(dataFormat);
        if (dataFormat === "channelsFirst") {
          return transpose4(x, [0, 2, 3, 1]);
        } else {
          return x;
        }
      });
    }
    function preprocessConv3DInput(x, dataFormat) {
      return tidy(() => {
        checkDataFormat(dataFormat);
        if (dataFormat === "channelsFirst") {
          return transpose4(x, [0, 2, 3, 4, 1]);
        } else {
          return x;
        }
      });
    }
    function conv1dWithBias(x, kernel, bias, strides = 1, padding = "valid", dataFormat, dilationRate = 1) {
      return tidy(() => {
        if (dataFormat == null) {
          dataFormat = imageDataFormat();
        }
        checkDataFormat(dataFormat);
        if (x.shape.length !== 3) {
          throw new ValueError(`The input of a conv1dWithBias operation should be 3, but is ${x.shape.length} instead.`);
        }
        if (kernel.shape.length !== 3) {
          throw new ValueError(`The kernel for a conv1dWithBias operation should be 3, but is ${kernel.shape.length} instead`);
        }
        if (bias != null && bias.shape.length !== 1) {
          throw new ValueError(`The bias for a conv1dWithBias operation should be 1, but is ${kernel.shape.length} instead`);
        }
        if (dataFormat === "channelsFirst") {
          x = transpose4(x, [0, 2, 1]);
        }
        if (padding === "causal") {
          throw new NotImplementedError("The support for CAUSAL padding mode in conv1dWithBias is not implemented yet.");
        }
        let y = conv1d(x, kernel, strides, padding === "same" ? "same" : "valid", "NWC", dilationRate);
        if (bias != null) {
          y = biasAdd(y, bias);
        }
        return y;
      });
    }
    function conv1d$1(x, kernel, strides = 1, padding = "valid", dataFormat, dilationRate = 1) {
      return tidy(() => {
        checkDataFormat(dataFormat);
        return conv1dWithBias(x, kernel, null, strides, padding, dataFormat, dilationRate);
      });
    }
    function conv2d$2(x, kernel, strides = [1, 1], padding = "valid", dataFormat, dilationRate) {
      return tidy(() => {
        checkDataFormat(dataFormat);
        return conv2dWithBiasActivation(x, kernel, null, strides, padding, dataFormat, dilationRate);
      });
    }
    function conv2dWithBiasActivation(x, kernel, bias, strides = [1, 1], padding = "valid", dataFormat, dilationRate, activation2 = null) {
      return tidy(() => {
        if (dataFormat == null) {
          dataFormat = imageDataFormat();
        }
        checkDataFormat(dataFormat);
        if (x.rank !== 3 && x.rank !== 4) {
          throw new ValueError(`conv2dWithBiasActivation expects input to be of rank 3 or 4, but received ${x.rank}.`);
        }
        if (kernel.rank !== 3 && kernel.rank !== 4) {
          throw new ValueError(`conv2dWithBiasActivation expects kernel to be of rank 3 or 4, but received ${x.rank}.`);
        }
        let y = preprocessConv2DInput(x, dataFormat);
        if (padding === "causal") {
          throw new NotImplementedError("The support for CAUSAL padding mode in conv1dWithBias is not implemented yet.");
        }
        y = conv2d$1({
          x: y,
          filter: kernel,
          strides,
          pad: padding === "same" ? "same" : "valid",
          dilations: dilationRate,
          dataFormat: "NHWC",
          bias,
          activation: activation2
        });
        if (dataFormat === "channelsFirst") {
          y = transpose4(y, [0, 3, 1, 2]);
        }
        return y;
      });
    }
    function conv3d$1(x, kernel, strides = [1, 1, 1], padding = "valid", dataFormat, dilationRate) {
      return tidy(() => {
        checkDataFormat(dataFormat);
        return conv3dWithBias(x, kernel, null, strides, padding, dataFormat, dilationRate);
      });
    }
    function conv3dWithBias(x, kernel, bias, strides = [1, 1, 1], padding = "valid", dataFormat, dilationRate) {
      return tidy(() => {
        if (dataFormat == null) {
          dataFormat = imageDataFormat();
        }
        checkDataFormat(dataFormat);
        if (x.rank !== 4 && x.rank !== 5) {
          throw new ValueError(`conv3dWithBias expects input to be of rank 4 or 5, but received ${x.rank}.`);
        }
        if (kernel.rank !== 4 && kernel.rank !== 5) {
          throw new ValueError(`conv3dWithBias expects kernel to be of rank 4 or 5, but received ${x.rank}.`);
        }
        let y = preprocessConv3DInput(x, dataFormat);
        if (padding === "causal") {
          throw new NotImplementedError("The support for CAUSAL padding mode in conv3dWithBias is not implemented yet.");
        }
        y = conv3d(y, kernel, strides, padding === "same" ? "same" : "valid", "NDHWC", dilationRate);
        if (bias != null) {
          y = biasAdd(y, bias);
        }
        if (dataFormat === "channelsFirst") {
          y = transpose4(y, [0, 4, 1, 2, 3]);
        }
        return y;
      });
    }
    class BaseConv extends Layer {
      constructor(rank, args) {
        super(args);
        this.bias = null;
        this.DEFAULT_KERNEL_INITIALIZER = "glorotNormal";
        this.DEFAULT_BIAS_INITIALIZER = "zeros";
        BaseConv.verifyArgs(args);
        this.rank = rank;
        assertPositiveInteger(this.rank, "rank");
        if (this.rank !== 1 && this.rank !== 2 && this.rank !== 3) {
          throw new NotImplementedError(`Convolution layer for rank other than 1, 2, or 3 (${this.rank}) is not implemented yet.`);
        }
        this.kernelSize = normalizeArray(args.kernelSize, rank, "kernelSize");
        this.strides = normalizeArray(args.strides == null ? 1 : args.strides, rank, "strides");
        this.padding = args.padding == null ? "valid" : args.padding;
        checkPaddingMode(this.padding);
        this.dataFormat = args.dataFormat == null ? "channelsLast" : args.dataFormat;
        checkDataFormat(this.dataFormat);
        this.activation = getActivation(args.activation);
        this.useBias = args.useBias == null ? true : args.useBias;
        this.biasInitializer = getInitializer(args.biasInitializer || this.DEFAULT_BIAS_INITIALIZER);
        this.biasConstraint = getConstraint(args.biasConstraint);
        this.biasRegularizer = getRegularizer(args.biasRegularizer);
        this.activityRegularizer = getRegularizer(args.activityRegularizer);
        this.dilationRate = normalizeArray(args.dilationRate == null ? 1 : args.dilationRate, rank, "dilationRate");
        if (this.rank === 1 && (Array.isArray(this.dilationRate) && this.dilationRate.length !== 1)) {
          throw new ValueError(`dilationRate must be a number or an array of a single number for 1D convolution, but received ${JSON.stringify(this.dilationRate)}`);
        } else if (this.rank === 2) {
          if (typeof this.dilationRate === "number") {
            this.dilationRate = [this.dilationRate, this.dilationRate];
          } else if (this.dilationRate.length !== 2) {
            throw new ValueError(`dilationRate must be a number or array of two numbers for 2D convolution, but received ${JSON.stringify(this.dilationRate)}`);
          }
        } else if (this.rank === 3) {
          if (typeof this.dilationRate === "number") {
            this.dilationRate = [this.dilationRate, this.dilationRate, this.dilationRate];
          } else if (this.dilationRate.length !== 3) {
            throw new ValueError(`dilationRate must be a number or array of three numbers for 3D convolution, but received ${JSON.stringify(this.dilationRate)}`);
          }
        }
      }
      static verifyArgs(args) {
        assert$1("kernelSize" in args, `required key 'kernelSize' not in config`);
        if (typeof args.kernelSize !== "number" && !checkArrayTypeAndLength(args.kernelSize, "number", 1, 3)) {
          throw new ValueError(`BaseConv expects config.kernelSize to be number or number[] with length 1, 2, or 3, but received ${JSON.stringify(args.kernelSize)}.`);
        }
      }
      getConfig() {
        const config2 = {
          kernelSize: this.kernelSize,
          strides: this.strides,
          padding: this.padding,
          dataFormat: this.dataFormat,
          dilationRate: this.dilationRate,
          activation: serializeActivation(this.activation),
          useBias: this.useBias,
          biasInitializer: serializeInitializer(this.biasInitializer),
          biasRegularizer: serializeRegularizer(this.biasRegularizer),
          activityRegularizer: serializeRegularizer(this.activityRegularizer),
          biasConstraint: serializeConstraint(this.biasConstraint)
        };
        const baseConfig = super.getConfig();
        Object.assign(config2, baseConfig);
        return config2;
      }
    }
    class Conv extends BaseConv {
      constructor(rank, args) {
        super(rank, args);
        this.kernel = null;
        Conv.verifyArgs(args);
        this.filters = args.filters;
        assertPositiveInteger(this.filters, "filters");
        this.kernelInitializer = getInitializer(args.kernelInitializer || this.DEFAULT_KERNEL_INITIALIZER);
        this.kernelConstraint = getConstraint(args.kernelConstraint);
        this.kernelRegularizer = getRegularizer(args.kernelRegularizer);
      }
      build(inputShape) {
        inputShape = getExactlyOneShape(inputShape);
        const channelAxis = this.dataFormat === "channelsFirst" ? 1 : inputShape.length - 1;
        if (inputShape[channelAxis] == null) {
          throw new ValueError(`The channel dimension of the input should be defined. Found ${inputShape[channelAxis]}`);
        }
        const inputDim = inputShape[channelAxis];
        const kernelShape = this.kernelSize.concat([inputDim, this.filters]);
        this.kernel = this.addWeight("kernel", kernelShape, null, this.kernelInitializer, this.kernelRegularizer, true, this.kernelConstraint);
        if (this.useBias) {
          this.bias = this.addWeight("bias", [this.filters], null, this.biasInitializer, this.biasRegularizer, true, this.biasConstraint);
        }
        this.inputSpec = [{ndim: this.rank + 2, axes: {[channelAxis]: inputDim}}];
        this.built = true;
      }
      call(inputs, kwargs) {
        return tidy(() => {
          inputs = getExactlyOneTensor(inputs);
          let outputs;
          const biasValue = this.bias == null ? null : this.bias.read();
          const fusedActivationName = mapActivationToFusedKernel(this.activation.getClassName());
          if (fusedActivationName != null && this.rank === 2) {
            outputs = conv2dWithBiasActivation(inputs, this.kernel.read(), biasValue, this.strides, this.padding, this.dataFormat, this.dilationRate, fusedActivationName);
          } else {
            if (this.rank === 1) {
              outputs = conv1dWithBias(inputs, this.kernel.read(), biasValue, this.strides[0], this.padding, this.dataFormat, this.dilationRate[0]);
            } else if (this.rank === 2) {
              outputs = conv2dWithBiasActivation(inputs, this.kernel.read(), biasValue, this.strides, this.padding, this.dataFormat, this.dilationRate);
            } else if (this.rank === 3) {
              outputs = conv3dWithBias(inputs, this.kernel.read(), biasValue, this.strides, this.padding, this.dataFormat, this.dilationRate);
            } else {
              throw new NotImplementedError("convolutions greater than 3D are not implemented yet.");
            }
            if (this.activation != null) {
              outputs = this.activation.apply(outputs);
            }
          }
          return outputs;
        });
      }
      computeOutputShape(inputShape) {
        inputShape = getExactlyOneShape(inputShape);
        const newSpace = [];
        const space = this.dataFormat === "channelsLast" ? inputShape.slice(1, inputShape.length - 1) : inputShape.slice(2);
        for (let i = 0; i < space.length; ++i) {
          const newDim = convOutputLength(space[i], this.kernelSize[i], this.padding, this.strides[i], typeof this.dilationRate === "number" ? this.dilationRate : this.dilationRate[i]);
          newSpace.push(newDim);
        }
        let outputShape = [inputShape[0]];
        if (this.dataFormat === "channelsLast") {
          outputShape = outputShape.concat(newSpace);
          outputShape.push(this.filters);
        } else {
          outputShape.push(this.filters);
          outputShape = outputShape.concat(newSpace);
        }
        return outputShape;
      }
      getConfig() {
        const config2 = {
          filters: this.filters,
          kernelInitializer: serializeInitializer(this.kernelInitializer),
          kernelRegularizer: serializeRegularizer(this.kernelRegularizer),
          kernelConstraint: serializeConstraint(this.kernelConstraint)
        };
        const baseConfig = super.getConfig();
        Object.assign(config2, baseConfig);
        return config2;
      }
      static verifyArgs(args) {
        if (!("filters" in args) || typeof args.filters !== "number" || args.filters < 1) {
          throw new ValueError(`Convolution layer expected config.filters to be a 'number' > 0 but got ${JSON.stringify(args.filters)}`);
        }
      }
    }
    class Conv2D$1 extends Conv {
      constructor(args) {
        super(2, args);
        Conv2D$1.verifyArgs(args);
      }
      getConfig() {
        const config2 = super.getConfig();
        delete config2["rank"];
        return config2;
      }
      static verifyArgs(args) {
        if (typeof args.kernelSize !== "number" && !checkArrayTypeAndLength(args.kernelSize, "number", 1, 2)) {
          throw new ValueError(`Conv2D expects config.kernelSize to be number or number[] with length 1 or 2, but received ${JSON.stringify(args.kernelSize)}.`);
        }
      }
    }
    Conv2D$1.className = "Conv2D";
    registerClass(Conv2D$1);
    class Conv3D$1 extends Conv {
      constructor(args) {
        super(3, args);
        Conv3D$1.verifyArgs(args);
      }
      getConfig() {
        const config2 = super.getConfig();
        delete config2["rank"];
        return config2;
      }
      static verifyArgs(args) {
        if (typeof args.kernelSize !== "number") {
          if (!(Array.isArray(args.kernelSize) && (args.kernelSize.length === 1 || args.kernelSize.length === 3))) {
            throw new ValueError(`Conv3D expects config.kernelSize to be number or [number, number, number], but received ${JSON.stringify(args.kernelSize)}.`);
          }
        }
      }
    }
    Conv3D$1.className = "Conv3D";
    registerClass(Conv3D$1);
    class Conv2DTranspose extends Conv2D$1 {
      constructor(args) {
        super(args);
        this.inputSpec = [new InputSpec({ndim: 4})];
        if (this.padding !== "same" && this.padding !== "valid") {
          throw new ValueError(`Conv2DTranspose currently supports only padding modes 'same' and 'valid', but received padding mode ${this.padding}`);
        }
      }
      build(inputShape) {
        inputShape = getExactlyOneShape(inputShape);
        if (inputShape.length !== 4) {
          throw new ValueError("Input should have rank 4; Received input shape: " + JSON.stringify(inputShape));
        }
        const channelAxis = this.dataFormat === "channelsFirst" ? 1 : inputShape.length - 1;
        if (inputShape[channelAxis] == null) {
          throw new ValueError("The channel dimension of the inputs should be defined. Found `None`.");
        }
        const inputDim = inputShape[channelAxis];
        const kernelShape = this.kernelSize.concat([this.filters, inputDim]);
        this.kernel = this.addWeight("kernel", kernelShape, "float32", this.kernelInitializer, this.kernelRegularizer, true, this.kernelConstraint);
        if (this.useBias) {
          this.bias = this.addWeight("bias", [this.filters], "float32", this.biasInitializer, this.biasRegularizer, true, this.biasConstraint);
        }
        this.inputSpec = [new InputSpec({ndim: 4, axes: {[channelAxis]: inputDim}})];
        this.built = true;
      }
      call(inputs, kwargs) {
        return tidy(() => {
          let input2 = getExactlyOneTensor(inputs);
          if (input2.shape.length !== 4) {
            throw new ValueError(`Conv2DTranspose.call() expects input tensor to be rank-4, but received a tensor of rank-${input2.shape.length}`);
          }
          const inputShape = input2.shape;
          const batchSize = inputShape[0];
          let hAxis;
          let wAxis;
          if (this.dataFormat === "channelsFirst") {
            hAxis = 2;
            wAxis = 3;
          } else {
            hAxis = 1;
            wAxis = 2;
          }
          const height = inputShape[hAxis];
          const width = inputShape[wAxis];
          const kernelH = this.kernelSize[0];
          const kernelW = this.kernelSize[1];
          const strideH = this.strides[0];
          const strideW = this.strides[1];
          const outHeight = deconvLength(height, strideH, kernelH, this.padding);
          const outWidth = deconvLength(width, strideW, kernelW, this.padding);
          const outputShape = [batchSize, outHeight, outWidth, this.filters];
          if (this.dataFormat !== "channelsLast") {
            input2 = transpose4(input2, [0, 2, 3, 1]);
          }
          let outputs = conv2dTranspose(input2, this.kernel.read(), outputShape, this.strides, this.padding);
          if (this.dataFormat !== "channelsLast") {
            outputs = transpose4(outputs, [0, 3, 1, 2]);
          }
          if (this.bias != null) {
            outputs = biasAdd(outputs, this.bias.read(), this.dataFormat);
          }
          if (this.activation != null) {
            outputs = this.activation.apply(outputs);
          }
          return outputs;
        });
      }
      computeOutputShape(inputShape) {
        inputShape = getExactlyOneShape(inputShape);
        const outputShape = inputShape.slice();
        let channelAxis;
        let heightAxis;
        let widthAxis;
        if (this.dataFormat === "channelsFirst") {
          channelAxis = 1;
          heightAxis = 2;
          widthAxis = 3;
        } else {
          channelAxis = 3;
          heightAxis = 1;
          widthAxis = 2;
        }
        const kernelH = this.kernelSize[0];
        const kernelW = this.kernelSize[1];
        const strideH = this.strides[0];
        const strideW = this.strides[1];
        outputShape[channelAxis] = this.filters;
        outputShape[heightAxis] = deconvLength(outputShape[heightAxis], strideH, kernelH, this.padding);
        outputShape[widthAxis] = deconvLength(outputShape[widthAxis], strideW, kernelW, this.padding);
        return outputShape;
      }
      getConfig() {
        const config2 = super.getConfig();
        delete config2["dilationRate"];
        return config2;
      }
    }
    Conv2DTranspose.className = "Conv2DTranspose";
    registerClass(Conv2DTranspose);
    class SeparableConv extends Conv {
      constructor(rank, config2) {
        super(rank, config2);
        this.DEFAULT_DEPTHWISE_INITIALIZER = "glorotUniform";
        this.DEFAULT_POINTWISE_INITIALIZER = "glorotUniform";
        this.depthwiseKernel = null;
        this.pointwiseKernel = null;
        if (config2.filters == null) {
          throw new ValueError("The `filters` configuration field is required by SeparableConv, but is unspecified.");
        }
        if (config2.kernelInitializer != null || config2.kernelRegularizer != null || config2.kernelConstraint != null) {
          throw new ValueError("Fields kernelInitializer, kernelRegularizer and kernelConstraint are invalid for SeparableConv2D. Use depthwiseInitializer, depthwiseRegularizer, depthwiseConstraint, pointwiseInitializer, pointwiseRegularizer and pointwiseConstraint instead.");
        }
        if (config2.padding != null && config2.padding !== "same" && config2.padding !== "valid") {
          throw new ValueError(`SeparableConv${this.rank}D supports only padding modes: 'same' and 'valid', but received ${JSON.stringify(config2.padding)}`);
        }
        this.depthMultiplier = config2.depthMultiplier == null ? 1 : config2.depthMultiplier;
        this.depthwiseInitializer = getInitializer(config2.depthwiseInitializer || this.DEFAULT_DEPTHWISE_INITIALIZER);
        this.depthwiseRegularizer = getRegularizer(config2.depthwiseRegularizer);
        this.depthwiseConstraint = getConstraint(config2.depthwiseConstraint);
        this.pointwiseInitializer = getInitializer(config2.depthwiseInitializer || this.DEFAULT_POINTWISE_INITIALIZER);
        this.pointwiseRegularizer = getRegularizer(config2.pointwiseRegularizer);
        this.pointwiseConstraint = getConstraint(config2.pointwiseConstraint);
      }
      build(inputShape) {
        inputShape = getExactlyOneShape(inputShape);
        if (inputShape.length < this.rank + 2) {
          throw new ValueError(`Inputs to SeparableConv${this.rank}D should have rank ${this.rank + 2}, but received input shape: ${JSON.stringify(inputShape)}`);
        }
        const channelAxis = this.dataFormat === "channelsFirst" ? 1 : inputShape.length - 1;
        if (inputShape[channelAxis] == null || inputShape[channelAxis] < 0) {
          throw new ValueError(`The channel dimension of the inputs should be defined, but found ${JSON.stringify(inputShape[channelAxis])}`);
        }
        const inputDim = inputShape[channelAxis];
        const depthwiseKernelShape = this.kernelSize.concat([inputDim, this.depthMultiplier]);
        const pointwiseKernelShape = [];
        for (let i = 0; i < this.rank; ++i) {
          pointwiseKernelShape.push(1);
        }
        pointwiseKernelShape.push(inputDim * this.depthMultiplier, this.filters);
        const trainable = true;
        this.depthwiseKernel = this.addWeight("depthwise_kernel", depthwiseKernelShape, "float32", this.depthwiseInitializer, this.depthwiseRegularizer, trainable, this.depthwiseConstraint);
        this.pointwiseKernel = this.addWeight("pointwise_kernel", pointwiseKernelShape, "float32", this.pointwiseInitializer, this.pointwiseRegularizer, trainable, this.pointwiseConstraint);
        if (this.useBias) {
          this.bias = this.addWeight("bias", [this.filters], "float32", this.biasInitializer, this.biasRegularizer, trainable, this.biasConstraint);
        } else {
          this.bias = null;
        }
        this.inputSpec = [new InputSpec({ndim: this.rank + 2, axes: {[channelAxis]: inputDim}})];
        this.built = true;
      }
      call(inputs, kwargs) {
        return tidy(() => {
          inputs = getExactlyOneTensor(inputs);
          let output;
          if (this.rank === 1) {
            throw new NotImplementedError("1D separable convolution is not implemented yet.");
          } else if (this.rank === 2) {
            if (this.dataFormat === "channelsFirst") {
              inputs = transpose4(inputs, [0, 2, 3, 1]);
            }
            output = separableConv2d(inputs, this.depthwiseKernel.read(), this.pointwiseKernel.read(), this.strides, this.padding, this.dilationRate, "NHWC");
          }
          if (this.useBias) {
            output = biasAdd(output, this.bias.read(), this.dataFormat);
          }
          if (this.activation != null) {
            output = this.activation.apply(output);
          }
          if (this.dataFormat === "channelsFirst") {
            output = transpose4(output, [0, 3, 1, 2]);
          }
          return output;
        });
      }
      getConfig() {
        const config2 = super.getConfig();
        delete config2["rank"];
        delete config2["kernelInitializer"];
        delete config2["kernelRegularizer"];
        delete config2["kernelConstraint"];
        config2["depthwiseInitializer"] = serializeInitializer(this.depthwiseInitializer);
        config2["pointwiseInitializer"] = serializeInitializer(this.pointwiseInitializer);
        config2["depthwiseRegularizer"] = serializeRegularizer(this.depthwiseRegularizer);
        config2["pointwiseRegularizer"] = serializeRegularizer(this.pointwiseRegularizer);
        config2["depthwiseConstraint"] = serializeConstraint(this.depthwiseConstraint);
        config2["pointwiseConstraint"] = serializeConstraint(this.pointwiseConstraint);
        return config2;
      }
    }
    SeparableConv.className = "SeparableConv";
    class SeparableConv2D extends SeparableConv {
      constructor(args) {
        super(2, args);
      }
    }
    SeparableConv2D.className = "SeparableConv2D";
    registerClass(SeparableConv2D);
    class Conv1D extends Conv {
      constructor(args) {
        super(1, args);
        Conv1D.verifyArgs(args);
        this.inputSpec = [{ndim: 3}];
      }
      getConfig() {
        const config2 = super.getConfig();
        delete config2["rank"];
        delete config2["dataFormat"];
        return config2;
      }
      static verifyArgs(args) {
        if (typeof args.kernelSize !== "number" && !checkArrayTypeAndLength(args.kernelSize, "number", 1, 1)) {
          throw new ValueError(`Conv1D expects config.kernelSize to be number or number[] with length 1, but received ${JSON.stringify(args.kernelSize)}.`);
        }
      }
    }
    Conv1D.className = "Conv1D";
    registerClass(Conv1D);
    class Cropping2D extends Layer {
      constructor(args) {
        super(args);
        if (typeof args.cropping === "number") {
          this.cropping = [[args.cropping, args.cropping], [args.cropping, args.cropping]];
        } else if (typeof args.cropping[0] === "number") {
          this.cropping = [
            [args.cropping[0], args.cropping[0]],
            [args.cropping[1], args.cropping[1]]
          ];
        } else {
          this.cropping = args.cropping;
        }
        this.dataFormat = args.dataFormat === void 0 ? "channelsLast" : args.dataFormat;
        this.inputSpec = [{ndim: 4}];
      }
      computeOutputShape(inputShape) {
        if (this.dataFormat === "channelsFirst") {
          return [
            inputShape[0],
            inputShape[1],
            inputShape[2] - this.cropping[0][0] - this.cropping[0][1],
            inputShape[3] - this.cropping[1][0] - this.cropping[1][1]
          ];
        } else {
          return [
            inputShape[0],
            inputShape[1] - this.cropping[0][0] - this.cropping[0][1],
            inputShape[2] - this.cropping[1][0] - this.cropping[1][1],
            inputShape[3]
          ];
        }
      }
      call(inputs, kwargs) {
        return tidy(() => {
          inputs = getExactlyOneTensor(inputs);
          if (this.dataFormat === "channelsLast") {
            const hSliced = sliceAlongAxis(inputs, this.cropping[0][0], inputs.shape[1] - this.cropping[0][0] - this.cropping[0][1], 2);
            return sliceAlongAxis(hSliced, this.cropping[1][0], inputs.shape[2] - this.cropping[1][1] - this.cropping[1][0], 3);
          } else {
            const hSliced = sliceAlongAxis(inputs, this.cropping[0][0], inputs.shape[2] - this.cropping[0][0] - this.cropping[0][1], 3);
            return sliceAlongAxis(hSliced, this.cropping[1][0], inputs.shape[3] - this.cropping[1][1] - this.cropping[1][0], 4);
          }
        });
      }
      getConfig() {
        const config2 = {cropping: this.cropping, dataFormat: this.dataFormat};
        const baseConfig = super.getConfig();
        Object.assign(config2, baseConfig);
        return config2;
      }
    }
    Cropping2D.className = "Cropping2D";
    registerClass(Cropping2D);
    class UpSampling2D extends Layer {
      constructor(args) {
        super(args);
        this.DEFAULT_SIZE = [2, 2];
        this.inputSpec = [{ndim: 4}];
        this.size = args.size == null ? this.DEFAULT_SIZE : args.size;
        this.dataFormat = args.dataFormat == null ? "channelsLast" : args.dataFormat;
      }
      computeOutputShape(inputShape) {
        if (this.dataFormat === "channelsFirst") {
          const height = inputShape[2] == null ? null : this.size[0] * inputShape[2];
          const width = inputShape[3] == null ? null : this.size[1] * inputShape[3];
          return [inputShape[0], inputShape[1], height, width];
        } else {
          const height = inputShape[1] == null ? null : this.size[0] * inputShape[1];
          const width = inputShape[2] == null ? null : this.size[1] * inputShape[2];
          return [inputShape[0], height, width, inputShape[3]];
        }
      }
      call(inputs, kwargs) {
        return tidy(() => {
          let input2 = getExactlyOneTensor(inputs);
          const inputShape = input2.shape;
          if (this.dataFormat === "channelsFirst") {
            input2 = transpose4(input2, [0, 2, 3, 1]);
            const height = this.size[0] * inputShape[2];
            const width = this.size[1] * inputShape[3];
            const resized = input2.resizeNearestNeighbor([height, width]);
            return transpose4(resized, [0, 3, 1, 2]);
          } else {
            const height = this.size[0] * inputShape[1];
            const width = this.size[1] * inputShape[2];
            return input2.resizeNearestNeighbor([height, width]);
          }
        });
      }
      getConfig() {
        const config2 = {size: this.size, dataFormat: this.dataFormat};
        const baseConfig = super.getConfig();
        Object.assign(config2, baseConfig);
        return config2;
      }
    }
    UpSampling2D.className = "UpSampling2D";
    registerClass(UpSampling2D);
    /**
     * @license
     * Copyright 2018 Google LLC
     *
     * Use of this source code is governed by an MIT-style
     * license that can be found in the LICENSE file or at
     * https://opensource.org/licenses/MIT.
     * =============================================================================
     */
    function depthwiseConv2d$2(x, depthwiseKernel, strides = [1, 1], padding = "valid", dataFormat, dilationRate) {
      return tidy(() => {
        if (dataFormat == null) {
          dataFormat = imageDataFormat();
        }
        checkDataFormat(dataFormat);
        let y = preprocessConv2DInput(x, dataFormat);
        if (x.rank !== 4) {
          throw new ValueError(`Input for depthwiseConv2d is required to be 4-D, but is instead ${x.rank}-D`);
        }
        if (depthwiseKernel.rank !== 4) {
          throw new ValueError(`depthwiseKernel is required to be 4-D, but is instead ${depthwiseKernel.rank}-D`);
        }
        y = depthwiseConv2d2(y, depthwiseKernel, strides, padding === "same" ? "same" : "valid", "NHWC", dilationRate);
        if (dataFormat === "channelsFirst") {
          y = transpose4(y, [0, 3, 1, 2]);
        }
        return y;
      });
    }
    class DepthwiseConv2D extends BaseConv {
      constructor(args) {
        super(2, args);
        this.depthwiseKernel = null;
        this.depthMultiplier = args.depthMultiplier == null ? 1 : args.depthMultiplier;
        this.depthwiseInitializer = getInitializer(args.depthwiseInitializer || this.DEFAULT_KERNEL_INITIALIZER);
        this.depthwiseConstraint = getConstraint(args.depthwiseConstraint);
        this.depthwiseRegularizer = getRegularizer(args.depthwiseRegularizer);
      }
      build(inputShape) {
        inputShape = getExactlyOneShape(inputShape);
        if (inputShape.length < 4) {
          throw new ValueError(`Inputs to DepthwiseConv2D should have rank 4. Received input shape: ${JSON.stringify(inputShape)}.`);
        }
        const channelAxis = this.dataFormat === "channelsFirst" ? 1 : 3;
        if (inputShape[channelAxis] == null || inputShape[channelAxis] < 0) {
          throw new ValueError(`The channel dimension of the inputs to DepthwiseConv2D should be defined, but is not (${inputShape[channelAxis]}).`);
        }
        const inputDim = inputShape[channelAxis];
        const depthwiseKernelShape = [
          this.kernelSize[0],
          this.kernelSize[1],
          inputDim,
          this.depthMultiplier
        ];
        this.depthwiseKernel = this.addWeight("depthwise_kernel", depthwiseKernelShape, null, this.depthwiseInitializer, this.depthwiseRegularizer, true, this.depthwiseConstraint);
        if (this.useBias) {
          this.bias = this.addWeight("bias", [inputDim * this.depthMultiplier], null, this.biasInitializer, this.biasRegularizer, true, this.biasConstraint);
        } else {
          this.bias = null;
        }
        this.built = true;
      }
      call(inputs, kwargs) {
        return tidy(() => {
          inputs = getExactlyOneTensor(inputs);
          let outputs = depthwiseConv2d$2(inputs, this.depthwiseKernel.read(), this.strides, this.padding, this.dataFormat, null);
          if (this.useBias) {
            outputs = biasAdd(outputs, this.bias.read(), this.dataFormat);
          }
          if (this.activation != null) {
            outputs = this.activation.apply(outputs);
          }
          return outputs;
        });
      }
      computeOutputShape(inputShape) {
        inputShape = getExactlyOneShape(inputShape);
        const rows = this.dataFormat === "channelsFirst" ? inputShape[2] : inputShape[1];
        const cols = this.dataFormat === "channelsFirst" ? inputShape[3] : inputShape[2];
        const outFilters = this.dataFormat === "channelsFirst" ? inputShape[1] * this.depthMultiplier : inputShape[3] * this.depthMultiplier;
        const outRows = convOutputLength(rows, this.kernelSize[0], this.padding, this.strides[0]);
        const outCols = convOutputLength(cols, this.kernelSize[1], this.padding, this.strides[1]);
        if (this.dataFormat === "channelsFirst") {
          return [inputShape[0], outFilters, outRows, outCols];
        } else {
          return [inputShape[0], outRows, outCols, outFilters];
        }
      }
      getConfig() {
        const config2 = super.getConfig();
        config2["depthMultiplier"] = this.depthMultiplier;
        config2["depthwiseInitializer"] = serializeInitializer(this.depthwiseInitializer);
        config2["depthwiseRegularizer"] = serializeRegularizer(this.depthwiseRegularizer);
        config2["depthwiseConstraint"] = serializeConstraint(this.depthwiseRegularizer);
        return config2;
      }
    }
    DepthwiseConv2D.className = "DepthwiseConv2D";
    registerClass(DepthwiseConv2D);
    /**
     * @license
     * Copyright 2018 Google LLC
     *
     * Use of this source code is governed by an MIT-style
     * license that can be found in the LICENSE file or at
     * https://opensource.org/licenses/MIT.
     * =============================================================================
     */
    function standardizeArgs(inputs, initialState, constants, numConstants) {
      if (Array.isArray(inputs)) {
        if (initialState != null || constants != null) {
          throw new ValueError("When inputs is an array, neither initialState or constants should be provided");
        }
        if (numConstants != null) {
          constants = inputs.slice(inputs.length - numConstants, inputs.length);
          inputs = inputs.slice(0, inputs.length - numConstants);
        }
        if (inputs.length > 1) {
          initialState = inputs.slice(1, inputs.length);
        }
        inputs = inputs[0];
      }
      function toListOrNull(x) {
        if (x == null || Array.isArray(x)) {
          return x;
        } else {
          return [x];
        }
      }
      initialState = toListOrNull(initialState);
      constants = toListOrNull(constants);
      return {inputs, initialState, constants};
    }
    function rnn(stepFunction, inputs, initialStates, goBackwards = false, mask, constants, unroll = false, needPerStepOutputs = false) {
      return tidy(() => {
        const ndim = inputs.shape.length;
        if (ndim < 3) {
          throw new ValueError(`Input should be at least 3D, but is ${ndim}D.`);
        }
        const axes = [1, 0].concat(range$1(2, ndim));
        inputs = transpose4(inputs, axes);
        if (constants != null) {
          throw new NotImplementedError("The rnn() functoin of the deeplearn.js backend does not support constants yet.");
        }
        if (unroll) {
          console.warn("Backend rnn(): the unroll = true option is not applicable to the imperative deeplearn.js backend.");
        }
        if (mask != null) {
          mask = mask.asType("bool").asType("float32");
          if (mask.rank === ndim - 1) {
            mask = expandDims(mask, -1);
          }
          mask = transpose4(mask, axes);
        }
        if (goBackwards) {
          inputs = reverse2(inputs, 0);
          if (mask != null) {
            mask = reverse2(mask, 0);
          }
        }
        const perStepOutputs = [];
        let lastOutput;
        let states = initialStates;
        const timeSteps = inputs.shape[0];
        const perStepInputs = unstack(inputs);
        let perStepMasks;
        if (mask != null) {
          perStepMasks = unstack(mask);
        }
        for (let t = 0; t < timeSteps; ++t) {
          const currentInput = perStepInputs[t];
          const stepOutputs = tidy(() => stepFunction(currentInput, states));
          if (mask == null) {
            lastOutput = stepOutputs[0];
            states = stepOutputs[1];
          } else {
            const maskedOutputs = tidy(() => {
              const stepMask = perStepMasks[t];
              const negStepMask = onesLike2(stepMask).sub(stepMask);
              const output = stepOutputs[0].mul(stepMask).add(states[0].mul(negStepMask));
              const newStates = states.map((state, i) => {
                return stepOutputs[1][i].mul(stepMask).add(state.mul(negStepMask));
              });
              return {output, newStates};
            });
            lastOutput = maskedOutputs.output;
            states = maskedOutputs.newStates;
          }
          if (needPerStepOutputs) {
            perStepOutputs.push(lastOutput);
          }
        }
        let outputs;
        if (needPerStepOutputs) {
          const axis = 1;
          outputs = stack(perStepOutputs, axis);
        }
        return [lastOutput, outputs, states];
      });
    }
    class RNN extends Layer {
      constructor(args) {
        super(args);
        let cell;
        if (args.cell == null) {
          throw new ValueError("cell property is missing for the constructor of RNN.");
        } else if (Array.isArray(args.cell)) {
          cell = new StackedRNNCells({cells: args.cell});
        } else {
          cell = args.cell;
        }
        if (cell.stateSize == null) {
          throw new ValueError("The RNN cell should have an attribute `stateSize` (tuple of integers, one integer per RNN state).");
        }
        this.cell = cell;
        this.returnSequences = args.returnSequences == null ? false : args.returnSequences;
        this.returnState = args.returnState == null ? false : args.returnState;
        this.goBackwards = args.goBackwards == null ? false : args.goBackwards;
        this._stateful = args.stateful == null ? false : args.stateful;
        this.unroll = args.unroll == null ? false : args.unroll;
        this.supportsMasking = true;
        this.inputSpec = [new InputSpec({ndim: 3})];
        this.stateSpec = null;
        this.states_ = null;
        this.numConstants = null;
        this.keptStates = [];
      }
      getStates() {
        if (this.states_ == null) {
          const numStates = Array.isArray(this.cell.stateSize) ? this.cell.stateSize.length : 1;
          return range$1(0, numStates).map((x) => null);
        } else {
          return this.states_;
        }
      }
      setStates(states) {
        this.states_ = states;
      }
      computeOutputShape(inputShape) {
        if (isArrayOfShapes(inputShape)) {
          inputShape = inputShape[0];
        }
        inputShape = inputShape;
        let stateSize = this.cell.stateSize;
        if (!Array.isArray(stateSize)) {
          stateSize = [stateSize];
        }
        const outputDim = stateSize[0];
        let outputShape;
        if (this.returnSequences) {
          outputShape = [inputShape[0], inputShape[1], outputDim];
        } else {
          outputShape = [inputShape[0], outputDim];
        }
        if (this.returnState) {
          const stateShape = [];
          for (const dim of stateSize) {
            stateShape.push([inputShape[0], dim]);
          }
          return [outputShape].concat(stateShape);
        } else {
          return outputShape;
        }
      }
      computeMask(inputs, mask) {
        return tidy(() => {
          if (Array.isArray(mask)) {
            mask = mask[0];
          }
          const outputMask = this.returnSequences ? mask : null;
          if (this.returnState) {
            const stateMask = this.states.map((s) => null);
            return [outputMask].concat(stateMask);
          } else {
            return outputMask;
          }
        });
      }
      get states() {
        if (this.states_ == null) {
          const numStates = Array.isArray(this.cell.stateSize) ? this.cell.stateSize.length : 1;
          const output = [];
          for (let i = 0; i < numStates; ++i) {
            output.push(null);
          }
          return output;
        } else {
          return this.states_;
        }
      }
      set states(s) {
        this.states_ = s;
      }
      build(inputShape) {
        const constantShape = null;
        if (this.numConstants != null) {
          throw new NotImplementedError("Constants support is not implemented in RNN yet.");
        }
        if (isArrayOfShapes(inputShape)) {
          inputShape = inputShape[0];
        }
        inputShape = inputShape;
        const batchSize = this.stateful ? inputShape[0] : null;
        const inputDim = inputShape.slice(2);
        this.inputSpec[0] = new InputSpec({shape: [batchSize, null, ...inputDim]});
        const stepInputShape = [inputShape[0]].concat(inputShape.slice(2));
        if (constantShape != null) {
          throw new NotImplementedError("Constants support is not implemented in RNN yet.");
        } else {
          this.cell.build(stepInputShape);
        }
        let stateSize;
        if (Array.isArray(this.cell.stateSize)) {
          stateSize = this.cell.stateSize;
        } else {
          stateSize = [this.cell.stateSize];
        }
        if (this.stateSpec != null) {
          if (!arraysEqual2(this.stateSpec.map((spec) => spec.shape[spec.shape.length - 1]), stateSize)) {
            throw new ValueError(`An initialState was passed that is not compatible with cell.stateSize. Received stateSpec=${this.stateSpec}; However cell.stateSize is ${this.cell.stateSize}`);
          }
        } else {
          this.stateSpec = stateSize.map((dim) => new InputSpec({shape: [null, dim]}));
        }
        if (this.stateful) {
          this.resetStates();
        }
      }
      resetStates(states, training = false) {
        tidy(() => {
          if (!this.stateful) {
            throw new AttributeError("Cannot call resetStates() on an RNN Layer that is not stateful.");
          }
          const batchSize = this.inputSpec[0].shape[0];
          if (batchSize == null) {
            throw new ValueError("If an RNN is stateful, it needs to know its batch size. Specify the batch size of your input tensors: \n- If using a Sequential model, specify the batch size by passing a `batchInputShape` option to your first layer.\n- If using the functional API, specify the batch size by passing a `batchShape` option to your Input layer.");
          }
          if (this.states_ == null) {
            if (Array.isArray(this.cell.stateSize)) {
              this.states_ = this.cell.stateSize.map((dim) => zeros3([batchSize, dim]));
            } else {
              this.states_ = [zeros3([batchSize, this.cell.stateSize])];
            }
          } else if (states == null) {
            dispose(this.states_);
            if (this.keptStates != null) {
              dispose(this.keptStates);
              this.keptStates = [];
            }
            if (Array.isArray(this.cell.stateSize)) {
              this.states_ = this.cell.stateSize.map((dim) => zeros3([batchSize, dim]));
            } else {
              this.states_[0] = zeros3([batchSize, this.cell.stateSize]);
            }
          } else {
            if (!Array.isArray(states)) {
              states = [states];
            }
            if (states.length !== this.states_.length) {
              throw new ValueError(`Layer ${this.name} expects ${this.states_.length} state(s), but it received ${states.length} state value(s). Input received: ${states}`);
            }
            if (training === true) {
              this.keptStates.push(this.states_.slice());
            } else {
              dispose(this.states_);
            }
            for (let index2 = 0; index2 < this.states_.length; ++index2) {
              const value = states[index2];
              const dim = Array.isArray(this.cell.stateSize) ? this.cell.stateSize[index2] : this.cell.stateSize;
              const expectedShape = [batchSize, dim];
              if (!arraysEqual2(value.shape, expectedShape)) {
                throw new ValueError(`State ${index2} is incompatible with layer ${this.name}: expected shape=${expectedShape}, received shape=${value.shape}`);
              }
              this.states_[index2] = value;
            }
          }
          this.states_ = this.states_.map((state) => keep(state.clone()));
        });
      }
      apply(inputs, kwargs) {
        let initialState = kwargs == null ? null : kwargs["initialState"];
        let constants = kwargs == null ? null : kwargs["constants"];
        if (kwargs == null) {
          kwargs = {};
        }
        const standardized = standardizeArgs(inputs, initialState, constants, this.numConstants);
        inputs = standardized.inputs;
        initialState = standardized.initialState;
        constants = standardized.constants;
        let additionalInputs = [];
        let additionalSpecs = [];
        if (initialState != null) {
          kwargs["initialState"] = initialState;
          additionalInputs = additionalInputs.concat(initialState);
          this.stateSpec = [];
          for (const state of initialState) {
            this.stateSpec.push(new InputSpec({shape: state.shape}));
          }
          additionalSpecs = additionalSpecs.concat(this.stateSpec);
        }
        if (constants != null) {
          kwargs["constants"] = constants;
          additionalInputs = additionalInputs.concat(constants);
          this.numConstants = constants.length;
        }
        const isTensor = additionalInputs[0] instanceof SymbolicTensor;
        if (isTensor) {
          const fullInput = [inputs].concat(additionalInputs);
          const fullInputSpec = this.inputSpec.concat(additionalSpecs);
          const originalInputSpec = this.inputSpec;
          this.inputSpec = fullInputSpec;
          const output = super.apply(fullInput, kwargs);
          this.inputSpec = originalInputSpec;
          return output;
        } else {
          return super.apply(inputs, kwargs);
        }
      }
      call(inputs, kwargs) {
        return tidy(() => {
          const mask = kwargs == null ? null : kwargs["mask"];
          const training = kwargs == null ? null : kwargs["training"];
          let initialState = kwargs == null ? null : kwargs["initialState"];
          inputs = getExactlyOneTensor(inputs);
          if (initialState == null) {
            if (this.stateful) {
              initialState = this.states_;
            } else {
              initialState = this.getInitialState(inputs);
            }
          }
          const numStates = Array.isArray(this.cell.stateSize) ? this.cell.stateSize.length : 1;
          if (initialState.length !== numStates) {
            throw new ValueError(`RNN Layer has ${numStates} state(s) but was passed ${initialState.length} initial state(s).`);
          }
          if (this.unroll) {
            console.warn("Ignoring unroll = true for RNN layer, due to imperative backend.");
          }
          const cellCallKwargs = {training};
          const step4 = (inputs2, states2) => {
            const outputs2 = this.cell.call([inputs2].concat(states2), cellCallKwargs);
            return [outputs2[0], outputs2.slice(1)];
          };
          const rnnOutputs = rnn(step4, inputs, initialState, this.goBackwards, mask, null, this.unroll, this.returnSequences);
          const lastOutput = rnnOutputs[0];
          const outputs = rnnOutputs[1];
          const states = rnnOutputs[2];
          if (this.stateful) {
            this.resetStates(states, training);
          }
          const output = this.returnSequences ? outputs : lastOutput;
          if (this.returnState) {
            return [output].concat(states);
          } else {
            return output;
          }
        });
      }
      getInitialState(inputs) {
        return tidy(() => {
          let initialState = zeros3(inputs.shape);
          initialState = sum$1(initialState, [1, 2]);
          initialState = expandDims$1(initialState);
          if (Array.isArray(this.cell.stateSize)) {
            return this.cell.stateSize.map((dim) => dim > 1 ? tile$2(initialState, [1, dim]) : initialState);
          } else {
            return this.cell.stateSize > 1 ? [tile$2(initialState, [1, this.cell.stateSize])] : [initialState];
          }
        });
      }
      get trainableWeights() {
        if (!this.trainable) {
          return [];
        }
        return this.cell.trainableWeights;
      }
      get nonTrainableWeights() {
        if (!this.trainable) {
          return this.cell.weights;
        }
        return this.cell.nonTrainableWeights;
      }
      setFastWeightInitDuringBuild(value) {
        super.setFastWeightInitDuringBuild(value);
        if (this.cell != null) {
          this.cell.setFastWeightInitDuringBuild(value);
        }
      }
      getConfig() {
        const baseConfig = super.getConfig();
        const config2 = {
          returnSequences: this.returnSequences,
          returnState: this.returnState,
          goBackwards: this.goBackwards,
          stateful: this.stateful,
          unroll: this.unroll
        };
        if (this.numConstants != null) {
          config2["numConstants"] = this.numConstants;
        }
        const cellConfig = this.cell.getConfig();
        if (this.getClassName() === RNN.className) {
          config2["cell"] = {
            className: this.cell.getClassName(),
            config: cellConfig
          };
        }
        return Object.assign({}, cellConfig, baseConfig, config2);
      }
      static fromConfig(cls, config2, customObjects = {}) {
        const cellConfig = config2["cell"];
        const cell = deserialize(cellConfig, customObjects);
        return new cls(Object.assign(config2, {cell}));
      }
    }
    RNN.className = "RNN";
    registerClass(RNN);
    class RNNCell extends Layer {
    }
    class SimpleRNNCell extends RNNCell {
      constructor(args) {
        super(args);
        this.DEFAULT_ACTIVATION = "tanh";
        this.DEFAULT_KERNEL_INITIALIZER = "glorotNormal";
        this.DEFAULT_RECURRENT_INITIALIZER = "orthogonal";
        this.DEFAULT_BIAS_INITIALIZER = "zeros";
        this.units = args.units;
        assertPositiveInteger(this.units, `units`);
        this.activation = getActivation(args.activation == null ? this.DEFAULT_ACTIVATION : args.activation);
        this.useBias = args.useBias == null ? true : args.useBias;
        this.kernelInitializer = getInitializer(args.kernelInitializer || this.DEFAULT_KERNEL_INITIALIZER);
        this.recurrentInitializer = getInitializer(args.recurrentInitializer || this.DEFAULT_RECURRENT_INITIALIZER);
        this.biasInitializer = getInitializer(args.biasInitializer || this.DEFAULT_BIAS_INITIALIZER);
        this.kernelRegularizer = getRegularizer(args.kernelRegularizer);
        this.recurrentRegularizer = getRegularizer(args.recurrentRegularizer);
        this.biasRegularizer = getRegularizer(args.biasRegularizer);
        this.kernelConstraint = getConstraint(args.kernelConstraint);
        this.recurrentConstraint = getConstraint(args.recurrentConstraint);
        this.biasConstraint = getConstraint(args.biasConstraint);
        this.dropout = min$1([1, max$1([0, args.dropout == null ? 0 : args.dropout])]);
        this.recurrentDropout = min$1([
          1,
          max$1([0, args.recurrentDropout == null ? 0 : args.recurrentDropout])
        ]);
        this.stateSize = this.units;
        this.dropoutMask = null;
        this.recurrentDropoutMask = null;
      }
      build(inputShape) {
        inputShape = getExactlyOneShape(inputShape);
        this.kernel = this.addWeight("kernel", [inputShape[inputShape.length - 1], this.units], null, this.kernelInitializer, this.kernelRegularizer, true, this.kernelConstraint);
        this.recurrentKernel = this.addWeight("recurrent_kernel", [this.units, this.units], null, this.recurrentInitializer, this.recurrentRegularizer, true, this.recurrentConstraint);
        if (this.useBias) {
          this.bias = this.addWeight("bias", [this.units], null, this.biasInitializer, this.biasRegularizer, true, this.biasConstraint);
        } else {
          this.bias = null;
        }
        this.built = true;
      }
      call(inputs, kwargs) {
        return tidy(() => {
          inputs = inputs;
          if (inputs.length !== 2) {
            throw new ValueError(`SimpleRNNCell expects 2 input Tensors, got ${inputs.length}.`);
          }
          let prevOutput = inputs[1];
          inputs = inputs[0];
          const training = kwargs["training"] == null ? false : kwargs["training"];
          if (0 < this.dropout && this.dropout < 1 && this.dropoutMask == null) {
            this.dropoutMask = generateDropoutMask({
              ones: () => onesLike2(inputs),
              rate: this.dropout,
              training
            });
          }
          if (0 < this.recurrentDropout && this.recurrentDropout < 1 && this.recurrentDropoutMask == null) {
            this.recurrentDropoutMask = generateDropoutMask({
              ones: () => onesLike2(prevOutput),
              rate: this.recurrentDropout,
              training
            });
          }
          let h;
          const dpMask = this.dropoutMask;
          const recDpMask = this.recurrentDropoutMask;
          if (dpMask != null) {
            h = dot$1(mul3(inputs, dpMask), this.kernel.read());
          } else {
            h = dot$1(inputs, this.kernel.read());
          }
          if (this.bias != null) {
            h = biasAdd(h, this.bias.read());
          }
          if (recDpMask != null) {
            prevOutput = mul3(prevOutput, recDpMask);
          }
          let output = add$1(h, dot$1(prevOutput, this.recurrentKernel.read()));
          if (this.activation != null) {
            output = this.activation.apply(output);
          }
          return [output, output];
        });
      }
      getConfig() {
        const baseConfig = super.getConfig();
        const config2 = {
          units: this.units,
          activation: serializeActivation(this.activation),
          useBias: this.useBias,
          kernelInitializer: serializeInitializer(this.kernelInitializer),
          recurrentInitializer: serializeInitializer(this.recurrentInitializer),
          biasInitializer: serializeInitializer(this.biasInitializer),
          kernelRegularizer: serializeRegularizer(this.kernelRegularizer),
          recurrentRegularizer: serializeRegularizer(this.recurrentRegularizer),
          biasRegularizer: serializeRegularizer(this.biasRegularizer),
          activityRegularizer: serializeRegularizer(this.activityRegularizer),
          kernelConstraint: serializeConstraint(this.kernelConstraint),
          recurrentConstraint: serializeConstraint(this.recurrentConstraint),
          biasConstraint: serializeConstraint(this.biasConstraint),
          dropout: this.dropout,
          recurrentDropout: this.recurrentDropout
        };
        return Object.assign({}, baseConfig, config2);
      }
    }
    SimpleRNNCell.className = "SimpleRNNCell";
    registerClass(SimpleRNNCell);
    class SimpleRNN extends RNN {
      constructor(args) {
        args.cell = new SimpleRNNCell(args);
        super(args);
      }
      call(inputs, kwargs) {
        return tidy(() => {
          if (this.cell.dropoutMask != null) {
            dispose(this.cell.dropoutMask);
            this.cell.dropoutMask = null;
          }
          if (this.cell.recurrentDropoutMask != null) {
            dispose(this.cell.recurrentDropoutMask);
            this.cell.recurrentDropoutMask = null;
          }
          const mask = kwargs == null ? null : kwargs["mask"];
          const training = kwargs == null ? null : kwargs["training"];
          const initialState = kwargs == null ? null : kwargs["initialState"];
          return super.call(inputs, {mask, training, initialState});
        });
      }
      static fromConfig(cls, config2) {
        return new cls(config2);
      }
    }
    SimpleRNN.className = "SimpleRNN";
    registerClass(SimpleRNN);
    class GRUCell extends RNNCell {
      constructor(args) {
        super(args);
        this.DEFAULT_ACTIVATION = "tanh";
        this.DEFAULT_RECURRENT_ACTIVATION = "hardSigmoid";
        this.DEFAULT_KERNEL_INITIALIZER = "glorotNormal";
        this.DEFAULT_RECURRENT_INITIALIZER = "orthogonal";
        this.DEFAULT_BIAS_INITIALIZER = "zeros";
        if (args.resetAfter) {
          throw new ValueError(`GRUCell does not support reset_after parameter set to true.`);
        }
        this.units = args.units;
        assertPositiveInteger(this.units, "units");
        this.activation = getActivation(args.activation === void 0 ? this.DEFAULT_ACTIVATION : args.activation);
        this.recurrentActivation = getActivation(args.recurrentActivation === void 0 ? this.DEFAULT_RECURRENT_ACTIVATION : args.recurrentActivation);
        this.useBias = args.useBias == null ? true : args.useBias;
        this.kernelInitializer = getInitializer(args.kernelInitializer || this.DEFAULT_KERNEL_INITIALIZER);
        this.recurrentInitializer = getInitializer(args.recurrentInitializer || this.DEFAULT_RECURRENT_INITIALIZER);
        this.biasInitializer = getInitializer(args.biasInitializer || this.DEFAULT_BIAS_INITIALIZER);
        this.kernelRegularizer = getRegularizer(args.kernelRegularizer);
        this.recurrentRegularizer = getRegularizer(args.recurrentRegularizer);
        this.biasRegularizer = getRegularizer(args.biasRegularizer);
        this.kernelConstraint = getConstraint(args.kernelConstraint);
        this.recurrentConstraint = getConstraint(args.recurrentConstraint);
        this.biasConstraint = getConstraint(args.biasConstraint);
        this.dropout = min$1([1, max$1([0, args.dropout == null ? 0 : args.dropout])]);
        this.recurrentDropout = min$1([
          1,
          max$1([0, args.recurrentDropout == null ? 0 : args.recurrentDropout])
        ]);
        this.implementation = args.implementation;
        this.stateSize = this.units;
        this.dropoutMask = null;
        this.recurrentDropoutMask = null;
      }
      build(inputShape) {
        inputShape = getExactlyOneShape(inputShape);
        const inputDim = inputShape[inputShape.length - 1];
        this.kernel = this.addWeight("kernel", [inputDim, this.units * 3], null, this.kernelInitializer, this.kernelRegularizer, true, this.kernelConstraint);
        this.recurrentKernel = this.addWeight("recurrent_kernel", [this.units, this.units * 3], null, this.recurrentInitializer, this.recurrentRegularizer, true, this.recurrentConstraint);
        if (this.useBias) {
          this.bias = this.addWeight("bias", [this.units * 3], null, this.biasInitializer, this.biasRegularizer, true, this.biasConstraint);
        } else {
          this.bias = null;
        }
        this.built = true;
      }
      call(inputs, kwargs) {
        return tidy(() => {
          inputs = inputs;
          if (inputs.length !== 2) {
            throw new ValueError(`GRUCell expects 2 input Tensors (inputs, h, c), got ${inputs.length}.`);
          }
          const training = kwargs["training"] == null ? false : kwargs["training"];
          let hTMinus1 = inputs[1];
          inputs = inputs[0];
          if (0 < this.dropout && this.dropout < 1 && this.dropoutMask == null) {
            this.dropoutMask = generateDropoutMask({
              ones: () => onesLike2(inputs),
              rate: this.dropout,
              training,
              count: 3
            });
          }
          if (0 < this.recurrentDropout && this.recurrentDropout < 1 && this.recurrentDropoutMask == null) {
            this.recurrentDropoutMask = generateDropoutMask({
              ones: () => onesLike2(hTMinus1),
              rate: this.recurrentDropout,
              training,
              count: 3
            });
          }
          const dpMask = this.dropoutMask;
          const recDpMask = this.recurrentDropoutMask;
          let z;
          let r;
          let hh;
          if (0 < this.dropout && this.dropout < 1) {
            inputs = mul3(inputs, dpMask[0]);
          }
          let matrixX = dot$1(inputs, this.kernel.read());
          if (this.useBias) {
            matrixX = biasAdd(matrixX, this.bias.read());
          }
          if (0 < this.recurrentDropout && this.recurrentDropout < 1) {
            hTMinus1 = mul3(hTMinus1, recDpMask[0]);
          }
          const recurrentKernelValue = this.recurrentKernel.read();
          const [rk1, rk2] = split2(recurrentKernelValue, [2 * this.units, this.units], recurrentKernelValue.rank - 1);
          const matrixInner = dot$1(hTMinus1, rk1);
          const [xZ, xR, xH] = split2(matrixX, 3, matrixX.rank - 1);
          const [recurrentZ, recurrentR] = split2(matrixInner, 2, matrixInner.rank - 1);
          z = this.recurrentActivation.apply(add$1(xZ, recurrentZ));
          r = this.recurrentActivation.apply(add$1(xR, recurrentR));
          const recurrentH = dot$1(mul3(r, hTMinus1), rk2);
          hh = this.activation.apply(add$1(xH, recurrentH));
          const h = add$1(mul3(z, hTMinus1), mul3(add$1(1, neg(z)), hh));
          return [h, h];
        });
      }
      getConfig() {
        const baseConfig = super.getConfig();
        const config2 = {
          units: this.units,
          activation: serializeActivation(this.activation),
          recurrentActivation: serializeActivation(this.recurrentActivation),
          useBias: this.useBias,
          kernelInitializer: serializeInitializer(this.kernelInitializer),
          recurrentInitializer: serializeInitializer(this.recurrentInitializer),
          biasInitializer: serializeInitializer(this.biasInitializer),
          kernelRegularizer: serializeRegularizer(this.kernelRegularizer),
          recurrentRegularizer: serializeRegularizer(this.recurrentRegularizer),
          biasRegularizer: serializeRegularizer(this.biasRegularizer),
          activityRegularizer: serializeRegularizer(this.activityRegularizer),
          kernelConstraint: serializeConstraint(this.kernelConstraint),
          recurrentConstraint: serializeConstraint(this.recurrentConstraint),
          biasConstraint: serializeConstraint(this.biasConstraint),
          dropout: this.dropout,
          recurrentDropout: this.recurrentDropout,
          implementation: this.implementation,
          resetAfter: false
        };
        return Object.assign({}, baseConfig, config2);
      }
    }
    GRUCell.className = "GRUCell";
    registerClass(GRUCell);
    class GRU extends RNN {
      constructor(args) {
        if (args.implementation === 0) {
          console.warn("`implementation=0` has been deprecated, and now defaults to `implementation=1`. Please update your layer call.");
        }
        args.cell = new GRUCell(args);
        super(args);
      }
      call(inputs, kwargs) {
        return tidy(() => {
          if (this.cell.dropoutMask != null) {
            dispose(this.cell.dropoutMask);
            this.cell.dropoutMask = null;
          }
          if (this.cell.recurrentDropoutMask != null) {
            dispose(this.cell.recurrentDropoutMask);
            this.cell.recurrentDropoutMask = null;
          }
          const mask = kwargs == null ? null : kwargs["mask"];
          const training = kwargs == null ? null : kwargs["training"];
          const initialState = kwargs == null ? null : kwargs["initialState"];
          return super.call(inputs, {mask, training, initialState});
        });
      }
      static fromConfig(cls, config2) {
        if (config2["implmentation"] === 0) {
          config2["implementation"] = 1;
        }
        return new cls(config2);
      }
    }
    GRU.className = "GRU";
    registerClass(GRU);
    class LSTMCell extends RNNCell {
      constructor(args) {
        super(args);
        this.DEFAULT_ACTIVATION = "tanh";
        this.DEFAULT_RECURRENT_ACTIVATION = "hardSigmoid";
        this.DEFAULT_KERNEL_INITIALIZER = "glorotNormal";
        this.DEFAULT_RECURRENT_INITIALIZER = "orthogonal";
        this.DEFAULT_BIAS_INITIALIZER = "zeros";
        this.units = args.units;
        assertPositiveInteger(this.units, "units");
        this.activation = getActivation(args.activation === void 0 ? this.DEFAULT_ACTIVATION : args.activation);
        this.recurrentActivation = getActivation(args.recurrentActivation === void 0 ? this.DEFAULT_RECURRENT_ACTIVATION : args.recurrentActivation);
        this.useBias = args.useBias == null ? true : args.useBias;
        this.kernelInitializer = getInitializer(args.kernelInitializer || this.DEFAULT_KERNEL_INITIALIZER);
        this.recurrentInitializer = getInitializer(args.recurrentInitializer || this.DEFAULT_RECURRENT_INITIALIZER);
        this.biasInitializer = getInitializer(args.biasInitializer || this.DEFAULT_BIAS_INITIALIZER);
        this.unitForgetBias = args.unitForgetBias;
        this.kernelRegularizer = getRegularizer(args.kernelRegularizer);
        this.recurrentRegularizer = getRegularizer(args.recurrentRegularizer);
        this.biasRegularizer = getRegularizer(args.biasRegularizer);
        this.kernelConstraint = getConstraint(args.kernelConstraint);
        this.recurrentConstraint = getConstraint(args.recurrentConstraint);
        this.biasConstraint = getConstraint(args.biasConstraint);
        this.dropout = min$1([1, max$1([0, args.dropout == null ? 0 : args.dropout])]);
        this.recurrentDropout = min$1([
          1,
          max$1([0, args.recurrentDropout == null ? 0 : args.recurrentDropout])
        ]);
        this.implementation = args.implementation;
        this.stateSize = [this.units, this.units];
        this.dropoutMask = null;
        this.recurrentDropoutMask = null;
      }
      build(inputShape) {
        var _a;
        inputShape = getExactlyOneShape(inputShape);
        const inputDim = inputShape[inputShape.length - 1];
        this.kernel = this.addWeight("kernel", [inputDim, this.units * 4], null, this.kernelInitializer, this.kernelRegularizer, true, this.kernelConstraint);
        this.recurrentKernel = this.addWeight("recurrent_kernel", [this.units, this.units * 4], null, this.recurrentInitializer, this.recurrentRegularizer, true, this.recurrentConstraint);
        let biasInitializer;
        if (this.useBias) {
          if (this.unitForgetBias) {
            const capturedBiasInit = this.biasInitializer;
            const capturedUnits = this.units;
            biasInitializer = new (_a = class CustomInit extends Initializer {
              apply(shape, dtype) {
                const bI = capturedBiasInit.apply([capturedUnits]);
                const bF = new Ones().apply([capturedUnits]);
                const bCAndH = capturedBiasInit.apply([capturedUnits * 2]);
                return concatAlongFirstAxis(concatAlongFirstAxis(bI, bF), bCAndH);
              }
            }, _a.className = "CustomInit", _a)();
          } else {
            biasInitializer = this.biasInitializer;
          }
          this.bias = this.addWeight("bias", [this.units * 4], null, biasInitializer, this.biasRegularizer, true, this.biasConstraint);
        } else {
          this.bias = null;
        }
        this.built = true;
      }
      call(inputs, kwargs) {
        return tidy(() => {
          const training = kwargs["training"] == null ? false : kwargs["training"];
          inputs = inputs;
          if (inputs.length !== 3) {
            throw new ValueError(`LSTMCell expects 3 input Tensors (inputs, h, c), got ${inputs.length}.`);
          }
          let hTMinus1 = inputs[1];
          const cTMinus1 = inputs[2];
          inputs = inputs[0];
          if (0 < this.dropout && this.dropout < 1 && this.dropoutMask == null) {
            this.dropoutMask = generateDropoutMask({
              ones: () => onesLike2(inputs),
              rate: this.dropout,
              training,
              count: 4
            });
          }
          if (0 < this.recurrentDropout && this.recurrentDropout < 1 && this.recurrentDropoutMask == null) {
            this.recurrentDropoutMask = generateDropoutMask({
              ones: () => onesLike2(hTMinus1),
              rate: this.recurrentDropout,
              training,
              count: 4
            });
          }
          const dpMask = this.dropoutMask;
          const recDpMask = this.recurrentDropoutMask;
          let i;
          let f;
          let c;
          let o;
          if (0 < this.dropout && this.dropout < 1) {
            inputs = mul3(inputs, dpMask[0]);
          }
          let z = dot$1(inputs, this.kernel.read());
          if (0 < this.recurrentDropout && this.recurrentDropout < 1) {
            hTMinus1 = mul3(hTMinus1, recDpMask[0]);
          }
          z = add$1(z, dot$1(hTMinus1, this.recurrentKernel.read()));
          if (this.useBias) {
            z = biasAdd(z, this.bias.read());
          }
          const [z0, z1, z2, z3] = split2(z, 4, z.rank - 1);
          i = this.recurrentActivation.apply(z0);
          f = this.recurrentActivation.apply(z1);
          c = add$1(mul3(f, cTMinus1), mul3(i, this.activation.apply(z2)));
          o = this.recurrentActivation.apply(z3);
          const h = mul3(o, this.activation.apply(c));
          return [h, h, c];
        });
      }
      getConfig() {
        const baseConfig = super.getConfig();
        const config2 = {
          units: this.units,
          activation: serializeActivation(this.activation),
          recurrentActivation: serializeActivation(this.recurrentActivation),
          useBias: this.useBias,
          kernelInitializer: serializeInitializer(this.kernelInitializer),
          recurrentInitializer: serializeInitializer(this.recurrentInitializer),
          biasInitializer: serializeInitializer(this.biasInitializer),
          unitForgetBias: this.unitForgetBias,
          kernelRegularizer: serializeRegularizer(this.kernelRegularizer),
          recurrentRegularizer: serializeRegularizer(this.recurrentRegularizer),
          biasRegularizer: serializeRegularizer(this.biasRegularizer),
          activityRegularizer: serializeRegularizer(this.activityRegularizer),
          kernelConstraint: serializeConstraint(this.kernelConstraint),
          recurrentConstraint: serializeConstraint(this.recurrentConstraint),
          biasConstraint: serializeConstraint(this.biasConstraint),
          dropout: this.dropout,
          recurrentDropout: this.recurrentDropout,
          implementation: this.implementation
        };
        return Object.assign({}, baseConfig, config2);
      }
    }
    LSTMCell.className = "LSTMCell";
    registerClass(LSTMCell);
    class LSTM extends RNN {
      constructor(args) {
        if (args.implementation === 0) {
          console.warn("`implementation=0` has been deprecated, and now defaults to `implementation=1`. Please update your layer call.");
        }
        args.cell = new LSTMCell(args);
        super(args);
      }
      call(inputs, kwargs) {
        return tidy(() => {
          if (this.cell.dropoutMask != null) {
            dispose(this.cell.dropoutMask);
            this.cell.dropoutMask = null;
          }
          if (this.cell.recurrentDropoutMask != null) {
            dispose(this.cell.recurrentDropoutMask);
            this.cell.recurrentDropoutMask = null;
          }
          const mask = kwargs == null ? null : kwargs["mask"];
          const training = kwargs == null ? null : kwargs["training"];
          const initialState = kwargs == null ? null : kwargs["initialState"];
          return super.call(inputs, {mask, training, initialState});
        });
      }
      static fromConfig(cls, config2) {
        if (config2["implmentation"] === 0) {
          config2["implementation"] = 1;
        }
        return new cls(config2);
      }
    }
    LSTM.className = "LSTM";
    registerClass(LSTM);
    class StackedRNNCells extends RNNCell {
      constructor(args) {
        super(args);
        this.cells = args.cells;
      }
      get stateSize() {
        const stateSize = [];
        for (const cell of this.cells.slice().reverse()) {
          if (Array.isArray(cell.stateSize)) {
            stateSize.push(...cell.stateSize);
          } else {
            stateSize.push(cell.stateSize);
          }
        }
        return stateSize;
      }
      call(inputs, kwargs) {
        return tidy(() => {
          inputs = inputs;
          let states = inputs.slice(1);
          const nestedStates = [];
          for (const cell of this.cells.slice().reverse()) {
            if (Array.isArray(cell.stateSize)) {
              nestedStates.push(states.splice(0, cell.stateSize.length));
            } else {
              nestedStates.push(states.splice(0, 1));
            }
          }
          nestedStates.reverse();
          const newNestedStates = [];
          let callInputs;
          for (let i = 0; i < this.cells.length; ++i) {
            const cell = this.cells[i];
            states = nestedStates[i];
            if (i === 0) {
              callInputs = [inputs[0]].concat(states);
            } else {
              callInputs = [callInputs[0]].concat(states);
            }
            callInputs = cell.call(callInputs, kwargs);
            newNestedStates.push(callInputs.slice(1));
          }
          states = [];
          for (const cellStates of newNestedStates.slice().reverse()) {
            states.push(...cellStates);
          }
          return [callInputs[0]].concat(states);
        });
      }
      build(inputShape) {
        if (isArrayOfShapes(inputShape)) {
          inputShape = inputShape[0];
        }
        inputShape = inputShape;
        let outputDim;
        this.cells.forEach((cell, i) => {
          nameScope(`RNNCell_${i}`, () => {
            cell.build(inputShape);
            if (Array.isArray(cell.stateSize)) {
              outputDim = cell.stateSize[0];
            } else {
              outputDim = cell.stateSize;
            }
            inputShape = [inputShape[0], outputDim];
          });
        });
        this.built = true;
      }
      getConfig() {
        const baseConfig = super.getConfig();
        const getCellConfig = (cell) => {
          return {
            className: cell.getClassName(),
            config: cell.getConfig()
          };
        };
        const cellConfigs = this.cells.map(getCellConfig);
        const config2 = {cells: cellConfigs};
        return Object.assign({}, baseConfig, config2);
      }
      static fromConfig(cls, config2, customObjects = {}) {
        const cells = [];
        for (const cellConfig of config2["cells"]) {
          cells.push(deserialize(cellConfig, customObjects));
        }
        return new cls({cells});
      }
      get trainableWeights() {
        if (!this.trainable) {
          return [];
        }
        const weights = [];
        for (const cell of this.cells) {
          weights.push(...cell.trainableWeights);
        }
        return weights;
      }
      get nonTrainableWeights() {
        const weights = [];
        for (const cell of this.cells) {
          weights.push(...cell.nonTrainableWeights);
        }
        if (!this.trainable) {
          const trainableWeights = [];
          for (const cell of this.cells) {
            trainableWeights.push(...cell.trainableWeights);
          }
          return trainableWeights.concat(weights);
        }
        return weights;
      }
      getWeights() {
        const weights = [];
        for (const cell of this.cells) {
          weights.push(...cell.weights);
        }
        return batchGetValue(weights);
      }
      setWeights(weights) {
        const tuples = [];
        for (const cell of this.cells) {
          const numParams = cell.weights.length;
          const inputWeights = weights.splice(numParams);
          for (let i = 0; i < cell.weights.length; ++i) {
            tuples.push([cell.weights[i], inputWeights[i]]);
          }
        }
        batchSetValue(tuples);
      }
    }
    StackedRNNCells.className = "StackedRNNCells";
    registerClass(StackedRNNCells);
    function generateDropoutMask(args) {
      const {ones: ones3, rate, training = false, count: count2 = 1} = args;
      const droppedInputs = () => dropout$1(ones3(), rate);
      const createMask = () => inTrainPhase(droppedInputs, ones3, training);
      if (!count2 || count2 <= 1) {
        return keep(createMask().clone());
      }
      const masks = Array(count2).fill(void 0).map(createMask);
      return masks.map((m) => keep(m.clone()));
    }
    /**
     * @license
     * Copyright 2020 Google LLC
     *
     * Use of this source code is governed by an MIT-style
     * license that can be found in the LICENSE file or at
     * https://opensource.org/licenses/MIT.
     * =============================================================================
     */
    var __rest = function(s, e) {
      var t = {};
      for (var p2 in s)
        if (Object.prototype.hasOwnProperty.call(s, p2) && e.indexOf(p2) < 0)
          t[p2] = s[p2];
      if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p2 = Object.getOwnPropertySymbols(s); i < p2.length; i++) {
          if (e.indexOf(p2[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p2[i]))
            t[p2[i]] = s[p2[i]];
        }
      return t;
    };
    class ConvRNN2DCell extends RNNCell {
    }
    class ConvRNN2D extends RNN {
      constructor(args) {
        if (args.unroll) {
          throw new NotImplementedError("Unrolling is not possible with convolutional RNNs.");
        }
        if (Array.isArray(args.cell)) {
          throw new NotImplementedError("It is not possible at the moment to stack convolutional cells.");
        }
        super(args);
        this.inputSpec = [new InputSpec({ndim: 5})];
      }
      call(inputs, kwargs) {
        return tidy(() => {
          if (this.cell.dropoutMask != null) {
            dispose(this.cell.dropoutMask);
            this.cell.dropoutMask = null;
          }
          if (this.cell.recurrentDropoutMask != null) {
            dispose(this.cell.recurrentDropoutMask);
            this.cell.recurrentDropoutMask = null;
          }
          if (kwargs && kwargs["constants"]) {
            throw new ValueError("ConvRNN2D cell does not support constants");
          }
          const mask = kwargs == null ? null : kwargs["mask"];
          const training = kwargs == null ? null : kwargs["training"];
          const initialState = kwargs == null ? null : kwargs["initialState"];
          return super.call(inputs, {mask, training, initialState});
        });
      }
      computeOutputShape(inputShape) {
        let outShape = this.computeSingleOutputShape(inputShape);
        if (!this.returnSequences) {
          outShape = [outShape[0], ...outShape.slice(2)];
        }
        if (this.returnState) {
          outShape = [outShape, ...Array(2).fill([inputShape[0], ...outShape.slice(-3)])];
        }
        return outShape;
      }
      getInitialState(inputs) {
        return tidy(() => {
          const {stateSize} = this.cell;
          const inputShape = inputs.shape;
          const outputShape = this.computeSingleOutputShape(inputShape);
          const stateShape = [outputShape[0], ...outputShape.slice(2)];
          const initialState = zeros3(stateShape);
          if (Array.isArray(stateSize)) {
            return Array(stateSize.length).fill(initialState);
          }
          return [initialState];
        });
      }
      resetStates(states, training = false) {
        tidy(() => {
          if (!this.stateful) {
            throw new AttributeError("Cannot call resetStates() on an RNN Layer that is not stateful.");
          }
          const inputShape = this.inputSpec[0].shape;
          const outputShape = this.computeSingleOutputShape(inputShape);
          const stateShape = [outputShape[0], ...outputShape.slice(2)];
          const batchSize = inputShape[0];
          if (batchSize == null) {
            throw new ValueError("If an RNN is stateful, it needs to know its batch size. Specify the batch size of your input tensors: \n- If using a Sequential model, specify the batch size by passing a `batchInputShape` option to your first layer.\n- If using the functional API, specify the batch size by passing a `batchShape` option to your Input layer.");
          }
          if (this.getStates() == null) {
            if (Array.isArray(this.cell.stateSize)) {
              this.states_ = this.cell.stateSize.map(() => zeros3(stateShape));
            } else {
              this.states_ = [zeros3(stateShape)];
            }
          } else if (states == null) {
            dispose(this.states_);
            if (this.keptStates != null) {
              dispose(this.keptStates);
              this.keptStates = [];
            }
            if (Array.isArray(this.cell.stateSize)) {
              this.states_ = this.cell.stateSize.map(() => zeros3(stateShape));
            } else {
              this.states_[0] = zeros3(stateShape);
            }
          } else {
            if (!Array.isArray(states)) {
              states = [states];
            }
            if (states.length !== this.states_.length) {
              throw new ValueError(`Layer ${this.name} expects ${this.states_.length} state(s), but it received ${states.length} state value(s). Input received: ${states}`);
            }
            if (training) {
              this.keptStates.push(this.states_.slice());
            } else {
              dispose(this.states_);
            }
            for (let index2 = 0; index2 < this.states_.length; ++index2) {
              const value = states[index2];
              const expectedShape = stateShape;
              if (!arraysEqual2(value.shape, expectedShape)) {
                throw new ValueError(`State ${index2} is incompatible with layer ${this.name}: expected shape=${expectedShape}, received shape=${value.shape}`);
              }
              this.states_[index2] = value;
            }
          }
          this.states_ = this.states_.map((state) => keep(state.clone()));
        });
      }
      computeSingleOutputShape(inputShape) {
        const {dataFormat, filters, kernelSize, padding, strides, dilationRate} = this.cell;
        const isChannelsFirst = dataFormat === "channelsFirst";
        const h = inputShape[isChannelsFirst ? 3 : 2];
        const w = inputShape[isChannelsFirst ? 4 : 3];
        const hOut = convOutputLength(h, kernelSize[0], padding, strides[0], dilationRate[0]);
        const wOut = convOutputLength(w, kernelSize[1], padding, strides[1], dilationRate[1]);
        const outShape = [
          ...inputShape.slice(0, 2),
          ...isChannelsFirst ? [filters, hOut, wOut] : [hOut, wOut, filters]
        ];
        return outShape;
      }
    }
    ConvRNN2D.className = "ConvRNN2D";
    class ConvLSTM2DCell extends LSTMCell {
      constructor(args) {
        const {filters, kernelSize, strides, padding, dataFormat, dilationRate} = args;
        super(Object.assign({}, args, {units: filters}));
        this.filters = filters;
        assertPositiveInteger(this.filters, "filters");
        this.kernelSize = normalizeArray(kernelSize, 2, "kernelSize");
        this.kernelSize.forEach((size) => assertPositiveInteger(size, "kernelSize"));
        this.strides = normalizeArray(strides || 1, 2, "strides");
        this.strides.forEach((stride) => assertPositiveInteger(stride, "strides"));
        this.padding = padding || "valid";
        checkPaddingMode(this.padding);
        this.dataFormat = dataFormat || "channelsLast";
        checkDataFormat(this.dataFormat);
        this.dilationRate = normalizeArray(dilationRate || 1, 2, "dilationRate");
        this.dilationRate.forEach((rate) => assertPositiveInteger(rate, "dilationRate"));
      }
      build(inputShape) {
        var _a;
        inputShape = getExactlyOneShape(inputShape);
        const channelAxis = this.dataFormat === "channelsFirst" ? 1 : inputShape.length - 1;
        if (inputShape[channelAxis] == null) {
          throw new ValueError(`The channel dimension of the input should be defined. Found ${inputShape[channelAxis]}`);
        }
        const inputDim = inputShape[channelAxis];
        const numOfKernels = 4;
        const kernelShape = this.kernelSize.concat([inputDim, this.filters * numOfKernels]);
        this.kernel = this.addWeight("kernel", kernelShape, null, this.kernelInitializer, this.kernelRegularizer, true, this.kernelConstraint);
        const recurrentKernelShape = this.kernelSize.concat([this.filters, this.filters * numOfKernels]);
        this.recurrentKernel = this.addWeight("recurrent_kernel", recurrentKernelShape, null, this.recurrentInitializer, this.recurrentRegularizer, true, this.recurrentConstraint);
        if (this.useBias) {
          let biasInitializer;
          if (this.unitForgetBias) {
            const init2 = this.biasInitializer;
            const filters = this.filters;
            biasInitializer = new (_a = class CustomInit extends Initializer {
              apply(shape, dtype) {
                const biasI = init2.apply([filters]);
                const biasF = ones$1([filters]);
                const biasCAndO = init2.apply([filters * 2]);
                return concatenate([biasI, biasF, biasCAndO]);
              }
            }, _a.className = "CustomInit", _a)();
          } else {
            biasInitializer = this.biasInitializer;
          }
          this.bias = this.addWeight("bias", [this.filters * numOfKernels], null, biasInitializer, this.biasRegularizer, true, this.biasConstraint);
        }
        this.built = true;
      }
      call(inputs, kwargs) {
        return tidy(() => {
          if (inputs.length !== 3) {
            throw new ValueError(`ConvLSTM2DCell expects 3 input Tensors (inputs, h, c), got ${inputs.length}.`);
          }
          const training = kwargs["training"] || false;
          const x = inputs[0];
          const hTMinus1 = inputs[1];
          const cTMinus1 = inputs[2];
          const numOfKernels = 4;
          if (0 < this.dropout && this.dropout < 1 && this.dropoutMask == null) {
            this.dropoutMask = generateDropoutMask({
              ones: () => onesLike2(x),
              rate: this.dropout,
              training,
              count: numOfKernels
            });
          }
          const dropoutMask = this.dropoutMask;
          const applyDropout = (x2, mask, index2) => {
            if (!mask || !mask[index2]) {
              return x2;
            }
            return mul3(mask[index2], x2);
          };
          let xI = applyDropout(x, dropoutMask, 0);
          let xF = applyDropout(x, dropoutMask, 1);
          let xC = applyDropout(x, dropoutMask, 2);
          let xO = applyDropout(x, dropoutMask, 3);
          if (0 < this.recurrentDropout && this.recurrentDropout < 1 && this.recurrentDropoutMask == null) {
            this.recurrentDropoutMask = generateDropoutMask({
              ones: () => onesLike2(hTMinus1),
              rate: this.recurrentDropout,
              training,
              count: numOfKernels
            });
          }
          const recDropoutMask = this.recurrentDropoutMask;
          let hI = applyDropout(hTMinus1, recDropoutMask, 0);
          let hF = applyDropout(hTMinus1, recDropoutMask, 1);
          let hC = applyDropout(hTMinus1, recDropoutMask, 2);
          let hO = applyDropout(hTMinus1, recDropoutMask, 3);
          const kernelChannelAxis = 3;
          const [kernelI, kernelF, kernelC, kernelO] = split2(this.kernel.read(), numOfKernels, kernelChannelAxis);
          const [biasI, biasF, biasC, biasO] = this.useBias ? split2(this.bias.read(), numOfKernels) : [null, null, null, null];
          xI = this.inputConv(xI, kernelI, biasI, this.padding);
          xF = this.inputConv(xF, kernelF, biasF, this.padding);
          xC = this.inputConv(xC, kernelC, biasC, this.padding);
          xO = this.inputConv(xO, kernelO, biasO, this.padding);
          const [recKernelI, recKernelF, recKernelC, recKernelO] = split2(this.recurrentKernel.read(), numOfKernels, kernelChannelAxis);
          hI = this.recurrentConv(hI, recKernelI);
          hF = this.recurrentConv(hF, recKernelF);
          hC = this.recurrentConv(hC, recKernelC);
          hO = this.recurrentConv(hO, recKernelO);
          const i = this.recurrentActivation.apply(add$1(xI, hI));
          const f = this.recurrentActivation.apply(add$1(xF, hF));
          const c = add$1(mul3(f, cTMinus1), mul3(i, this.activation.apply(add$1(xC, hC))));
          const h = mul3(this.recurrentActivation.apply(add$1(xO, hO)), this.activation.apply(c));
          return [h, h, c];
        });
      }
      getConfig() {
        const _a = super.getConfig(), {units: _} = _a, baseConfig = __rest(_a, ["units"]);
        const config2 = {
          filters: this.filters,
          kernelSize: this.kernelSize,
          padding: this.padding,
          dataFormat: this.dataFormat,
          dilationRate: this.dilationRate,
          strides: this.strides
        };
        return Object.assign({}, baseConfig, config2);
      }
      inputConv(x, w, b, padding) {
        const out = conv2d2(x, w, this.strides, padding || "valid", this.dataFormat === "channelsFirst" ? "NCHW" : "NHWC", this.dilationRate);
        if (b) {
          return biasAdd(out, b, this.dataFormat);
        }
        return out;
      }
      recurrentConv(x, w) {
        const strides = 1;
        return conv2d2(x, w, strides, "same", this.dataFormat === "channelsFirst" ? "NCHW" : "NHWC");
      }
    }
    ConvLSTM2DCell.className = "ConvLSTM2DCell";
    registerClass(ConvLSTM2DCell);
    class ConvLSTM2D extends ConvRNN2D {
      constructor(args) {
        const cell = new ConvLSTM2DCell(args);
        super(Object.assign({}, args, {cell}));
      }
      static fromConfig(cls, config2) {
        return new cls(config2);
      }
    }
    ConvLSTM2D.className = "ConvLSTM2D";
    registerClass(ConvLSTM2D);
    /**
     * @license
     * Copyright 2018 Google LLC
     *
     * Use of this source code is governed by an MIT-style
     * license that can be found in the LICENSE file or at
     * https://opensource.org/licenses/MIT.
     * =============================================================================
     */
    class Dropout extends Layer {
      constructor(args) {
        super(args);
        this.rate = Math.max(Math.min(args.rate, 1), 0);
        this.noiseShape = args.noiseShape;
        this.seed = args.seed;
        this.supportsMasking = true;
      }
      getNoiseShape(input2) {
        if (this.noiseShape == null) {
          return this.noiseShape;
        }
        const inputShape = input2.shape;
        const noiseShape = [];
        for (let i = 0; i < this.noiseShape.length; ++i) {
          noiseShape.push(this.noiseShape[i] == null ? inputShape[i] : this.noiseShape[i]);
        }
        return noiseShape;
      }
      call(inputs, kwargs) {
        return tidy(() => {
          this.invokeCallHook(inputs, kwargs);
          const input2 = getExactlyOneTensor(inputs);
          if (0 < this.rate && this.rate < 1) {
            const training = kwargs["training"] == null ? false : kwargs["training"];
            const noiseShape = this.getNoiseShape(input2);
            const output = inTrainPhase(() => dropout$1(input2, this.rate, noiseShape, this.seed), () => input2, training);
            return output;
          }
          return inputs;
        });
      }
      getConfig() {
        const config2 = {
          rate: this.rate,
          noiseShape: this.noiseShape,
          seed: this.seed
        };
        const baseConfig = super.getConfig();
        Object.assign(config2, baseConfig);
        return config2;
      }
      dispose() {
        return super.dispose();
      }
    }
    Dropout.className = "Dropout";
    registerClass(Dropout);
    class SpatialDropout1D extends Dropout {
      constructor(args) {
        super(args);
        this.inputSpec = [{ndim: 3}];
      }
      getNoiseShape(input2) {
        const inputShape = input2.shape;
        return [inputShape[0], 1, inputShape[2]];
      }
    }
    SpatialDropout1D.className = "SpatialDropout1D";
    registerClass(SpatialDropout1D);
    class Dense extends Layer {
      constructor(args) {
        super(args);
        this.activation = null;
        this.useBias = true;
        this.kernel = null;
        this.bias = null;
        this.DEFAULT_KERNEL_INITIALIZER = "glorotNormal";
        this.DEFAULT_BIAS_INITIALIZER = "zeros";
        if (args.batchInputShape == null && args.inputShape == null && args.inputDim != null) {
          let batchSize = null;
          if (args.batchSize != null) {
            batchSize = args.batchSize;
          }
          this.batchInputShape = [batchSize, args.inputDim];
        }
        this.units = args.units;
        assertPositiveInteger(this.units, "units");
        this.activation = getActivation(args.activation);
        if (args.useBias != null) {
          this.useBias = args.useBias;
        }
        this.kernelInitializer = getInitializer(args.kernelInitializer || this.DEFAULT_KERNEL_INITIALIZER);
        this.biasInitializer = getInitializer(args.biasInitializer || this.DEFAULT_BIAS_INITIALIZER);
        this.kernelConstraint = getConstraint(args.kernelConstraint);
        this.biasConstraint = getConstraint(args.biasConstraint);
        this.kernelRegularizer = getRegularizer(args.kernelRegularizer);
        this.biasRegularizer = getRegularizer(args.biasRegularizer);
        this.activityRegularizer = getRegularizer(args.activityRegularizer);
        this.supportsMasking = true;
        this.inputSpec = [{minNDim: 2}];
      }
      build(inputShape) {
        inputShape = getExactlyOneShape(inputShape);
        const inputLastDim = inputShape[inputShape.length - 1];
        if (this.kernel == null) {
          this.kernel = this.addWeight("kernel", [inputLastDim, this.units], null, this.kernelInitializer, this.kernelRegularizer, true, this.kernelConstraint);
          if (this.useBias) {
            this.bias = this.addWeight("bias", [this.units], null, this.biasInitializer, this.biasRegularizer, true, this.biasConstraint);
          }
        }
        this.inputSpec = [{minNDim: 2, axes: {[-1]: inputLastDim}}];
        this.built = true;
      }
      computeOutputShape(inputShape) {
        inputShape = getExactlyOneShape(inputShape);
        const outputShape = inputShape.slice();
        outputShape[outputShape.length - 1] = this.units;
        return outputShape;
      }
      call(inputs, kwargs) {
        return tidy(() => {
          this.invokeCallHook(inputs, kwargs);
          const input2 = getExactlyOneTensor(inputs);
          const fusedActivationName = mapActivationToFusedKernel(this.activation.getClassName());
          let output;
          if (fusedActivationName != null) {
            output = dot$1(input2, this.kernel.read(), fusedActivationName, this.bias ? this.bias.read() : null);
          } else {
            output = dot$1(input2, this.kernel.read());
            if (this.bias != null) {
              output = biasAdd(output, this.bias.read());
            }
            if (this.activation != null) {
              output = this.activation.apply(output);
            }
          }
          return output;
        });
      }
      getConfig() {
        const config2 = {
          units: this.units,
          activation: serializeActivation(this.activation),
          useBias: this.useBias,
          kernelInitializer: serializeInitializer(this.kernelInitializer),
          biasInitializer: serializeInitializer(this.biasInitializer),
          kernelRegularizer: serializeRegularizer(this.kernelRegularizer),
          biasRegularizer: serializeRegularizer(this.biasRegularizer),
          activityRegularizer: serializeRegularizer(this.activityRegularizer),
          kernelConstraint: serializeConstraint(this.kernelConstraint),
          biasConstraint: serializeConstraint(this.biasConstraint)
        };
        const baseConfig = super.getConfig();
        Object.assign(config2, baseConfig);
        return config2;
      }
    }
    Dense.className = "Dense";
    registerClass(Dense);
    class Flatten extends Layer {
      constructor(args) {
        args = args || {};
        super(args);
        this.inputSpec = [{minNDim: 3}];
        this.dataFormat = args.dataFormat;
      }
      computeOutputShape(inputShape) {
        inputShape = getExactlyOneShape(inputShape);
        for (const dim of inputShape.slice(1)) {
          if (dim == null) {
            throw new ValueError(`The shape of the input to "Flatten" is not fully defined (got ${inputShape.slice(1)}). Make sure to pass a complete "input_shape" or "batch_input_shape" argument to the first layer in your model.`);
          }
        }
        return [inputShape[0], arrayProd(inputShape, 1)];
      }
      call(inputs, kwargs) {
        return tidy(() => {
          this.invokeCallHook(inputs, kwargs);
          let input2 = getExactlyOneTensor(inputs);
          if (this.dataFormat === "channelsFirst" && input2.rank > 1) {
            const permutation = [0];
            for (let i = 2; i < input2.rank; ++i) {
              permutation.push(i);
            }
            permutation.push(1);
            input2 = input2.transpose(permutation);
          }
          return batchFlatten(input2);
        });
      }
      getConfig() {
        const config2 = {};
        if (this.dataFormat != null) {
          config2["dataFormat"] = this.dataFormat;
        }
        const baseConfig = super.getConfig();
        Object.assign(config2, baseConfig);
        return config2;
      }
    }
    Flatten.className = "Flatten";
    registerClass(Flatten);
    class Activation$1 extends Layer {
      constructor(args) {
        super(args);
        this.supportsMasking = true;
        this.activation = getActivation(args.activation);
      }
      call(inputs, kwargs) {
        return tidy(() => {
          this.invokeCallHook(inputs, kwargs);
          const input2 = getExactlyOneTensor(inputs);
          return this.activation.apply(input2);
        });
      }
      getConfig() {
        const config2 = {activation: serializeActivation(this.activation)};
        const baseConfig = super.getConfig();
        Object.assign(config2, baseConfig);
        return config2;
      }
    }
    Activation$1.className = "Activation";
    registerClass(Activation$1);
    class RepeatVector extends Layer {
      constructor(args) {
        super(args);
        this.n = args.n;
        this.inputSpec = [{ndim: 2}];
      }
      computeOutputShape(inputShape) {
        return [inputShape[0], this.n, inputShape[1]];
      }
      call(inputs, kwargs) {
        return tidy(() => {
          inputs = getExactlyOneTensor(inputs);
          return repeat(inputs, this.n);
        });
      }
      getConfig() {
        const config2 = {
          n: this.n
        };
        const baseConfig = super.getConfig();
        Object.assign(config2, baseConfig);
        return config2;
      }
    }
    RepeatVector.className = "RepeatVector";
    registerClass(RepeatVector);
    class Reshape$1 extends Layer {
      constructor(args) {
        super(args);
        this.targetShape = args.targetShape;
        for (let i = 0; i < this.targetShape.length; ++i) {
          if (this.isUnknown(this.targetShape[i])) {
            this.targetShape[i] = null;
          }
        }
      }
      isUnknown(dim) {
        return dim < 0 || dim == null;
      }
      fixUnknownDimension(inputShape, outputShape) {
        const errorMsg = "Total size of new array must be unchanged.";
        const finalShape = outputShape.slice();
        let known = 1;
        let unknown = null;
        for (let i = 0; i < finalShape.length; ++i) {
          const dim = finalShape[i];
          if (this.isUnknown(dim)) {
            if (unknown === null) {
              unknown = i;
            } else {
              throw new ValueError("Can only specifiy one unknown dimension.");
            }
          } else {
            known *= dim;
          }
        }
        const originalSize = arrayProd(inputShape);
        if (unknown !== null) {
          if (known === 0 || originalSize % known !== 0) {
            throw new ValueError(errorMsg);
          }
          finalShape[unknown] = originalSize / known;
        } else if (originalSize !== known) {
          throw new ValueError(errorMsg);
        }
        return finalShape;
      }
      computeOutputShape(inputShape) {
        let anyUnknownDims = false;
        for (let i = 0; i < inputShape.length; ++i) {
          if (this.isUnknown(inputShape[i])) {
            anyUnknownDims = true;
            break;
          }
        }
        if (anyUnknownDims) {
          return inputShape.slice(0, 1).concat(this.targetShape);
        } else {
          return inputShape.slice(0, 1).concat(this.fixUnknownDimension(inputShape.slice(1), this.targetShape));
        }
      }
      call(inputs, kwargs) {
        return tidy(() => {
          this.invokeCallHook(inputs, kwargs);
          const input2 = getExactlyOneTensor(inputs);
          const inputShape = input2.shape;
          const outputShape = inputShape.slice(0, 1).concat(this.fixUnknownDimension(inputShape.slice(1), this.targetShape));
          return input2.reshape(outputShape);
        });
      }
      getConfig() {
        const config2 = {
          targetShape: this.targetShape
        };
        const baseConfig = super.getConfig();
        Object.assign(config2, baseConfig);
        return config2;
      }
    }
    Reshape$1.className = "Reshape";
    registerClass(Reshape$1);
    class Permute extends Layer {
      constructor(args) {
        super(args);
        if (args.dims == null) {
          throw new Error("Required configuration field `dims` is missing during Permute constructor call.");
        }
        if (!Array.isArray(args.dims)) {
          throw new Error(`Permute constructor requires \`dims\` to be an Array, but received ${args.dims} instead.`);
        }
        const expectedSortedIndices = range$1(1, args.dims.length + 1);
        if (!arraysEqual2(args.dims.slice().sort(), expectedSortedIndices)) {
          throw new Error("Invalid permutation `dims`: " + JSON.stringify(args.dims) + " `dims` must contain consecutive integers starting from 1.");
        }
        this.dims = args.dims;
        this.dimsIncludingBatch = [0].concat(this.dims);
        this.inputSpec = [new InputSpec({ndim: this.dims.length + 1})];
      }
      computeOutputShape(inputShape) {
        inputShape = getExactlyOneShape(inputShape);
        const outputShape = inputShape.slice();
        this.dims.forEach((dim, i) => {
          outputShape[i + 1] = inputShape[dim];
        });
        return outputShape;
      }
      call(inputs, kwargs) {
        return transpose4(getExactlyOneTensor(inputs), this.dimsIncludingBatch);
      }
      getConfig() {
        const config2 = {
          dims: this.dims
        };
        const baseConfig = super.getConfig();
        Object.assign(config2, baseConfig);
        return config2;
      }
    }
    Permute.className = "Permute";
    registerClass(Permute);
    class Masking extends Layer {
      constructor(args) {
        super(args == null ? {} : args);
        this.supportsMasking = true;
        if (args != null) {
          this.maskValue = args.maskValue == null ? 0 : args.maskValue;
        } else {
          this.maskValue = 0;
        }
      }
      computeOutputShape(inputShape) {
        return inputShape;
      }
      getConfig() {
        const baseConfig = super.getConfig();
        const config2 = {maskValue: this.maskValue};
        Object.assign(config2, baseConfig);
        return config2;
      }
      computeMask(inputs, mask) {
        const input2 = getExactlyOneTensor(inputs);
        const axis = -1;
        return any(notEqual(input2, this.maskValue), axis);
      }
      call(inputs, kwargs) {
        return tidy(() => {
          this.invokeCallHook(inputs, kwargs);
          const input2 = getExactlyOneTensor(inputs);
          const axis = -1;
          const keepDims = true;
          const booleanMask = any(notEqual(input2, this.maskValue), axis, keepDims);
          const output = input2.mul(booleanMask.asType(input2.dtype));
          return output;
        });
      }
    }
    Masking.className = "Masking";
    registerClass(Masking);
    /**
     * @license
     * Copyright 2018 Google LLC
     *
     * Use of this source code is governed by an MIT-style
     * license that can be found in the LICENSE file or at
     * https://opensource.org/licenses/MIT.
     * =============================================================================
     */
    class Embedding extends Layer {
      constructor(args) {
        super(args);
        this.embeddings = null;
        this.DEFAULT_EMBEDDINGS_INITIALIZER = "randomUniform";
        if (args.batchInputShape == null && args.inputShape == null) {
          let batchSize = null;
          if (args.batchSize != null) {
            batchSize = args.batchSize;
          }
          if (args.inputLength == null) {
            this.batchInputShape = [batchSize, null];
          } else {
            this.batchInputShape = [batchSize].concat(toList(args.inputLength));
          }
        }
        this.inputDim = args.inputDim;
        assertPositiveInteger(this.inputDim, "inputDim");
        this.outputDim = args.outputDim;
        assertPositiveInteger(this.outputDim, "outputDim");
        this.embeddingsInitializer = getInitializer(args.embeddingsInitializer || this.DEFAULT_EMBEDDINGS_INITIALIZER);
        this.embeddingsRegularizer = getRegularizer(args.embeddingsRegularizer);
        this.activityRegularizer = getRegularizer(args.activityRegularizer);
        this.embeddingsConstraint = getConstraint(args.embeddingsConstraint);
        this.maskZero = args.maskZero;
        this.supportsMasking = args.maskZero;
        this.inputLength = args.inputLength;
      }
      build(inputShape) {
        this.embeddings = this.addWeight("embeddings", [this.inputDim, this.outputDim], this.dtype, this.embeddingsInitializer, this.embeddingsRegularizer, true, this.embeddingsConstraint);
        this.built = true;
      }
      warnOnIncompatibleInputShape(inputShape) {
      }
      computeMask(inputs, mask) {
        return tidy(() => {
          if (!this.maskZero) {
            return null;
          } else {
            inputs = getExactlyOneTensor(inputs);
            return notEqual(inputs, zerosLike2(inputs));
          }
        });
      }
      computeOutputShape(inputShape) {
        inputShape = getExactlyOneShape(inputShape);
        if (this.inputLength == null) {
          return [...inputShape, this.outputDim];
        }
        const inLens = toList(this.inputLength);
        if (inLens.length !== inputShape.length - 1) {
          throw new ValueError(`"inputLength" is ${this.inputLength}, but received input shape has shape ${inputShape}`);
        } else {
          let i = 0;
          for (let k = 0; k < inLens.length; ++k) {
            const s1 = inLens[k];
            const s2 = inputShape[k + 1];
            if (s1 != null && s2 != null && s1 !== s2) {
              throw new ValueError(`"inputLength" is ${this.inputLength}, but received input shape has shape ${inputShape}`);
            } else if (s1 == null) {
              inLens[i] = s2;
            }
            i++;
          }
        }
        return [inputShape[0], ...inLens, this.outputDim];
      }
      call(inputs, kwargs) {
        return tidy(() => {
          this.invokeCallHook(inputs, kwargs);
          let input2 = getExactlyOneTensor(inputs);
          if (input2.dtype !== "int32") {
            input2 = cast$1(input2, "int32");
          }
          const output = gather$1(this.embeddings.read(), input2.as1D());
          return output.reshape(getExactlyOneShape(this.computeOutputShape(input2.shape)));
        });
      }
      getConfig() {
        const config2 = {
          inputDim: this.inputDim,
          outputDim: this.outputDim,
          embeddingsInitializer: serializeInitializer(this.embeddingsInitializer),
          embeddingsRegularizer: serializeRegularizer(this.embeddingsRegularizer),
          activityRegularizer: serializeRegularizer(this.activityRegularizer),
          embeddingsConstraint: serializeConstraint(this.embeddingsConstraint),
          maskZero: this.maskZero,
          inputLength: this.inputLength
        };
        const baseConfig = super.getConfig();
        Object.assign(config2, baseConfig);
        return config2;
      }
    }
    Embedding.className = "Embedding";
    registerClass(Embedding);
    /**
     * @license
     * Copyright 2018 Google LLC
     *
     * Use of this source code is governed by an MIT-style
     * license that can be found in the LICENSE file or at
     * https://opensource.org/licenses/MIT.
     * =============================================================================
     */
    class Merge extends Layer {
      constructor(args) {
        super(args || {});
        this.supportsMasking = true;
      }
      mergeFunction(inputs) {
        throw new NotImplementedError();
      }
      computeElementwiseOpOutputShape(shape1, shape2) {
        if (shape1 == null || shape2 == null) {
          return null;
        } else if (shape1.length < shape2.length) {
          return this.computeElementwiseOpOutputShape(shape2, shape1);
        } else if (shape2.length === 0) {
          return shape1;
        }
        const outputShape = shape1.slice(0, shape1.length - shape2.length);
        for (let k = 0; k < shape2.length; ++k) {
          const i = shape1[shape1.length - shape2.length + k];
          const j = shape2[k];
          if (i == null || j == null || i < 0 || j < 0) {
            outputShape.push(null);
          } else if (i === 1) {
            outputShape.push(j);
          } else if (j === 1) {
            outputShape.push(i);
          } else {
            if (i !== j) {
              throw new ValueError("Operands could not be broadcast together with shapes " + JSON.stringify(shape1) + " " + JSON.stringify(shape2));
            }
            outputShape.push(i);
          }
        }
        return outputShape;
      }
      build(inputShape) {
        if (Array.isArray(inputShape) && !Array.isArray(inputShape[0])) {
          inputShape = [getExactlyOneShape(inputShape)];
        }
        inputShape = inputShape;
        if (inputShape.length < 2) {
          throw new ValueError(`A merge layer should be called on an Array of at least 2 inputs. Got ${inputShape.length} input(s).`);
        }
        let batchSizes = [];
        for (const shape of inputShape) {
          if (shape != null && shape[0] !== null) {
            batchSizes.push(shape[0]);
          }
        }
        batchSizes = unique$1(batchSizes);
        if (batchSizes.length > 1) {
          throw new ValueError(`Can not merge tensors with different batch sizes. Got tensors with shapes: ${JSON.stringify(inputShape)}.`);
        }
        let outputShape = inputShape[0] == null ? null : inputShape[0].slice(1);
        for (let i = 1; i < inputShape.length; ++i) {
          const shape = inputShape[i] == null ? null : inputShape[i].slice(1);
          outputShape = this.computeElementwiseOpOutputShape(outputShape, shape);
        }
        const allRanks = inputShape.map((shape) => shape.length);
        if (inputShape.indexOf(null) === -1 && unique$1(allRanks).length === 1) {
          this.reshapeRequired = false;
        } else {
          this.reshapeRequired = true;
        }
      }
      call(inputs, kwargs) {
        return tidy(() => {
          inputs = inputs;
          if (this.reshapeRequired) {
            const reshapedInputs = [];
            const inputDims = inputs.map((input2) => input2.rank);
            if (inputDims.indexOf(null) === -1) {
              const maxNDim = max$1(inputDims);
              for (let x of inputs) {
                const xNDim = x.rank;
                for (let k = 0; k < maxNDim - xNDim; ++k) {
                  x = expandDims$1(x, 1);
                }
                reshapedInputs.push(x);
              }
              return this.mergeFunction(reshapedInputs);
            } else {
              let transposed = false;
              for (const x of inputs) {
                const xNDim = x.rank;
                if (xNDim == null) {
                  const xShape = x.shape;
                  const batchSize = xShape[0];
                  const newShape = xShape.slice(1).concat([batchSize]);
                  let xTransposed = x.reshape([batchSize].concat(arrayProd(xShape.slice(1))));
                  xTransposed = transpose4(xTransposed, [1, 0]);
                  xTransposed = xTransposed.reshape(newShape);
                  reshapedInputs.push(xTransposed);
                  transposed = true;
                } else if (xNDim > 1) {
                  const dims = range$1(1, xNDim).concat([0]);
                  reshapedInputs.push(transpose4(x, dims));
                  transposed = true;
                } else {
                  reshapedInputs.push(x);
                }
              }
              let y = this.mergeFunction(reshapedInputs);
              const yNDim = y.rank;
              if (transposed) {
                if (yNDim == null) {
                  const yShape = y.shape;
                  const yNDim2 = yShape.length;
                  const batchSize = yShape[yNDim2 - 1];
                  const newShape = [batchSize].concat(yShape.slice(0, yShape.length - 1));
                  y = transpose4(y.reshape([-1, batchSize]), [1, 0]).reshape(newShape);
                } else if (yNDim > 1) {
                  const dims = [yNDim - 1].concat(range$1(0, yNDim - 1));
                  y = transpose4(y, dims);
                }
              }
              return y;
            }
          } else {
            return this.mergeFunction(inputs);
          }
        });
      }
      computeOutputShape(inputShape) {
        inputShape = inputShape;
        let outputShape;
        if (inputShape[0] == null) {
          outputShape = null;
        } else {
          outputShape = inputShape[0].slice(1);
        }
        for (let i = 1; i < inputShape.length; ++i) {
          const shape = inputShape[i] == null ? null : inputShape[i].slice(1);
          outputShape = this.computeElementwiseOpOutputShape(outputShape, shape);
        }
        let batchSizes = [];
        for (const shape of inputShape) {
          if (shape != null && shape[0] !== null) {
            batchSizes.push(shape[0]);
          }
        }
        batchSizes = unique$1(batchSizes);
        if (batchSizes.length === 1) {
          outputShape = batchSizes.concat(outputShape);
        } else {
          outputShape = [null].concat(outputShape);
        }
        return outputShape;
      }
      computeMask(inputs, mask) {
        return tidy(() => {
          if (mask == null) {
            return null;
          }
          if (!Array.isArray(mask)) {
            throw new ValueError("`mask` should be an Array");
          }
          if (!Array.isArray(inputs)) {
            throw new ValueError("`inputs` should be an Array");
          }
          if (mask.length !== inputs.length) {
            throw new ValueError(`The Array 'inputs' and 'mask' are expected to have the same length, but have different lengths (${inputs.length} vs ${mask.length})`);
          }
          if (mask.every((m) => m == null)) {
            return null;
          }
          mask = mask.map((m) => m == null ? m : expandDims(m, 0));
          let output = mask[0];
          for (let i = 1; i < mask.length - 1; ++i) {
            output = logicalAnd(output, mask[i]);
          }
          return output;
        });
      }
    }
    class Add$1 extends Merge {
      constructor(args) {
        super(args);
      }
      mergeFunction(inputs) {
        return tidy(() => {
          let output = inputs[0].clone();
          for (let i = 1; i < inputs.length; ++i) {
            output = add$1(output, inputs[i]);
          }
          return output;
        });
      }
    }
    Add$1.className = "Add";
    registerClass(Add$1);
    function add$2(config2) {
      if (Array.isArray(config2)) {
        const layer = new Add$1({});
        return layer.apply(config2);
      } else {
        return new Add$1(config2);
      }
    }
    class Multiply$1 extends Merge {
      constructor(args) {
        super(args);
      }
      mergeFunction(inputs) {
        return tidy(() => {
          let output = inputs[0].clone();
          for (let i = 1; i < inputs.length; ++i) {
            output = mul3(output, inputs[i]);
          }
          return output;
        });
      }
    }
    Multiply$1.className = "Multiply";
    registerClass(Multiply$1);
    function multiply(config2) {
      if (Array.isArray(config2)) {
        const layer = new Multiply$1({});
        return layer.apply(config2);
      } else {
        return new Multiply$1(config2);
      }
    }
    class Average extends Merge {
      constructor(args) {
        super(args);
      }
      mergeFunction(inputs) {
        return tidy(() => {
          let output = inputs[0].clone();
          for (let i = 1; i < inputs.length; ++i) {
            output = add$1(output, inputs[i]);
          }
          return mul3(1 / inputs.length, output);
        });
      }
    }
    Average.className = "Average";
    registerClass(Average);
    function average(config2) {
      if (Array.isArray(config2)) {
        const layer = new Average({});
        return layer.apply(config2);
      } else {
        return new Average(config2);
      }
    }
    class Maximum$1 extends Merge {
      constructor(args) {
        super(args);
      }
      mergeFunction(inputs) {
        return tidy(() => {
          let output = inputs[0];
          for (let i = 1; i < inputs.length; ++i) {
            output = maximum(output, inputs[i]);
          }
          return output;
        });
      }
    }
    Maximum$1.className = "Maximum";
    registerClass(Maximum$1);
    function maximum$1(config2) {
      if (Array.isArray(config2)) {
        const layer = new Maximum$1({});
        return layer.apply(config2);
      } else {
        return new Maximum$1(config2);
      }
    }
    class Minimum$1 extends Merge {
      constructor(args) {
        super(args);
      }
      mergeFunction(inputs) {
        return tidy(() => {
          let output = inputs[0];
          for (let i = 1; i < inputs.length; ++i) {
            output = minimum(output, inputs[i]);
          }
          return output;
        });
      }
    }
    Minimum$1.className = "Minimum";
    registerClass(Minimum$1);
    function minimum$1(config2) {
      if (Array.isArray(config2)) {
        const layer = new Minimum$1({});
        return layer.apply(config2);
      } else {
        return new Minimum$1(config2);
      }
    }
    class Concatenate extends Merge {
      constructor(args) {
        super(args);
        this.DEFAULT_AXIS = -1;
        if (args == null) {
          args = {};
        }
        this.axis = args.axis == null ? this.DEFAULT_AXIS : args.axis;
        this.supportsMasking = true;
        this.reshapeRequired = false;
      }
      build(inputShape) {
        if (!(Array.isArray(inputShape) && Array.isArray(inputShape[0])) || inputShape.length === 1) {
          throw new ValueError("A `Concatenate` layer should be called on a list of at least 2 inputs");
        }
        inputShape = inputShape;
        let allNoneShape = true;
        for (const shape of inputShape) {
          if (shape != null) {
            allNoneShape = false;
            break;
          }
        }
        if (allNoneShape) {
          return;
        }
        const shapeSet = [];
        for (let i = 0; i < inputShape.length; ++i) {
          const shapeWithoutConcatAxis = inputShape[i].slice();
          shapeWithoutConcatAxis.splice(this.axis, 1);
          let exists = false;
          for (const shape of shapeSet) {
            if (arraysEqual2(shape, shapeWithoutConcatAxis)) {
              exists = true;
              break;
            }
          }
          if (!exists) {
            shapeSet.push(shapeWithoutConcatAxis);
          }
        }
        if (shapeSet.length > 1) {
          throw new ValueError("A `Concatenate` layer requires inputs with matching shapes except for the concat axis. Got input shapes: " + JSON.stringify(inputShape));
        }
      }
      mergeFunction(inputs) {
        return tidy(() => {
          return concatenate(inputs, this.axis);
        });
      }
      computeOutputShape(inputShape) {
        if (!(Array.isArray(inputShape) && Array.isArray(inputShape[0]))) {
          throw new ValueError("A `Concatenate` layer should be called on a list of inputs.");
        }
        const inputShapes = inputShape;
        const outputShape = inputShapes[0].slice();
        const axis = this.axis < 0 ? outputShape.length + this.axis : this.axis;
        for (const shape of inputShapes.slice(1)) {
          if (outputShape[axis] == null || shape[axis] == null) {
            outputShape[axis] = null;
            break;
          }
          outputShape[axis] += shape[axis];
        }
        return outputShape;
      }
      computeMask(inputs, mask) {
        if (mask == null) {
          return null;
        }
        if (!Array.isArray(mask)) {
          throw new ValueError("`mask` should be an array for Concatenate");
        }
        if (!Array.isArray(inputs)) {
          throw new ValueError("`inputs` should be an array for Concatenate");
        }
        if (mask.length !== inputs.length) {
          throw new ValueError(`Mismatch in the length of mask (${mask.length}) and the legnth of inputs (${inputs.length})`);
        }
        return tidy(() => {
          let allNullMasks = true;
          mask.forEach((m) => {
            if (m != null) {
              allNullMasks = false;
              return;
            }
          });
          if (allNullMasks) {
            return null;
          }
          const outputMasks = [];
          for (let i = 0; i < inputs.length; ++i) {
            if (mask[i] == null) {
              outputMasks.push(onesLike2(inputs[i]).asType("bool"));
            } else if (mask[i].rank < inputs[i].rank) {
              outputMasks.push(expandDims(mask[i], -1));
            } else {
              outputMasks.push(mask[i]);
            }
          }
          const concatenatedMasks = concat2(outputMasks, this.axis);
          return all(concatenatedMasks, -1, false);
        });
      }
      getConfig() {
        const config2 = {
          axis: this.axis
        };
        const baseConfig = super.getConfig();
        Object.assign(config2, baseConfig);
        return config2;
      }
    }
    Concatenate.className = "Concatenate";
    registerClass(Concatenate);
    function concatenate$1(config2) {
      if (Array.isArray(config2)) {
        const layer = new Concatenate({});
        return layer.apply(config2);
      } else {
        return new Concatenate(config2);
      }
    }
    function interpretAxis(axis, dim) {
      while (axis < 0) {
        axis += dim;
      }
      return axis;
    }
    function batchDot(x, y, axes) {
      if (x.shape.length > 3 || y.shape.length > 3) {
        throw new NotImplementedError("batchDot is not implemented for tensors of 4D or higher rank yet");
      }
      assert2(x.shape.length >= 2, () => `batchDot requires the rank of x to be >= 2, but got ${x.shape.length}`);
      assert2(x.shape.length >= 2, () => `batchDot requires the rank of y to be >= 2, but got ${y.shape.length}`);
      if (typeof axes === "number") {
        axes = [axes, axes];
      }
      if (x.dtype === "complex64" || y.dtype === "complex64") {
        throw new NotImplementedError("batchDot is not implemented for complex64-type Tensors yet.");
      }
      const xNDim = x.shape.length;
      const yNDim = y.shape.length;
      if (axes == null) {
        axes = [xNDim - 1, yNDim - 2];
      }
      const axesArray = axes;
      return tidy(() => {
        let diff;
        if (xNDim > yNDim) {
          diff = xNDim - yNDim;
          const diffShape = [];
          for (let i = 0; i < diff; ++i) {
            diffShape.push(1);
          }
          y = y.reshape(y.shape.concat(diffShape));
        } else if (yNDim > xNDim) {
          diff = yNDim - xNDim;
          const diffShape = [];
          for (let i = 0; i < diff; ++i) {
            diffShape.push(1);
          }
          x = x.reshape(x.shape.concat(diffShape));
        } else {
          diff = 0;
        }
        let out;
        if (x.shape.length === 2 && y.shape.length === 2) {
          if (axesArray[0] === axesArray[1]) {
            out = x.mul(y).sum(axesArray[0]);
          } else {
            out = x.transpose([1, 0]).mul(y).sum(axesArray[1]);
          }
        } else {
          const adjX = axesArray[0] !== x.shape.length - 1;
          const adjY = axesArray[1] === y.shape.length - 1;
          out = x.matMul(y, adjX, adjY);
        }
        if (diff > 0) {
          let idx;
          if (xNDim > yNDim) {
            idx = xNDim + yNDim - 3;
          } else {
            idx = xNDim - 1;
          }
          const squeezeAxes = [];
          for (let i = idx; i < idx + diff; ++i) {
            squeezeAxes.push(i);
          }
          out = out.squeeze(squeezeAxes);
        }
        if (out.shape.length === 1) {
          out = out.expandDims(1);
        }
        return out;
      });
    }
    class Dot extends Merge {
      constructor(args) {
        super(args);
        this.axes = args.axes;
        this.normalize = args.normalize == null ? false : args.normalize;
        this.supportsMasking = true;
        this.reshapeRequired = false;
      }
      build(inputShape) {
        assert2(Array.isArray(inputShape) && inputShape.length === 2 && Array.isArray(inputShape[0]) && Array.isArray(inputShape[1]), () => "A `Dot` layer should be called on a list of exactly 2 inputs.");
        const shape1 = inputShape[0];
        const shape2 = inputShape[1];
        if (shape1.length > 3 || shape2.length > 3) {
          throw new NotImplementedError("Dot layer does not support tensors of 4D or higher rank yet.");
        }
        const axes = this.interpretAxes(shape1, shape2);
        if (shape1[axes[0]] !== shape2[axes[1]]) {
          throw new ValueError(`Dimension incompatibility: ${shape1[axes[0]]} !== ${shape2[axes[1]]}`);
        }
      }
      mergeFunction(inputs) {
        if (inputs.length !== 2) {
          throw new ValueError(`A \`Dot\` layer must be called on exactly 2 inputs, but received ${inputs.length} input(s).`);
        }
        let x1 = inputs[0];
        let x2 = inputs[1];
        let axes;
        if (!Array.isArray(this.axes)) {
          axes = [
            interpretAxis(this.axes, x1.shape.length),
            interpretAxis(this.axes, x2.shape.length)
          ];
        } else {
          axes = this.axes.map((axis, i) => interpretAxis(axis, inputs[i].shape.length));
        }
        if (this.normalize) {
          x1 = l2Normalize(x1, axes[0]);
          x2 = l2Normalize(x2, axes[1]);
        }
        return batchDot(x1, x2, axes);
      }
      interpretAxes(shape1, shape2) {
        let axes;
        if (!Array.isArray(this.axes)) {
          axes = [
            interpretAxis(this.axes, shape1.length),
            interpretAxis(this.axes, shape2.length)
          ];
        } else {
          axes = this.axes;
        }
        return axes;
      }
      computeOutputShape(inputShape) {
        assert2(Array.isArray(inputShape) && inputShape.length === 2 && Array.isArray(inputShape[0]) && Array.isArray(inputShape[1]), () => "A `Dot` layer should be called on a list of exactly 2 inputs.");
        const shape1 = inputShape[0].slice();
        const shape2 = inputShape[1].slice();
        if (shape1.length > 3 || shape2.length > 3) {
          throw new NotImplementedError("Dot layer does not support tensors of 4D or higher rank yet.");
        }
        const axes = this.interpretAxes(shape1, shape2);
        shape1.splice(axes[0], 1);
        shape2.splice(axes[1], 1);
        shape2.splice(0, 1);
        const outputShape = shape1.concat(shape2);
        if (outputShape.length === 1) {
          outputShape.push(1);
        }
        return outputShape;
      }
      computeMask(inputs, mask) {
        return null;
      }
      getConfig() {
        const config2 = {
          axes: this.axes,
          normalize: this.normalize
        };
        const baseConfig = super.getConfig();
        Object.assign(config2, baseConfig);
        return config2;
      }
    }
    Dot.className = "Dot";
    registerClass(Dot);
    /**
     * @license
     * Copyright 2018 Google LLC
     *
     * Use of this source code is governed by an MIT-style
     * license that can be found in the LICENSE file or at
     * https://opensource.org/licenses/MIT.
     * =============================================================================
     */
    class GaussianNoise extends Layer {
      constructor(args) {
        super(args);
        this.supportsMasking = true;
        this.stddev = args.stddev;
      }
      computeOutputShape(inputShape) {
        return inputShape;
      }
      getConfig() {
        const baseConfig = super.getConfig();
        const config2 = {stddev: this.stddev};
        Object.assign(config2, baseConfig);
        return config2;
      }
      call(inputs, kwargs) {
        return tidy(() => {
          this.invokeCallHook(inputs, kwargs);
          const input2 = getExactlyOneTensor(inputs);
          const noised = () => randomNormal$1(input2.shape, 0, this.stddev).add(input2);
          const output = inTrainPhase(noised, () => input2, kwargs["training"] || false);
          return output;
        });
      }
    }
    GaussianNoise.className = "GaussianNoise";
    registerClass(GaussianNoise);
    class GaussianDropout extends Layer {
      constructor(args) {
        super(args);
        this.supportsMasking = true;
        this.rate = args.rate;
      }
      computeOutputShape(inputShape) {
        return inputShape;
      }
      getConfig() {
        const baseConfig = super.getConfig();
        const config2 = {rate: this.rate};
        Object.assign(config2, baseConfig);
        return config2;
      }
      call(inputs, kwargs) {
        return tidy(() => {
          this.invokeCallHook(inputs, kwargs);
          const input2 = getExactlyOneTensor(inputs);
          if (this.rate > 0 && this.rate < 1) {
            const noised = () => {
              const stddev = Math.sqrt(this.rate / (1 - this.rate));
              return input2.mul(randomNormal$1(input2.shape, 1, stddev));
            };
            return inTrainPhase(noised, () => input2, kwargs["training"] || false);
          }
          return input2;
        });
      }
    }
    GaussianDropout.className = "GaussianDropout";
    registerClass(GaussianDropout);
    class AlphaDropout extends Layer {
      constructor(args) {
        super(args);
        this.supportsMasking = true;
        this.rate = args.rate;
        this.noiseShape = args.noiseShape;
      }
      _getNoiseShape(inputs) {
        return this.noiseShape || getExactlyOneTensor(inputs).shape;
      }
      computeOutputShape(inputShape) {
        return inputShape;
      }
      getConfig() {
        const baseConfig = super.getConfig();
        const config2 = {rate: this.rate};
        Object.assign(config2, baseConfig);
        return config2;
      }
      call(inputs, kwargs) {
        return tidy(() => {
          if (this.rate < 1 && this.rate > 0) {
            const noiseShape = this._getNoiseShape(inputs);
            const droppedInputs = () => {
              const input2 = getExactlyOneTensor(inputs);
              const alpha = 1.6732632423543772;
              const scale2 = 1.0507009873554805;
              const alphaP = -alpha * scale2;
              let keptIdx = greaterEqual(randomUniform(noiseShape), this.rate);
              keptIdx = cast$1(keptIdx, "float32");
              const a = ((1 - this.rate) * (1 + this.rate * alphaP ** 2)) ** -0.5;
              const b = -a * alphaP * this.rate;
              const x = input2.mul(keptIdx).add(keptIdx.add(-1).mul(alphaP));
              return x.mul(a).add(b);
            };
            return inTrainPhase(droppedInputs, () => getExactlyOneTensor(inputs), kwargs["training"] || false);
          }
          return inputs;
        });
      }
    }
    AlphaDropout.className = "AlphaDropout";
    registerClass(AlphaDropout);
    /**
     * @license
     * Copyright 2018 Google LLC
     *
     * Use of this source code is governed by an MIT-style
     * license that can be found in the LICENSE file or at
     * https://opensource.org/licenses/MIT.
     * =============================================================================
     */
    function batchNormalization(x, mean2, variance2, beta, gamma, epsilon2 = 1e-3) {
      let out;
      if (x.rank === 2) {
        out = batchNorm2d(x, mean2, variance2, beta, gamma, epsilon2);
      } else if (x.rank === 3) {
        out = batchNorm3d(x, mean2, variance2, beta, gamma, epsilon2);
      } else if (x.rank === 4) {
        out = batchNorm4d(x, mean2, variance2, beta, gamma, epsilon2);
      } else {
        throw new NotImplementedError(`batchNormalization is not implemented for array of rank ${x.rank} yet`);
      }
      return out;
    }
    function regularNormalizeBatchInTraining(x, gamma, beta, reductionAxes, epsilon2 = 1e-3) {
      return tidy(() => {
        const meanAndVariance = moments(x, reductionAxes);
        const mean2 = meanAndVariance.mean;
        const variance2 = meanAndVariance.variance;
        const normed = batchNormalization(x, mean2, variance2, beta, gamma, epsilon2);
        return [normed, mean2, variance2];
      });
    }
    function broadcastNormalizeBatchInTraining(x, gamma, beta, reductionAxes, epsilon2 = 1e-3) {
      return tidy(() => {
        const meanAndVariance = moments(x, reductionAxes);
        const mean2 = meanAndVariance.mean;
        const variance2 = meanAndVariance.variance;
        const targetShape = [];
        for (const axis of range$1(0, x.rank)) {
          if (reductionAxes.indexOf(axis) !== -1) {
            targetShape.push(1);
          } else {
            targetShape.push(x.shape[axis]);
          }
        }
        const broadcastMean = mean2.reshape(targetShape);
        const broadcastVariance = variance2.reshape(targetShape);
        const broadcastGamma = gamma == null ? null : gamma.reshape(targetShape);
        const broadcastBeta = beta == null ? null : beta.reshape(targetShape);
        const normed = batchNormalization(x, broadcastMean, broadcastVariance, broadcastBeta, broadcastGamma, epsilon2);
        return [normed, mean2, variance2];
      });
    }
    function normalizeBatchInTraining(x, gamma, beta, reductionAxes, epsilon2 = 1e-3) {
      if (arraysEqual2(reductionAxes.slice().sort(), range$1(0, x.rank - 1))) {
        return regularNormalizeBatchInTraining(x, gamma, beta, reductionAxes, epsilon2);
      } else {
        return broadcastNormalizeBatchInTraining(x, gamma, beta, reductionAxes, epsilon2);
      }
    }
    class BatchNormalization extends Layer {
      constructor(args) {
        if (args == null) {
          args = {};
        }
        super(args);
        this.supportsMasking = true;
        this.axis = args.axis == null ? -1 : args.axis;
        this.momentum = args.momentum == null ? 0.99 : args.momentum;
        this.epsilon = args.epsilon == null ? 1e-3 : args.epsilon;
        this.center = args.center == null ? true : args.center;
        this.scale = args.scale == null ? true : args.scale;
        this.betaInitializer = getInitializer(args.betaInitializer || "zeros");
        this.gammaInitializer = getInitializer(args.gammaInitializer || "ones");
        this.movingMeanInitializer = getInitializer(args.movingMeanInitializer || "zeros");
        this.movingVarianceInitializer = getInitializer(args.movingVarianceInitializer || "ones");
        this.betaConstraint = getConstraint(args.betaConstraint);
        this.gammaConstraint = getConstraint(args.gammaConstraint);
        this.betaRegularizer = getRegularizer(args.betaRegularizer);
        this.gammaRegularizer = getRegularizer(args.gammaRegularizer);
      }
      build(inputShape) {
        inputShape = getExactlyOneShape(inputShape);
        const axis = this.axis >= 0 ? this.axis : this.axis + inputShape.length;
        const dim = inputShape[axis];
        if (dim == null) {
          throw new ValueError(`Axis ${axis} of input tensor should have a defined dimension but the layer received an input with shape ${JSON.stringify(inputShape)}.`);
        }
        this.inputSpec = [new InputSpec({ndim: inputShape.length, axes: {[axis]: dim}})];
        const shape = [dim];
        if (this.scale) {
          this.gamma = this.addWeight("gamma", shape, null, this.gammaInitializer, this.gammaRegularizer, true, this.gammaConstraint);
        }
        if (this.center) {
          this.beta = this.addWeight("beta", shape, null, this.betaInitializer, this.betaRegularizer, true, this.betaConstraint);
        }
        this.movingMean = this.addWeight("moving_mean", shape, null, this.movingMeanInitializer, null, false);
        this.movingVariance = this.addWeight("moving_variance", shape, null, this.movingVarianceInitializer, null, false);
        this.built = true;
      }
      call(inputs, kwargs) {
        return tidy(() => {
          const training = kwargs["training"] == null ? false : kwargs["training"];
          const input2 = getExactlyOneTensor(inputs);
          const inputShape = input2.shape;
          const ndim = inputShape.length;
          const reductionAxes = range$1(0, ndim);
          const axis = this.axis >= 0 ? this.axis : this.axis + ndim;
          reductionAxes.splice(axis, 1);
          const broadcastShape = pyListRepeat(1, ndim);
          broadcastShape[axis] = inputShape[axis];
          const sortedReductionAxes = reductionAxes.slice();
          sortedReductionAxes.sort();
          const needsBroadcasting = !arraysEqual2(sortedReductionAxes, range$1(0, ndim).slice(0, ndim - 1));
          const normalizeInference = () => {
            if (needsBroadcasting) {
              const broadcastMovingMean = this.movingMean.read().reshape(broadcastShape);
              const broadcastMovingVariance = this.movingVariance.read().reshape(broadcastShape);
              const broadcastBeta = this.center ? this.beta.read().reshape(broadcastShape) : null;
              const broadcastGamma = this.scale ? this.gamma.read().reshape(broadcastShape) : null;
              return batchNormalization(input2, broadcastMovingMean, broadcastMovingVariance, broadcastBeta, broadcastGamma, this.epsilon);
            } else {
              return batchNormalization(input2, this.movingMean.read(), this.movingVariance.read(), this.beta == null ? null : this.beta.read(), this.gamma == null ? null : this.gamma.read(), this.epsilon);
            }
          };
          if (!training) {
            return normalizeInference();
          }
          const [normedTraining, mean2, variance2] = normalizeBatchInTraining(input2, this.gamma.read(), this.beta.read(), reductionAxes, this.epsilon);
          const doMovingAverage = (variable2, value, momentum) => {
            tidy(() => {
              const decay = 1 - momentum;
              const origValue = variable2.read();
              const updateDelta = origValue.sub(value).mul(decay);
              variable2.write(origValue.sub(updateDelta));
            });
          };
          const updateMovingMeanAndVariance = () => {
            doMovingAverage(this.movingMean, mean2, this.momentum);
            doMovingAverage(this.movingVariance, variance2, this.momentum);
          };
          updateMovingMeanAndVariance();
          return normedTraining;
        });
      }
      getConfig() {
        const config2 = {
          axis: this.axis,
          momentum: this.momentum,
          epsilon: this.epsilon,
          center: this.center,
          scale: this.scale,
          betaInitializer: serializeInitializer(this.betaInitializer),
          gammaInitializer: serializeInitializer(this.gammaInitializer),
          movingMeanInitializer: serializeInitializer(this.movingMeanInitializer),
          movingVarianceInitializer: serializeInitializer(this.movingVarianceInitializer),
          betaRegularizer: serializeRegularizer(this.betaRegularizer),
          gammaRegularizer: serializeRegularizer(this.gammaRegularizer),
          betaConstraint: serializeConstraint(this.betaConstraint),
          gammaConstraint: serializeConstraint(this.gammaConstraint)
        };
        const baseConfig = super.getConfig();
        Object.assign(config2, baseConfig);
        return config2;
      }
    }
    BatchNormalization.className = "BatchNormalization";
    registerClass(BatchNormalization);
    class LayerNormalization extends Layer {
      constructor(args) {
        if (args == null) {
          args = {};
        }
        super(args);
        this.axis = args.axis == null ? -1 : args.axis;
        if (typeof this.axis === "number") {
          if (!Number.isInteger(this.axis)) {
            throw new Error(`Expected axis to be an integer, but received ${this.axis}`);
          }
        } else if (Array.isArray(this.axis)) {
          for (const axis of this.axis) {
            if (!Number.isInteger(axis)) {
              throw new Error(`Expected axis to be an array of integers, but received ${JSON.stringify(this.axis)}`);
            }
          }
        } else {
          throw new Error(`Expected axis to be an integer or an array of integers, but received ${JSON.stringify(this.axis)}`);
        }
        this.epsilon = args.epsilon == null ? 1e-3 : args.epsilon;
        this.center = args.center == null ? true : args.center;
        this.scale = args.scale == null ? true : args.scale;
        this.betaInitializer = getInitializer(args.betaInitializer || "zeros");
        this.gammaInitializer = getInitializer(args.gammaInitializer || "ones");
        this.betaRegularizer = getRegularizer(args.betaRegularizer);
        this.gammaRegularizer = getRegularizer(args.gammaRegularizer);
        this.supportsMasking = true;
      }
      build(inputShape) {
        inputShape = getExactlyOneShape(inputShape);
        const nDims = inputShape.length;
        if (typeof this.axis === "number") {
          this.axis = [this.axis];
        }
        for (let i = 0; i < this.axis.length; ++i) {
          if (this.axis[i] < 0) {
            this.axis[i] += nDims;
          }
        }
        for (const axis of this.axis) {
          if (axis < 0 || axis >= nDims) {
            throw new Error(`Invalid axis: ${axis}`);
          }
        }
        if (this.axis.length !== unique$1(this.axis).length) {
          throw new Error(`Found duplicate axes in: ${this.axis}`);
        }
        const paramShape = this.axis.map((axis) => inputShape[axis]);
        const trainable = true;
        if (this.scale) {
          this.gamma = this.addWeight("gamma", paramShape, "float32", this.gammaInitializer, this.gammaRegularizer, trainable);
        } else {
          this.gamma = null;
        }
        if (this.center) {
          this.beta = this.addWeight("beta", paramShape, "float32", this.betaInitializer, this.betaRegularizer, trainable);
        } else {
          this.beta = null;
        }
        this.built = true;
      }
      call(inputs, kwargs) {
        const input2 = getExactlyOneTensor(inputs);
        const inputShape = input2.shape;
        const nDims = inputShape.length;
        return tidy(() => {
          const keepDims = true;
          let {mean: mean2, variance: variance2} = moments(input2, this.axis, keepDims);
          const broadcastShape = pyListRepeat(1, nDims);
          for (const dim of this.axis) {
            broadcastShape[dim] = inputShape[dim];
          }
          const broadcast = (v) => {
            if (v != null && v.shape.length !== nDims && this.axis !== [nDims - 1]) {
              return v.reshape(broadcastShape);
            } else {
              return v;
            }
          };
          let scale2 = broadcast(this.gamma.read());
          let offset = broadcast(this.beta.read());
          const momentsTiling = [];
          const scaleOffsetTiling = [];
          for (let i = 0; i < nDims; ++i) {
            if (this.axis.indexOf(i) !== -1) {
              momentsTiling.push(inputShape[i]);
              scaleOffsetTiling.push(1);
            } else {
              momentsTiling.push(1);
              scaleOffsetTiling.push(inputShape[i]);
            }
          }
          mean2 = mean2.tile(momentsTiling);
          variance2 = variance2.tile(momentsTiling);
          scale2 = scale2.tile(scaleOffsetTiling);
          offset = offset.tile(scaleOffsetTiling);
          return batchNormalization(input2, mean2, variance2, offset, scale2, this.epsilon);
        });
      }
      getConfig() {
        const config2 = {
          axis: this.axis,
          epsilon: this.epsilon,
          center: this.center,
          scale: this.scale,
          betaInitializer: serializeInitializer(this.betaInitializer),
          gammaInitializer: serializeInitializer(this.gammaInitializer),
          betaRegularizer: serializeRegularizer(this.betaRegularizer),
          gammaRegularizer: serializeRegularizer(this.gammaRegularizer)
        };
        const baseConfig = super.getConfig();
        Object.assign(config2, baseConfig);
        return config2;
      }
    }
    LayerNormalization.className = "LayerNormalization";
    registerClass(LayerNormalization);
    /**
     * @license
     * Copyright 2018 Google LLC
     *
     * Use of this source code is governed by an MIT-style
     * license that can be found in the LICENSE file or at
     * https://opensource.org/licenses/MIT.
     * =============================================================================
     */
    function temporalPadding(x, padding) {
      return tidy(() => {
        if (x.rank !== 3) {
          throw new ValueError(`temporalPadding expects input tensor to be 3-D, but received a ${x.rank}-D tensor.`);
        }
        if (padding == null) {
          padding = [1, 1];
        }
        if (padding.length !== 2) {
          throw new ValueError(`temporalPadding expects input padding pattern to be a length-2 array, but received a length-${padding.length} array.`);
        }
        const pattern = [[0, 0], padding, [0, 0]];
        return pad2(x, pattern);
      });
    }
    function spatial2dPadding(x, padding, dataFormat) {
      return tidy(() => {
        if (x.rank !== 4) {
          throw new ValueError(`temporalPadding expects input tensor to be 4-D, but received a ${x.rank}-D tensor.`);
        }
        if (padding == null) {
          padding = [[1, 1], [1, 1]];
        }
        if (padding.length !== 2 || padding[0].length !== 2 || padding[1].length !== 2) {
          throw new ValueError("spatial2dPadding expects `padding` to be an Array of two Arrays, each of which is an Array of two integers.");
        }
        if (dataFormat == null) {
          dataFormat = imageDataFormat();
        }
        if (dataFormat !== "channelsLast" && dataFormat !== "channelsFirst") {
          throw new ValueError(`Unknown data format: ${dataFormat}. Supported data formats are 'channelsLast' and 'channelsFirst.`);
        }
        let pattern;
        if (dataFormat === "channelsFirst") {
          pattern = [[0, 0], [0, 0], padding[0], padding[1]];
        } else {
          pattern = [[0, 0], padding[0], padding[1], [0, 0]];
        }
        return pad2(x, pattern);
      });
    }
    class ZeroPadding2D extends Layer {
      constructor(args) {
        if (args == null) {
          args = {};
        }
        super(args);
        this.dataFormat = args.dataFormat == null ? imageDataFormat() : args.dataFormat;
        if (args.padding == null) {
          this.padding = [[1, 1], [1, 1]];
        } else if (typeof args.padding === "number") {
          this.padding = [[args.padding, args.padding], [args.padding, args.padding]];
        } else {
          args.padding = args.padding;
          if (args.padding.length !== 2) {
            throw new ValueError(`ZeroPadding2D expects padding to be a length-2 array, but received a length-${args.padding.length} array.`);
          }
          let heightPadding;
          let widthPadding;
          if (typeof args.padding[0] === "number") {
            heightPadding = [args.padding[0], args.padding[0]];
            widthPadding = [args.padding[1], args.padding[1]];
          } else {
            args.padding = args.padding;
            if (args.padding[0].length !== 2) {
              throw new ValueError(`ZeroPadding2D expects height padding to be a length-2 array, but received a length-${args.padding[0].length} array.`);
            }
            heightPadding = args.padding[0];
            if (args.padding[1].length !== 2) {
              throw new ValueError(`ZeroPadding2D expects width padding to be a length-2 array, but received a length-${args.padding[1].length} array.`);
            }
            widthPadding = args.padding[1];
          }
          this.padding = [heightPadding, widthPadding];
        }
        this.inputSpec = [new InputSpec({ndim: 4})];
      }
      computeOutputShape(inputShape) {
        inputShape = getExactlyOneShape(inputShape);
        let rows;
        let cols;
        if (this.dataFormat === "channelsFirst") {
          if (inputShape[2] != null && inputShape[2] >= 0) {
            rows = inputShape[2] + this.padding[0][0] + this.padding[0][1];
          } else {
            rows = null;
          }
          if (inputShape[3] != null && inputShape[3] >= 0) {
            cols = inputShape[3] + this.padding[1][0] + this.padding[1][1];
          } else {
            cols = null;
          }
          return [inputShape[0], inputShape[1], rows, cols];
        } else {
          if (inputShape[1] != null && inputShape[1] >= 0) {
            rows = inputShape[1] + this.padding[0][0] + this.padding[0][1];
          } else {
            rows = null;
          }
          if (inputShape[2] != null && inputShape[2] >= 0) {
            cols = inputShape[2] + this.padding[1][0] + this.padding[1][1];
          } else {
            cols = null;
          }
          return [inputShape[0], rows, cols, inputShape[3]];
        }
      }
      call(inputs, kwargs) {
        return tidy(() => spatial2dPadding(getExactlyOneTensor(inputs), this.padding, this.dataFormat));
      }
      getConfig() {
        const config2 = {
          padding: this.padding,
          dataFormat: this.dataFormat
        };
        const baseConfig = super.getConfig();
        Object.assign(config2, baseConfig);
        return config2;
      }
    }
    ZeroPadding2D.className = "ZeroPadding2D";
    registerClass(ZeroPadding2D);
    /**
     * @license
     * Copyright 2018 Google LLC
     *
     * Use of this source code is governed by an MIT-style
     * license that can be found in the LICENSE file or at
     * https://opensource.org/licenses/MIT.
     * =============================================================================
     */
    function pool2d(x, poolSize, strides, padding, dataFormat, poolMode) {
      return tidy(() => {
        checkDataFormat(dataFormat);
        checkPoolMode(poolMode);
        checkPaddingMode(padding);
        if (strides == null) {
          strides = [1, 1];
        }
        if (padding == null) {
          padding = "valid";
        }
        if (dataFormat == null) {
          dataFormat = imageDataFormat();
        }
        if (poolMode == null) {
          poolMode = "max";
        }
        x = preprocessConv2DInput(x, dataFormat);
        let y;
        const paddingString = padding === "same" ? "same" : "valid";
        if (poolMode === "max") {
          y = maxPool2(x, poolSize, strides, paddingString);
        } else {
          y = avgPool2(x, poolSize, strides, paddingString);
        }
        if (dataFormat === "channelsFirst") {
          y = transpose4(y, [0, 3, 1, 2]);
        }
        return y;
      });
    }
    function pool3d(x, poolSize, strides, padding, dataFormat, poolMode) {
      return tidy(() => {
        checkDataFormat(dataFormat);
        checkPoolMode(poolMode);
        checkPaddingMode(padding);
        if (strides == null) {
          strides = [1, 1, 1];
        }
        if (padding == null) {
          padding = "valid";
        }
        if (dataFormat == null) {
          dataFormat = imageDataFormat();
        }
        if (poolMode == null) {
          poolMode = "max";
        }
        x = preprocessConv3DInput(x, dataFormat);
        let y;
        const paddingString = padding === "same" ? "same" : "valid";
        if (poolMode === "max") {
          y = maxPool3d(x, poolSize, strides, paddingString);
        } else {
          y = avgPool3d(x, poolSize, strides, paddingString);
        }
        if (dataFormat === "channelsFirst") {
          y = transpose4(y, [0, 4, 1, 2, 3]);
        }
        return y;
      });
    }
    class Pooling1D extends Layer {
      constructor(args) {
        if (args.poolSize == null) {
          args.poolSize = 2;
        }
        super(args);
        if (typeof args.poolSize === "number") {
          this.poolSize = [args.poolSize];
        } else if (Array.isArray(args.poolSize) && args.poolSize.length === 1 && typeof args.poolSize[0] === "number") {
          this.poolSize = args.poolSize;
        } else {
          throw new ValueError(`poolSize for 1D convolutional layer must be a number or an Array of a single number, but received ${JSON.stringify(args.poolSize)}`);
        }
        assertPositiveInteger(this.poolSize, "poolSize");
        if (args.strides == null) {
          this.strides = this.poolSize;
        } else {
          if (typeof args.strides === "number") {
            this.strides = [args.strides];
          } else if (Array.isArray(args.strides) && args.strides.length === 1 && typeof args.strides[0] === "number") {
            this.strides = args.strides;
          } else {
            throw new ValueError(`strides for 1D convolutional layer must be a number or an Array of a single number, but received ${JSON.stringify(args.strides)}`);
          }
        }
        assertPositiveInteger(this.strides, "strides");
        this.padding = args.padding == null ? "valid" : args.padding;
        checkPaddingMode(this.padding);
        this.inputSpec = [new InputSpec({ndim: 3})];
      }
      computeOutputShape(inputShape) {
        inputShape = getExactlyOneShape(inputShape);
        const length = convOutputLength(inputShape[1], this.poolSize[0], this.padding, this.strides[0]);
        return [inputShape[0], length, inputShape[2]];
      }
      call(inputs, kwargs) {
        return tidy(() => {
          this.invokeCallHook(inputs, kwargs);
          inputs = expandDims$1(getExactlyOneTensor(inputs), 2);
          const output = this.poolingFunction(getExactlyOneTensor(inputs), [this.poolSize[0], 1], [this.strides[0], 1], this.padding, "channelsLast");
          return squeeze(output, [2]);
        });
      }
      getConfig() {
        const config2 = {
          poolSize: this.poolSize,
          padding: this.padding,
          strides: this.strides
        };
        const baseConfig = super.getConfig();
        Object.assign(config2, baseConfig);
        return config2;
      }
    }
    class MaxPooling1D extends Pooling1D {
      constructor(args) {
        super(args);
      }
      poolingFunction(inputs, poolSize, strides, padding, dataFormat) {
        checkDataFormat(dataFormat);
        checkPaddingMode(padding);
        return pool2d(inputs, poolSize, strides, padding, dataFormat, "max");
      }
    }
    MaxPooling1D.className = "MaxPooling1D";
    registerClass(MaxPooling1D);
    class AveragePooling1D extends Pooling1D {
      constructor(args) {
        super(args);
      }
      poolingFunction(inputs, poolSize, strides, padding, dataFormat) {
        checkDataFormat(dataFormat);
        checkPaddingMode(padding);
        return pool2d(inputs, poolSize, strides, padding, dataFormat, "avg");
      }
    }
    AveragePooling1D.className = "AveragePooling1D";
    registerClass(AveragePooling1D);
    class Pooling2D extends Layer {
      constructor(args) {
        if (args.poolSize == null) {
          args.poolSize = [2, 2];
        }
        super(args);
        this.poolSize = Array.isArray(args.poolSize) ? args.poolSize : [args.poolSize, args.poolSize];
        if (args.strides == null) {
          this.strides = this.poolSize;
        } else if (Array.isArray(args.strides)) {
          if (args.strides.length !== 2) {
            throw new ValueError(`If the strides property of a 2D pooling layer is an Array, it is expected to have a length of 2, but received length ${args.strides.length}.`);
          }
          this.strides = args.strides;
        } else {
          this.strides = [args.strides, args.strides];
        }
        assertPositiveInteger(this.poolSize, "poolSize");
        assertPositiveInteger(this.strides, "strides");
        this.padding = args.padding == null ? "valid" : args.padding;
        this.dataFormat = args.dataFormat == null ? "channelsLast" : args.dataFormat;
        checkDataFormat(this.dataFormat);
        checkPaddingMode(this.padding);
        this.inputSpec = [new InputSpec({ndim: 4})];
      }
      computeOutputShape(inputShape) {
        inputShape = getExactlyOneShape(inputShape);
        let rows = this.dataFormat === "channelsFirst" ? inputShape[2] : inputShape[1];
        let cols = this.dataFormat === "channelsFirst" ? inputShape[3] : inputShape[2];
        rows = convOutputLength(rows, this.poolSize[0], this.padding, this.strides[0]);
        cols = convOutputLength(cols, this.poolSize[1], this.padding, this.strides[1]);
        if (this.dataFormat === "channelsFirst") {
          return [inputShape[0], inputShape[1], rows, cols];
        } else {
          return [inputShape[0], rows, cols, inputShape[3]];
        }
      }
      call(inputs, kwargs) {
        return tidy(() => {
          this.invokeCallHook(inputs, kwargs);
          return this.poolingFunction(getExactlyOneTensor(inputs), this.poolSize, this.strides, this.padding, this.dataFormat);
        });
      }
      getConfig() {
        const config2 = {
          poolSize: this.poolSize,
          padding: this.padding,
          strides: this.strides,
          dataFormat: this.dataFormat
        };
        const baseConfig = super.getConfig();
        Object.assign(config2, baseConfig);
        return config2;
      }
    }
    class MaxPooling2D extends Pooling2D {
      constructor(args) {
        super(args);
      }
      poolingFunction(inputs, poolSize, strides, padding, dataFormat) {
        checkDataFormat(dataFormat);
        checkPaddingMode(padding);
        return pool2d(inputs, poolSize, strides, padding, dataFormat, "max");
      }
    }
    MaxPooling2D.className = "MaxPooling2D";
    registerClass(MaxPooling2D);
    class AveragePooling2D extends Pooling2D {
      constructor(args) {
        super(args);
      }
      poolingFunction(inputs, poolSize, strides, padding, dataFormat) {
        checkDataFormat(dataFormat);
        checkPaddingMode(padding);
        return pool2d(inputs, poolSize, strides, padding, dataFormat, "avg");
      }
    }
    AveragePooling2D.className = "AveragePooling2D";
    registerClass(AveragePooling2D);
    class Pooling3D extends Layer {
      constructor(args) {
        if (args.poolSize == null) {
          args.poolSize = [2, 2, 2];
        }
        super(args);
        this.poolSize = Array.isArray(args.poolSize) ? args.poolSize : [args.poolSize, args.poolSize, args.poolSize];
        if (args.strides == null) {
          this.strides = this.poolSize;
        } else if (Array.isArray(args.strides)) {
          if (args.strides.length !== 3) {
            throw new ValueError(`If the strides property of a 3D pooling layer is an Array, it is expected to have a length of 3, but received length ${args.strides.length}.`);
          }
          this.strides = args.strides;
        } else {
          this.strides = [args.strides, args.strides, args.strides];
        }
        assertPositiveInteger(this.poolSize, "poolSize");
        assertPositiveInteger(this.strides, "strides");
        this.padding = args.padding == null ? "valid" : args.padding;
        this.dataFormat = args.dataFormat == null ? "channelsLast" : args.dataFormat;
        checkDataFormat(this.dataFormat);
        checkPaddingMode(this.padding);
        this.inputSpec = [new InputSpec({ndim: 5})];
      }
      computeOutputShape(inputShape) {
        inputShape = getExactlyOneShape(inputShape);
        let depths = this.dataFormat === "channelsFirst" ? inputShape[2] : inputShape[1];
        let rows = this.dataFormat === "channelsFirst" ? inputShape[3] : inputShape[2];
        let cols = this.dataFormat === "channelsFirst" ? inputShape[4] : inputShape[3];
        depths = convOutputLength(depths, this.poolSize[0], this.padding, this.strides[0]);
        rows = convOutputLength(rows, this.poolSize[1], this.padding, this.strides[1]);
        cols = convOutputLength(cols, this.poolSize[2], this.padding, this.strides[2]);
        if (this.dataFormat === "channelsFirst") {
          return [inputShape[0], inputShape[1], depths, rows, cols];
        } else {
          return [inputShape[0], depths, rows, cols, inputShape[4]];
        }
      }
      call(inputs, kwargs) {
        return tidy(() => {
          this.invokeCallHook(inputs, kwargs);
          return this.poolingFunction(getExactlyOneTensor(inputs), this.poolSize, this.strides, this.padding, this.dataFormat);
        });
      }
      getConfig() {
        const config2 = {
          poolSize: this.poolSize,
          padding: this.padding,
          strides: this.strides,
          dataFormat: this.dataFormat
        };
        const baseConfig = super.getConfig();
        Object.assign(config2, baseConfig);
        return config2;
      }
    }
    class MaxPooling3D extends Pooling3D {
      constructor(args) {
        super(args);
      }
      poolingFunction(inputs, poolSize, strides, padding, dataFormat) {
        checkDataFormat(dataFormat);
        checkPaddingMode(padding);
        return pool3d(inputs, poolSize, strides, padding, dataFormat, "max");
      }
    }
    MaxPooling3D.className = "MaxPooling3D";
    registerClass(MaxPooling3D);
    class AveragePooling3D extends Pooling3D {
      constructor(args) {
        super(args);
      }
      poolingFunction(inputs, poolSize, strides, padding, dataFormat) {
        checkDataFormat(dataFormat);
        checkPaddingMode(padding);
        return pool3d(inputs, poolSize, strides, padding, dataFormat, "avg");
      }
    }
    AveragePooling3D.className = "AveragePooling3D";
    registerClass(AveragePooling3D);
    class GlobalPooling1D extends Layer {
      constructor(args) {
        super(args);
        this.inputSpec = [new InputSpec({ndim: 3})];
      }
      computeOutputShape(inputShape) {
        return [inputShape[0], inputShape[2]];
      }
      call(inputs, kwargs) {
        throw new NotImplementedError();
      }
    }
    class GlobalAveragePooling1D extends GlobalPooling1D {
      constructor(args) {
        super(args || {});
      }
      call(inputs, kwargs) {
        return tidy(() => {
          const input2 = getExactlyOneTensor(inputs);
          return mean(input2, 1);
        });
      }
    }
    GlobalAveragePooling1D.className = "GlobalAveragePooling1D";
    registerClass(GlobalAveragePooling1D);
    class GlobalMaxPooling1D extends GlobalPooling1D {
      constructor(args) {
        super(args || {});
      }
      call(inputs, kwargs) {
        return tidy(() => {
          const input2 = getExactlyOneTensor(inputs);
          return max2(input2, 1);
        });
      }
    }
    GlobalMaxPooling1D.className = "GlobalMaxPooling1D";
    registerClass(GlobalMaxPooling1D);
    class GlobalPooling2D extends Layer {
      constructor(args) {
        super(args);
        this.dataFormat = args.dataFormat == null ? "channelsLast" : args.dataFormat;
        checkDataFormat(this.dataFormat);
        this.inputSpec = [new InputSpec({ndim: 4})];
      }
      computeOutputShape(inputShape) {
        inputShape = inputShape;
        if (this.dataFormat === "channelsLast") {
          return [inputShape[0], inputShape[3]];
        } else {
          return [inputShape[0], inputShape[1]];
        }
      }
      call(inputs, kwargs) {
        throw new NotImplementedError();
      }
      getConfig() {
        const config2 = {dataFormat: this.dataFormat};
        const baseConfig = super.getConfig();
        Object.assign(config2, baseConfig);
        return config2;
      }
    }
    class GlobalAveragePooling2D extends GlobalPooling2D {
      call(inputs, kwargs) {
        return tidy(() => {
          const input2 = getExactlyOneTensor(inputs);
          if (this.dataFormat === "channelsLast") {
            return mean(input2, [1, 2]);
          } else {
            return mean(input2, [2, 3]);
          }
        });
      }
    }
    GlobalAveragePooling2D.className = "GlobalAveragePooling2D";
    registerClass(GlobalAveragePooling2D);
    class GlobalMaxPooling2D extends GlobalPooling2D {
      call(inputs, kwargs) {
        return tidy(() => {
          const input2 = getExactlyOneTensor(inputs);
          if (this.dataFormat === "channelsLast") {
            return max2(input2, [1, 2]);
          } else {
            return max2(input2, [2, 3]);
          }
        });
      }
    }
    GlobalMaxPooling2D.className = "GlobalMaxPooling2D";
    registerClass(GlobalMaxPooling2D);
    /**
     * @license
     * Copyright 2018 Google LLC
     *
     * Use of this source code is governed by an MIT-style
     * license that can be found in the LICENSE file or at
     * https://opensource.org/licenses/MIT.
     * =============================================================================
     */
    class Wrapper extends Layer {
      constructor(args) {
        super(args);
        this.layer = args.layer;
      }
      build(inputShape) {
        this.built = true;
      }
      get trainable() {
        if (this.layer != null) {
          return this.layer.trainable;
        } else {
          return false;
        }
      }
      set trainable(value) {
        if (this.layer != null) {
          this.layer.trainable = value;
        }
      }
      get trainableWeights() {
        return this.layer.trainableWeights;
      }
      get nonTrainableWeights() {
        return this.layer.nonTrainableWeights;
      }
      get updates() {
        return this.layer._updates;
      }
      get losses() {
        return this.layer.losses;
      }
      getWeights() {
        return this.layer.getWeights();
      }
      setWeights(weights) {
        this.layer.setWeights(weights);
      }
      getConfig() {
        const config2 = {
          layer: {
            className: this.layer.getClassName(),
            config: this.layer.getConfig()
          }
        };
        const baseConfig = super.getConfig();
        Object.assign(config2, baseConfig);
        return config2;
      }
      setFastWeightInitDuringBuild(value) {
        super.setFastWeightInitDuringBuild(value);
        if (this.layer != null) {
          this.layer.setFastWeightInitDuringBuild(value);
        }
      }
      static fromConfig(cls, config2, customObjects = {}) {
        const layerConfig = config2["layer"];
        const layer = deserialize(layerConfig, customObjects);
        delete config2["layer"];
        const newConfig = {layer};
        Object.assign(newConfig, config2);
        return new cls(newConfig);
      }
    }
    class TimeDistributed extends Wrapper {
      constructor(args) {
        super(args);
        this.supportsMasking = true;
      }
      build(inputShape) {
        inputShape = getExactlyOneShape(inputShape);
        if (inputShape.length < 3) {
          throw new ValueError(`TimeDistributed layer expects an input shape >= 3D, but received input shape ${JSON.stringify(inputShape)}`);
        }
        this.inputSpec = [{shape: inputShape}];
        const childInputShape = [inputShape[0]].concat(inputShape.slice(2));
        if (!this.layer.built) {
          this.layer.build(childInputShape);
          this.layer.built = true;
        }
        super.build(inputShape);
      }
      computeOutputShape(inputShape) {
        inputShape = getExactlyOneShape(inputShape);
        const childInputShape = [inputShape[0]].concat(inputShape.slice(2));
        const childOutputShape = this.layer.computeOutputShape(childInputShape);
        const timesteps = inputShape[1];
        return [childOutputShape[0], timesteps].concat(childOutputShape.slice(1));
      }
      call(inputs, kwargs) {
        return tidy(() => {
          inputs = getExactlyOneTensor(inputs);
          const step4 = (inputs2, states) => {
            const output = getExactlyOneTensor(this.layer.call(inputs2, kwargs));
            return [output, []];
          };
          const rnnOutputs = rnn(step4, inputs, [], false, null, null, false, true);
          const y = rnnOutputs[1];
          return y;
        });
      }
    }
    TimeDistributed.className = "TimeDistributed";
    registerClass(TimeDistributed);
    function checkBidirectionalMergeMode(value) {
      checkStringTypeUnionValue(VALID_BIDIRECTIONAL_MERGE_MODES, "BidirectionalMergeMode", value);
    }
    const DEFAULT_BIDIRECTIONAL_MERGE_MODE = "concat";
    class Bidirectional extends Wrapper {
      constructor(args) {
        super(args);
        const layerConfig = args.layer.getConfig();
        const forwDict = {};
        forwDict["className"] = args.layer.getClassName();
        forwDict["config"] = layerConfig;
        this.forwardLayer = deserialize(forwDict);
        layerConfig["goBackwards"] = layerConfig["goBackwards"] === true ? false : true;
        const backDict = {};
        backDict["className"] = args.layer.getClassName();
        backDict["config"] = layerConfig;
        this.backwardLayer = deserialize(backDict);
        this.forwardLayer.name = "forward_" + this.forwardLayer.name;
        this.backwardLayer.name = "backward_" + this.backwardLayer.name;
        this.mergeMode = args.mergeMode === void 0 ? DEFAULT_BIDIRECTIONAL_MERGE_MODE : args.mergeMode;
        checkBidirectionalMergeMode(this.mergeMode);
        if (args.weights) {
          throw new NotImplementedError("weights support is not implemented for Bidirectional layer yet.");
        }
        this._stateful = args.layer.stateful;
        this.returnSequences = args.layer.returnSequences;
        this.returnState = args.layer.returnState;
        this.supportsMasking = true;
        this._trainable = true;
        this.inputSpec = args.layer.inputSpec;
        this.numConstants = null;
      }
      get trainable() {
        return this._trainable;
      }
      set trainable(value) {
        this._trainable = value;
        if (this.forwardLayer != null) {
          this.forwardLayer.trainable = value;
        }
        if (this.backwardLayer != null) {
          this.backwardLayer.trainable = value;
        }
      }
      getWeights() {
        return this.forwardLayer.getWeights().concat(this.backwardLayer.getWeights());
      }
      setWeights(weights) {
        const numWeights = weights.length;
        const numeightsOver2 = Math.floor(numWeights / 2);
        this.forwardLayer.setWeights(weights.slice(0, numeightsOver2));
        this.backwardLayer.setWeights(weights.slice(numeightsOver2));
      }
      computeOutputShape(inputShape) {
        let layerShapes = this.forwardLayer.computeOutputShape(inputShape);
        if (!(Array.isArray(layerShapes) && Array.isArray(layerShapes[0]))) {
          layerShapes = [layerShapes];
        }
        layerShapes = layerShapes;
        let outputShape;
        let outputShapes;
        let stateShape;
        if (this.returnState) {
          stateShape = layerShapes.slice(1);
          outputShape = layerShapes[0];
        } else {
          outputShape = layerShapes[0];
        }
        outputShape = outputShape;
        if (this.mergeMode === "concat") {
          outputShape[outputShape.length - 1] *= 2;
          outputShapes = [outputShape];
        } else if (this.mergeMode == null) {
          outputShapes = [outputShape, outputShape.slice()];
        } else {
          outputShapes = [outputShape];
        }
        if (this.returnState) {
          if (this.mergeMode == null) {
            return outputShapes.concat(stateShape).concat(stateShape.slice());
          }
          return [outputShape].concat(stateShape).concat(stateShape.slice());
        }
        return singletonOrArray(outputShapes);
      }
      apply(inputs, kwargs) {
        let initialState = kwargs == null ? null : kwargs["initialState"];
        let constants = kwargs == null ? null : kwargs["constants"];
        if (kwargs == null) {
          kwargs = {};
        }
        const standardized = standardizeArgs(inputs, initialState, constants, this.numConstants);
        inputs = standardized.inputs;
        initialState = standardized.initialState;
        constants = standardized.constants;
        if (Array.isArray(inputs)) {
          initialState = inputs.slice(1);
          inputs = inputs[0];
        }
        if ((initialState == null || initialState.length === 0) && constants == null) {
          return super.apply(inputs, kwargs);
        }
        const additionalInputs = [];
        const additionalSpecs = [];
        if (initialState != null) {
          const numStates = initialState.length;
          if (numStates % 2 > 0) {
            throw new ValueError("When passing `initialState` to a Bidrectional RNN, the state should be an Array containing the states of the underlying RNNs.");
          }
          kwargs["initialState"] = initialState;
          additionalInputs.push(...initialState);
          const stateSpecs = initialState.map((state) => new InputSpec({shape: state.shape}));
          this.forwardLayer.stateSpec = stateSpecs.slice(0, numStates / 2);
          this.backwardLayer.stateSpec = stateSpecs.slice(numStates / 2);
          additionalSpecs.push(...stateSpecs);
        }
        if (constants != null) {
          throw new NotImplementedError("Support for constants in Bidirectional layers is not implemented yet.");
        }
        const isSymbolicTensor = additionalInputs[0] instanceof SymbolicTensor;
        for (const tensor7 of additionalInputs) {
          if (tensor7 instanceof SymbolicTensor !== isSymbolicTensor) {
            throw new ValueError("The initial state of a Bidirectional layer cannot be specified as a mix of symbolic and non-symbolic tensors");
          }
        }
        if (isSymbolicTensor) {
          const fullInput = [inputs].concat(additionalInputs);
          const fullInputSpec = this.inputSpec.concat(additionalSpecs);
          const originalInputSpec = this.inputSpec;
          this.inputSpec = fullInputSpec;
          const output = super.apply(fullInput, kwargs);
          this.inputSpec = originalInputSpec;
          return output;
        } else {
          return super.apply(inputs, kwargs);
        }
      }
      call(inputs, kwargs) {
        return tidy(() => {
          const initialState = kwargs["initialState"];
          let y;
          let yRev;
          if (initialState == null) {
            y = this.forwardLayer.call(inputs, kwargs);
            yRev = this.backwardLayer.call(inputs, kwargs);
          } else {
            const forwardState = initialState.slice(0, initialState.length / 2);
            const backwardState = initialState.slice(initialState.length / 2);
            y = this.forwardLayer.call(inputs, Object.assign(kwargs, {initialState: forwardState}));
            yRev = this.backwardLayer.call(inputs, Object.assign(kwargs, {initialState: backwardState}));
          }
          let states;
          if (this.returnState) {
            if (Array.isArray(y)) {
              states = y.slice(1).concat(yRev.slice(1));
            } else {
            }
            y = y[0];
            yRev = yRev[0];
          }
          if (this.returnSequences) {
            yRev = reverse2(yRev, 1);
          }
          let output;
          if (this.mergeMode === "concat") {
            output = concatenate([y, yRev]);
          } else if (this.mergeMode === "sum") {
            output = add$1(y, yRev);
          } else if (this.mergeMode === "ave") {
            output = mul3(0.5, add$1(y, yRev));
          } else if (this.mergeMode === "mul") {
            output = mul3(y, yRev);
          } else if (this.mergeMode == null) {
            output = [y, yRev];
          }
          if (this.returnState) {
            if (this.mergeMode == null) {
              return output.concat(states);
            }
            return [output].concat(states);
          }
          return output;
        });
      }
      resetStates(states) {
        this.forwardLayer.resetStates();
        this.backwardLayer.resetStates();
      }
      build(inputShape) {
        nameScope(this.forwardLayer.name, () => {
          this.forwardLayer.build(inputShape);
        });
        nameScope(this.backwardLayer.name, () => {
          this.backwardLayer.build(inputShape);
        });
        this.built = true;
      }
      computeMask(inputs, mask) {
        if (Array.isArray(mask)) {
          mask = mask[0];
        }
        let outputMask;
        if (this.returnSequences) {
          if (this.mergeMode == null) {
            outputMask = [mask, mask];
          } else {
            outputMask = mask;
          }
        } else {
          if (this.mergeMode == null) {
            outputMask = [null, null];
          } else {
            outputMask = null;
          }
        }
        if (this.returnState) {
          const states = this.forwardLayer.states;
          const stateMask = states.map((state) => null);
          if (Array.isArray(outputMask)) {
            return outputMask.concat(stateMask).concat(stateMask);
          } else {
            return [outputMask].concat(stateMask).concat(stateMask);
          }
        } else {
          return outputMask;
        }
      }
      get trainableWeights() {
        return this.forwardLayer.trainableWeights.concat(this.backwardLayer.trainableWeights);
      }
      get nonTrainableWeights() {
        return this.forwardLayer.nonTrainableWeights.concat(this.backwardLayer.nonTrainableWeights);
      }
      setFastWeightInitDuringBuild(value) {
        super.setFastWeightInitDuringBuild(value);
        if (this.forwardLayer != null) {
          this.forwardLayer.setFastWeightInitDuringBuild(value);
        }
        if (this.backwardLayer != null) {
          this.backwardLayer.setFastWeightInitDuringBuild(value);
        }
      }
      getConfig() {
        const config2 = {
          mergeMode: this.mergeMode
        };
        const baseConfig = super.getConfig();
        Object.assign(config2, baseConfig);
        return config2;
      }
      static fromConfig(cls, config2) {
        const rnnLayer = deserialize(config2["layer"]);
        delete config2["layer"];
        if (config2["numConstants"] != null) {
          throw new NotImplementedError(`Deserialization of a Bidirectional layer with numConstants present is not supported yet.`);
        }
        const newConfig = config2;
        newConfig["layer"] = rnnLayer;
        return new cls(newConfig);
      }
    }
    Bidirectional.className = "Bidirectional";
    registerClass(Bidirectional);
    /**
     * @license
     * Copyright 2018 Google LLC
     *
     * Use of this source code is governed by an MIT-style
     * license that can be found in the LICENSE file or at
     * https://opensource.org/licenses/MIT.
     * =============================================================================
     */
    function inputLayer(args) {
      return new InputLayer(args);
    }
    function elu$2(args) {
      return new ELU(args);
    }
    function reLU(args) {
      return new ReLU(args);
    }
    function leakyReLU(args) {
      return new LeakyReLU(args);
    }
    function prelu$1(args) {
      return new PReLU(args);
    }
    function softmax$1(args) {
      return new Softmax$2(args);
    }
    function thresholdedReLU(args) {
      return new ThresholdedReLU(args);
    }
    function conv1d$2(args) {
      return new Conv1D(args);
    }
    function conv2d$3(args) {
      return new Conv2D$1(args);
    }
    function conv2dTranspose$1(args) {
      return new Conv2DTranspose(args);
    }
    function conv3d$2(args) {
      return new Conv3D$1(args);
    }
    function separableConv2d$1(args) {
      return new SeparableConv2D(args);
    }
    function cropping2D(args) {
      return new Cropping2D(args);
    }
    function upSampling2d(args) {
      return new UpSampling2D(args);
    }
    function depthwiseConv2d$3(args) {
      return new DepthwiseConv2D(args);
    }
    function activation(args) {
      return new Activation$1(args);
    }
    function dense(args) {
      return new Dense(args);
    }
    function dropout$2(args) {
      return new Dropout(args);
    }
    function spatialDropout1d(args) {
      return new SpatialDropout1D(args);
    }
    function flatten$2(args) {
      return new Flatten(args);
    }
    function repeatVector(args) {
      return new RepeatVector(args);
    }
    function reshape$1(args) {
      return new Reshape$1(args);
    }
    function permute(args) {
      return new Permute(args);
    }
    function embedding2(args) {
      return new Embedding(args);
    }
    function add$3(args) {
      return new Add$1(args);
    }
    function average$1(args) {
      return new Average(args);
    }
    function concatenate$2(args) {
      return new Concatenate(args);
    }
    function maximum$2(args) {
      return new Maximum$1(args);
    }
    function minimum$2(args) {
      return new Minimum$1(args);
    }
    function multiply$1(args) {
      return new Multiply$1(args);
    }
    function dot$2(args) {
      return new Dot(args);
    }
    function batchNormalization$1(args) {
      return new BatchNormalization(args);
    }
    function layerNormalization(args) {
      return new LayerNormalization(args);
    }
    function zeroPadding2d(args) {
      return new ZeroPadding2D(args);
    }
    function averagePooling1d(args) {
      return new AveragePooling1D(args);
    }
    function avgPool1d(args) {
      return averagePooling1d(args);
    }
    function avgPooling1d(args) {
      return averagePooling1d(args);
    }
    function averagePooling2d(args) {
      return new AveragePooling2D(args);
    }
    function avgPool2d(args) {
      return averagePooling2d(args);
    }
    function avgPooling2d(args) {
      return averagePooling2d(args);
    }
    function averagePooling3d(args) {
      return new AveragePooling3D(args);
    }
    function avgPool3d$1(args) {
      return averagePooling3d(args);
    }
    function avgPooling3d(args) {
      return averagePooling3d(args);
    }
    function globalAveragePooling1d(args) {
      return new GlobalAveragePooling1D(args);
    }
    function globalAveragePooling2d(args) {
      return new GlobalAveragePooling2D(args);
    }
    function globalMaxPooling1d(args) {
      return new GlobalMaxPooling1D(args);
    }
    function globalMaxPooling2d(args) {
      return new GlobalMaxPooling2D(args);
    }
    function maxPooling1d(args) {
      return new MaxPooling1D(args);
    }
    function maxPooling2d(args) {
      return new MaxPooling2D(args);
    }
    function maxPooling3d(args) {
      return new MaxPooling3D(args);
    }
    function gru(args) {
      return new GRU(args);
    }
    function gruCell(args) {
      return new GRUCell(args);
    }
    function lstm(args) {
      return new LSTM(args);
    }
    function lstmCell(args) {
      return new LSTMCell(args);
    }
    function simpleRNN(args) {
      return new SimpleRNN(args);
    }
    function simpleRNNCell(args) {
      return new SimpleRNNCell(args);
    }
    function convLstm2d(args) {
      return new ConvLSTM2D(args);
    }
    function convLstm2dCell(args) {
      return new ConvLSTM2DCell(args);
    }
    function rnn$1(args) {
      return new RNN(args);
    }
    function stackedRNNCells(args) {
      return new StackedRNNCells(args);
    }
    function bidirectional(args) {
      return new Bidirectional(args);
    }
    function timeDistributed(args) {
      return new TimeDistributed(args);
    }
    const globalMaxPool1d = globalMaxPooling1d;
    const globalMaxPool2d = globalMaxPooling2d;
    const maxPool1d = maxPooling1d;
    const maxPool2d = maxPooling2d;
    function gaussianNoise(args) {
      return new GaussianNoise(args);
    }
    function gaussianDropout(args) {
      return new GaussianDropout(args);
    }
    function alphaDropout(args) {
      return new AlphaDropout(args);
    }
    function masking(args) {
      return new Masking(args);
    }
    var exports_layers = /* @__PURE__ */ Object.freeze({
      __proto__: null,
      inputLayer,
      elu: elu$2,
      reLU,
      leakyReLU,
      prelu: prelu$1,
      softmax: softmax$1,
      thresholdedReLU,
      conv1d: conv1d$2,
      conv2d: conv2d$3,
      conv2dTranspose: conv2dTranspose$1,
      conv3d: conv3d$2,
      separableConv2d: separableConv2d$1,
      cropping2D,
      upSampling2d,
      depthwiseConv2d: depthwiseConv2d$3,
      activation,
      dense,
      dropout: dropout$2,
      spatialDropout1d,
      flatten: flatten$2,
      repeatVector,
      reshape: reshape$1,
      permute,
      embedding: embedding2,
      add: add$3,
      average: average$1,
      concatenate: concatenate$2,
      maximum: maximum$2,
      minimum: minimum$2,
      multiply: multiply$1,
      dot: dot$2,
      batchNormalization: batchNormalization$1,
      layerNormalization,
      zeroPadding2d,
      averagePooling1d,
      avgPool1d,
      avgPooling1d,
      averagePooling2d,
      avgPool2d,
      avgPooling2d,
      averagePooling3d,
      avgPool3d: avgPool3d$1,
      avgPooling3d,
      globalAveragePooling1d,
      globalAveragePooling2d,
      globalMaxPooling1d,
      globalMaxPooling2d,
      maxPooling1d,
      maxPooling2d,
      maxPooling3d,
      gru,
      gruCell,
      lstm,
      lstmCell,
      simpleRNN,
      simpleRNNCell,
      convLstm2d,
      convLstm2dCell,
      rnn: rnn$1,
      stackedRNNCells,
      bidirectional,
      timeDistributed,
      globalMaxPool1d,
      globalMaxPool2d,
      maxPool1d,
      maxPool2d,
      Layer,
      RNN,
      RNNCell,
      input,
      gaussianNoise,
      gaussianDropout,
      alphaDropout,
      masking
    });
    function binaryAccuracy$1(yTrue, yPred) {
      return binaryAccuracy(yTrue, yPred);
    }
    function binaryCrossentropy$2(yTrue, yPred) {
      return binaryCrossentropy$1(yTrue, yPred);
    }
    function sparseCategoricalAccuracy$1(yTrue, yPred) {
      return sparseCategoricalAccuracy(yTrue, yPred);
    }
    function categoricalAccuracy$1(yTrue, yPred) {
      return categoricalAccuracy(yTrue, yPred);
    }
    function categoricalCrossentropy$2(yTrue, yPred) {
      return categoricalCrossentropy$1(yTrue, yPred);
    }
    function precision$1(yTrue, yPred) {
      return precision(yTrue, yPred);
    }
    function recall$1(yTrue, yPred) {
      return recall(yTrue, yPred);
    }
    function cosineProximity$1(yTrue, yPred) {
      return cosineProximity(yTrue, yPred);
    }
    function meanAbsoluteError$1(yTrue, yPred) {
      return meanAbsoluteError(yTrue, yPred);
    }
    function meanAbsolutePercentageError$1(yTrue, yPred) {
      return meanAbsolutePercentageError(yTrue, yPred);
    }
    function MAPE$2(yTrue, yPred) {
      return meanAbsolutePercentageError(yTrue, yPred);
    }
    function mape$2(yTrue, yPred) {
      return meanAbsolutePercentageError(yTrue, yPred);
    }
    function meanSquaredError$2(yTrue, yPred) {
      return meanSquaredError$1(yTrue, yPred);
    }
    function MSE$2(yTrue, yPred) {
      return meanSquaredError$1(yTrue, yPred);
    }
    function mse$2(yTrue, yPred) {
      return meanSquaredError$1(yTrue, yPred);
    }
    var exports_metrics = /* @__PURE__ */ Object.freeze({
      __proto__: null,
      binaryAccuracy: binaryAccuracy$1,
      binaryCrossentropy: binaryCrossentropy$2,
      sparseCategoricalAccuracy: sparseCategoricalAccuracy$1,
      categoricalAccuracy: categoricalAccuracy$1,
      categoricalCrossentropy: categoricalCrossentropy$2,
      precision: precision$1,
      recall: recall$1,
      cosineProximity: cosineProximity$1,
      meanAbsoluteError: meanAbsoluteError$1,
      meanAbsolutePercentageError: meanAbsolutePercentageError$1,
      MAPE: MAPE$2,
      mape: mape$2,
      meanSquaredError: meanSquaredError$2,
      MSE: MSE$2,
      mse: mse$2
    });
    /**
     * @license
     * Copyright 2018 Google LLC
     *
     * Use of this source code is governed by an MIT-style
     * license that can be found in the LICENSE file or at
     * https://opensource.org/licenses/MIT.
     * =============================================================================
     */
    var exports_models = /* @__PURE__ */ Object.freeze({
      __proto__: null,
      modelFromJSON
    });
    /**
     * @license
     * Copyright 2018 Google LLC
     *
     * Use of this source code is governed by an MIT-style
     * license that can be found in the LICENSE file or at
     * https://opensource.org/licenses/MIT.
     * =============================================================================
     */
    function l1l2(config2) {
      return new L1L2(config2);
    }
    function l1$1(config2) {
      return l1(config2);
    }
    function l2$1(config2) {
      return l2(config2);
    }
    var exports_regularizers = /* @__PURE__ */ Object.freeze({
      __proto__: null,
      l1l2,
      l1: l1$1,
      l2: l2$1
    });
    /**
     * @license
     * Copyright 2018 Google LLC
     *
     * Use of this source code is governed by an MIT-style
     * license that can be found in the LICENSE file or at
     * https://opensource.org/licenses/MIT.
     * =============================================================================
     */
    class Callback extends BaseCallback {
      constructor() {
        super(...arguments);
        this.model = null;
      }
      setModel(model2) {
        if (!(model2 instanceof LayersModel)) {
          throw new Error("model must be a LayersModel, not some other Container");
        }
        this.model = model2;
      }
    }
    function less$1(currVal, prevVal) {
      return currVal < prevVal;
    }
    function greater$1(currVal, prevVal) {
      return currVal > prevVal;
    }
    class EarlyStopping extends Callback {
      constructor(args) {
        super();
        if (args == null) {
          args = {};
        }
        if (args.restoreBestWeights) {
          throw new NotImplementedError("restoreBestWeights = True is not implemented in EarlyStopping yet.");
        }
        this.monitor = args.monitor || "val_loss";
        this.minDelta = Math.abs(args.minDelta || 0);
        this.patience = args.patience || 0;
        this.verbose = args.verbose || 0;
        this.mode = args.mode || "auto";
        this.baseline = args.baseline;
        if (["auto", "min", "max"].indexOf(this.mode) === -1) {
          console.warn(`EarlyStopping mode '${this.mode}' is invalid. Falling back to mode 'auto'.`);
          this.mode = "auto";
        }
        if (this.mode === "min") {
          this.monitorFunc = less$1;
        } else if (this.mode === "max") {
          this.monitorFunc = greater$1;
        } else {
          if (this.monitor.indexOf("acc") !== -1) {
            this.monitorFunc = greater$1;
          } else {
            this.monitorFunc = less$1;
          }
        }
        if (this.monitorFunc === less$1) {
          this.minDelta *= -1;
        }
      }
      async onTrainBegin(logs) {
        this.wait = 0;
        this.stoppedEpoch = 0;
        if (this.baseline != null) {
          this.best = this.baseline;
        } else {
          this.best = this.monitorFunc === less$1 ? Infinity : -Infinity;
        }
      }
      async onEpochEnd(epoch, logs) {
        await resolveScalarsInLogs(logs);
        const current = this.getMonitorValue(logs);
        if (current == null) {
          return;
        }
        if (this.monitorFunc(current - this.minDelta, this.best)) {
          this.best = current;
          this.wait = 0;
        } else {
          this.wait++;
          if (this.wait >= this.patience) {
            this.stoppedEpoch = epoch;
            this.model.stopTraining = true;
          }
        }
      }
      async onTrainEnd(logs) {
        if (this.stoppedEpoch > 0 && this.verbose) {
          console.log(`Epoch ${this.stoppedEpoch}: early stopping.`);
        }
      }
      getMonitorValue(logs) {
        if (logs == null) {
          logs = {};
        }
        const monitorValue = logs[this.monitor];
        if (monitorValue == null) {
          console.warn(`Metric for EarlyStopping ${this.monitor} is not available. Available metrics are: ${Object.keys(logs)}`);
        }
        return monitorValue;
      }
    }
    function earlyStopping(args) {
      return new EarlyStopping(args);
    }
    const callbacks = {earlyStopping};
    /**
     * @license
     * Copyright 2018 Google LLC
     *
     * Use of this source code is governed by an MIT-style
     * license that can be found in the LICENSE file or at
     * https://opensource.org/licenses/MIT.
     * =============================================================================
     */
    /**
     * @license
     * Copyright 2019 Google LLC. All Rights Reserved.
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     * http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     *
     * =============================================================================
     */
    var DataType;
    (function(DataType2) {
      DataType2[DataType2["DT_INVALID"] = 0] = "DT_INVALID";
      DataType2[DataType2["DT_FLOAT"] = 1] = "DT_FLOAT";
      DataType2[DataType2["DT_DOUBLE"] = 2] = "DT_DOUBLE";
      DataType2[DataType2["DT_INT32"] = 3] = "DT_INT32";
      DataType2[DataType2["DT_UINT8"] = 4] = "DT_UINT8";
      DataType2[DataType2["DT_INT16"] = 5] = "DT_INT16";
      DataType2[DataType2["DT_INT8"] = 6] = "DT_INT8";
      DataType2[DataType2["DT_STRING"] = 7] = "DT_STRING";
      DataType2[DataType2["DT_COMPLEX64"] = 8] = "DT_COMPLEX64";
      DataType2[DataType2["DT_INT64"] = 9] = "DT_INT64";
      DataType2[DataType2["DT_BOOL"] = 10] = "DT_BOOL";
      DataType2[DataType2["DT_QINT8"] = 11] = "DT_QINT8";
      DataType2[DataType2["DT_QUINT8"] = 12] = "DT_QUINT8";
      DataType2[DataType2["DT_QINT32"] = 13] = "DT_QINT32";
      DataType2[DataType2["DT_BFLOAT16"] = 14] = "DT_BFLOAT16";
      DataType2[DataType2["DT_FLOAT_REF"] = 101] = "DT_FLOAT_REF";
      DataType2[DataType2["DT_DOUBLE_REF"] = 102] = "DT_DOUBLE_REF";
      DataType2[DataType2["DT_INT32_REF"] = 103] = "DT_INT32_REF";
      DataType2[DataType2["DT_UINT8_REF"] = 104] = "DT_UINT8_REF";
      DataType2[DataType2["DT_INT16_REF"] = 105] = "DT_INT16_REF";
      DataType2[DataType2["DT_INT8_REF"] = 106] = "DT_INT8_REF";
      DataType2[DataType2["DT_STRING_REF"] = 107] = "DT_STRING_REF";
      DataType2[DataType2["DT_COMPLEX64_REF"] = 108] = "DT_COMPLEX64_REF";
      DataType2[DataType2["DT_INT64_REF"] = 109] = "DT_INT64_REF";
      DataType2[DataType2["DT_BOOL_REF"] = 110] = "DT_BOOL_REF";
      DataType2[DataType2["DT_QINT8_REF"] = 111] = "DT_QINT8_REF";
      DataType2[DataType2["DT_QUINT8_REF"] = 112] = "DT_QUINT8_REF";
      DataType2[DataType2["DT_QINT32_REF"] = 113] = "DT_QINT32_REF";
      DataType2[DataType2["DT_BFLOAT16_REF"] = 114] = "DT_BFLOAT16_REF";
    })(DataType || (DataType = {}));
    var SaverDef;
    (function(SaverDef2) {
      let CheckpointFormatVersion;
      (function(CheckpointFormatVersion2) {
        CheckpointFormatVersion2[CheckpointFormatVersion2["LEGACY"] = 0] = "LEGACY";
        CheckpointFormatVersion2[CheckpointFormatVersion2["V1"] = 1] = "V1";
        CheckpointFormatVersion2[CheckpointFormatVersion2["V2"] = 2] = "V2";
      })(CheckpointFormatVersion = SaverDef2.CheckpointFormatVersion || (SaverDef2.CheckpointFormatVersion = {}));
    })(SaverDef || (SaverDef = {}));
    /**
     * @license
     * Copyright 2019 Google LLC. All Rights Reserved.
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     * http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     * =============================================================================
     */
    const CUSTOM_OPS = {};
    function registerOp(name, opFunc) {
      const opMapper = {
        tfOpName: name,
        category: "custom",
        inputs: [],
        attrs: [],
        customExecutor: opFunc
      };
      CUSTOM_OPS[name] = opMapper;
    }
    function getRegisteredOp(name) {
      return CUSTOM_OPS[name];
    }
    function deregisterOp(name) {
      delete CUSTOM_OPS[name];
    }
    /**
     * @license
     * Copyright 2018 Google LLC. All Rights Reserved.
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     * http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     * =============================================================================
     */
    function getParamValue(paramName, node, tensorMap, context, resourceManager) {
      const inputParam = node.inputParams[paramName];
      if (inputParam && inputParam.inputIndexStart !== void 0) {
        const start = inputParam.inputIndexStart;
        const end = inputParam.inputIndexEnd === 0 ? void 0 : inputParam.inputIndexEnd === void 0 ? start + 1 : inputParam.inputIndexEnd;
        if (inputParam.type === "tensor") {
          return getTensor(node.inputNames[inputParam.inputIndexStart], tensorMap, context, resourceManager);
        }
        if (inputParam.type === "tensors") {
          const inputs = node.inputNames.slice(start, end);
          return inputs.map((name) => getTensor(name, tensorMap, context, resourceManager));
        }
        const tensor7 = getTensor(node.inputNames.slice(start)[0], tensorMap, context, resourceManager);
        const data2 = tensor7.dataSync();
        return inputParam.type === "number" ? data2[0] : toNestedArray2(tensor7.shape, data2);
      }
      const attrParam = node.attrParams[paramName];
      return attrParam && attrParam.value;
    }
    function getTensor(name, tensorsMap, context, resourceManager) {
      const [nodeName, index2] = parseNodeName(name);
      if (resourceManager != null) {
        const tensor7 = resourceManager.getHashTableHandleByName(nodeName);
        if (tensor7 != null) {
          return tensor7;
        }
      }
      const contextId = context.currentContextIds.find((contextId2) => {
        return !!tensorsMap[getNodeNameWithContextId(nodeName, contextId2)];
      });
      return contextId !== void 0 ? tensorsMap[getNodeNameWithContextId(nodeName, contextId)][index2] : void 0;
    }
    function getTensorsForCurrentContenxt(name, tensorsMap, context) {
      return tensorsMap[getNodeNameWithContextId(name, context.currentContextId)];
    }
    function getNodeNameAndIndex(inputName, context) {
      const [nodeName, index2] = parseNodeName(inputName);
      return [
        getNodeNameWithContextId(nodeName, context && context.currentContextId),
        index2
      ];
    }
    function getNodeNameWithContextId(name, contextId) {
      return !!contextId ? `${name}-${contextId}` : name;
    }
    function parseNodeName(name) {
      const parts = name.split(":");
      if (parts.length === 1) {
        return [name, 0];
      }
      const nodeName = parts[0];
      return [nodeName, Number(parts[parts.length - 1])];
    }
    function split$2(arr, size) {
      const res = [];
      for (let i = 0; i < arr.length; i += size) {
        res.push(arr.slice(i, i + size));
      }
      return res;
    }
    function getPadding(node, tensorMap, context) {
      let pad3 = getParamValue("pad", node, tensorMap, context);
      if (pad3 === "explicit") {
        pad3 = getParamValue("explicitPaddings", node, tensorMap, context);
        const explicitPadding = [[0, 0], [0, 0], [0, 0], [0, 0]];
        for (let i = 0; i < 4; i++) {
          explicitPadding[i][0] = pad3[i * 2];
          explicitPadding[i][1] = pad3[i * 2 + 1];
        }
        return explicitPadding;
      }
      return pad3;
    }
    function cloneTensor(tensor7) {
      return tensor7.kept ? tensor7 : clone(tensor7);
    }
    /**
     * @license
     * Copyright 2018 Google LLC. All Rights Reserved.
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     * http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     * =============================================================================
     */
    const json = [
      {
        tfOpName: "Add",
        category: "arithmetic",
        inputs: [
          {start: 0, name: "a", type: "tensor"},
          {start: 1, name: "b", type: "tensor"}
        ],
        attrs: [
          {tfName: "T", name: "dtype", type: "dtype", notSupported: true}
        ]
      },
      {
        tfOpName: "AddV2",
        category: "arithmetic",
        inputs: [
          {start: 0, name: "a", type: "tensor"},
          {start: 1, name: "b", type: "tensor"}
        ],
        attrs: [
          {tfName: "T", name: "dtype", type: "dtype", notSupported: true}
        ]
      },
      {
        tfOpName: "AddN",
        category: "arithmetic",
        inputs: [{start: 0, end: 0, name: "tensors", type: "tensors"}]
      },
      {
        tfOpName: "BiasAdd",
        category: "arithmetic",
        inputs: [
          {start: 0, name: "a", type: "tensor"},
          {start: 1, name: "b", type: "tensor"}
        ],
        attrs: [
          {tfName: "T", name: "dtype", type: "dtype", notSupported: true}
        ]
      },
      {
        tfOpName: "Sub",
        category: "arithmetic",
        inputs: [
          {start: 0, name: "a", type: "tensor"},
          {start: 1, name: "b", type: "tensor"}
        ],
        attrs: [
          {tfName: "T", name: "dtype", type: "dtype", notSupported: true}
        ]
      },
      {
        tfOpName: "RealDiv",
        category: "arithmetic",
        inputs: [
          {start: 0, name: "a", type: "tensor"},
          {start: 1, name: "b", type: "tensor"}
        ],
        attrs: [
          {tfName: "T", name: "dtype", type: "dtype", notSupported: true}
        ]
      },
      {
        tfOpName: "Div",
        category: "arithmetic",
        inputs: [
          {start: 0, name: "a", type: "tensor"},
          {start: 1, name: "b", type: "tensor"}
        ],
        attrs: [
          {tfName: "T", name: "dtype", type: "dtype", notSupported: true}
        ]
      },
      {
        tfOpName: "DivNoNan",
        category: "arithmetic",
        inputs: [
          {start: 0, name: "a", type: "tensor"},
          {start: 1, name: "b", type: "tensor"}
        ],
        attrs: [
          {tfName: "T", name: "dtype", type: "dtype", notSupported: true}
        ]
      },
      {
        tfOpName: "FloorDiv",
        category: "arithmetic",
        inputs: [
          {start: 0, name: "a", type: "tensor"},
          {start: 1, name: "b", type: "tensor"}
        ],
        attrs: [
          {tfName: "T", name: "dtype", type: "dtype", notSupported: true}
        ]
      },
      {
        tfOpName: "Mul",
        category: "arithmetic",
        inputs: [
          {start: 0, name: "a", type: "tensor"},
          {start: 1, name: "b", type: "tensor"}
        ],
        attrs: [
          {tfName: "T", name: "dtype", type: "dtype", notSupported: true}
        ]
      },
      {
        tfOpName: "Maximum",
        category: "arithmetic",
        inputs: [
          {start: 0, name: "a", type: "tensor"},
          {start: 1, name: "b", type: "tensor"}
        ]
      },
      {
        tfOpName: "Minimum",
        category: "arithmetic",
        inputs: [
          {start: 0, name: "a", type: "tensor"},
          {start: 1, name: "b", type: "tensor"}
        ]
      },
      {
        tfOpName: "Pow",
        category: "arithmetic",
        inputs: [
          {start: 0, name: "a", type: "tensor"},
          {start: 1, name: "b", type: "tensor"}
        ],
        attrs: [
          {tfName: "T", name: "dtype", type: "dtype", notSupported: true}
        ]
      },
      {
        tfOpName: "SquaredDifference",
        category: "arithmetic",
        inputs: [
          {start: 0, name: "a", type: "tensor"},
          {start: 1, name: "b", type: "tensor"}
        ],
        attrs: [
          {tfName: "T", name: "dtype", type: "dtype", notSupported: true}
        ]
      },
      {
        tfOpName: "Mod",
        category: "arithmetic",
        inputs: [
          {start: 0, name: "a", type: "tensor"},
          {start: 1, name: "b", type: "tensor"}
        ],
        attrs: [
          {tfName: "T", name: "dtype", type: "dtype", notSupported: true}
        ]
      },
      {
        tfOpName: "FloorMod",
        category: "arithmetic",
        inputs: [
          {start: 0, name: "a", type: "tensor"},
          {start: 1, name: "b", type: "tensor"}
        ],
        attrs: [
          {tfName: "T", name: "dtype", type: "dtype", notSupported: true}
        ]
      }
    ];
    var arithmetic = /* @__PURE__ */ Object.freeze({
      __proto__: null,
      json
    });
    /**
     * @license
     * Copyright 2018 Google LLC. All Rights Reserved.
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     * http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     * =============================================================================
     */
    const json$1 = [
      {
        tfOpName: "Abs",
        category: "basic_math",
        inputs: [
          {start: 0, name: "x", type: "tensor"}
        ],
        attrs: [
          {tfName: "T", name: "dtype", type: "dtype", notSupported: true}
        ]
      },
      {
        tfOpName: "Acos",
        category: "basic_math",
        inputs: [
          {start: 0, name: "x", type: "tensor"}
        ],
        attrs: [
          {tfName: "T", name: "dtype", type: "dtype", notSupported: true}
        ]
      },
      {
        tfOpName: "Asin",
        category: "basic_math",
        inputs: [
          {start: 0, name: "x", type: "tensor"}
        ],
        attrs: [
          {tfName: "T", name: "dtype", type: "dtype", notSupported: true}
        ]
      },
      {
        tfOpName: "Atan",
        category: "basic_math",
        inputs: [
          {start: 0, name: "x", type: "tensor"}
        ],
        attrs: [
          {tfName: "T", name: "dtype", type: "dtype", notSupported: true}
        ]
      },
      {
        tfOpName: "Atan2",
        category: "basic_math",
        inputs: [
          {start: 0, name: "x", type: "tensor"},
          {start: 1, name: "y", type: "tensor"}
        ],
        attrs: [
          {tfName: "T", name: "dtype", type: "dtype", notSupported: true}
        ]
      },
      {
        tfOpName: "Ceil",
        category: "basic_math",
        inputs: [
          {start: 0, name: "x", type: "tensor"}
        ],
        attrs: [
          {tfName: "T", name: "dtype", type: "dtype", notSupported: true}
        ]
      },
      {
        tfOpName: "ClipByValue",
        category: "basic_math",
        inputs: [
          {start: 0, name: "x", type: "tensor"}
        ],
        attrs: [
          {tfName: "clip_value_min", name: "clipValueMin", type: "number"},
          {tfName: "clip_value_max", name: "clipValueMax", type: "number"}
        ]
      },
      {
        tfOpName: "Complex",
        category: "basic_math",
        inputs: [
          {start: 0, name: "real", type: "tensor"},
          {start: 1, name: "imag", type: "tensor"}
        ],
        attrs: [
          {tfName: "T", name: "dtype", type: "dtype", notSupported: true}
        ]
      },
      {
        tfOpName: "ComplexAbs",
        category: "basic_math",
        inputs: [
          {start: 0, name: "x", type: "tensor"}
        ],
        attrs: [
          {tfName: "T", name: "dtype", type: "dtype", notSupported: true}
        ]
      },
      {
        tfOpName: "Cos",
        category: "basic_math",
        inputs: [
          {start: 0, name: "x", type: "tensor"}
        ],
        attrs: [
          {tfName: "T", name: "dtype", type: "dtype", notSupported: true}
        ]
      },
      {
        tfOpName: "Cosh",
        category: "basic_math",
        inputs: [
          {start: 0, name: "x", type: "tensor"}
        ],
        attrs: [
          {tfName: "T", name: "dtype", type: "dtype", notSupported: true}
        ]
      },
      {
        tfOpName: "Elu",
        category: "basic_math",
        inputs: [
          {start: 0, name: "x", type: "tensor"}
        ],
        attrs: [
          {tfName: "T", name: "dtype", type: "dtype", notSupported: true}
        ]
      },
      {
        tfOpName: "Exp",
        category: "basic_math",
        inputs: [
          {start: 0, name: "x", type: "tensor"}
        ],
        attrs: [
          {tfName: "T", name: "dtype", type: "dtype", notSupported: true}
        ]
      },
      {
        tfOpName: "Floor",
        category: "basic_math",
        inputs: [
          {start: 0, name: "x", type: "tensor"}
        ],
        attrs: [
          {tfName: "T", name: "dtype", type: "dtype", notSupported: true}
        ]
      },
      {
        tfOpName: "Log",
        category: "basic_math",
        inputs: [
          {start: 0, name: "x", type: "tensor"}
        ],
        attrs: [
          {tfName: "T", name: "dtype", type: "dtype", notSupported: true}
        ]
      },
      {
        tfOpName: "Imag",
        category: "basic_math",
        inputs: [
          {start: 0, name: "x", type: "tensor"}
        ],
        attrs: [
          {tfName: "T", name: "dtype", type: "dtype", notSupported: true},
          {
            tfName: "Tout",
            name: "outputType",
            type: "dtype",
            notSupported: true
          }
        ]
      },
      {
        tfOpName: "Neg",
        category: "basic_math",
        inputs: [
          {start: 0, name: "x", type: "tensor"}
        ],
        attrs: [
          {tfName: "T", name: "dtype", type: "dtype", notSupported: true}
        ]
      },
      {
        tfOpName: "Real",
        category: "basic_math",
        inputs: [
          {start: 0, name: "x", type: "tensor"}
        ],
        attrs: [
          {tfName: "T", name: "dtype", type: "dtype", notSupported: true},
          {
            tfName: "Tout",
            name: "outputType",
            type: "dtype",
            notSupported: true
          }
        ]
      },
      {
        tfOpName: "Prelu",
        category: "basic_math",
        inputs: [
          {start: 0, name: "x", type: "tensor"},
          {start: 1, name: "alpha", type: "tensor"}
        ],
        attrs: [
          {tfName: "T", name: "dtype", type: "dtype", notSupported: true}
        ]
      },
      {
        tfOpName: "Relu",
        category: "basic_math",
        inputs: [
          {start: 0, name: "x", type: "tensor"}
        ],
        attrs: [
          {tfName: "T", name: "dtype", type: "dtype", notSupported: true}
        ]
      },
      {
        tfOpName: "Relu6",
        category: "basic_math",
        inputs: [
          {start: 0, name: "x", type: "tensor"}
        ],
        attrs: [
          {tfName: "T", name: "dtype", type: "dtype", notSupported: true},
          {
            tfName: "clipValueMin",
            name: "clipValueMin",
            type: "number",
            defaultValue: 0
          },
          {
            tfName: "clipValueMax",
            name: "clipValueMax",
            type: "number",
            defaultValue: 6
          }
        ]
      },
      {
        tfOpName: "Selu",
        category: "basic_math",
        inputs: [
          {start: 0, name: "x", type: "tensor"}
        ],
        attrs: [
          {tfName: "T", name: "dtype", type: "dtype", notSupported: true}
        ]
      },
      {
        tfOpName: "Sigmoid",
        category: "basic_math",
        inputs: [
          {start: 0, name: "x", type: "tensor"}
        ],
        attrs: [
          {tfName: "T", name: "dtype", type: "dtype", notSupported: true}
        ]
      },
      {
        tfOpName: "Sin",
        category: "basic_math",
        inputs: [
          {start: 0, name: "x", type: "tensor"}
        ],
        attrs: [
          {tfName: "T", name: "dtype", type: "dtype", notSupported: true}
        ]
      },
      {
        tfOpName: "Sinh",
        category: "basic_math",
        inputs: [
          {start: 0, name: "x", type: "tensor"}
        ],
        attrs: [
          {tfName: "T", name: "dtype", type: "dtype", notSupported: true}
        ]
      },
      {
        tfOpName: "Sqrt",
        category: "basic_math",
        inputs: [
          {start: 0, name: "x", type: "tensor"}
        ],
        attrs: [
          {tfName: "T", name: "dtype", type: "dtype", notSupported: true}
        ]
      },
      {
        tfOpName: "Rsqrt",
        category: "basic_math",
        inputs: [
          {start: 0, name: "x", type: "tensor"}
        ],
        attrs: [
          {tfName: "T", name: "dtype", type: "dtype", notSupported: true}
        ]
      },
      {
        tfOpName: "Square",
        category: "basic_math",
        inputs: [
          {start: 0, name: "x", type: "tensor"}
        ],
        attrs: [
          {tfName: "T", name: "dtype", type: "dtype", notSupported: true}
        ]
      },
      {
        tfOpName: "Tan",
        category: "basic_math",
        inputs: [
          {start: 0, name: "x", type: "tensor"}
        ],
        attrs: [
          {tfName: "T", name: "dtype", type: "dtype", notSupported: true}
        ]
      },
      {
        tfOpName: "Tanh",
        category: "basic_math",
        inputs: [
          {start: 0, name: "x", type: "tensor"}
        ],
        attrs: [
          {tfName: "T", name: "dtype", type: "dtype", notSupported: true}
        ]
      },
      {
        tfOpName: "Sign",
        category: "basic_math",
        inputs: [
          {start: 0, name: "x", type: "tensor"}
        ],
        attrs: [
          {tfName: "T", name: "dtype", type: "dtype", notSupported: true}
        ]
      },
      {
        tfOpName: "Round",
        category: "basic_math",
        inputs: [
          {start: 0, name: "x", type: "tensor"}
        ],
        attrs: [
          {tfName: "T", name: "dtype", type: "dtype", notSupported: true}
        ]
      },
      {
        tfOpName: "Expm1",
        category: "basic_math",
        inputs: [
          {start: 0, name: "x", type: "tensor"}
        ],
        attrs: [
          {tfName: "T", name: "dtype", type: "dtype", notSupported: true}
        ]
      },
      {
        tfOpName: "Log1p",
        category: "basic_math",
        inputs: [
          {start: 0, name: "x", type: "tensor"}
        ],
        attrs: [
          {tfName: "T", name: "dtype", type: "dtype", notSupported: true}
        ]
      },
      {
        tfOpName: "Reciprocal",
        category: "basic_math",
        inputs: [
          {start: 0, name: "x", type: "tensor"}
        ],
        attrs: [
          {tfName: "T", name: "dtype", type: "dtype", notSupported: true}
        ]
      },
      {
        tfOpName: "Softplus",
        category: "basic_math",
        inputs: [
          {start: 0, name: "x", type: "tensor"}
        ],
        attrs: [
          {tfName: "T", name: "dtype", type: "dtype", notSupported: true}
        ]
      },
      {
        tfOpName: "Asinh",
        category: "basic_math",
        inputs: [
          {start: 0, name: "x", type: "tensor"}
        ],
        attrs: [
          {tfName: "T", name: "dtype", type: "dtype", notSupported: true}
        ]
      },
      {
        tfOpName: "Acosh",
        category: "basic_math",
        inputs: [
          {start: 0, name: "x", type: "tensor"}
        ],
        attrs: [
          {tfName: "T", name: "dtype", type: "dtype", notSupported: true}
        ]
      },
      {
        tfOpName: "Atanh",
        category: "basic_math",
        inputs: [
          {start: 0, name: "x", type: "tensor"}
        ],
        attrs: [
          {tfName: "T", name: "dtype", type: "dtype", notSupported: true}
        ]
      },
      {
        tfOpName: "Erf",
        category: "basic_math",
        inputs: [
          {start: 0, name: "x", type: "tensor"}
        ],
        attrs: [
          {tfName: "T", name: "dtype", type: "dtype", notSupported: true}
        ]
      },
      {
        tfOpName: "Prod",
        category: "basic_math",
        inputs: [
          {start: 0, name: "x", type: "tensor"},
          {start: 1, name: "axes", type: "number[]"}
        ],
        attrs: [
          {
            tfName: "keep_dims",
            name: "keepDims",
            type: "bool",
            notSupported: true
          },
          {tfName: "T", name: "dtype", type: "dtype", notSupported: true}
        ]
      },
      {
        tfOpName: "LeakyRelu",
        category: "basic_math",
        inputs: [
          {start: 0, name: "x", type: "tensor"}
        ],
        attrs: [
          {
            tfName: "alpha",
            name: "alpha",
            type: "number",
            defaultValue: 0.2
          },
          {
            tfName: "T",
            name: "dtype",
            type: "dtype",
            notSupported: true
          }
        ]
      }
    ];
    var basicMath = /* @__PURE__ */ Object.freeze({
      __proto__: null,
      json: json$1
    });
    const json$2 = [
      {
        tfOpName: "LoopCond",
        category: "control",
        inputs: [{start: 0, name: "pred", type: "tensor"}]
      },
      {
        tfOpName: "Switch",
        category: "control",
        inputs: [
          {start: 0, name: "data", type: "tensor"},
          {start: 1, name: "pred", type: "tensor"}
        ]
      },
      {
        tfOpName: "Merge",
        category: "control",
        inputs: [{start: 0, end: 0, name: "tensors", type: "tensors"}]
      },
      {
        tfOpName: "Enter",
        category: "control",
        inputs: [
          {start: 0, name: "tensor", type: "tensor"}
        ],
        attrs: [
          {tfName: "T", name: "dtype", type: "dtype", notSupported: true},
          {tfName: "frame_name", name: "frameName", type: "string"},
          {tfName: "is_constant", name: "isConstant", type: "bool"}
        ]
      },
      {
        tfOpName: "Exit",
        category: "control",
        inputs: [
          {start: 0, name: "tensor", type: "tensor"}
        ],
        attrs: [
          {tfName: "T", name: "dtype", type: "dtype", notSupported: true}
        ]
      },
      {
        tfOpName: "NextIteration",
        category: "control",
        inputs: [
          {start: 0, name: "tensor", type: "tensor"}
        ],
        attrs: [
          {tfName: "T", name: "dtype", type: "dtype", notSupported: true}
        ]
      },
      {
        tfOpName: "TensorArrayV3",
        category: "control",
        inputs: [
          {start: 0, name: "size", type: "number"}
        ],
        attrs: [
          {tfName: "dtype", name: "dtype", type: "dtype"},
          {tfName: "element_shape", name: "elementShape", type: "shape"},
          {tfName: "dynamic_size", name: "dynamicSize", type: "bool"},
          {tfName: "clear_after_read", name: "clearAfterRead", type: "bool"},
          {
            tfName: "identical_element_shapes",
            name: "identicalElementShapes",
            type: "bool"
          },
          {tfName: "tensor_array_name", name: "name", type: "string"}
        ]
      },
      {
        tfOpName: "TensorArrayWriteV3",
        category: "control",
        inputs: [
          {start: 0, name: "tensorArrayId", type: "tensor"},
          {start: 1, name: "index", type: "number"},
          {start: 2, name: "tensor", type: "tensor"},
          {start: 3, name: "flowIn", type: "number"}
        ],
        attrs: [
          {tfName: "T", name: "dtype", type: "dtype", notSupported: true}
        ]
      },
      {
        tfOpName: "TensorArrayReadV3",
        category: "control",
        inputs: [
          {start: 0, name: "tensorArrayId", type: "tensor"},
          {start: 1, name: "index", type: "number"},
          {start: 2, name: "flowIn", type: "number"}
        ],
        attrs: [{
          tfName: "dtype",
          name: "dtype",
          type: "dtype",
          notSupported: true
        }]
      },
      {
        tfOpName: "TensorArrayGatherV3",
        category: "control",
        inputs: [
          {start: 0, name: "tensorArrayId", type: "tensor"},
          {start: 1, name: "indices", type: "number[]"},
          {start: 2, name: "flowIn", type: "number"}
        ],
        attrs: [
          {tfName: "dtype", name: "dtype", type: "dtype"},
          {tfName: "element_shape", name: "elementShape", type: "shape"}
        ]
      },
      {
        tfOpName: "TensorArrayScatterV3",
        category: "control",
        inputs: [
          {start: 0, name: "tensorArrayId", type: "tensor"},
          {start: 1, name: "indices", type: "number[]"},
          {start: 2, name: "tensor", type: "tensor"},
          {start: 3, name: "flowIn", type: "number"}
        ],
        attrs: [{tfName: "T", name: "dtype", type: "dtype"}]
      },
      {
        tfOpName: "TensorArrayConcatV3",
        category: "control",
        inputs: [
          {start: 0, name: "tensorArrayId", type: "tensor"},
          {start: 1, name: "flowIn", type: "number"}
        ],
        attrs: [
          {tfName: "dtype", name: "dtype", type: "dtype"},
          {
            tfName: "element_shape_except0",
            name: "elementShapeExcept0",
            type: "shape",
            notSupported: true
          }
        ]
      },
      {
        tfOpName: "TensorArraySplitV3",
        category: "control",
        inputs: [
          {start: 0, name: "tensorArrayId", type: "tensor"},
          {start: 1, name: "tensor", type: "tensor"},
          {start: 2, name: "lengths", type: "number[]"},
          {start: 3, name: "flowIn", type: "number"}
        ],
        attrs: [{tfName: "T", name: "dtype", type: "dtype"}]
      },
      {
        tfOpName: "TensorArraySizeV3",
        category: "control",
        inputs: [
          {start: 0, name: "tensorArrayId", type: "tensor"},
          {start: 1, name: "flowIn", type: "number"}
        ]
      },
      {
        tfOpName: "TensorArrayCloseV3",
        category: "control",
        inputs: [{start: 0, name: "tensorArrayId", type: "tensor"}]
      },
      {
        tfOpName: "StatelessIf",
        category: "control",
        inputs: [
          {start: 0, name: "cond", type: "tensor"},
          {start: 1, end: 0, name: "args", type: "tensors"}
        ],
        attrs: [
          {tfName: "then_branch", name: "thenBranch", type: "func"},
          {tfName: "else_branch", name: "elseBranch", type: "func"}
        ]
      },
      {
        tfOpName: "If",
        category: "control",
        inputs: [
          {start: 0, name: "cond", type: "tensor"},
          {start: 1, end: 0, name: "args", type: "tensors"}
        ],
        attrs: [
          {tfName: "then_branch", name: "thenBranch", type: "func"},
          {tfName: "else_branch", name: "elseBranch", type: "func"}
        ]
      },
      {
        tfOpName: "StatelessWhile",
        category: "control",
        inputs: [
          {start: 0, end: 0, name: "args", type: "tensors"}
        ],
        attrs: [
          {tfName: "cond", name: "cond", type: "func"},
          {tfName: "body", name: "body", type: "func"}
        ]
      },
      {
        tfOpName: "While",
        category: "control",
        inputs: [
          {start: 0, end: 0, name: "args", type: "tensors"}
        ],
        attrs: [
          {tfName: "cond", name: "cond", type: "func"},
          {tfName: "body", name: "body", type: "func"}
        ]
      },
      {
        tfOpName: "TensorListScatter",
        category: "control",
        inputs: [
          {start: 0, name: "tensor", type: "tensor"},
          {start: 1, name: "indices", type: "number[]"},
          {start: 2, name: "elementShape", type: "shape"}
        ],
        attrs: [{tfName: "element_dtype", name: "elementDType", type: "dtype"}]
      },
      {
        tfOpName: "TensorListScatterV2",
        category: "control",
        inputs: [
          {start: 0, name: "tensor", type: "tensor"},
          {start: 1, name: "indices", type: "number[]"},
          {start: 2, name: "elementShape", type: "shape"},
          {start: 3, name: "numElements", type: "number"}
        ],
        attrs: [{tfName: "element_dtype", name: "elementDType", type: "dtype"}]
      },
      {
        tfOpName: "TensorListGather",
        category: "control",
        inputs: [
          {start: 0, name: "tensorListId", type: "tensor"},
          {start: 1, name: "indices", type: "number[]"},
          {start: 2, name: "elementShape", type: "shape"}
        ],
        attrs: [{tfName: "element_dtype", name: "elementDType", type: "dtype"}]
      },
      {
        tfOpName: "TensorListGetItem",
        category: "control",
        inputs: [
          {start: 0, name: "tensorListId", type: "tensor"},
          {start: 1, name: "index", type: "number"},
          {start: 2, name: "elementShape", type: "shape"}
        ],
        attrs: [{tfName: "element_dtype", name: "elementDType", type: "dtype"}]
      },
      {
        tfOpName: "TensorListSetItem",
        category: "control",
        inputs: [
          {start: 0, name: "tensorListId", type: "tensor"},
          {start: 1, name: "index", type: "number"},
          {start: 2, name: "tensor", type: "tensor"}
        ],
        attrs: [{tfName: "element_dtype", name: "elementDType", type: "dtype"}]
      },
      {
        tfOpName: "TensorListReserve",
        category: "control",
        inputs: [
          {start: 0, name: "elementShape", type: "shape"},
          {start: 1, name: "numElements", type: "number"}
        ],
        attrs: [{tfName: "element_dtype", name: "elementDType", type: "dtype"}]
      },
      {
        tfOpName: "TensorListFromTensor",
        category: "control",
        inputs: [
          {start: 0, name: "tensor", type: "tensor"},
          {start: 1, name: "elementShape", type: "shape"}
        ],
        attrs: [{tfName: "element_dtype", name: "elementDType", type: "dtype"}]
      },
      {
        tfOpName: "TensorListStack",
        category: "control",
        inputs: [
          {start: 0, name: "tensorListId", type: "tensor"},
          {start: 1, name: "elementShape", type: "shape"}
        ],
        attrs: [
          {tfName: "element_dtype", name: "elementDType", type: "dtype"},
          {tfName: "num_elements", name: "numElements", type: "dtype"}
        ]
      },
      {
        tfOpName: "TensorListSplit",
        category: "control",
        inputs: [
          {start: 0, name: "tensor", type: "tensor"},
          {start: 1, name: "elementShape", type: "shape"},
          {start: 2, name: "lengths", type: "number[]"}
        ],
        attrs: [{tfName: "element_dtype", name: "elementDType", type: "dtype"}]
      },
      {
        tfOpName: "TensorListConcat",
        category: "control",
        inputs: [
          {start: 0, name: "tensorListId", type: "tensor"}
        ],
        attrs: [
          {tfName: "element_shape", name: "elementShape", type: "shape"},
          {tfName: "element_dtype", name: "elementDType", type: "dtype"}
        ]
      },
      {
        tfOpName: "TensorListPopBack",
        category: "control",
        inputs: [
          {start: 0, name: "tensorListId", type: "tensor"},
          {start: 1, name: "elementShape", type: "shape"}
        ],
        attrs: [{tfName: "element_dtype", name: "elementDType", type: "dtype"}]
      },
      {
        tfOpName: "TensorListPushBack",
        category: "control",
        inputs: [
          {start: 0, name: "tensorListId", type: "tensor"},
          {start: 1, name: "tensor", type: "tensor"}
        ],
        attrs: [
          {tfName: "element_dtype", name: "elementDType", type: "dtype"}
        ]
      }
    ];
    var control = /* @__PURE__ */ Object.freeze({
      __proto__: null,
      json: json$2
    });
    /**
     * @license
     * Copyright 2020 Google LLC. All Rights Reserved.
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     * http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     * =============================================================================
     */
    const json$3 = [
      {
        tfOpName: "AvgPool",
        category: "convolution",
        inputs: [
          {start: 0, name: "x", type: "tensor"}
        ],
        attrs: [
          {tfName: "strides", name: "strides", type: "number[]"},
          {tfName: "padding", name: "pad", type: "string"},
          {
            tfName: "data_format",
            name: "dataFormat",
            type: "string",
            notSupported: true
          },
          {tfName: "ksize", name: "kernelSize", type: "number[]"},
          {tfName: "T", name: "dtype", type: "dtype", notSupported: true}
        ]
      },
      {
        tfOpName: "MaxPool",
        category: "convolution",
        inputs: [
          {start: 0, name: "x", type: "tensor"}
        ],
        attrs: [
          {tfName: "strides", name: "strides", type: "number[]"},
          {tfName: "padding", name: "pad", type: "string"},
          {
            tfName: "data_format",
            name: "dataFormat",
            type: "string",
            notSupported: true
          },
          {tfName: "ksize", name: "kernelSize", type: "number[]"},
          {tfName: "T", name: "dtype", type: "dtype", notSupported: true}
        ]
      },
      {
        tfOpName: "MaxPoolWithArgmax",
        category: "convolution",
        inputs: [
          {start: 0, name: "x", type: "tensor"}
        ],
        attrs: [
          {tfName: "strides", name: "strides", type: "number[]"},
          {tfName: "padding", name: "pad", type: "string"},
          {tfName: "ksize", name: "kernelSize", type: "number[]"},
          {
            tfName: "include_batch_in_index",
            name: "includeBatchInIndex",
            type: "bool"
          },
          {tfName: "T", name: "dtype", type: "dtype", notSupported: true}
        ]
      },
      {
        tfOpName: "AvgPool3D",
        category: "convolution",
        inputs: [
          {start: 0, name: "x", type: "tensor"}
        ],
        attrs: [
          {tfName: "strides", name: "strides", type: "number[]"},
          {tfName: "padding", name: "pad", type: "string"},
          {
            tfName: "data_format",
            name: "dataFormat",
            type: "string",
            notSupported: true
          },
          {tfName: "ksize", name: "kernelSize", type: "number[]"},
          {tfName: "T", name: "dtype", type: "dtype", notSupported: true}
        ]
      },
      {
        tfOpName: "MaxPool3D",
        category: "convolution",
        inputs: [
          {start: 0, name: "x", type: "tensor"}
        ],
        attrs: [
          {tfName: "strides", name: "strides", type: "number[]"},
          {tfName: "padding", name: "pad", type: "string"},
          {
            tfName: "data_format",
            name: "dataFormat",
            type: "string",
            notSupported: true
          },
          {tfName: "ksize", name: "kernelSize", type: "number[]"},
          {tfName: "T", name: "dtype", type: "dtype", notSupported: true}
        ]
      },
      {
        tfOpName: "Conv1D",
        category: "convolution",
        inputs: [
          {start: 0, name: "x", type: "tensor"},
          {start: 1, name: "filter", type: "tensor"}
        ],
        attrs: [
          {tfName: "stride", name: "stride", type: "number"},
          {tfName: "padding", name: "pad", type: "string"},
          {
            tfName: "data_format",
            name: "dataFormat",
            type: "string",
            defaultValue: "NWC"
          },
          {tfName: "T", name: "dtype", type: "dtype", notSupported: true},
          {
            tfName: "dilation",
            name: "dilation",
            type: "number",
            defaultValue: 1
          }
        ]
      },
      {
        tfOpName: "Conv2D",
        category: "convolution",
        inputs: [
          {start: 0, name: "x", type: "tensor"},
          {start: 1, name: "filter", type: "tensor"}
        ],
        attrs: [
          {tfName: "T", name: "dtype", type: "dtype", notSupported: true},
          {tfName: "strides", name: "strides", type: "number[]"},
          {tfName: "padding", name: "pad", type: "string"},
          {tfName: "useCudnnOnGpu", name: "useCudnnOnGpu", type: "bool"},
          {
            tfName: "data_format",
            name: "dataFormat",
            type: "string",
            defaultValue: "NHWC"
          },
          {
            tfName: "explicit_paddings",
            name: "explicitPaddings",
            type: "number[]",
            defaultValue: []
          },
          {tfName: "dilations", name: "dilations", type: "number[]"}
        ]
      },
      {
        tfOpName: "_FusedConv2D",
        category: "convolution",
        inputs: [
          {start: 0, name: "x", type: "tensor"},
          {start: 1, name: "filter", type: "tensor"},
          {start: 2, end: 0, name: "args", type: "tensors"}
        ],
        attrs: [
          {tfName: "num_args", name: "numArgs", type: "number"},
          {tfName: "T", name: "dtype", type: "dtype", notSupported: true},
          {tfName: "strides", name: "strides", type: "number[]"},
          {tfName: "padding", name: "pad", type: "string"},
          {
            tfName: "explicit_paddings",
            name: "explicitPaddings",
            type: "number[]",
            defaultValue: []
          },
          {
            tfName: "use_cudnn_on_gpu",
            name: "useCudnnOnGpu",
            type: "bool",
            defaultValue: true
          },
          {
            tfName: "data_format",
            name: "dataFormat",
            type: "string",
            defaultValue: "NHWC"
          },
          {
            tfName: "dilations",
            name: "dilations",
            type: "number[]",
            defaultValue: [1, 1, 1, 1]
          },
          {
            tfName: "fused_ops",
            name: "fusedOps",
            type: "string[]",
            defaultValue: []
          },
          {
            tfName: "epsilon",
            name: "epsilon",
            type: "number",
            defaultValue: 1e-4
          }
        ]
      },
      {
        tfOpName: "Conv2DBackpropInput",
        category: "convolution",
        inputs: [
          {start: 2, name: "x", type: "tensor"},
          {start: 1, name: "filter", type: "tensor"},
          {start: 0, name: "outputShape", type: "number[]"}
        ],
        attrs: [
          {tfName: "strides", name: "strides", type: "number[]"},
          {tfName: "padding", name: "pad", type: "string"},
          {
            tfName: "data_format",
            name: "dataFormat",
            type: "string",
            notSupported: true
          },
          {
            tfName: "explicit_paddings",
            name: "explicitPaddings",
            type: "number[]",
            defaultValue: []
          }
        ]
      },
      {
        tfOpName: "DepthwiseConv2d",
        category: "convolution",
        inputs: [
          {start: 0, name: "input", type: "tensor"},
          {start: 1, name: "filter", type: "tensor"}
        ],
        attrs: [
          {tfName: "strides", name: "strides", type: "number[]"},
          {tfName: "padding", name: "pad", type: "string"},
          {
            tfName: "data_format",
            name: "dataFormat",
            type: "string",
            defaultValue: "NHWC"
          },
          {
            tfName: "explicit_paddings",
            name: "explicitPaddings",
            type: "number[]",
            defaultValue: []
          },
          {tfName: "dilations", name: "dilations", type: "number[]"}
        ]
      },
      {
        tfOpName: "DepthwiseConv2dNative",
        category: "convolution",
        inputs: [
          {start: 0, name: "input", type: "tensor"},
          {start: 1, name: "filter", type: "tensor"}
        ],
        attrs: [
          {tfName: "strides", name: "strides", type: "number[]"},
          {tfName: "padding", name: "pad", type: "string"},
          {
            tfName: "data_format",
            name: "dataFormat",
            type: "string",
            defaultValue: "NHWC"
          },
          {
            tfName: "explicit_paddings",
            name: "explicitPaddings",
            type: "number[]",
            defaultValue: []
          },
          {tfName: "dilations", name: "dilations", type: "number[]"}
        ]
      },
      {
        tfOpName: "FusedDepthwiseConv2dNative",
        category: "convolution",
        inputs: [
          {start: 0, name: "x", type: "tensor"},
          {start: 1, name: "filter", type: "tensor"},
          {start: 2, end: 0, name: "args", type: "tensors"}
        ],
        attrs: [
          {tfName: "num_args", name: "numArgs", type: "number"},
          {tfName: "T", name: "dtype", type: "dtype", notSupported: true},
          {tfName: "strides", name: "strides", type: "number[]"},
          {tfName: "padding", name: "pad", type: "string"},
          {
            tfName: "data_format",
            name: "dataFormat",
            type: "string",
            defaultValue: "NHWC"
          },
          {
            tfName: "dilations",
            name: "dilations",
            type: "number[]",
            defaultValue: [1, 1, 1, 1]
          },
          {
            tfName: "fused_ops",
            name: "fusedOps",
            type: "string[]",
            defaultValue: []
          }
        ]
      },
      {
        tfOpName: "Conv3D",
        category: "convolution",
        inputs: [
          {start: 0, name: "x", type: "tensor"},
          {start: 1, name: "filter", type: "tensor"}
        ],
        attrs: [
          {tfName: "strides", name: "strides", type: "number[]"},
          {tfName: "padding", name: "pad", type: "string"},
          {
            tfName: "data_format",
            name: "dataFormat",
            type: "string",
            defaultValue: "NHWC"
          },
          {tfName: "dilations", name: "dilations", type: "number[]"}
        ]
      },
      {
        tfOpName: "Dilation2D",
        category: "convolution",
        inputs: [
          {start: 0, name: "x", type: "tensor"},
          {start: 1, name: "filter", type: "tensor"}
        ],
        attrs: [
          {tfName: "strides", name: "strides", type: "number[]"},
          {tfName: "rates", name: "dilations", type: "number[]"},
          {tfName: "padding", name: "pad", type: "string"}
        ]
      }
    ];
    var convolution = /* @__PURE__ */ Object.freeze({
      __proto__: null,
      json: json$3
    });
    /**
     * @license
     * Copyright 2018 Google LLC. All Rights Reserved.
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     * http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     * =============================================================================
     */
    const json$4 = [
      {
        tfOpName: "Fill",
        category: "creation",
        inputs: [
          {start: 0, name: "shape", type: "number[]"},
          {start: 1, name: "value", type: "number"}
        ],
        attrs: [{tfName: "T", name: "dtype", type: "dtype"}]
      },
      {
        tfOpName: "LinSpace",
        category: "creation",
        inputs: [
          {start: 0, name: "start", type: "number"},
          {start: 1, name: "stop", type: "number"},
          {start: 2, name: "num", type: "number"}
        ],
        attrs: [
          {tfName: "T", name: "dtype", type: "dtype", notSupported: true}
        ]
      },
      {
        tfOpName: "OneHot",
        category: "creation",
        inputs: [
          {start: 0, name: "indices", type: "tensor"},
          {start: 1, name: "depth", type: "number"},
          {start: 2, name: "onValue", type: "number", defaultValue: 1},
          {start: 3, name: "offValue", type: "number", defaultValue: 0}
        ],
        attrs: [
          {
            tfName: "axis",
            name: "axis",
            type: "number",
            notSupported: true
          },
          {tfName: "T", name: "dtype", type: "dtype", notSupported: true}
        ]
      },
      {
        tfOpName: "Ones",
        category: "creation",
        inputs: [
          {start: 0, name: "shape", type: "number[]"}
        ],
        attrs: [{tfName: "T", name: "dtype", type: "dtype"}]
      },
      {
        tfOpName: "OnesLike",
        category: "creation",
        inputs: [
          {start: 0, name: "x", type: "tensor"}
        ],
        attrs: [{tfName: "dtype", name: "dtype", type: "dtype"}]
      },
      {
        tfOpName: "RandomUniform",
        category: "creation",
        inputs: [
          {start: 0, name: "shape", type: "number[]"}
        ],
        attrs: [
          {
            tfName: "minval",
            name: "minval",
            type: "number",
            defaultValue: 0
          },
          {
            tfName: "maxval",
            name: "maxval",
            type: "number",
            defaultValue: 1
          },
          {tfName: "dtype", name: "dtype", type: "dtype"},
          {tfName: "seed", name: "seed", type: "number", defaultValue: 0},
          {
            tfName: "seed2",
            name: "seed2",
            type: "number",
            defaultValue: 0,
            notSupported: true
          },
          {tfName: "T", name: "T", type: "number", notSupported: true}
        ]
      },
      {
        tfOpName: "Range",
        category: "creation",
        inputs: [
          {start: 0, name: "start", type: "number"},
          {start: 1, name: "stop", type: "number"},
          {start: 2, name: "step", type: "number", defaultValue: 0}
        ],
        attrs: [{tfName: "Tidx", name: "dtype", type: "dtype"}]
      },
      {
        tfOpName: "TruncatedNormal",
        category: "creation",
        inputs: [
          {start: 0, name: "shape", type: "number[]"}
        ],
        attrs: [
          {
            tfName: "means",
            name: "mean",
            type: "number",
            defaultValue: 0
          },
          {
            tfName: "stddev",
            name: "stdDev",
            type: "number",
            defaultValue: 1
          },
          {tfName: "seed", name: "seed", type: "number"},
          {
            tfName: "seed2",
            name: "seed2",
            type: "number",
            defaultValue: 0,
            notSupported: true
          },
          {tfName: "dtype", name: "dtype", type: "dtype"},
          {tfName: "T", name: "T", type: "number", notSupported: true}
        ]
      },
      {
        tfOpName: "Zeros",
        category: "creation",
        inputs: [
          {start: 0, name: "shape", type: "number[]"}
        ],
        attrs: [{tfName: "T", name: "dtype", type: "dtype"}]
      },
      {
        tfOpName: "ZerosLike",
        category: "creation",
        inputs: [
          {start: 0, name: "x", type: "tensor"}
        ],
        attrs: [{tfName: "T", name: "dtype", type: "dtype"}]
      },
      {
        tfOpName: "Multinomial",
        category: "creation",
        inputs: [
          {start: 0, name: "logits", type: "tensor"},
          {start: 1, name: "numSamples", type: "number"}
        ],
        attrs: [
          {tfName: "seed", name: "seed", type: "number"},
          {tfName: "seed2", name: "seed2", type: "number"},
          {tfName: "T", name: "dtype", type: "dtype"},
          {tfName: "output_dtype", name: "output_dtype", type: "dtype"}
        ]
      }
    ];
    var creation = /* @__PURE__ */ Object.freeze({
      __proto__: null,
      json: json$4
    });
    /**
     * @license
     * Copyright 2018 Google LLC. All Rights Reserved.
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     * http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     * =============================================================================
     */
    const json$5 = [
      {
        tfOpName: "NonMaxSuppressionV2",
        category: "dynamic",
        inputs: [
          {start: 0, name: "boxes", type: "tensor"},
          {start: 1, name: "scores", type: "tensor"},
          {start: 2, name: "maxOutputSize", type: "number"},
          {start: 3, name: "iouThreshold", type: "number"}
        ]
      },
      {
        tfOpName: "NonMaxSuppressionV3",
        category: "dynamic",
        inputs: [
          {start: 0, name: "boxes", type: "tensor"},
          {start: 1, name: "scores", type: "tensor"},
          {start: 2, name: "maxOutputSize", type: "number"},
          {start: 3, name: "iouThreshold", type: "number"},
          {start: 4, name: "scoreThreshold", type: "number"}
        ]
      },
      {
        tfOpName: "NonMaxSuppressionV4",
        category: "dynamic",
        inputs: [
          {start: 0, name: "boxes", type: "tensor"},
          {start: 1, name: "scores", type: "tensor"},
          {start: 2, name: "maxOutputSize", type: "number"},
          {start: 3, name: "iouThreshold", type: "number"},
          {start: 4, name: "scoreThreshold", type: "number"}
        ],
        attrs: [
          {tfName: "T", name: "dtype", type: "dtype", notSupported: true},
          {
            tfName: "T_threshold",
            name: "threshold",
            type: "dtype",
            notSupported: true
          },
          {
            tfName: "pad_to_max_output_size",
            name: "padToMaxOutputSize",
            type: "bool"
          }
        ]
      },
      {
        tfOpName: "NonMaxSuppressionV5",
        category: "dynamic",
        inputs: [
          {start: 0, name: "boxes", type: "tensor"},
          {start: 1, name: "scores", type: "tensor"},
          {start: 2, name: "maxOutputSize", type: "number"},
          {start: 3, name: "iouThreshold", type: "number"},
          {start: 4, name: "scoreThreshold", type: "number"},
          {start: 5, name: "softNmsSigma", type: "number"}
        ]
      },
      {
        tfOpName: "Where",
        category: "dynamic",
        inputs: [
          {start: 0, name: "condition", type: "tensor"}
        ],
        attrs: [
          {tfName: "T", name: "dtype", type: "dtype", notSupported: true}
        ]
      },
      {
        tfOpName: "ListDiff",
        category: "dynamic",
        inputs: [
          {start: 0, name: "x", type: "tensor"},
          {start: 1, name: "y", type: "tensor"}
        ],
        attrs: [{
          tfName: "T",
          name: "dtype",
          type: "dtype",
          notSupported: true
        }]
      }
    ];
    var dynamic = /* @__PURE__ */ Object.freeze({
      __proto__: null,
      json: json$5
    });
    /**
     * @license
     * Copyright 2018 Google LLC. All Rights Reserved.
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     * http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     * =============================================================================
     */
    const json$6 = [
      {
        tfOpName: "TopKV2",
        category: "evaluation",
        inputs: [
          {start: 0, name: "x", type: "tensor"},
          {start: 1, name: "k", type: "number"}
        ],
        attrs: [{tfName: "sorted", name: "sorted", type: "bool"}]
      },
      {
        tfOpName: "Unique",
        category: "evaluation",
        inputs: [
          {start: 0, name: "x", type: "tensor"}
        ]
      },
      {
        tfOpName: "UniqueV2",
        category: "evaluation",
        inputs: [
          {start: 0, name: "x", type: "tensor"},
          {start: 1, name: "axis", type: "number"}
        ]
      }
    ];
    var evaluation = /* @__PURE__ */ Object.freeze({
      __proto__: null,
      json: json$6
    });
    /**
     * @license
     * Copyright 2018 Google LLC. All Rights Reserved.
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     * http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     * =============================================================================
     */
    const json$7 = [
      {
        tfOpName: "PlaceholderWithDefault",
        category: "graph",
        inputs: [
          {start: 0, name: "default", type: "tensor"}
        ],
        attrs: [
          {tfName: "shape", name: "shape", type: "shape"},
          {tfName: "dtype", name: "dtype", type: "dtype"}
        ]
      },
      {
        tfOpName: "Placeholder",
        category: "graph",
        attrs: [
          {tfName: "shape", name: "shape", type: "shape"},
          {tfName: "dtype", name: "dtype", type: "dtype"}
        ]
      },
      {tfOpName: "Const", category: "graph"},
      {
        tfOpName: "Identity",
        category: "graph",
        inputs: [{start: 0, name: "x", type: "tensor"}]
      },
      {
        tfOpName: "IdentityN",
        category: "graph",
        inputs: [{start: 0, end: 0, name: "x", type: "tensors"}]
      },
      {
        tfOpName: "Snapshot",
        category: "graph",
        inputs: [{start: 0, name: "x", type: "tensor"}]
      },
      {
        tfOpName: "Rank",
        category: "graph",
        inputs: [{start: 0, name: "x", type: "tensor"}]
      },
      {
        tfOpName: "Size",
        category: "graph",
        inputs: [{start: 0, name: "x", type: "tensor"}]
      },
      {
        tfOpName: "Shape",
        category: "graph",
        inputs: [{start: 0, name: "x", type: "tensor"}]
      },
      {
        tfOpName: "ShapeN",
        category: "graph",
        inputs: [{start: 0, end: 0, name: "x", type: "tensors"}]
      },
      {
        tfOpName: "Print",
        category: "graph",
        inputs: [
          {start: 0, name: "x", type: "tensor"},
          {start: 1, name: "data", type: "tensors"}
        ],
        attrs: [
          {tfName: "message", name: "message", type: "string"},
          {
            tfName: "first_n",
            name: "firstN",
            type: "number",
            notSupported: true
          },
          {
            tfName: "summarize",
            name: "summarize",
            type: "number",
            defaultValue: 3
          }
        ]
      },
      {tfOpName: "NoOp", category: "graph", inputs: []},
      {
        tfOpName: "StopGradient",
        category: "graph",
        inputs: [{start: 0, name: "x", type: "tensor"}]
      },
      {
        tfOpName: "FakeQuantWithMinMaxVars",
        category: "graph",
        inputs: [
          {start: 0, name: "x", type: "tensor"}
        ],
        attrs: [
          {tfName: "min", name: "min", type: "number"},
          {tfName: "max", name: "max", type: "number"}
        ]
      }
    ];
    var graph = /* @__PURE__ */ Object.freeze({
      __proto__: null,
      json: json$7
    });
    const json$8 = [
      {
        tfOpName: "HashTable",
        category: "hash_table",
        inputs: [],
        attrs: [
          {tfName: "shared_name", name: "sharedName", type: "string"},
          {
            tfName: "use_node_name_sharing",
            name: "useNodeNameSharing",
            type: "bool"
          },
          {tfName: "key_dtype", name: "keyDType", type: "dtype"},
          {tfName: "value_dtype", name: "valueDType", type: "dtype"}
        ]
      },
      {
        tfOpName: "HashTableV2",
        category: "hash_table",
        inputs: [],
        attrs: [
          {tfName: "shared_name", name: "sharedName", type: "string"},
          {
            tfName: "use_node_name_sharing",
            name: "useNodeNameSharing",
            type: "bool"
          },
          {tfName: "key_dtype", name: "keyDType", type: "dtype"},
          {tfName: "value_dtype", name: "valueDType", type: "dtype"}
        ]
      },
      {
        tfOpName: "LookupTableImport",
        category: "hash_table",
        inputs: [
          {start: 0, name: "tableHandle", type: "tensor"},
          {start: 1, name: "keys", type: "tensor"},
          {start: 2, name: "values", type: "tensor"}
        ],
        attrs: [
          {tfName: "Tin", name: "tIn", type: "dtype", notSupported: true},
          {
            tfName: "Tout",
            name: "tOut",
            type: "dtype",
            notSupported: true
          }
        ]
      },
      {
        tfOpName: "LookupTableImportV2",
        category: "hash_table",
        inputs: [
          {start: 0, name: "tableHandle", type: "tensor"},
          {start: 1, name: "keys", type: "tensor"},
          {start: 2, name: "values", type: "tensor"}
        ],
        attrs: [
          {tfName: "Tin", name: "tIn", type: "dtype", notSupported: true},
          {
            tfName: "Tout",
            name: "tOut",
            type: "dtype",
            notSupported: true
          }
        ]
      },
      {
        tfOpName: "LookupTableFind",
        category: "hash_table",
        inputs: [
          {start: 0, name: "tableHandle", type: "tensor"},
          {start: 1, name: "keys", type: "tensor"},
          {start: 2, name: "defaultValue", type: "tensor"}
        ],
        attrs: [
          {tfName: "Tin", name: "tIn", type: "dtype", notSupported: true},
          {
            tfName: "Tout",
            name: "tOut",
            type: "dtype",
            notSupported: true
          }
        ]
      },
      {
        tfOpName: "LookupTableFindV2",
        category: "hash_table",
        inputs: [
          {start: 0, name: "tableHandle", type: "tensor"},
          {start: 1, name: "keys", type: "tensor"},
          {start: 2, name: "defaultValue", type: "tensor"}
        ],
        attrs: [
          {tfName: "Tin", name: "tIn", type: "dtype", notSupported: true},
          {
            tfName: "Tout",
            name: "tOut",
            type: "dtype",
            notSupported: true
          }
        ]
      }
    ];
    var hashTable = /* @__PURE__ */ Object.freeze({
      __proto__: null,
      json: json$8
    });
    /**
     * @license
     * Copyright 2018 Google LLC. All Rights Reserved.
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     * http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     * =============================================================================
     */
    const json$9 = [
      {
        tfOpName: "ResizeBilinear",
        category: "image",
        inputs: [
          {start: 0, name: "images", type: "tensor"},
          {start: 1, name: "size", type: "number[]"}
        ],
        attrs: [
          {tfName: "align_corners", name: "alignCorners", type: "bool"},
          {tfName: "T", name: "dtype", type: "dtype", notSupported: true}
        ]
      },
      {
        tfOpName: "ResizeNearestNeighbor",
        category: "image",
        inputs: [
          {start: 0, name: "images", type: "tensor"},
          {start: 1, name: "size", type: "number[]"}
        ],
        attrs: [
          {tfName: "align_corners", name: "alignCorners", type: "bool"},
          {tfName: "T", name: "dtype", type: "dtype", notSupported: true}
        ]
      },
      {
        tfOpName: "CropAndResize",
        category: "image",
        inputs: [
          {start: 0, name: "image", type: "tensor"},
          {start: 1, name: "boxes", type: "tensor"},
          {start: 2, name: "boxInd", type: "tensor"},
          {start: 3, name: "cropSize", type: "number[]"}
        ],
        attrs: [
          {tfName: "method", name: "method", type: "string"},
          {
            tfName: "extrapolation_value",
            name: "extrapolationValue",
            type: "number"
          }
        ]
      }
    ];
    var image$1 = /* @__PURE__ */ Object.freeze({
      __proto__: null,
      json: json$9
    });
    /**
     * @license
     * Copyright 2018 Google LLC. All Rights Reserved.
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     * http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     * =============================================================================
     */
    const json$a = [
      {
        tfOpName: "Equal",
        category: "logical",
        inputs: [
          {start: 0, name: "a", type: "tensor"},
          {start: 1, name: "b", type: "tensor"}
        ],
        attrs: [
          {tfName: "T", name: "dtype", type: "dtype", notSupported: true}
        ]
      },
      {
        tfOpName: "NotEqual",
        category: "logical",
        inputs: [
          {start: 0, name: "a", type: "tensor"},
          {start: 1, name: "b", type: "tensor"}
        ],
        attrs: [
          {tfName: "T", name: "dtype", type: "dtype", notSupported: true}
        ]
      },
      {
        tfOpName: "Greater",
        category: "logical",
        inputs: [
          {start: 0, name: "a", type: "tensor"},
          {start: 1, name: "b", type: "tensor"}
        ],
        attrs: [
          {tfName: "T", name: "dtype", type: "dtype", notSupported: true}
        ]
      },
      {
        tfOpName: "GreaterEqual",
        category: "logical",
        inputs: [
          {start: 0, name: "a", type: "tensor"},
          {start: 1, name: "b", type: "tensor"}
        ],
        attrs: [
          {tfName: "T", name: "dtype", type: "dtype", notSupported: true}
        ]
      },
      {
        tfOpName: "Less",
        category: "logical",
        inputs: [
          {start: 0, name: "a", type: "tensor"},
          {start: 1, name: "b", type: "tensor"}
        ],
        attrs: [
          {tfName: "T", name: "dtype", type: "dtype", notSupported: true}
        ]
      },
      {
        tfOpName: "LessEqual",
        category: "logical",
        inputs: [
          {start: 0, name: "a", type: "tensor"},
          {start: 1, name: "b", type: "tensor"}
        ],
        attrs: [
          {tfName: "T", name: "dtype", type: "dtype", notSupported: true}
        ]
      },
      {
        tfOpName: "LogicalAnd",
        category: "logical",
        inputs: [
          {start: 0, name: "a", type: "tensor"},
          {start: 1, name: "b", type: "tensor"}
        ],
        attrs: [
          {tfName: "T", name: "dtype", type: "dtype", notSupported: true}
        ]
      },
      {
        tfOpName: "LogicalNot",
        category: "logical",
        inputs: [
          {start: 0, name: "a", type: "tensor"}
        ],
        attrs: [
          {tfName: "T", name: "dtype", type: "dtype", notSupported: true}
        ]
      },
      {
        tfOpName: "LogicalOr",
        category: "logical",
        inputs: [
          {start: 0, name: "a", type: "tensor"},
          {start: 1, name: "b", type: "tensor"}
        ],
        attrs: [
          {tfName: "T", name: "dtype", type: "dtype", notSupported: true}
        ]
      },
      {
        tfOpName: "Select",
        category: "logical",
        inputs: [
          {start: 0, name: "condition", type: "tensor"},
          {start: 1, name: "a", type: "tensor"},
          {start: 2, name: "b", type: "tensor"}
        ],
        attrs: [
          {tfName: "T", name: "dtype", type: "dtype", notSupported: true}
        ]
      },
      {
        tfOpName: "SelectV2",
        category: "logical",
        inputs: [
          {start: 0, name: "condition", type: "tensor"},
          {start: 1, name: "a", type: "tensor"},
          {start: 2, name: "b", type: "tensor"}
        ],
        attrs: [{
          tfName: "T",
          name: "dtype",
          type: "dtype",
          notSupported: true
        }]
      }
    ];
    var logical = /* @__PURE__ */ Object.freeze({
      __proto__: null,
      json: json$a
    });
    /**
     * @license
     * Copyright 2018 Google LLC. All Rights Reserved.
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     * http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     * =============================================================================
     */
    const json$b = [
      {
        tfOpName: "_FusedMatMul",
        category: "matrices",
        inputs: [
          {start: 0, name: "a", type: "tensor"},
          {start: 1, name: "b", type: "tensor"},
          {start: 2, end: 0, name: "args", type: "tensors"}
        ],
        attrs: [
          {tfName: "num_args", name: "numArgs", type: "number"},
          {
            tfName: "fused_ops",
            name: "fusedOps",
            type: "string[]",
            defaultValue: []
          },
          {
            tfName: "epsilon",
            name: "epsilon",
            type: "number",
            defaultValue: 1e-4
          },
          {
            tfName: "transpose_a",
            name: "transposeA",
            type: "bool",
            defaultValue: false
          },
          {
            tfName: "transpose_b",
            name: "transposeB",
            type: "bool",
            defaultValue: false
          },
          {tfName: "T", name: "dtype", type: "dtype", notSupported: true}
        ]
      },
      {
        tfOpName: "MatMul",
        category: "matrices",
        inputs: [
          {start: 0, name: "a", type: "tensor"},
          {start: 1, name: "b", type: "tensor"}
        ],
        attrs: [
          {
            tfName: "transpose_a",
            name: "transposeA",
            type: "bool",
            defaultValue: false
          },
          {
            tfName: "transpose_b",
            name: "transposeB",
            type: "bool",
            defaultValue: false
          },
          {tfName: "T", name: "dtype", type: "dtype", notSupported: true}
        ]
      },
      {
        tfOpName: "BatchMatMul",
        category: "matrices",
        inputs: [
          {start: 0, name: "a", type: "tensor"},
          {start: 1, name: "b", type: "tensor"}
        ],
        attrs: [
          {
            tfName: "adj_x",
            name: "transposeA",
            type: "bool",
            defaultValue: false
          },
          {
            tfName: "adj_y",
            name: "transposeB",
            type: "bool",
            defaultValue: false
          },
          {tfName: "T", name: "dtype", type: "dtype", notSupported: true}
        ]
      },
      {
        tfOpName: "BatchMatMulV2",
        category: "matrices",
        inputs: [
          {start: 0, name: "a", type: "tensor"},
          {start: 1, name: "b", type: "tensor"}
        ],
        attrs: [
          {
            tfName: "adj_x",
            name: "transposeA",
            type: "bool",
            defaultValue: false
          },
          {
            tfName: "adj_y",
            name: "transposeB",
            type: "bool",
            defaultValue: false
          },
          {tfName: "T", name: "dtype", type: "dtype", notSupported: true}
        ]
      },
      {
        tfOpName: "Transpose",
        category: "matrices",
        inputs: [
          {start: 0, name: "x", type: "tensor"},
          {start: 1, name: "perm", type: "number[]"}
        ],
        attrs: [{
          tfName: "T",
          name: "dtype",
          type: "dtype",
          notSupported: true
        }]
      }
    ];
    var matrices = /* @__PURE__ */ Object.freeze({
      __proto__: null,
      json: json$b
    });
    /**
     * @license
     * Copyright 2018 Google LLC. All Rights Reserved.
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     * http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     * =============================================================================
     */
    const json$c = [
      {
        tfOpName: "FusedBatchNorm",
        category: "normalization",
        inputs: [
          {start: 0, name: "x", type: "tensor"},
          {start: 1, name: "scale", type: "tensor"},
          {start: 2, name: "offset", type: "tensor"},
          {start: 3, name: "mean", type: "tensor"},
          {start: 4, name: "variance", type: "tensor"}
        ],
        attrs: [
          {
            tfName: "epsilon",
            name: "epsilon",
            type: "number",
            defaultValue: 1e-3
          },
          {
            tfName: "data_format",
            name: "dataFormat",
            type: "string",
            notSupported: true
          }
        ]
      },
      {
        tfOpName: "FusedBatchNormV2",
        category: "normalization",
        inputs: [
          {start: 0, name: "x", type: "tensor"},
          {start: 1, name: "scale", type: "tensor"},
          {start: 2, name: "offset", type: "tensor"},
          {start: 3, name: "mean", type: "tensor"},
          {start: 4, name: "variance", type: "tensor"}
        ],
        attrs: [
          {
            tfName: "epsilon",
            name: "epsilon",
            type: "number",
            defaultValue: 1e-3
          },
          {
            tfName: "data_format",
            name: "dataFormat",
            type: "string",
            notSupported: true
          }
        ]
      },
      {
        tfOpName: "FusedBatchNormV3",
        category: "normalization",
        inputs: [
          {start: 0, name: "x", type: "tensor"},
          {start: 1, name: "scale", type: "tensor"},
          {start: 2, name: "offset", type: "tensor"},
          {start: 3, name: "mean", type: "tensor"},
          {start: 4, name: "variance", type: "tensor"}
        ],
        attrs: [
          {
            tfName: "epsilon",
            name: "epsilon",
            type: "number",
            defaultValue: 1e-3
          },
          {
            tfName: "data_format",
            name: "dataFormat",
            type: "string",
            notSupported: true
          }
        ]
      },
      {
        tfOpName: "LRN",
        category: "normalization",
        inputs: [
          {start: 0, name: "x", type: "tensor"}
        ],
        attrs: [
          {
            tfName: "depth_radius",
            name: "radius",
            type: "number",
            defaultValue: 5
          },
          {tfName: "bias", name: "bias", type: "number", defaultValue: 1},
          {
            tfName: "alpha",
            name: "alpha",
            type: "number",
            defaultValue: 1
          },
          {
            tfName: "beta",
            name: "beta",
            type: "number",
            defaultValue: 0.5
          }
        ]
      },
      {
        tfOpName: "Softmax",
        category: "normalization",
        inputs: [{start: 0, name: "x", type: "tensor"}]
      },
      {
        tfOpName: "LogSoftmax",
        category: "normalization",
        inputs: [{start: 0, name: "x", type: "tensor"}]
      },
      {
        tfOpName: "SparseToDense",
        category: "normalization",
        inputs: [
          {start: 0, name: "sparseIndices", type: "tensor"},
          {start: 1, name: "outputShape", type: "number[]"},
          {start: 2, name: "sparseValues", type: "tensor"},
          {start: 3, name: "defaultValue", type: "tensor"}
        ],
        attrs: [{
          tfName: "validate_indices",
          name: "validateIndices",
          type: "bool",
          defaultValue: true,
          notSupported: true
        }]
      }
    ];
    var normalization = /* @__PURE__ */ Object.freeze({
      __proto__: null,
      json: json$c
    });
    /**
     * @license
     * Copyright 2018 Google LLC. All Rights Reserved.
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     * http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     * =============================================================================
     */
    const json$d = [
      {
        tfOpName: "Max",
        category: "reduction",
        inputs: [
          {start: 0, name: "x", type: "tensor"},
          {start: 1, name: "axis", type: "number[]"}
        ],
        attrs: [{tfName: "keep_dims", name: "keepDims", type: "bool"}]
      },
      {
        tfOpName: "Mean",
        category: "reduction",
        inputs: [
          {start: 0, name: "x", type: "tensor"},
          {start: 1, name: "axis", type: "number[]"}
        ],
        attrs: [{tfName: "keep_dims", name: "keepDims", type: "bool"}]
      },
      {
        tfOpName: "Min",
        category: "reduction",
        inputs: [
          {start: 0, name: "x", type: "tensor"},
          {start: 1, name: "axis", type: "number[]"}
        ],
        attrs: [{tfName: "keep_dims", name: "keepDims", type: "bool"}]
      },
      {
        tfOpName: "Sum",
        category: "reduction",
        inputs: [
          {start: 0, name: "x", type: "tensor"},
          {start: 1, name: "axis", type: "number[]"}
        ],
        attrs: [{tfName: "keep_dims", name: "keepDims", type: "bool"}]
      },
      {
        tfOpName: "All",
        category: "reduction",
        inputs: [
          {start: 0, name: "x", type: "tensor"},
          {start: 1, name: "axis", type: "number[]"}
        ],
        attrs: [{tfName: "keep_dims", name: "keepDims", type: "bool"}]
      },
      {
        tfOpName: "Any",
        category: "reduction",
        inputs: [
          {start: 0, name: "x", type: "tensor"},
          {start: 1, name: "axis", type: "number[]"}
        ],
        attrs: [{tfName: "keep_dims", name: "keepDims", type: "bool"}]
      },
      {
        tfOpName: "ArgMax",
        category: "reduction",
        inputs: [
          {start: 0, name: "x", type: "tensor"},
          {start: 1, name: "axis", type: "number"}
        ]
      },
      {
        tfOpName: "ArgMin",
        category: "reduction",
        inputs: [
          {start: 0, name: "x", type: "tensor"},
          {start: 1, name: "axis", type: "number"}
        ]
      },
      {
        tfOpName: "Prod",
        category: "reduction",
        inputs: [
          {start: 0, name: "x", type: "tensor"},
          {start: 1, name: "axis", type: "number[]"}
        ],
        attrs: [{tfName: "keep_dims", name: "keepDims", type: "bool"}]
      },
      {
        tfOpName: "Cumsum",
        category: "reduction",
        inputs: [
          {start: 0, name: "x", type: "tensor"},
          {start: 1, name: "axis", type: "number"}
        ],
        attrs: [
          {tfName: "exclusive", name: "exclusive", type: "bool"},
          {tfName: "reverse", name: "reverse", type: "bool"}
        ]
      }
    ];
    var reduction = /* @__PURE__ */ Object.freeze({
      __proto__: null,
      json: json$d
    });
    /**
     * @license
     * Copyright 2018 Google LLC. All Rights Reserved.
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     * http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     * =============================================================================
     */
    const json$e = [
      {
        tfOpName: "ConcatV2",
        category: "slice_join",
        inputs: [
          {start: 0, end: -1, name: "tensors", type: "tensors"},
          {start: -1, name: "axis", type: "number"}
        ],
        attrs: [{tfName: "N", name: "n", type: "number", defaultValue: 2}]
      },
      {
        tfOpName: "Concat",
        category: "slice_join",
        inputs: [
          {start: 1, end: 0, name: "tensors", type: "tensors"},
          {start: 0, name: "axis", type: "number"}
        ],
        attrs: [{tfName: "N", name: "n", type: "number", defaultValue: 2}]
      },
      {
        tfOpName: "GatherV2",
        category: "slice_join",
        inputs: [
          {start: 0, name: "x", type: "tensor"},
          {start: 1, name: "indices", type: "tensor"},
          {start: 2, name: "axis", type: "number", defaultValue: 0}
        ]
      },
      {
        tfOpName: "Gather",
        category: "slice_join",
        inputs: [
          {start: 0, name: "x", type: "tensor"},
          {start: 1, name: "indices", type: "tensor"}
        ],
        attrs: [
          {tfName: "axis", name: "axis", type: "number", defaultValue: 0},
          {
            tfName: "validate_indices",
            name: "validateIndices",
            type: "bool",
            notSupported: true
          }
        ]
      },
      {
        tfOpName: "Reverse",
        category: "slice_join",
        inputs: [
          {start: 0, name: "x", type: "tensor"},
          {start: 1, name: "dims", type: "bool", notSupported: true}
        ]
      },
      {
        tfOpName: "ReverseV2",
        category: "slice_join",
        inputs: [
          {start: 0, name: "x", type: "tensor"},
          {start: 1, name: "axis", type: "number[]"}
        ]
      },
      {
        tfOpName: "Slice",
        category: "slice_join",
        inputs: [
          {start: 0, name: "x", type: "tensor"},
          {start: 1, name: "begin", type: "number[]"},
          {start: 2, name: "size", type: "number[]"}
        ]
      },
      {
        tfOpName: "StridedSlice",
        category: "slice_join",
        inputs: [
          {start: 0, name: "x", type: "tensor"},
          {start: 1, name: "begin", type: "number[]"},
          {start: 2, name: "end", type: "number[]"},
          {start: 3, name: "strides", type: "number[]"}
        ],
        attrs: [
          {
            tfName: "begin_mask",
            name: "beginMask",
            type: "number",
            defaultValue: 0
          },
          {
            tfName: "end_mask",
            name: "endMask",
            type: "number",
            defaultValue: 0
          },
          {
            tfName: "new_axis_mask",
            name: "newAxisMask",
            type: "number",
            defaultValue: 0
          },
          {
            tfName: "ellipsis_mask",
            name: "ellipsisMask",
            type: "number",
            defaultValue: 0
          },
          {
            tfName: "shrink_axis_mask",
            name: "shrinkAxisMask",
            type: "number",
            defaultValue: 0
          }
        ]
      },
      {
        tfOpName: "Pack",
        category: "slice_join",
        inputs: [
          {start: 0, end: 0, name: "tensors", type: "tensors"}
        ],
        attrs: [
          {tfName: "axis", name: "axis", type: "number", defaultValue: 0}
        ]
      },
      {
        tfOpName: "Unpack",
        category: "slice_join",
        inputs: [
          {start: 0, name: "tensor", type: "tensor"}
        ],
        attrs: [
          {tfName: "axis", name: "axis", type: "number", defaultValue: 0},
          {
            tfName: "num",
            name: "num",
            type: "number",
            defaultValue: 0,
            notSupported: true
          }
        ]
      },
      {
        tfOpName: "Tile",
        category: "slice_join",
        inputs: [
          {start: 0, name: "x", type: "tensor"},
          {start: 1, name: "reps", type: "number[]"}
        ]
      },
      {
        tfOpName: "Split",
        category: "slice_join",
        inputs: [
          {start: 0, name: "axis", type: "number", defaultValue: 0},
          {start: 1, name: "x", type: "tensor"}
        ],
        attrs: [{
          tfName: "num_split",
          name: "numOrSizeSplits",
          type: "number",
          defaultValue: 1
        }]
      },
      {
        tfOpName: "SplitV",
        category: "slice_join",
        inputs: [
          {start: 0, name: "x", type: "tensor"},
          {start: 1, name: "numOrSizeSplits", type: "number[]"},
          {start: 2, name: "axis", type: "number", defaultValue: 0}
        ]
      },
      {
        tfOpName: "ScatterNd",
        category: "slice_join",
        inputs: [
          {start: 0, name: "indices", type: "tensor"},
          {start: 1, name: "values", type: "tensor"},
          {start: 2, name: "shape", type: "number[]"}
        ]
      },
      {
        tfOpName: "GatherNd",
        category: "slice_join",
        inputs: [
          {start: 0, name: "x", type: "tensor"},
          {start: 1, name: "indices", type: "tensor"}
        ]
      },
      {
        tfOpName: "SparseToDense",
        category: "slice_join",
        inputs: [
          {start: 0, name: "sparseIndices", type: "tensor"},
          {start: 1, name: "outputShape", type: "number[]"},
          {start: 2, name: "sparseValues", type: "tensor"},
          {start: 3, name: "defaultValue", type: "tensor"}
        ],
        attrs: [{
          tfName: "validate_indices",
          name: "validateIndices",
          type: "bool",
          defaultValue: false,
          notSupported: true
        }]
      }
    ];
    var sliceJoin = /* @__PURE__ */ Object.freeze({
      __proto__: null,
      json: json$e
    });
    /**
     * @license
     * Copyright 2018 Google LLC. All Rights Reserved.
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     * http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     * =============================================================================
     */
    const json$f = [
      {
        tfOpName: "FFT",
        category: "spectral",
        inputs: [{start: 0, name: "x", type: "tensor"}]
      },
      {
        tfOpName: "IFFT",
        category: "spectral",
        inputs: [{start: 0, name: "x", type: "tensor"}]
      },
      {
        tfOpName: "RFFT",
        category: "spectral",
        inputs: [
          {start: 0, name: "x", type: "tensor"},
          {
            start: 1,
            name: "fft_length",
            type: "number",
            notSupported: true
          }
        ]
      },
      {
        tfOpName: "IRFFT",
        category: "spectral",
        inputs: [
          {start: 0, name: "x", type: "tensor"},
          {
            start: 1,
            name: "fft_length",
            type: "number",
            notSupported: true
          }
        ]
      }
    ];
    var spectral$1 = /* @__PURE__ */ Object.freeze({
      __proto__: null,
      json: json$f
    });
    /**
     * @license
     * Copyright 2018 Google LLC. All Rights Reserved.
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     * http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     * =============================================================================
     */
    const json$g = [
      {
        tfOpName: "Cast",
        category: "transformation",
        inputs: [
          {start: 0, name: "x", type: "tensor"}
        ],
        attrs: [
          {
            tfName: "SrcT",
            name: "sdtype",
            type: "dtype",
            notSupported: true
          },
          {tfName: "DstT", name: "dtype", type: "dtype"}
        ]
      },
      {
        tfOpName: "ExpandDims",
        category: "transformation",
        inputs: [
          {start: 0, name: "x", type: "tensor"},
          {start: 1, name: "axis", type: "number"}
        ]
      },
      {
        tfOpName: "MirrorPad",
        category: "transformation",
        inputs: [
          {start: 0, name: "x", type: "tensor"},
          {start: 1, name: "padding", type: "number[]"}
        ],
        attrs: [{tfName: "mode", name: "mode", type: "string"}]
      },
      {
        tfOpName: "Pad",
        category: "transformation",
        inputs: [
          {start: 0, name: "x", type: "tensor"},
          {start: 1, name: "padding", type: "number[]"}
        ],
        attrs: [{
          tfName: "constant_value",
          name: "constantValue",
          type: "number",
          defaultValue: 0
        }]
      },
      {
        tfOpName: "PadV2",
        category: "transformation",
        inputs: [
          {start: 0, name: "x", type: "tensor"},
          {start: 1, name: "padding", type: "number[]"},
          {
            start: 2,
            name: "constantValue",
            type: "number",
            defaultValue: 0
          }
        ]
      },
      {
        tfOpName: "Reshape",
        category: "transformation",
        inputs: [
          {start: 0, name: "x", type: "tensor"},
          {start: 1, name: "shape", type: "number[]"}
        ]
      },
      {
        tfOpName: "Squeeze",
        category: "transformation",
        inputs: [
          {start: 0, name: "x", type: "tensor"}
        ],
        attrs: [{
          tfName: "axis",
          tfDeprecatedName: "squeeze_dims",
          name: "axis",
          type: "number[]"
        }]
      },
      {
        tfOpName: "SpaceToBatchND",
        category: "transformation",
        inputs: [
          {start: 0, name: "x", type: "tensor"},
          {start: 1, name: "blockShape", type: "number[]"},
          {start: 2, name: "paddings", type: "number[]"}
        ]
      },
      {
        tfOpName: "BatchToSpaceND",
        category: "transformation",
        inputs: [
          {start: 0, name: "x", type: "tensor"},
          {start: 1, name: "blockShape", type: "number[]"},
          {start: 2, name: "crops", type: "number[]"}
        ]
      },
      {
        tfOpName: "DepthToSpace",
        category: "transformation",
        inputs: [
          {start: 0, name: "x", type: "tensor"}
        ],
        attrs: [
          {tfName: "block_size", name: "blockSize", type: "number"},
          {tfName: "data_format", name: "dataFormat", type: "string"}
        ]
      },
      {
        tfOpName: "BroadcastTo",
        category: "transformation",
        inputs: [
          {start: 0, name: "x", type: "tensor"},
          {start: 1, name: "shape", type: "number[]"}
        ],
        attrs: []
      }
    ];
    var transformation = /* @__PURE__ */ Object.freeze({
      __proto__: null,
      json: json$g
    });
    /**
     * @license
     * Copyright 2018 Google LLC. All Rights Reserved.
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     * http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     * =============================================================================
     */
    class OperationMapper {
      static get Instance() {
        return this._instance || (this._instance = new this());
      }
      constructor() {
        const ops = [
          arithmetic,
          basicMath,
          control,
          convolution,
          creation,
          dynamic,
          evaluation,
          logical,
          image$1,
          graph,
          matrices,
          normalization,
          reduction,
          sliceJoin,
          spectral$1,
          transformation,
          hashTable
        ];
        const mappersJson = [].concat(...ops.map((op3) => op3.json));
        this.opMappers = mappersJson.reduce((map, mapper) => {
          map[mapper.tfOpName] = mapper;
          return map;
        }, {});
      }
      transformGraph(graph2, signature = {}) {
        const tfNodes = graph2.node;
        const placeholders = [];
        const weights = [];
        const initNodes = [];
        const nodes = tfNodes.reduce((map, node) => {
          map[node.name] = this.mapNode(node);
          if (node.op.startsWith("Placeholder")) {
            placeholders.push(map[node.name]);
          } else if (node.op === "Const") {
            weights.push(map[node.name]);
          } else if (node.input == null || node.input.length === 0) {
            initNodes.push(map[node.name]);
          }
          return map;
        }, {});
        let inputs = [];
        const outputs = [];
        let inputNodeNameToKey = {};
        let outputNodeNameToKey = {};
        if (signature != null) {
          inputNodeNameToKey = this.mapSignatureEntries(signature.inputs);
          outputNodeNameToKey = this.mapSignatureEntries(signature.outputs);
        }
        const allNodes = Object.keys(nodes);
        allNodes.forEach((key) => {
          const node = nodes[key];
          node.inputNames.forEach((name) => {
            const [nodeName] = getNodeNameAndIndex(name);
            node.inputs.push(nodes[nodeName]);
            nodes[nodeName].children.push(node);
          });
        });
        if (Object.keys(outputNodeNameToKey).length === 0) {
          allNodes.forEach((key) => {
            const node = nodes[key];
            if (node.children.length === 0) {
              outputs.push(node);
            }
          });
        } else {
          Object.keys(outputNodeNameToKey).forEach((name) => {
            const [nodeName] = getNodeNameAndIndex(name);
            const node = nodes[nodeName];
            if (node != null) {
              node.signatureKey = outputNodeNameToKey[name];
              outputs.push(node);
            }
          });
        }
        if (Object.keys(inputNodeNameToKey).length > 0) {
          Object.keys(inputNodeNameToKey).forEach((name) => {
            const [nodeName] = getNodeNameAndIndex(name);
            const node = nodes[nodeName];
            if (node) {
              node.signatureKey = inputNodeNameToKey[name];
              inputs.push(node);
            }
          });
        } else {
          inputs = placeholders;
        }
        let functions = {};
        if (graph2.library != null && graph2.library.function != null) {
          functions = graph2.library.function.reduce((functions2, func2) => {
            functions2[func2.signature.name] = this.mapFunction(func2);
            return functions2;
          }, {});
        }
        const result = {nodes, inputs, outputs, weights, placeholders, signature, functions};
        if (initNodes.length > 0) {
          result.initNodes = initNodes;
        }
        return result;
      }
      mapSignatureEntries(entries) {
        return Object.keys(entries || {}).reduce((prev, curr) => {
          prev[entries[curr].name] = curr;
          return prev;
        }, {});
      }
      mapNode(node) {
        const mapper = getRegisteredOp(node.op) || this.opMappers[node.op] || {};
        if (node.attr == null) {
          node.attr = {};
        }
        const newNode = {
          name: node.name,
          op: node.op,
          category: mapper.category,
          inputNames: (node.input || []).map((input2) => input2.startsWith("^") ? input2.substr(1) : input2),
          inputs: [],
          children: [],
          inputParams: {},
          attrParams: {},
          rawAttrs: node.attr
        };
        if (mapper.inputs != null) {
          newNode.inputParams = mapper.inputs.reduce((map, param) => {
            map[param.name] = {
              type: param.type,
              inputIndexStart: param.start,
              inputIndexEnd: param.end
            };
            return map;
          }, {});
        }
        if (mapper.attrs != null) {
          newNode.attrParams = mapper.attrs.reduce((map, param) => {
            const type = param.type;
            let value = void 0;
            switch (param.type) {
              case "string":
                value = getStringParam(node.attr, param.tfName, param.defaultValue);
                if (value === void 0 && !!param.tfDeprecatedName) {
                  value = getStringParam(node.attr, param.tfDeprecatedName, param.defaultValue);
                }
                break;
              case "string[]":
                value = getStringArrayParam(node.attr, param.tfName, param.defaultValue);
                if (value === void 0 && !!param.tfDeprecatedName) {
                  value = getStringArrayParam(node.attr, param.tfDeprecatedName, param.defaultValue);
                }
                break;
              case "number":
                value = getNumberParam(node.attr, param.tfName, param.defaultValue || 0);
                if (value === void 0 && !!param.tfDeprecatedName) {
                  value = getNumberParam(node.attr, param.tfDeprecatedName, param.defaultValue);
                }
                break;
              case "number[]":
                value = getNumericArrayParam(node.attr, param.tfName, param.defaultValue);
                if (value === void 0 && !!param.tfDeprecatedName) {
                  value = getNumericArrayParam(node.attr, param.tfDeprecatedName, param.defaultValue);
                }
                break;
              case "bool":
                value = getBoolParam(node.attr, param.tfName, param.defaultValue);
                if (value === void 0 && !!param.tfDeprecatedName) {
                  value = getBoolParam(node.attr, param.tfDeprecatedName, param.defaultValue);
                }
                break;
              case "bool[]":
                value = getBoolArrayParam(node.attr, param.tfName, param.defaultValue);
                if (value === void 0 && !!param.tfDeprecatedName) {
                  value = getBoolArrayParam(node.attr, param.tfDeprecatedName, param.defaultValue);
                }
                break;
              case "shape":
                value = getTensorShapeParam(node.attr, param.tfName, param.defaultValue);
                if (value === void 0 && !!param.tfDeprecatedName) {
                  value = getTensorShapeParam(node.attr, param.tfDeprecatedName, param.defaultValue);
                }
                break;
              case "shape[]":
                value = getTensorShapeArrayParam(node.attr, param.tfName, param.defaultValue);
                if (value === void 0 && !!param.tfDeprecatedName) {
                  value = getTensorShapeArrayParam(node.attr, param.tfDeprecatedName, param.defaultValue);
                }
                break;
              case "dtype":
                value = getDtypeParam(node.attr, param.tfName, param.defaultValue);
                if (value === void 0 && !!param.tfDeprecatedName) {
                  value = getDtypeParam(node.attr, param.tfDeprecatedName, param.defaultValue);
                }
                break;
              case "dtype[]":
                value = getDtypeArrayParam(node.attr, param.tfName, param.defaultValue);
                if (value === void 0 && !!param.tfDeprecatedName) {
                  value = getDtypeArrayParam(node.attr, param.tfDeprecatedName, param.defaultValue);
                }
                break;
              case "func":
                value = getFuncParam(node.attr, param.tfName, param.defaultValue);
                if (value === void 0 && !!param.tfDeprecatedName) {
                  value = getFuncParam(node.attr, param.tfDeprecatedName, param.defaultValue);
                }
                break;
              case "tensor":
              case "tensors":
                break;
              default:
                throw new Error(`Unsupported param type: ${param.type} for op: ${node.op}`);
            }
            map[param.name] = {value, type};
            return map;
          }, {});
        }
        return newNode;
      }
      mapFunction(functionDef) {
        const tfNodes = functionDef.nodeDef;
        const placeholders = [];
        const weights = [];
        let nodes = {};
        if (tfNodes != null) {
          nodes = tfNodes.reduce((map, node) => {
            map[node.name] = this.mapNode(node);
            if (node.op === "Const") {
              weights.push(map[node.name]);
            }
            return map;
          }, {});
        }
        const inputs = [];
        const outputs = [];
        functionDef.signature.inputArg.forEach((arg) => {
          const [nodeName] = getNodeNameAndIndex(arg.name);
          const node = {
            name: nodeName,
            op: "Placeholder",
            inputs: [],
            inputNames: [],
            category: "graph",
            inputParams: {},
            attrParams: {dtype: {value: parseDtypeParam(arg.type), type: "dtype"}},
            children: []
          };
          node.signatureKey = arg.name;
          inputs.push(node);
          nodes[nodeName] = node;
        });
        const allNodes = Object.keys(nodes);
        allNodes.forEach((key) => {
          const node = nodes[key];
          node.inputNames.forEach((name) => {
            const [nodeName] = getNodeNameAndIndex(name);
            node.inputs.push(nodes[nodeName]);
            nodes[nodeName].children.push(node);
          });
        });
        const returnNodeMap = functionDef.ret;
        functionDef.signature.outputArg.forEach((output) => {
          const [nodeName, index2] = getNodeNameAndIndex(returnNodeMap[output.name]);
          const node = nodes[nodeName];
          if (node != null) {
            node.defaultOutput = index2;
            outputs.push(node);
          }
        });
        const signature = this.mapArgsToSignature(functionDef);
        return {nodes, inputs, outputs, weights, placeholders, signature};
      }
      mapArgsToSignature(functionDef) {
        return {
          methodName: functionDef.signature.name,
          inputs: functionDef.signature.inputArg.reduce((map, arg) => {
            map[arg.name] = this.mapArgToTensorInfo(arg);
            return map;
          }, {}),
          outputs: functionDef.signature.outputArg.reduce((map, arg) => {
            map[arg.name] = this.mapArgToTensorInfo(arg, functionDef.ret);
            return map;
          }, {})
        };
      }
      mapArgToTensorInfo(arg, nameMap2) {
        let name = arg.name;
        if (nameMap2 != null) {
          name = nameMap2[name];
        }
        return {name, dtype: arg.type};
      }
    }
    function decodeBase64(text) {
      const global2 = env2().global;
      if (typeof global2.atob !== "undefined") {
        return global2.atob(text);
      } else if (typeof Buffer !== "undefined") {
        return new Buffer(text, "base64").toString();
      } else {
        throw new Error("Unable to decode base64 in this environment. Missing built-in atob() or Buffer()");
      }
    }
    function parseStringParam(s, keepCase) {
      const value = Array.isArray(s) ? String.fromCharCode.apply(null, s) : decodeBase64(s);
      return keepCase ? value : value.toLowerCase();
    }
    function getStringParam(attrs, name, def, keepCase = false) {
      const param = attrs[name];
      if (param != null) {
        return parseStringParam(param.s, keepCase);
      }
      return def;
    }
    function getBoolParam(attrs, name, def) {
      const param = attrs[name];
      return param ? param.b : def;
    }
    function getNumberParam(attrs, name, def) {
      const param = attrs[name] || {};
      const value = param["i"] != null ? param["i"] : param["f"] != null ? param["f"] : def;
      return typeof value === "number" ? value : parseInt(value, 10);
    }
    function parseDtypeParam(value) {
      if (typeof value === "string") {
        value = DataType[value];
      }
      switch (value) {
        case DataType.DT_FLOAT:
          return "float32";
        case DataType.DT_INT32:
        case DataType.DT_INT64:
        case DataType.DT_INT8:
        case DataType.DT_UINT8:
          return "int32";
        case DataType.DT_BOOL:
          return "bool";
        case DataType.DT_DOUBLE:
          return "float32";
        case DataType.DT_STRING:
          return "string";
        default:
          return null;
      }
    }
    function getFuncParam(attrs, name, def) {
      const param = attrs[name];
      if (param && param.func) {
        return param.func.name;
      }
      return def;
    }
    function getDtypeParam(attrs, name, def) {
      const param = attrs[name];
      if (param && param.type) {
        return parseDtypeParam(param.type);
      }
      return def;
    }
    function getDtypeArrayParam(attrs, name, def) {
      const param = attrs[name];
      if (param && param.list && param.list.type) {
        return param.list.type.map((v) => parseDtypeParam(v));
      }
      return def;
    }
    function parseTensorShapeParam(shape) {
      if (shape.unknownRank) {
        return void 0;
      }
      if (shape.dim != null) {
        return shape.dim.map((dim) => typeof dim.size === "number" ? dim.size : parseInt(dim.size, 10));
      }
      return [];
    }
    function getTensorShapeParam(attrs, name, def) {
      const param = attrs[name];
      if (param && param.shape) {
        return parseTensorShapeParam(param.shape);
      }
      return def;
    }
    function getNumericArrayParam(attrs, name, def) {
      const param = attrs[name];
      if (param) {
        return ((param.list.f && param.list.f.length ? param.list.f : param.list.i) || []).map((v) => typeof v === "number" ? v : parseInt(v, 10));
      }
      return def;
    }
    function getStringArrayParam(attrs, name, def, keepCase = false) {
      const param = attrs[name];
      if (param && param.list && param.list.s) {
        return param.list.s.map((v) => {
          return parseStringParam(v, keepCase);
        });
      }
      return def;
    }
    function getTensorShapeArrayParam(attrs, name, def) {
      const param = attrs[name];
      if (param && param.list && param.list.shape) {
        return param.list.shape.map((v) => {
          return parseTensorShapeParam(v);
        });
      }
      return def;
    }
    function getBoolArrayParam(attrs, name, def) {
      const param = attrs[name];
      if (param && param.list && param.list.b) {
        return param.list.b;
      }
      return def;
    }
    /**
     * @license
     * Copyright 2019 Google LLC. All Rights Reserved.
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     * http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     * =============================================================================
     */
    class NodeValueImpl {
      constructor(node, tensorMap, context) {
        this.node = node;
        this.tensorMap = tensorMap;
        this.context = context;
        this.inputs = [];
        this.attrs = {};
        this.inputs = node.inputNames.map((name) => this.getInput(name));
        if (node.rawAttrs != null) {
          this.attrs = Object.keys(node.rawAttrs).reduce((attrs, key) => {
            attrs[key] = this.getAttr(key);
            return attrs;
          }, {});
        }
      }
      getInput(name) {
        return getTensor(name, this.tensorMap, this.context);
      }
      getAttr(name, defaultValue) {
        const value = this.node.rawAttrs[name];
        if (value.tensor != null) {
          return getTensor(name, this.tensorMap, this.context);
        }
        if (value.i != null || value.f != null) {
          return getNumberParam(this.node.rawAttrs, name, defaultValue);
        }
        if (value.s != null) {
          return getStringParam(this.node.rawAttrs, name, defaultValue);
        }
        if (value.b != null) {
          return getBoolParam(this.node.rawAttrs, name, defaultValue);
        }
        if (value.shape != null) {
          return getTensorShapeParam(this.node.rawAttrs, name, defaultValue);
        }
        if (value.type != null) {
          return getDtypeParam(this.node.rawAttrs, name, defaultValue);
        }
        if (value.list != null) {
          if (value.list.i != null || value.list.f != null) {
            return getNumericArrayParam(this.node.rawAttrs, name, defaultValue);
          }
          if (value.list.s != null) {
            return getStringArrayParam(this.node.rawAttrs, name, defaultValue);
          }
          if (value.list.shape != null) {
            return getTensorShapeArrayParam(this.node.rawAttrs, name, defaultValue);
          }
          if (value.list.b != null) {
            return getBoolArrayParam(this.node.rawAttrs, name, defaultValue);
          }
          if (value.list.type != null) {
            return getDtypeArrayParam(this.node.rawAttrs, name, defaultValue);
          }
        }
        return defaultValue;
      }
    }
    /**
     * @license
     * Copyright 2020 Google LLC. All Rights Reserved.
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     * http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     * =============================================================================
     */
    /**
     * @license
     * Copyright 2018 Google LLC. All Rights Reserved.
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     * http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     * =============================================================================
     */
    const executeOp = (node, tensorMap, context) => {
      switch (node.op) {
        case "BiasAdd":
        case "AddV2":
        case "Add": {
          return [add$1(getParamValue("a", node, tensorMap, context), getParamValue("b", node, tensorMap, context))];
        }
        case "AddN": {
          return [addN(getParamValue("tensors", node, tensorMap, context))];
        }
        case "FloorMod":
        case "Mod":
          return [mod(getParamValue("a", node, tensorMap, context), getParamValue("b", node, tensorMap, context))];
        case "Mul":
          return [mul3(getParamValue("a", node, tensorMap, context), getParamValue("b", node, tensorMap, context))];
        case "RealDiv":
        case "Div": {
          return [div(getParamValue("a", node, tensorMap, context), getParamValue("b", node, tensorMap, context))];
        }
        case "DivNoNan": {
          return [divNoNan(getParamValue("a", node, tensorMap, context), getParamValue("b", node, tensorMap, context))];
        }
        case "FloorDiv": {
          return [floorDiv(getParamValue("a", node, tensorMap, context), getParamValue("b", node, tensorMap, context))];
        }
        case "Sub": {
          return [sub(getParamValue("a", node, tensorMap, context), getParamValue("b", node, tensorMap, context))];
        }
        case "Minimum": {
          return [minimum(getParamValue("a", node, tensorMap, context), getParamValue("b", node, tensorMap, context))];
        }
        case "Maximum": {
          return [maximum(getParamValue("a", node, tensorMap, context), getParamValue("b", node, tensorMap, context))];
        }
        case "Pow": {
          return [pow(getParamValue("a", node, tensorMap, context), getParamValue("b", node, tensorMap, context))];
        }
        case "SquaredDifference": {
          return [squaredDifference(getParamValue("a", node, tensorMap, context), getParamValue("b", node, tensorMap, context))];
        }
        default:
          throw TypeError(`Node type ${node.op} is not implemented`);
      }
    };
    const CATEGORY = "arithmetic";
    /**
     * @license
     * Copyright 2018 Google LLC. All Rights Reserved.
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     * http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     * =============================================================================
     */
    const executeOp$1 = (node, tensorMap, context) => {
      switch (node.op) {
        case "Abs":
        case "ComplexAbs":
          return [abs(getParamValue("x", node, tensorMap, context))];
        case "Acos":
          return [acos(getParamValue("x", node, tensorMap, context))];
        case "Acosh":
          return [acosh(getParamValue("x", node, tensorMap, context))];
        case "Asin":
          return [asin(getParamValue("x", node, tensorMap, context))];
        case "Asinh":
          return [asinh(getParamValue("x", node, tensorMap, context))];
        case "Atan":
          return [atan(getParamValue("x", node, tensorMap, context))];
        case "Atan2":
          return [atan2(getParamValue("x", node, tensorMap, context), getParamValue("y", node, tensorMap, context))];
        case "Atanh":
          return [atanh(getParamValue("x", node, tensorMap, context))];
        case "Ceil":
          return [ceil(getParamValue("x", node, tensorMap, context))];
        case "Complex":
          return [complex3(getParamValue("real", node, tensorMap, context), getParamValue("imag", node, tensorMap, context))];
        case "Cos":
          return [cos(getParamValue("x", node, tensorMap, context))];
        case "Cosh":
          return [cosh(getParamValue("x", node, tensorMap, context))];
        case "Elu":
          return [elu3(getParamValue("x", node, tensorMap, context))];
        case "Erf":
          return [erf(getParamValue("x", node, tensorMap, context))];
        case "Exp":
          return [exp(getParamValue("x", node, tensorMap, context))];
        case "Expm1": {
          return [expm1(getParamValue("x", node, tensorMap, context))];
        }
        case "Floor":
          return [floor(getParamValue("x", node, tensorMap, context))];
        case "Log":
          return [log22(getParamValue("x", node, tensorMap, context))];
        case "Log1p": {
          return [log1p(getParamValue("x", node, tensorMap, context))];
        }
        case "Imag":
          return [imag(getParamValue("x", node, tensorMap, context))];
        case "Neg":
          return [neg(getParamValue("x", node, tensorMap, context))];
        case "Reciprocal": {
          return [reciprocal(getParamValue("x", node, tensorMap, context))];
        }
        case "Real":
          return [real(getParamValue("x", node, tensorMap, context))];
        case "Relu":
          return [relu3(getParamValue("x", node, tensorMap, context))];
        case "Round": {
          return [round(getParamValue("x", node, tensorMap, context))];
        }
        case "Selu":
          return [selu(getParamValue("x", node, tensorMap, context))];
        case "Sigmoid":
          return [sigmoid2(getParamValue("x", node, tensorMap, context))];
        case "Sin":
          return [sin(getParamValue("x", node, tensorMap, context))];
        case "Sign": {
          return [sign(getParamValue("x", node, tensorMap, context))];
        }
        case "Sinh": {
          return [sinh(getParamValue("x", node, tensorMap, context))];
        }
        case "Softplus": {
          return [softplus(getParamValue("x", node, tensorMap, context))];
        }
        case "Sqrt": {
          return [sqrt(getParamValue("x", node, tensorMap, context))];
        }
        case "Square": {
          return [square(getParamValue("x", node, tensorMap, context))];
        }
        case "Tanh": {
          return [tanh$1(getParamValue("x", node, tensorMap, context))];
        }
        case "Tan":
          return [tan(getParamValue("x", node, tensorMap, context))];
        case "Relu6":
        case "ClipByValue":
          return [clipByValue(getParamValue("x", node, tensorMap, context), getParamValue("clipValueMin", node, tensorMap, context), getParamValue("clipValueMax", node, tensorMap, context))];
        case "Rsqrt":
          return [rsqrt(getTensor(node.inputNames[0], tensorMap, context))];
        case "Prod":
          return [prod(getParamValue("x", node, tensorMap, context), getParamValue("axes", node, tensorMap, context))];
        case "LeakyRelu":
          return [leakyRelu(getParamValue("x", node, tensorMap, context), getParamValue("alpha", node, tensorMap, context))];
        case "Prelu":
          return [prelu4(getParamValue("x", node, tensorMap, context), getParamValue("alpha", node, tensorMap, context))];
        default:
          throw TypeError(`Node type ${node.op} is not implemented`);
      }
    };
    const CATEGORY$1 = "basic_math";
    /**
     * @license
     * Copyright 2020 Google LLC. All Rights Reserved.
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     * http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     * =============================================================================
     */
    function assertShapesMatchAllowUndefinedSize(shapeA, shapeB, errorMessagePrefix = "") {
      assert2(shapesEqualAllowUndefinedSize(shapeA, shapeB), () => errorMessagePrefix + ` Shapes ${shapeA} and ${shapeB} must match`);
    }
    function shapesEqualAllowUndefinedSize(n1, n2) {
      if (n1.length !== n2.length) {
        return false;
      }
      for (let i = 0; i < n1.length; i++) {
        if (n1[i] !== -1 && n2[i] !== -1 && n1[i] !== n2[i]) {
          return false;
        }
      }
      return true;
    }
    /**
     * @license
     * Copyright 2018 Google LLC. All Rights Reserved.
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     * http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     * =============================================================================
     */
    class TensorArray {
      constructor(name, dtype, maxSize, elementShape, identicalElementShapes, dynamicSize, clearAfterRead) {
        this.name = name;
        this.dtype = dtype;
        this.maxSize = maxSize;
        this.elementShape = elementShape;
        this.identicalElementShapes = identicalElementShapes;
        this.dynamicSize = dynamicSize;
        this.clearAfterRead = clearAfterRead;
        this.tensors = [];
        this.closed_ = false;
        this.idTensor = scalar3(0);
        keep(this.idTensor);
      }
      get id() {
        return this.idTensor.id;
      }
      get closed() {
        return this.closed_;
      }
      clearAndClose(keepIds) {
        this.tensors.forEach((tensor7) => {
          if (keepIds == null || !keepIds.has(tensor7.tensor.id)) {
            tensor7.tensor.dispose();
          }
        });
        this.tensors = [];
        this.closed_ = true;
        this.idTensor.dispose();
      }
      size() {
        return this.tensors.length;
      }
      read(index2) {
        if (this.closed_) {
          throw new Error(`TensorArray ${this.name} has already been closed.`);
        }
        if (index2 < 0 || index2 >= this.size()) {
          throw new Error(`Tried to read from index ${index2}, but array size is: ${this.size()}`);
        }
        const tensorWithState = this.tensors[index2];
        if (tensorWithState.cleared) {
          throw new Error(`TensorArray ${this.name}: Could not read index ${index2} twice because it was cleared after a previous read (perhaps try setting clear_after_read = false?).`);
        }
        if (this.clearAfterRead) {
          tensorWithState.cleared = true;
        }
        tensorWithState.read = true;
        return tensorWithState.tensor;
      }
      readMany(indices) {
        return indices.map((index2) => this.read(index2));
      }
      write(index2, tensor7) {
        if (this.closed_) {
          throw new Error(`TensorArray ${this.name} has already been closed.`);
        }
        if (index2 < 0 || !this.dynamicSize && index2 >= this.maxSize) {
          throw new Error(`Tried to write to index ${index2}, but array is not resizeable and size is: ${this.maxSize}`);
        }
        const t = this.tensors[index2] || {};
        if (tensor7.dtype !== this.dtype) {
          throw new Error(`TensorArray ${this.name}: Could not write to TensorArray index ${index2},
          because the value dtype is ${tensor7.dtype}, but TensorArray dtype is ${this.dtype}.`);
        }
        if (this.size() === 0 && (this.elementShape == null || this.elementShape.length === 0)) {
          this.elementShape = tensor7.shape;
        }
        assertShapesMatchAllowUndefinedSize(this.elementShape, tensor7.shape, `TensorArray ${this.name}: Could not write to TensorArray index ${index2}.`);
        if (t.read) {
          throw new Error(`TensorArray ${this.name}: Could not write to TensorArray index ${index2}, because it has already been read.`);
        }
        if (t.written) {
          throw new Error(`TensorArray ${this.name}: Could not write to TensorArray index ${index2}, because it has already been written.`);
        }
        t.tensor = tensor7;
        keep(tensor7);
        t.written = true;
        this.tensors[index2] = t;
      }
      writeMany(indices, tensors) {
        if (indices.length !== tensors.length) {
          throw new Error(`TensorArray ${this.name}: could not write multiple tensors,because the index size: ${indices.length} is not the same as tensors size: ${tensors.length}.`);
        }
        indices.forEach((i, index2) => this.write(i, tensors[index2]));
      }
      gather(indices, dtype) {
        if (!!dtype && dtype !== this.dtype) {
          throw new Error(`TensorArray dtype is ${this.dtype} but gather requested dtype ${dtype}`);
        }
        if (!indices) {
          indices = [];
          for (let i = 0; i < this.size(); i++) {
            indices.push(i);
          }
        } else {
          indices = indices.slice(0, this.size());
        }
        if (indices.length === 0) {
          return tensor6([], [0].concat(this.elementShape));
        }
        const tensors = this.readMany(indices);
        assertShapesMatchAllowUndefinedSize(this.elementShape, tensors[0].shape, "TensorArray shape mismatch: ");
        return stack(tensors, 0);
      }
      concat(dtype) {
        if (!!dtype && dtype !== this.dtype) {
          throw new Error(`TensorArray dtype is ${this.dtype} but concat requested dtype ${dtype}`);
        }
        if (this.size() === 0) {
          return tensor6([], [0].concat(this.elementShape));
        }
        const indices = [];
        for (let i = 0; i < this.size(); i++) {
          indices.push(i);
        }
        const tensors = this.readMany(indices);
        assertShapesMatchAllowUndefinedSize(this.elementShape, tensors[0].shape, `TensorArray shape mismatch: tensor array shape (${this.elementShape}) vs first tensor shape (${tensors[0].shape})`);
        return concat2(tensors, 0);
      }
      scatter(indices, tensor7) {
        if (tensor7.dtype !== this.dtype) {
          throw new Error(`TensorArray dtype is ${this.dtype} but tensor has dtype ${tensor7.dtype}`);
        }
        if (indices.length !== tensor7.shape[0]) {
          throw new Error(`Expected len(indices) == tensor.shape[0], but saw: ${indices.length} vs. ${tensor7.shape[0]}`);
        }
        const maxIndex = Math.max(...indices);
        if (!this.dynamicSize && maxIndex >= this.maxSize) {
          throw new Error(`Max index must be < array size (${maxIndex}  vs. ${this.maxSize})`);
        }
        this.writeMany(indices, unstack(tensor7, 0));
      }
      split(length, tensor7) {
        if (tensor7.dtype !== this.dtype) {
          throw new Error(`TensorArray dtype is ${this.dtype} but tensor has dtype ${tensor7.dtype}`);
        }
        let totalLength = 0;
        const cumulativeLengths = length.map((len) => {
          totalLength += len;
          return totalLength;
        });
        if (totalLength !== tensor7.shape[0]) {
          throw new Error(`Expected sum of lengths to be equal to
          tensor.shape[0], but sum of lengths is
        ${totalLength}, and tensor's shape is: ${tensor7.shape}`);
        }
        if (!this.dynamicSize && length.length !== this.maxSize) {
          throw new Error(`TensorArray's size is not equal to the size of lengths (${this.maxSize} vs. ${length.length}), and the TensorArray is not marked as dynamically resizeable`);
        }
        const elementPerRow = totalLength === 0 ? 0 : tensor7.size / totalLength;
        const tensors = [];
        tidy(() => {
          tensor7 = reshape5(tensor7, [1, totalLength, elementPerRow]);
          for (let i = 0; i < length.length; ++i) {
            const previousLength = i === 0 ? 0 : cumulativeLengths[i - 1];
            const indices2 = [0, previousLength, 0];
            const sizes = [1, length[i], elementPerRow];
            tensors[i] = reshape5(slice2(tensor7, indices2, sizes), this.elementShape);
          }
          return tensors;
        });
        const indices = [];
        for (let i = 0; i < length.length; i++) {
          indices[i] = i;
        }
        this.writeMany(indices, tensors);
      }
    }
    /**
     * @license
     * Copyright 2020 Google LLC. All Rights Reserved.
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     * http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     * =============================================================================
     */
    class TensorList {
      constructor(tensors, elementShape, elementDtype, maxNumElements = -1) {
        this.tensors = tensors;
        this.elementShape = elementShape;
        this.elementDtype = elementDtype;
        if (tensors != null) {
          tensors.forEach((tensor7) => {
            if (elementDtype !== tensor7.dtype) {
              throw new Error(`Invalid data types; op elements ${elementDtype}, but list elements ${tensor7.dtype}`);
            }
            assertShapesMatchAllowUndefinedSize(elementShape, tensor7.shape, "TensorList shape mismatch: ");
            keep(tensor7);
          });
        }
        this.idTensor = scalar3(0);
        this.maxNumElements = maxNumElements;
        keep(this.idTensor);
      }
      get id() {
        return this.idTensor.id;
      }
      copy() {
        return new TensorList([...this.tensors], this.elementShape, this.elementDtype);
      }
      clearAndClose(keepIds) {
        this.tensors.forEach((tensor7) => {
          if (keepIds == null || !keepIds.has(tensor7.id)) {
            tensor7.dispose();
          }
        });
        this.tensors.length = 0;
        this.idTensor.dispose();
      }
      size() {
        return this.tensors.length;
      }
      stack(elementShape, elementDtype, numElements = -1) {
        if (elementDtype !== this.elementDtype) {
          throw new Error(`Invalid data types; op elements ${elementDtype}, but list elements ${this.elementDtype}`);
        }
        if (numElements !== -1 && this.tensors.length !== numElements) {
          throw new Error(`Operation expected a list with ${numElements} elements but got a list with ${this.tensors.length} elements.`);
        }
        assertShapesMatchAllowUndefinedSize(elementShape, this.elementShape, "TensorList shape mismatch: ");
        return tidy(() => {
          const reshapedTensors = this.tensors.map((tensor7) => reshape5(tensor7, elementShape));
          return stack(reshapedTensors, 0);
        });
      }
      popBack(elementShape, elementDtype) {
        if (elementDtype !== this.elementDtype) {
          throw new Error(`Invalid data types; op elements ${elementDtype}, but list elements ${this.elementDtype}`);
        }
        if (this.size() === 0) {
          throw new Error("Trying to pop from an empty list.");
        }
        const tensor7 = this.tensors.pop();
        assertShapesMatchAllowUndefinedSize(tensor7.shape, elementShape, "TensorList shape mismatch: ");
        return reshape5(tensor7, elementShape);
      }
      pushBack(tensor7) {
        if (tensor7.dtype !== this.elementDtype) {
          throw new Error(`Invalid data types; op elements ${tensor7.dtype}, but list elements ${this.elementDtype}`);
        }
        assertShapesMatchAllowUndefinedSize(tensor7.shape, this.elementShape, "TensorList shape mismatch: ");
        if (this.maxNumElements === this.size()) {
          throw new Error(`Trying to push element into a full list.`);
        }
        keep(tensor7);
        this.tensors.push(tensor7);
      }
      resize(size) {
        if (size < 0) {
          throw new Error(`TensorListResize expects size to be non-negative. Got: ${size}`);
        }
        if (this.maxNumElements !== -1 && size > this.maxNumElements) {
          throw new Error(`TensorListResize input size ${size} is greater maxNumElement ${this.maxNumElements}.`);
        }
        this.tensors.length = size;
      }
      getItem(elementIndex, elementShape, elementDtype) {
        if (elementDtype !== this.elementDtype) {
          throw new Error(`Invalid data types; op elements ${elementDtype}, but list elements ${this.elementDtype}`);
        }
        if (elementIndex < 0 || elementIndex > this.tensors.length) {
          throw new Error(`Trying to access element ${elementIndex} in a list with ${this.tensors.length} elements.`);
        }
        if (this.tensors[elementIndex] == null) {
          throw new Error(`element at index ${elementIndex} is null.`);
        }
        assertShapesMatchAllowUndefinedSize(this.tensors[elementIndex].shape, elementShape, "TensorList shape mismatch: ");
        return this.tensors[elementIndex];
      }
      setItem(elementIndex, tensor7) {
        if (tensor7.dtype !== this.elementDtype) {
          throw new Error(`Invalid data types; op elements ${tensor7.dtype}, but list elements ${this.elementDtype}`);
        }
        if (elementIndex < 0 || this.maxNumElements !== -1 && elementIndex >= this.maxNumElements) {
          throw new Error(`Trying to set element ${elementIndex} in a list with max ${this.maxNumElements} elements.`);
        }
        assertShapesMatchAllowUndefinedSize(this.elementShape, tensor7.shape, "TensorList shape mismatch: ");
        keep(tensor7);
        this.tensors[elementIndex] = tensor7;
      }
      gather(indices, elementDtype, elementShape) {
        if (elementDtype !== this.elementDtype) {
          throw new Error(`Invalid data types; op elements ${elementDtype}, but list elements ${this.elementDtype}`);
        }
        assertShapesMatchAllowUndefinedSize(this.elementShape, elementShape, "TensorList shape mismatch: ");
        indices = indices.slice(0, this.size());
        if (indices.length === 0) {
          return tensor6([], [0].concat(this.elementShape));
        }
        return tidy(() => {
          const tensors = indices.map((i) => reshape5(this.tensors[i], elementShape));
          return stack(tensors, 0);
        });
      }
      concat(elementDtype, elementShape) {
        if (!!elementDtype && elementDtype !== this.elementDtype) {
          throw new Error(`TensorList dtype is ${this.elementDtype} but concat requested dtype ${elementDtype}`);
        }
        assertShapesMatchAllowUndefinedSize(this.elementShape, elementShape, "TensorList shape mismatch: ");
        if (this.size() === 0) {
          return tensor6([], [0].concat(this.elementShape));
        }
        return tidy(() => {
          const tensors = this.tensors.map((t) => reshape5(t, elementShape));
          return concat2(tensors, 0);
        });
      }
    }
    function fromTensor(tensor7, elementShape, elementDtype) {
      const dtype = tensor7.dtype;
      if (tensor7.shape.length < 1) {
        throw new Error(`Tensor must be at least a vector, but saw shape: ${tensor7.shape}`);
      }
      if (tensor7.dtype !== elementDtype) {
        throw new Error(`Invalid data types; op elements ${tensor7.dtype}, but list elements ${elementDtype}`);
      }
      const outputShape = tensor7.shape.slice(1);
      assertShapesMatchAllowUndefinedSize(outputShape, elementShape, "TensorList shape mismatch: ");
      const tensorList = unstack(tensor7);
      return new TensorList(tensorList, elementShape, dtype);
    }
    function reserve(elementShape, elementDtype, numElements) {
      return new TensorList([], elementShape, elementDtype, numElements);
    }
    function scatter(tensor7, indices, elementShape, numElements) {
      if (indices.length !== tensor7.shape[0]) {
        throw new Error(`Expected len(indices) == tensor.shape[0], but saw: ${indices.length} vs. ${tensor7.shape[0]}`);
      }
      const maxIndex = Math.max(...indices);
      if (numElements != null && numElements !== -1 && maxIndex >= numElements) {
        throw new Error(`Max index must be < array size (${maxIndex}  vs. ${numElements})`);
      }
      const list = new TensorList([], elementShape, tensor7.dtype, numElements);
      const tensors = unstack(tensor7, 0);
      indices.forEach((value, index2) => {
        list.setItem(value, tensors[index2]);
      });
      return list;
    }
    function split$3(tensor7, length, elementShape) {
      let totalLength = 0;
      const cumulativeLengths = length.map((len) => {
        totalLength += len;
        return totalLength;
      });
      if (totalLength !== tensor7.shape[0]) {
        throw new Error(`Expected sum of lengths to be equal to
          tensor.shape[0], but sum of lengths is
        ${totalLength}, and tensor's shape is: ${tensor7.shape}`);
      }
      const elementPerRow = totalLength === 0 ? 0 : tensor7.size / totalLength;
      const tensors = tidy(() => {
        const tensors2 = [];
        tensor7 = reshape5(tensor7, [1, totalLength, elementPerRow]);
        for (let i = 0; i < length.length; ++i) {
          const previousLength = i === 0 ? 0 : cumulativeLengths[i - 1];
          const indices = [0, previousLength, 0];
          const sizes = [1, length[i], elementPerRow];
          tensors2[i] = reshape5(slice2(tensor7, indices, sizes), elementShape);
        }
        tensor7.dispose();
        return tensors2;
      });
      const list = new TensorList([], elementShape, tensor7.dtype, length.length);
      for (let i = 0; i < tensors.length; i++) {
        list.setItem(i, tensors[i]);
      }
      return list;
    }
    /**
     * @license
     * Copyright 2018 Google LLC. All Rights Reserved.
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     * http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     * =============================================================================
     */
    const executeOp$2 = async (node, tensorMap, context) => {
      switch (node.op) {
        case "If":
        case "StatelessIf": {
          const thenFunc = getParamValue("thenBranch", node, tensorMap, context);
          const elseFunc = getParamValue("elseBranch", node, tensorMap, context);
          const cond = getParamValue("cond", node, tensorMap, context);
          const args = getParamValue("args", node, tensorMap, context);
          const condValue = await cond.data();
          if (condValue[0]) {
            return context.functionMap[thenFunc].executeFunctionAsync(args, context.tensorArrayMap, context.tensorListMap);
          } else {
            return context.functionMap[elseFunc].executeFunctionAsync(args, context.tensorArrayMap, context.tensorListMap);
          }
        }
        case "While":
        case "StatelessWhile": {
          const bodyFunc = getParamValue("body", node, tensorMap, context);
          const condFunc = getParamValue("cond", node, tensorMap, context);
          const args = getParamValue("args", node, tensorMap, context);
          const condResult = await context.functionMap[condFunc].executeFunctionAsync(args, context.tensorArrayMap, context.tensorListMap);
          const argIds = args.map((tensor7) => tensor7.id);
          let condValue = await condResult[0].data();
          condResult.forEach((tensor7) => {
            if (!tensor7.kept && argIds.indexOf(tensor7.id) === -1) {
              tensor7.dispose();
            }
          });
          let result = args;
          while (condValue[0]) {
            const origResult = result;
            result = await context.functionMap[bodyFunc].executeFunctionAsync(result, context.tensorArrayMap, context.tensorListMap);
            const resultIds = result.map((tensor7) => tensor7.id);
            origResult.forEach((tensor7) => {
              if (!tensor7.kept && argIds.indexOf(tensor7.id) === -1 && resultIds.indexOf(tensor7.id) === -1) {
                tensor7.dispose();
              }
            });
            const condResult2 = await context.functionMap[condFunc].executeFunctionAsync(result, context.tensorArrayMap, context.tensorListMap);
            condValue = await condResult2[0].data();
            condResult2.forEach((tensor7) => {
              if (!tensor7.kept && argIds.indexOf(tensor7.id) === -1 && resultIds.indexOf(tensor7.id) === -1) {
                tensor7.dispose();
              }
            });
          }
          return result;
        }
        case "LoopCond": {
          const pred = getParamValue("pred", node, tensorMap, context);
          return [cloneTensor(pred)];
        }
        case "Switch": {
          const pred = getParamValue("pred", node, tensorMap, context);
          let data2 = getParamValue("data", node, tensorMap, context);
          if (!data2.kept) {
            data2 = cloneTensor(data2);
          }
          return (await pred.data())[0] ? [void 0, data2] : [data2, void 0];
        }
        case "Merge": {
          const inputName = node.inputNames.find((name) => getTensor(name, tensorMap, context) !== void 0);
          if (inputName) {
            const data2 = getTensor(inputName, tensorMap, context);
            return [cloneTensor(data2)];
          }
          return void 0;
        }
        case "Enter": {
          const frameId = getParamValue("frameName", node, tensorMap, context);
          const data2 = getParamValue("tensor", node, tensorMap, context);
          context.enterFrame(frameId);
          return [cloneTensor(data2)];
        }
        case "Exit": {
          const data2 = getParamValue("tensor", node, tensorMap, context);
          context.exitFrame();
          return [cloneTensor(data2)];
        }
        case "NextIteration": {
          const data2 = getParamValue("tensor", node, tensorMap, context);
          context.nextIteration();
          return [cloneTensor(data2)];
        }
        case "TensorArrayV3": {
          const size = getParamValue("size", node, tensorMap, context);
          const dtype = getParamValue("dtype", node, tensorMap, context);
          const elementShape = getParamValue("elementShape", node, tensorMap, context);
          const dynamicSize = getParamValue("dynamicSize", node, tensorMap, context);
          const clearAfterRead = getParamValue("clearAfterRead", node, tensorMap, context);
          const identicalElementShapes = getParamValue("identicalElementShapes", node, tensorMap, context);
          const name = getParamValue("name", node, tensorMap, context);
          const tensorArray = new TensorArray(name, dtype, size, elementShape, identicalElementShapes, dynamicSize, clearAfterRead);
          context.addTensorArray(tensorArray);
          return [tensorArray.idTensor, scalar3(1)];
        }
        case "TensorArrayWriteV3": {
          const id = getParamValue("tensorArrayId", node, tensorMap, context);
          const index2 = getParamValue("index", node, tensorMap, context);
          const writeTensor = getParamValue("tensor", node, tensorMap, context);
          const writeTensorArray = context.getTensorArray(id.id);
          writeTensorArray.write(index2, writeTensor);
          return [writeTensorArray.idTensor];
        }
        case "TensorArrayReadV3": {
          const readId = getParamValue("tensorArrayId", node, tensorMap, context);
          const readIndex = getParamValue("index", node, tensorMap, context);
          const readTensorArray = context.getTensorArray(readId.id);
          return [readTensorArray.read(readIndex)];
        }
        case "TensorArrayGatherV3": {
          const gatherId = getParamValue("tensorArrayId", node, tensorMap, context);
          const gatherIndices = getParamValue("indices", node, tensorMap, context);
          const gatherDtype = getParamValue("dtype", node, tensorMap, context);
          const gatherTensorArray = context.getTensorArray(gatherId.id);
          return [gatherTensorArray.gather(gatherIndices, gatherDtype)];
        }
        case "TensorArrayScatterV3": {
          const scatterId = getParamValue("tensorArrayId", node, tensorMap, context);
          const scatterIndices = getParamValue("indices", node, tensorMap, context);
          const scatterTensor = getParamValue("tensor", node, tensorMap, context);
          const scatterTensorArray = context.getTensorArray(scatterId.id);
          scatterTensorArray.scatter(scatterIndices, scatterTensor);
          return [scatterTensorArray.idTensor];
        }
        case "TensorArrayConcatV3": {
          const concatId = getParamValue("tensorArrayId", node, tensorMap, context);
          const concatTensorArray = context.getTensorArray(concatId.id);
          const concatDtype = getParamValue("dtype", node, tensorMap, context);
          return [concatTensorArray.concat(concatDtype)];
        }
        case "TensorArraySplitV3": {
          const splitId = getParamValue("tensorArrayId", node, tensorMap, context);
          const splitTensor = getParamValue("tensor", node, tensorMap, context);
          const lengths = getParamValue("lengths", node, tensorMap, context);
          const splitTensorArray = context.getTensorArray(splitId.id);
          splitTensorArray.split(lengths, splitTensor);
          return [splitTensorArray.idTensor];
        }
        case "TensorArraySizeV3": {
          const sizeId = getParamValue("tensorArrayId", node, tensorMap, context);
          const sizeTensorArray = context.getTensorArray(sizeId.id);
          return [scalar3(sizeTensorArray.size(), "int32")];
        }
        case "TensorArrayCloseV3": {
          const closeId = getParamValue("tensorArrayId", node, tensorMap, context);
          const closeTensorArray = context.getTensorArray(closeId.id);
          closeTensorArray.clearAndClose();
          return [closeTensorArray.idTensor];
        }
        case "TensorListSetItem": {
          const idTensor = getParamValue("tensorListId", node, tensorMap, context);
          const index2 = getParamValue("index", node, tensorMap, context);
          const writeTensor = getParamValue("tensor", node, tensorMap, context);
          const tensorList = context.getTensorList(idTensor.id);
          tensorList.setItem(index2, writeTensor);
          return [tensorList.idTensor];
        }
        case "TensorListGetItem": {
          const idTensor = getParamValue("tensorListId", node, tensorMap, context);
          const readIndex = getParamValue("index", node, tensorMap, context);
          const elementShape = getParamValue("elementShape", node, tensorMap, context);
          const elementDType = getParamValue("elementDType", node, tensorMap, context);
          const tensorList = context.getTensorList(idTensor.id);
          return [tensorList.getItem(readIndex, elementShape, elementDType)];
        }
        case "TensorListScatterV2":
        case "TensorListScatter": {
          const scatterIndices = getParamValue("indices", node, tensorMap, context);
          const scatterTensor = getParamValue("tensor", node, tensorMap, context);
          const elementShape = getParamValue("elementShape", node, tensorMap, context);
          const numElements = getParamValue("numElements", node, tensorMap, context);
          const tensorList = scatter(scatterTensor, scatterIndices, elementShape, numElements);
          context.addTensorList(tensorList);
          return [tensorList.idTensor];
        }
        case "TensorListReserve": {
          const elementShape = getParamValue("elementShape", node, tensorMap, context);
          const elementDtype = getParamValue("elementDType", node, tensorMap, context);
          const numElements = getParamValue("numElements", node, tensorMap, context);
          const tensorList = reserve(elementShape, elementDtype, numElements);
          context.addTensorList(tensorList);
          return [tensorList.idTensor];
        }
        case "TensorListGather": {
          const gatherId = getParamValue("tensorListId", node, tensorMap, context);
          const gatherIndices = getParamValue("indices", node, tensorMap, context);
          const elementShape = getParamValue("elementShape", node, tensorMap, context);
          const elementDtype = getParamValue("elementDType", node, tensorMap, context);
          const tensorList = context.getTensorList(gatherId.id);
          return [tensorList.gather(gatherIndices, elementDtype, elementShape)];
        }
        case "TensorListStack": {
          const idTensor = getParamValue("tensorListId", node, tensorMap, context);
          const elementShape = getParamValue("elementShape", node, tensorMap, context);
          const elementDtype = getParamValue("elementDType", node, tensorMap, context);
          const numElements = getParamValue("numElements", node, tensorMap, context);
          const tensorList = context.getTensorList(idTensor.id);
          return [tensorList.stack(elementShape, elementDtype, numElements)];
        }
        case "TensorListFromTensor": {
          const tensor7 = getParamValue("tensor", node, tensorMap, context);
          const elementShape = getParamValue("elementShape", node, tensorMap, context);
          const elementDtype = getParamValue("elementDType", node, tensorMap, context);
          const tensorList = fromTensor(tensor7, elementShape, elementDtype);
          context.addTensorList(tensorList);
          return [tensorList.idTensor];
        }
        case "TensorListConcat": {
          const concatId = getParamValue("tensorListId", node, tensorMap, context);
          const tensorList = context.getTensorList(concatId.id);
          const concatDtype = getParamValue("dtype", node, tensorMap, context);
          const elementShape = getParamValue("elementShape", node, tensorMap, context);
          return [tensorList.concat(concatDtype, elementShape)];
        }
        case "TensorListPushBack": {
          const idTensor = getParamValue("tensorListId", node, tensorMap, context);
          const writeTensor = getParamValue("tensor", node, tensorMap, context);
          const tensorList = context.getTensorList(idTensor.id);
          tensorList.pushBack(writeTensor);
          return [tensorList.idTensor];
        }
        case "TensorListPopBack": {
          const idTensor = getParamValue("tensorListId", node, tensorMap, context);
          const elementShape = getParamValue("elementShape", node, tensorMap, context);
          const elementDType = getParamValue("elementDType", node, tensorMap, context);
          const tensorList = context.getTensorList(idTensor.id);
          return [tensorList.popBack(elementShape, elementDType)];
        }
        case "TensorListSplit": {
          const splitTensor = getParamValue("tensor", node, tensorMap, context);
          const elementShape = getParamValue("elementShape", node, tensorMap, context);
          const lengths = getParamValue("lengths", node, tensorMap, context);
          const tensorList = split$3(splitTensor, lengths, elementShape);
          context.addTensorList(tensorList);
          return [tensorList.idTensor];
        }
        default:
          throw TypeError(`Node type ${node.op} is not implemented`);
      }
    };
    const CATEGORY$2 = "control";
    /**
     * @license
     * Copyright 2018 Google LLC. All Rights Reserved.
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     * http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     * =============================================================================
     */
    function fusedConvAndDepthWiseParams(node, tensorMap, context) {
      const [extraOp, activationFunc] = getParamValue("fusedOps", node, tensorMap, context);
      const isBiasAdd = extraOp === "biasadd";
      const isPrelu = activationFunc === "prelu";
      const isBatchNorm = extraOp === "fusedbatchnorm";
      const numArgs = getParamValue("numArgs", node, tensorMap, context);
      if (isBiasAdd) {
        if (isPrelu && numArgs !== 2) {
          throw new Error("FusedConv2d and DepthwiseConv2d with BiasAdd and Prelu must have two extra arguments: bias and alpha.");
        }
        if (!isPrelu && numArgs !== 1) {
          throw new Error("FusedConv2d and DepthwiseConv2d with BiasAdd must have one extra argument: bias.");
        }
      }
      if (isBatchNorm) {
        throw new Error("FusedConv2d and DepthwiseConv2d with FusedBatchNorm is not supported.");
      }
      const stride = getParamValue("strides", node, tensorMap, context);
      const pad3 = getPadding(node, tensorMap, context);
      const dataFormat = getParamValue("dataFormat", node, tensorMap, context).toUpperCase();
      const dilations = getParamValue("dilations", node, tensorMap, context);
      const [biasArg, preluArg] = getParamValue("args", node, tensorMap, context);
      return {
        stride,
        pad: pad3,
        dataFormat,
        dilations,
        biasArg,
        preluArg,
        activationFunc
      };
    }
    const executeOp$3 = (node, tensorMap, context) => {
      switch (node.op) {
        case "Conv1D": {
          const stride = getParamValue("stride", node, tensorMap, context);
          const pad3 = getParamValue("pad", node, tensorMap, context);
          const dataFormat = getParamValue("dataFormat", node, tensorMap, context).toUpperCase();
          const dilation = getParamValue("dilation", node, tensorMap, context);
          return [conv1d(getParamValue("x", node, tensorMap, context), getParamValue("filter", node, tensorMap, context), stride, pad3, dataFormat, dilation)];
        }
        case "Conv2D": {
          const stride = getParamValue("strides", node, tensorMap, context);
          const pad3 = getPadding(node, tensorMap, context);
          const dataFormat = getParamValue("dataFormat", node, tensorMap, context).toUpperCase();
          const dilations = getParamValue("dilations", node, tensorMap, context);
          return [conv2d2(getParamValue("x", node, tensorMap, context), getParamValue("filter", node, tensorMap, context), [stride[1], stride[2]], pad3, dataFormat, [dilations[1], dilations[2]])];
        }
        case "_FusedConv2D": {
          const {stride, pad: pad3, dataFormat, dilations, biasArg, preluArg, activationFunc} = fusedConvAndDepthWiseParams(node, tensorMap, context);
          return [conv2d$1({
            x: getParamValue("x", node, tensorMap, context),
            filter: getParamValue("filter", node, tensorMap, context),
            strides: [stride[1], stride[2]],
            pad: pad3,
            dataFormat,
            dilations: [dilations[1], dilations[2]],
            bias: biasArg,
            activation: activationFunc,
            preluActivationWeights: preluArg
          })];
        }
        case "FusedDepthwiseConv2dNative": {
          const {stride, pad: pad3, dataFormat, dilations, biasArg, preluArg, activationFunc} = fusedConvAndDepthWiseParams(node, tensorMap, context);
          return [depthwiseConv2d$1({
            x: getParamValue("x", node, tensorMap, context),
            filter: getParamValue("filter", node, tensorMap, context),
            strides: [stride[1], stride[2]],
            pad: pad3,
            dataFormat,
            dilations: [dilations[1], dilations[2]],
            bias: biasArg,
            activation: activationFunc,
            preluActivationWeights: preluArg
          })];
        }
        case "Conv2DBackpropInput":
        case "Conv2dTranspose": {
          const shape = getParamValue("outputShape", node, tensorMap, context);
          const stride = getParamValue("strides", node, tensorMap, context);
          const pad3 = getPadding(node, tensorMap, context);
          return [conv2dTranspose(getParamValue("x", node, tensorMap, context), getParamValue("filter", node, tensorMap, context), shape, [stride[1], stride[2]], pad3)];
        }
        case "DepthwiseConv2dNative":
        case "DepthwiseConv2d": {
          const stride = getParamValue("strides", node, tensorMap, context);
          const pad3 = getPadding(node, tensorMap, context);
          const dilations = getParamValue("dilations", node, tensorMap, context);
          const dataFormat = getParamValue("dataFormat", node, tensorMap, context).toUpperCase();
          return [depthwiseConv2d2(getParamValue("input", node, tensorMap, context), getParamValue("filter", node, tensorMap, context), [stride[1], stride[2]], pad3, dataFormat, [dilations[1], dilations[2]])];
        }
        case "Conv3D": {
          const stride = getParamValue("strides", node, tensorMap, context);
          const pad3 = getParamValue("pad", node, tensorMap, context);
          const dataFormat = getParamValue("dataFormat", node, tensorMap, context).toUpperCase();
          const dilations = getParamValue("dilations", node, tensorMap, context);
          return [conv3d(getParamValue("x", node, tensorMap, context), getParamValue("filter", node, tensorMap, context), [stride[1], stride[2], stride[3]], pad3, dataFormat, [dilations[1], dilations[2], dilations[3]])];
        }
        case "AvgPool": {
          const stride = getParamValue("strides", node, tensorMap, context);
          const pad3 = getParamValue("pad", node, tensorMap, context);
          const kernelSize = getParamValue("kernelSize", node, tensorMap, context);
          return [avgPool2(getParamValue("x", node, tensorMap, context), [kernelSize[1], kernelSize[2]], [stride[1], stride[2]], pad3)];
        }
        case "MaxPool": {
          const stride = getParamValue("strides", node, tensorMap, context);
          const pad3 = getParamValue("pad", node, tensorMap, context);
          const kernelSize = getParamValue("kernelSize", node, tensorMap, context);
          return [maxPool2(getParamValue("x", node, tensorMap, context), [kernelSize[1], kernelSize[2]], [stride[1], stride[2]], pad3)];
        }
        case "MaxPoolWithArgmax": {
          const stride = getParamValue("strides", node, tensorMap, context);
          const pad3 = getParamValue("pad", node, tensorMap, context);
          const kernelSize = getParamValue("kernelSize", node, tensorMap, context);
          const includeBatchInIndex = getParamValue("includeBatchInIndex", node, tensorMap, context);
          const {result, indexes} = maxPoolWithArgmax(getParamValue("x", node, tensorMap, context), [kernelSize[1], kernelSize[2]], [stride[1], stride[2]], pad3, includeBatchInIndex);
          return [result, indexes];
        }
        case "AvgPool3D": {
          const stride = getParamValue("strides", node, tensorMap, context);
          const pad3 = getParamValue("pad", node, tensorMap, context);
          const kernelSize = getParamValue("kernelSize", node, tensorMap, context);
          return [avgPool3d(getParamValue("x", node, tensorMap, context), [kernelSize[1], kernelSize[2], kernelSize[3]], [stride[1], stride[2], stride[3]], pad3)];
        }
        case "MaxPool3D": {
          const stride = getParamValue("strides", node, tensorMap, context);
          const pad3 = getParamValue("pad", node, tensorMap, context);
          const kernelSize = getParamValue("kernelSize", node, tensorMap, context);
          return [maxPool3d(getParamValue("x", node, tensorMap, context), [kernelSize[1], kernelSize[2], kernelSize[3]], [stride[1], stride[2], stride[3]], pad3)];
        }
        case "Dilation2D": {
          const strides = getParamValue("strides", node, tensorMap, context);
          const pad3 = getParamValue("pad", node, tensorMap, context);
          const dilations = getParamValue("dilations", node, tensorMap, context);
          const strideHeight = strides[1];
          const strideWidth = strides[2];
          const dilationHeight = dilations[1];
          const dilationWidth = dilations[2];
          return [dilation2d(getParamValue("x", node, tensorMap, context), getParamValue("filter", node, tensorMap, context), [strideHeight, strideWidth], pad3, [dilationHeight, dilationWidth], "NHWC")];
        }
        default:
          throw TypeError(`Node type ${node.op} is not implemented`);
      }
    };
    const CATEGORY$3 = "convolution";
    /**
     * @license
     * Copyright 2018 Google LLC. All Rights Reserved.
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     * http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     * =============================================================================
     */
    const executeOp$4 = (node, tensorMap, context) => {
      switch (node.op) {
        case "Fill": {
          const shape = getParamValue("shape", node, tensorMap, context);
          const dtype = getParamValue("dtype", node, tensorMap, context);
          const value = getParamValue("value", node, tensorMap, context);
          return [fill2(shape, value, dtype)];
        }
        case "LinSpace": {
          const start = getParamValue("start", node, tensorMap, context);
          const stop = getParamValue("stop", node, tensorMap, context);
          const num = getParamValue("num", node, tensorMap, context);
          return [linspace(start, stop, num)];
        }
        case "Multinomial": {
          const logits = getParamValue("logits", node, tensorMap, context);
          const numSamples = getParamValue("numSamples", node, tensorMap, context);
          const seed = getParamValue("seed", node, tensorMap, context);
          return [multinomial(logits, numSamples, seed)];
        }
        case "OneHot": {
          const indices = getParamValue("indices", node, tensorMap, context);
          const depth = getParamValue("depth", node, tensorMap, context);
          const onValue = getParamValue("onValue", node, tensorMap, context);
          const offValue = getParamValue("offValue", node, tensorMap, context);
          return [oneHot2(indices, depth, onValue, offValue)];
        }
        case "Ones": {
          return [ones$1(getParamValue("shape", node, tensorMap, context), getParamValue("dtype", node, tensorMap, context))];
        }
        case "OnesLike": {
          return [onesLike2(getParamValue("x", node, tensorMap, context))];
        }
        case "RandomUniform": {
          return [randomUniform(getParamValue("shape", node, tensorMap, context), getParamValue("minval", node, tensorMap, context), getParamValue("maxval", node, tensorMap, context), getParamValue("dtype", node, tensorMap, context))];
        }
        case "Range": {
          const start = getParamValue("start", node, tensorMap, context);
          const stop = getParamValue("stop", node, tensorMap, context);
          const step4 = getParamValue("step", node, tensorMap, context);
          return [range(start, stop, step4, getParamValue("dtype", node, tensorMap, context))];
        }
        case "TruncatedNormal": {
          const shape = getParamValue("shape", node, tensorMap, context);
          const mean2 = getParamValue("mean", node, tensorMap, context);
          const stdDev = getParamValue("stdDev", node, tensorMap, context);
          const seed = getParamValue("seed", node, tensorMap, context);
          return [truncatedNormal(shape, mean2, stdDev, getParamValue("dtype", node, tensorMap, context), seed)];
        }
        case "Zeros": {
          return [zeros3(getParamValue("shape", node, tensorMap, context), getParamValue("dtype", node, tensorMap, context))];
        }
        case "ZerosLike": {
          return [zerosLike2(getParamValue("x", node, tensorMap, context))];
        }
        default:
          throw TypeError(`Node type ${node.op} is not implemented`);
      }
    };
    const CATEGORY$4 = "creation";
    /**
     * @license
     * Copyright 2018 Google LLC. All Rights Reserved.
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     * http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     * =============================================================================
     */
    function nmsParams(node, tensorMap, context) {
      const boxes = getParamValue("boxes", node, tensorMap, context);
      const scores = getParamValue("scores", node, tensorMap, context);
      const maxOutputSize = getParamValue("maxOutputSize", node, tensorMap, context);
      const iouThreshold = getParamValue("iouThreshold", node, tensorMap, context);
      const scoreThreshold = getParamValue("scoreThreshold", node, tensorMap, context);
      const softNmsSigma = getParamValue("softNmsSigma", node, tensorMap, context);
      return {
        boxes,
        scores,
        maxOutputSize,
        iouThreshold,
        scoreThreshold,
        softNmsSigma
      };
    }
    const executeOp$5 = async (node, tensorMap, context) => {
      switch (node.op) {
        case "NonMaxSuppressionV5": {
          const {boxes, scores, maxOutputSize, iouThreshold, scoreThreshold, softNmsSigma} = nmsParams(node, tensorMap, context);
          const result = await image2.nonMaxSuppressionWithScoreAsync(boxes, scores, maxOutputSize, iouThreshold, scoreThreshold, softNmsSigma);
          return [result.selectedIndices, result.selectedScores];
        }
        case "NonMaxSuppressionV4": {
          const {boxes, scores, maxOutputSize, iouThreshold, scoreThreshold} = nmsParams(node, tensorMap, context);
          const padToMaxOutputSize = getParamValue("padToMaxOutputSize", node, tensorMap, context);
          const result = await image2.nonMaxSuppressionPaddedAsync(boxes, scores, maxOutputSize, iouThreshold, scoreThreshold, padToMaxOutputSize);
          return [result.selectedIndices, result.validOutputs];
        }
        case "NonMaxSuppressionV3":
        case "NonMaxSuppressionV2": {
          const {boxes, scores, maxOutputSize, iouThreshold, scoreThreshold} = nmsParams(node, tensorMap, context);
          return [await image2.nonMaxSuppressionAsync(boxes, scores, maxOutputSize, iouThreshold, scoreThreshold)];
        }
        case "Where": {
          const condition = cast7(getParamValue("condition", node, tensorMap, context), "bool");
          const result = [await whereAsync(condition)];
          condition.dispose();
          return result;
        }
        case "ListDiff": {
          return setdiff1dAsync(getParamValue("x", node, tensorMap, context), getParamValue("y", node, tensorMap, context));
        }
        default:
          throw TypeError(`Node type ${node.op} is not implemented`);
      }
    };
    const CATEGORY$5 = "dynamic";
    /**
     * @license
     * Copyright 2018 Google LLC. All Rights Reserved.
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     * http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     * =============================================================================
     */
    const executeOp$6 = (node, tensorMap, context) => {
      switch (node.op) {
        case "TopKV2": {
          const x = getParamValue("x", node, tensorMap, context);
          const k = getParamValue("k", node, tensorMap, context);
          const sorted = getParamValue("sorted", node, tensorMap, context);
          const result = topk(x, k, sorted);
          return [result.values, result.indices];
        }
        case "Unique": {
          const x = getParamValue("x", node, tensorMap, context);
          const result = unique(x);
          return [result.values, result.indices];
        }
        case "UniqueV2": {
          const x = getParamValue("x", node, tensorMap, context);
          const axis = getParamValue("axis", node, tensorMap, context);
          const result = unique(x, axis);
          return [result.values, result.indices];
        }
        default:
          throw TypeError(`Node type ${node.op} is not implemented`);
      }
    };
    const CATEGORY$6 = "evaluation";
    /**
     * @license
     * Copyright 2018 Google LLC. All Rights Reserved.
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     * http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     * =============================================================================
     */
    const executeOp$7 = (node, tensorMap, context) => {
      switch (node.op) {
        case "Const": {
          return tensorMap[node.name];
        }
        case "PlaceholderWithDefault":
          const def = getParamValue("default", node, tensorMap, context);
          return [getTensor(node.name, tensorMap, context) || def];
        case "Placeholder":
          return [getTensor(node.name, tensorMap, context)];
        case "Identity":
        case "StopGradient":
        case "FakeQuantWithMinMaxVars": {
          const data3 = getParamValue("x", node, tensorMap, context);
          return [cloneTensor(data3)];
        }
        case "IdentityN":
          return getParamValue("x", node, tensorMap, context).map((t) => cloneTensor(t));
        case "Snapshot":
          const snapshot = getParamValue("x", node, tensorMap, context);
          return [cloneTensor(snapshot)];
        case "Shape":
          return [tensor1d3(getParamValue("x", node, tensorMap, context).shape, "int32")];
        case "ShapeN":
          return getParamValue("x", node, tensorMap, context).map((t) => tensor1d3(t.shape));
        case "Size":
          return [scalar3(getParamValue("x", node, tensorMap, context).size, "int32")];
        case "Rank":
          return [scalar3(getParamValue("x", node, tensorMap, context).rank, "int32")];
        case "NoOp":
          return [scalar3(1)];
        case "Print":
          const input2 = getParamValue("x", node, tensorMap, context);
          const data2 = getParamValue("data", node, tensorMap, context);
          const message = getParamValue("message", node, tensorMap, context);
          const summarize = getParamValue("summarize", node, tensorMap, context);
          console.warn("The graph has a tf.print() operation,usually used for debugging, which slows down performance.");
          console.log(message);
          for (let i = 0; i < data2.length; i++) {
            console.log(Array.prototype.slice.call(data2[i].dataSync()).slice(0, summarize));
          }
          return [input2];
        default:
          throw TypeError(`Node type ${node.op} is not implemented`);
      }
    };
    const CATEGORY$7 = "graph";
    /**
     * @license
     * Copyright 2020 Google LLC. All Rights Reserved.
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     * http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     * =============================================================================
     */
    class HashTable {
      constructor(keyDType, valueDType) {
        this.keyDType = keyDType;
        this.valueDType = valueDType;
        this.handle = scalar3(0);
        this.tensorMap = new Map();
        keep(this.handle);
      }
      get id() {
        return this.handle.id;
      }
      clearAndClose() {
        this.tensorMap.forEach((value) => value.dispose());
        this.tensorMap.clear();
        this.handle.dispose();
      }
      size() {
        return this.tensorMap.size;
      }
      async import(keys, values) {
        this.checkKeyAndValueTensor(keys, values);
        const $keys = await keys.data();
        this.tensorMap.forEach((value) => value.dispose());
        this.tensorMap.clear();
        return tidy(() => {
          const $values = unstack(values);
          const keysLength = $keys.length;
          const valuesLength = $values.length;
          assert2(keysLength === valuesLength, () => `The number of elements doesn't match, keys has ${keysLength} elements, the values has ${valuesLength} elements.`);
          for (let i = 0; i < keysLength; i++) {
            const key = $keys[i];
            const value = $values[i];
            keep(value);
            this.tensorMap.set(key, value);
          }
          return this.handle;
        });
      }
      async find(keys, defaultValue) {
        this.checkKeyAndValueTensor(keys, defaultValue);
        const $keys = await keys.data();
        return tidy(() => {
          const result = [];
          for (let i = 0; i < $keys.length; i++) {
            const key = $keys[i];
            const value = this.findWithDefault(key, defaultValue);
            result.push(value);
          }
          return stack(result);
        });
      }
      findWithDefault(key, defaultValue) {
        const result = this.tensorMap.get(key);
        return result != null ? result : defaultValue;
      }
      checkKeyAndValueTensor(key, value) {
        if (key.dtype !== this.keyDType) {
          throw new Error(`Expect key dtype ${this.keyDType}, but got ${key.dtype}`);
        }
        if (value.dtype !== this.valueDType) {
          throw new Error(`Expect value dtype ${this.valueDType}, but got ${value.dtype}`);
        }
      }
    }
    /**
     * @license
     * Copyright 2020 Google LLC. All Rights Reserved.
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     * http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     * =============================================================================
     */
    const executeOp$8 = async (node, tensorMap, context, resourceManager) => {
      switch (node.op) {
        case "HashTable":
        case "HashTableV2": {
          const keyDType = getParamValue("keyDType", node, tensorMap, context);
          const valueDType = getParamValue("valueDType", node, tensorMap, context);
          const hashTable2 = new HashTable(keyDType, valueDType);
          resourceManager.addHashTable(node.name, hashTable2);
          return [hashTable2.handle];
        }
        case "LookupTableImport":
        case "LookupTableImportV2": {
          const handle = getParamValue("tableHandle", node, tensorMap, context, resourceManager);
          const keys = getParamValue("keys", node, tensorMap, context);
          const values = getParamValue("values", node, tensorMap, context);
          const hashTable2 = resourceManager.getHashTableById(handle.id);
          return [await hashTable2.import(keys, values)];
        }
        case "LookupTableFind":
        case "LookupTableFindV2": {
          const handle = getParamValue("tableHandle", node, tensorMap, context, resourceManager);
          const keys = getParamValue("keys", node, tensorMap, context);
          const defaultValue = getParamValue("defaultValue", node, tensorMap, context);
          const hashTable2 = resourceManager.getHashTableById(handle.id);
          return [await hashTable2.find(keys, defaultValue)];
        }
        default:
          throw TypeError(`Node type ${node.op} is not implemented`);
      }
    };
    const CATEGORY$8 = "hash_table";
    /**
     * @license
     * Copyright 2018 Google LLC. All Rights Reserved.
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     * http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     * =============================================================================
     */
    const executeOp$9 = (node, tensorMap, context) => {
      switch (node.op) {
        case "ResizeBilinear": {
          const images = getParamValue("images", node, tensorMap, context);
          const size = getParamValue("size", node, tensorMap, context);
          const alignCorners = getParamValue("alignCorners", node, tensorMap, context);
          return [image2.resizeBilinear(images, [size[0], size[1]], alignCorners)];
        }
        case "ResizeNearestNeighbor": {
          const images = getParamValue("images", node, tensorMap, context);
          const size = getParamValue("size", node, tensorMap, context);
          const alignCorners = getParamValue("alignCorners", node, tensorMap, context);
          return [image2.resizeNearestNeighbor(images, [size[0], size[1]], alignCorners)];
        }
        case "CropAndResize": {
          const image$12 = getParamValue("image", node, tensorMap, context);
          const boxes = getParamValue("boxes", node, tensorMap, context);
          const boxInd = getParamValue("boxInd", node, tensorMap, context);
          const cropSize = getParamValue("cropSize", node, tensorMap, context);
          const method = getParamValue("method", node, tensorMap, context);
          const extrapolationValue = getParamValue("extrapolationValue", node, tensorMap, context);
          return [image2.cropAndResize(image$12, boxes, boxInd, cropSize, method, extrapolationValue)];
        }
        default:
          throw TypeError(`Node type ${node.op} is not implemented`);
      }
    };
    const CATEGORY$9 = "image";
    /**
     * @license
     * Copyright 2018 Google LLC. All Rights Reserved.
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     * http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     * =============================================================================
     */
    const executeOp$a = (node, tensorMap, context) => {
      switch (node.op) {
        case "Equal": {
          return [equal(getParamValue("a", node, tensorMap, context), getParamValue("b", node, tensorMap, context))];
        }
        case "NotEqual": {
          return [notEqual(getParamValue("a", node, tensorMap, context), getParamValue("b", node, tensorMap, context))];
        }
        case "Greater": {
          return [greater(getParamValue("a", node, tensorMap, context), getParamValue("b", node, tensorMap, context))];
        }
        case "GreaterEqual": {
          return [greaterEqual(getParamValue("a", node, tensorMap, context), getParamValue("b", node, tensorMap, context))];
        }
        case "Less": {
          return [less(getParamValue("a", node, tensorMap, context), getParamValue("b", node, tensorMap, context))];
        }
        case "LessEqual": {
          return [lessEqual(getParamValue("a", node, tensorMap, context), getParamValue("b", node, tensorMap, context))];
        }
        case "LogicalAnd": {
          return [logicalAnd(getParamValue("a", node, tensorMap, context), getParamValue("b", node, tensorMap, context))];
        }
        case "LogicalNot": {
          return [logicalNot(getParamValue("a", node, tensorMap, context))];
        }
        case "LogicalOr": {
          return [logicalOr(getParamValue("a", node, tensorMap, context), getParamValue("b", node, tensorMap, context))];
        }
        case "Select":
        case "SelectV2": {
          return [where(getParamValue("condition", node, tensorMap, context), getParamValue("a", node, tensorMap, context), getParamValue("b", node, tensorMap, context))];
        }
        default:
          throw TypeError(`Node type ${node.op} is not implemented`);
      }
    };
    const CATEGORY$a = "logical";
    /**
     * @license
     * Copyright 2018 Google LLC. All Rights Reserved.
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     * http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     * =============================================================================
     */
    const executeOp$b = (node, tensorMap, context) => {
      switch (node.op) {
        case "BatchMatMul":
        case "BatchMatMulV2":
        case "MatMul":
          return [matMul(getParamValue("a", node, tensorMap, context), getParamValue("b", node, tensorMap, context), getParamValue("transposeA", node, tensorMap, context), getParamValue("transposeB", node, tensorMap, context))];
        case "Transpose":
          return [transpose4(getParamValue("x", node, tensorMap, context), getParamValue("perm", node, tensorMap, context))];
        case "_FusedMatMul":
          const [extraOp, activationFunc] = getParamValue("fusedOps", node, tensorMap, context);
          const isBiasAdd = extraOp === "biasadd";
          const isPrelu = activationFunc === "prelu";
          const numArgs = getParamValue("numArgs", node, tensorMap, context);
          if (isBiasAdd) {
            if (isPrelu && numArgs !== 2) {
              throw new Error("Fused MatMul with BiasAdd and Prelu must have two extra arguments: bias and alpha.");
            }
            if (!isPrelu && numArgs !== 1) {
              throw new Error("Fused MatMul with BiasAdd must have one extra argument: bias.");
            }
          }
          const [biasArg, preluArg] = getParamValue("args", node, tensorMap, context);
          return [matMul$1({
            a: getParamValue("a", node, tensorMap, context),
            b: getParamValue("b", node, tensorMap, context),
            transposeA: getParamValue("transposeA", node, tensorMap, context),
            transposeB: getParamValue("transposeB", node, tensorMap, context),
            bias: biasArg,
            activation: activationFunc,
            preluActivationWeights: preluArg
          })];
        default:
          throw TypeError(`Node type ${node.op} is not implemented`);
      }
    };
    const CATEGORY$b = "matrices";
    /**
     * @license
     * Copyright 2018 Google LLC. All Rights Reserved.
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     * http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     * =============================================================================
     */
    const executeOp$c = (node, tensorMap, context) => {
      switch (node.op) {
        case "FusedBatchNorm":
        case "FusedBatchNormV2": {
          return [batchNorm(getParamValue("x", node, tensorMap, context), getParamValue("mean", node, tensorMap, context), getParamValue("variance", node, tensorMap, context), getParamValue("offset", node, tensorMap, context), getParamValue("scale", node, tensorMap, context), getParamValue("epsilon", node, tensorMap, context))];
        }
        case "FusedBatchNormV3": {
          return [batchNorm(getParamValue("x", node, tensorMap, context), getParamValue("mean", node, tensorMap, context), getParamValue("variance", node, tensorMap, context), getParamValue("offset", node, tensorMap, context), getParamValue("scale", node, tensorMap, context), getParamValue("epsilon", node, tensorMap, context))];
        }
        case "LRN": {
          return [localResponseNormalization(getParamValue("x", node, tensorMap, context), getParamValue("radius", node, tensorMap, context), getParamValue("bias", node, tensorMap, context), getParamValue("alpha", node, tensorMap, context), getParamValue("beta", node, tensorMap, context))];
        }
        case "Softmax": {
          return [softmax2(getParamValue("x", node, tensorMap, context))];
        }
        case "LogSoftmax": {
          return [logSoftmax(getParamValue("x", node, tensorMap, context))];
        }
        case "SparseToDense": {
          return [sparseToDense(getParamValue("sparseIndices", node, tensorMap, context), getParamValue("outputShape", node, tensorMap, context), getParamValue("sparseValues", node, tensorMap, context), getParamValue("defaultValue", node, tensorMap, context))];
        }
        default:
          throw TypeError(`Node type ${node.op} is not implemented`);
      }
    };
    const CATEGORY$c = "normalization";
    /**
     * @license
     * Copyright 2018 Google LLC. All Rights Reserved.
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     * http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     * =============================================================================
     */
    const executeOp$d = (node, tensorMap, context) => {
      switch (node.op) {
        case "Max": {
          const axis = getParamValue("axis", node, tensorMap, context);
          const keepDims = getParamValue("keepDims", node, tensorMap, context);
          return [max2(getParamValue("x", node, tensorMap, context), axis, keepDims)];
        }
        case "Mean": {
          const axis = getParamValue("axis", node, tensorMap, context);
          const keepDims = getParamValue("keepDims", node, tensorMap, context);
          return [mean(getParamValue("x", node, tensorMap, context), axis, keepDims)];
        }
        case "Min": {
          const axis = getParamValue("axis", node, tensorMap, context);
          const keepDims = getParamValue("keepDims", node, tensorMap, context);
          return [min2(getParamValue("x", node, tensorMap, context), axis, keepDims)];
        }
        case "Sum": {
          const axis = getParamValue("axis", node, tensorMap, context);
          const keepDims = getParamValue("keepDims", node, tensorMap, context);
          return [sum$1(getParamValue("x", node, tensorMap, context), axis, keepDims)];
        }
        case "All": {
          const axis = getParamValue("axis", node, tensorMap, context);
          const keepDims = getParamValue("keepDims", node, tensorMap, context);
          return [all(getParamValue("x", node, tensorMap, context), axis, keepDims)];
        }
        case "Any": {
          const axis = getParamValue("axis", node, tensorMap, context);
          const keepDims = getParamValue("keepDims", node, tensorMap, context);
          return [any(getParamValue("x", node, tensorMap, context), axis, keepDims)];
        }
        case "ArgMax": {
          const axis = getParamValue("axis", node, tensorMap, context);
          return [argMax(getParamValue("x", node, tensorMap, context), axis)];
        }
        case "ArgMin": {
          const axis = getParamValue("axis", node, tensorMap, context);
          return [argMin(getParamValue("x", node, tensorMap, context), axis)];
        }
        case "Prod": {
          const axis = getParamValue("axis", node, tensorMap, context);
          const keepDims = getParamValue("keepDims", node, tensorMap, context);
          return [prod(getParamValue("x", node, tensorMap, context), axis, keepDims)];
        }
        case "Cumsum": {
          const axis = getParamValue("axis", node, tensorMap, context);
          const exclusive = getParamValue("exclusive", node, tensorMap, context);
          const reverse3 = getParamValue("reverse", node, tensorMap, context);
          return [cumsum2(getParamValue("x", node, tensorMap, context), axis, exclusive, reverse3)];
        }
        default:
          throw TypeError(`Node type ${node.op} is not implemented`);
      }
    };
    const CATEGORY$d = "reduction";
    /**
     * @license
     * Copyright 2018 Google LLC. All Rights Reserved.
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     * http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     * =============================================================================
     */
    const executeOp$e = (node, tensorMap, context) => {
      switch (node.op) {
        case "ConcatV2":
        case "Concat": {
          const n = getParamValue("n", node, tensorMap, context);
          const axis = getParamValue("axis", node, tensorMap, context);
          let inputs = getParamValue("tensors", node, tensorMap, context);
          inputs = inputs.slice(0, n);
          return [concat2(inputs, axis)];
        }
        case "GatherV2":
        case "Gather": {
          const axis = getParamValue("axis", node, tensorMap, context);
          const input2 = getParamValue("x", node, tensorMap, context);
          const indices = getParamValue("indices", node, tensorMap, context);
          return [gather(input2, cast7(indices, "int32"), axis)];
        }
        case "ReverseV2":
        case "Reverse": {
          const axis = getParamValue("axis", node, tensorMap, context);
          const input2 = getParamValue("x", node, tensorMap, context);
          return [reverse2(input2, axis)];
        }
        case "Slice": {
          const begin = getParamValue("begin", node, tensorMap, context);
          const size = getParamValue("size", node, tensorMap, context);
          return [slice2(getParamValue("x", node, tensorMap, context), begin, size)];
        }
        case "StridedSlice": {
          const begin = getParamValue("begin", node, tensorMap, context);
          const end = getParamValue("end", node, tensorMap, context);
          const strides = getParamValue("strides", node, tensorMap, context);
          const beginMask = getParamValue("beginMask", node, tensorMap, context);
          const endMask = getParamValue("endMask", node, tensorMap, context);
          const ellipsisMask = getParamValue("ellipsisMask", node, tensorMap, context);
          const newAxisMask = getParamValue("newAxisMask", node, tensorMap, context);
          const shrinkAxisMask = getParamValue("shrinkAxisMask", node, tensorMap, context);
          const tensor7 = getParamValue("x", node, tensorMap, context);
          return [stridedSlice2(tensor7, begin, end, strides, beginMask, endMask, ellipsisMask, newAxisMask, shrinkAxisMask)];
        }
        case "Pack": {
          return tidy(() => {
            const axis = getParamValue("axis", node, tensorMap, context);
            const tensors = getParamValue("tensors", node, tensorMap, context);
            const shape = tensors[0].shape;
            const squeezedShape = squeeze(tensors[0]).shape;
            const mapped = tensors.map((tensor7) => {
              const sameShape = arraysEqual2(tensor7.shape, shape);
              if (!sameShape && !arraysEqual2(squeeze(tensor7).shape, squeezedShape)) {
                throw new Error("the input tensors shape does not match");
              }
              return sameShape ? tensor7 : reshape5(tensor7, shape);
            });
            return [stack(mapped, axis)];
          });
        }
        case "Unpack": {
          const axis = getParamValue("axis", node, tensorMap, context);
          const tensor7 = getParamValue("tensor", node, tensorMap, context);
          return unstack(tensor7, axis);
        }
        case "Tile": {
          const reps = getParamValue("reps", node, tensorMap, context);
          return [tile2(getParamValue("x", node, tensorMap, context), reps)];
        }
        case "Split":
        case "SplitV": {
          const axis = getParamValue("axis", node, tensorMap, context);
          const numOrSizeSplits = getParamValue("numOrSizeSplits", node, tensorMap, context);
          const tensor7 = getParamValue("x", node, tensorMap, context);
          return split2(tensor7, numOrSizeSplits, axis);
        }
        case "ScatterNd": {
          const indices = getParamValue("indices", node, tensorMap, context);
          const values = getParamValue("values", node, tensorMap, context);
          const shape = getParamValue("shape", node, tensorMap, context);
          return [scatterND(indices, values, shape)];
        }
        case "GatherNd": {
          const x = getParamValue("x", node, tensorMap, context);
          const indices = getParamValue("indices", node, tensorMap, context);
          return [gatherND(x, indices)];
        }
        case "SparseToDense": {
          const indices = getParamValue("sparseIndices", node, tensorMap, context);
          const shape = getParamValue("outputShape", node, tensorMap, context);
          const sparseValues = getParamValue("sparseValues", node, tensorMap, context);
          const defaultValue = getParamValue("defaultValue", node, tensorMap, context);
          return [sparseToDense(indices, sparseValues, shape, sparseValues.dtype === defaultValue.dtype ? defaultValue : cast7(defaultValue, sparseValues.dtype))];
        }
        default:
          throw TypeError(`Node type ${node.op} is not implemented`);
      }
    };
    const CATEGORY$e = "slice_join";
    /**
     * @license
     * Copyright 2018 Google LLC. All Rights Reserved.
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     * http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     * =============================================================================
     */
    const executeOp$f = (node, tensorMap, context) => {
      switch (node.op) {
        case "FFT": {
          return [fft(getParamValue("x", node, tensorMap, context))];
        }
        case "IFFT": {
          return [ifft(getParamValue("x", node, tensorMap, context))];
        }
        case "RFFT": {
          return [rfft(getParamValue("x", node, tensorMap, context))];
        }
        case "IRFFT": {
          return [irfft(getParamValue("x", node, tensorMap, context))];
        }
        default:
          throw TypeError(`Node type ${node.op} is not implemented`);
      }
    };
    const CATEGORY$f = "spectral";
    /**
     * @license
     * Copyright 2018 Google LLC. All Rights Reserved.
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     * http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     * =============================================================================
     */
    const executeOp$g = (node, tensorMap, context) => {
      switch (node.op) {
        case "Cast": {
          return [cast7(getParamValue("x", node, tensorMap, context), getParamValue("dtype", node, tensorMap, context))];
        }
        case "ExpandDims": {
          const axis = getParamValue("axis", node, tensorMap, context);
          return [expandDims(getParamValue("x", node, tensorMap, context), axis)];
        }
        case "Squeeze": {
          const axis = getParamValue("axis", node, tensorMap, context);
          return [squeeze(getParamValue("x", node, tensorMap, context), axis)];
        }
        case "Reshape": {
          return [reshape5(getParamValue("x", node, tensorMap, context), getParamValue("shape", node, tensorMap, context))];
        }
        case "MirrorPad": {
          return [mirrorPad(getParamValue("x", node, tensorMap, context), getParamValue("padding", node, tensorMap, context), getParamValue("mode", node, tensorMap, context))];
        }
        case "PadV2":
        case "Pad": {
          return [pad2(getParamValue("x", node, tensorMap, context), getParamValue("padding", node, tensorMap, context), getParamValue("constantValue", node, tensorMap, context))];
        }
        case "SpaceToBatchND": {
          const blockShape = getParamValue("blockShape", node, tensorMap, context);
          const paddings = getParamValue("paddings", node, tensorMap, context);
          return [spaceToBatchND(getParamValue("x", node, tensorMap, context), blockShape, paddings)];
        }
        case "BatchToSpaceND": {
          const blockShape = getParamValue("blockShape", node, tensorMap, context);
          const crops = getParamValue("crops", node, tensorMap, context);
          return [batchToSpaceND(getParamValue("x", node, tensorMap, context), blockShape, crops)];
        }
        case "DepthToSpace": {
          const blockSize = getParamValue("blockSize", node, tensorMap, context);
          const dataFormat = getParamValue("dataFormat", node, tensorMap, context).toUpperCase();
          return [depthToSpace2(getParamValue("x", node, tensorMap, context), blockSize, dataFormat)];
        }
        case "BroadcastTo": {
          return [broadcastTo(getParamValue("x", node, tensorMap, context), getParamValue("shape", node, tensorMap, context))];
        }
        default:
          throw TypeError(`Node type ${node.op} is not implemented`);
      }
    };
    const CATEGORY$g = "transformation";
    /**
     * @license
     * Copyright 2018 Google LLC. All Rights Reserved.
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     * http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     * =============================================================================
     */
    function executeOp$h(node, tensorMap, context, resourceManager) {
      const value = ((node2, tensorMap2, context2) => {
        switch (node2.category) {
          case "arithmetic":
            return tidy(() => executeOp(node2, tensorMap2, context2));
          case "basic_math":
            return tidy(() => executeOp$1(node2, tensorMap2, context2));
          case "control":
            return executeOp$2(node2, tensorMap2, context2);
          case "convolution":
            return tidy(() => executeOp$3(node2, tensorMap2, context2));
          case "creation":
            return tidy(() => executeOp$4(node2, tensorMap2, context2));
          case "dynamic":
            return executeOp$5(node2, tensorMap2, context2);
          case "evaluation":
            return tidy(() => executeOp$6(node2, tensorMap2, context2));
          case "image":
            return tidy(() => executeOp$9(node2, tensorMap2, context2));
          case "graph":
            return tidy(() => executeOp$7(node2, tensorMap2, context2));
          case "logical":
            return tidy(() => executeOp$a(node2, tensorMap2, context2));
          case "matrices":
            return tidy(() => executeOp$b(node2, tensorMap2, context2));
          case "normalization":
            return tidy(() => executeOp$c(node2, tensorMap2, context2));
          case "reduction":
            return tidy(() => executeOp$d(node2, tensorMap2, context2));
          case "slice_join":
            return tidy(() => executeOp$e(node2, tensorMap2, context2));
          case "spectral":
            return tidy(() => executeOp$f(node2, tensorMap2, context2));
          case "transformation":
            return tidy(() => executeOp$g(node2, tensorMap2, context2));
          case "hash_table":
            return executeOp$8(node2, tensorMap2, context2, resourceManager);
          case "custom":
            const opMapper = getRegisteredOp(node2.op);
            if (opMapper && opMapper.customExecutor) {
              return opMapper.customExecutor(new NodeValueImpl(node2, tensorMap2, context2));
            } else {
              throw TypeError(`Custom op ${node2.op} is not registered.`);
            }
          default:
            throw TypeError(`Unknown op '${node2.op}'. File an issue at https://github.com/tensorflow/tfjs/issues so we can add it, or register a custom execution with tf.registerOp()`);
        }
      })(node, tensorMap, context);
      if (isPromise2(value)) {
        return value.then((data2) => [].concat(data2));
      }
      return [].concat(value);
    }
    class ExecutionContext {
      constructor(weightMap = {}, tensorArrayMap = {}, tensorListMap = {}, functionMap = {}) {
        this.weightMap = weightMap;
        this.tensorArrayMap = tensorArrayMap;
        this.tensorListMap = tensorListMap;
        this.functionMap = functionMap;
        this.rootContext = {id: 0, frameName: "", iterationId: 0};
        this.contexts = [this.rootContext];
        this.lastId = 0;
        this.generateCurrentContextIds();
      }
      newFrame(id, frameName) {
        return {id, frameName, iterationId: 0};
      }
      set currentContext(contexts2) {
        if (this.contexts !== contexts2) {
          this.contexts = contexts2;
          this.generateCurrentContextIds();
        }
      }
      get currentContext() {
        return this.contexts;
      }
      get currentContextId() {
        return this._currentContextIds[0];
      }
      get currentContextIds() {
        return this._currentContextIds;
      }
      generateCurrentContextIds() {
        const names = [];
        for (let i = 0; i < this.contexts.length - 1; i++) {
          const contexts2 = this.contexts.slice(0, this.contexts.length - i);
          names.push(this.contextIdforContexts(contexts2));
        }
        names.push("");
        this._currentContextIds = names;
      }
      contextIdforContexts(contexts2) {
        return contexts2 ? contexts2.map((context) => context.id === 0 && context.iterationId === 0 ? "" : `${context.frameName}-${context.iterationId}`).join("/") : "";
      }
      enterFrame(frameId) {
        if (this.contexts) {
          this.lastId++;
          this.contexts = this.contexts.slice();
          this.contexts.push(this.newFrame(this.lastId, frameId));
          this._currentContextIds.unshift(this.contextIdforContexts(this.contexts));
        }
      }
      exitFrame() {
        if (this.contexts && this.contexts.length > 1) {
          this.contexts = this.contexts.slice();
          this.contexts.splice(-1);
          this.currentContextIds.shift();
        } else {
          throw new Error("Cannot exit frame, the context is empty");
        }
      }
      nextIteration() {
        if (this.contexts && this.contexts.length > 0) {
          this.contexts = this.contexts.slice();
          this.lastId++;
          const context = Object.assign({}, this.contexts[this.contexts.length - 1]);
          context.iterationId += 1;
          context.id = this.lastId;
          this.contexts.splice(-1, 1, context);
          this._currentContextIds.splice(0, 1, this.contextIdforContexts(this.contexts));
        } else {
          throw new Error("Cannot increase frame iteration, the context is empty");
        }
      }
      getWeight(name) {
        return this.weightMap[name];
      }
      addTensorArray(tensorArray) {
        this.tensorArrayMap[tensorArray.id] = tensorArray;
      }
      getTensorArray(id) {
        return this.tensorArrayMap[id];
      }
      addTensorList(tensorList) {
        this.tensorListMap[tensorList.id] = tensorList;
      }
      getTensorList(id) {
        return this.tensorListMap[id];
      }
      dispose(keepIds) {
        for (const key in this.tensorArrayMap) {
          this.tensorArrayMap[key].clearAndClose(keepIds);
        }
        for (const key in this.tensorListMap) {
          this.tensorListMap[key].clearAndClose(keepIds);
        }
      }
    }
    /**
     * @license
     * Copyright 2019 Google LLC. All Rights Reserved.
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     * http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     * =============================================================================
     */
    function getExecutionSubgraph(inputs, outputs, weightMap, initNodes) {
      const usedNodes = new Set();
      const missingInputs = [];
      let dynamicNode = null;
      let syncInputs = null;
      const seen = new Set();
      const inputNodeNames = Object.keys(inputs).map((name) => parseNodeName(name)[0]);
      let initNodeNames = [];
      if (initNodes != null) {
        initNodeNames = initNodes.map((node) => parseNodeName(node.name)[0]);
      }
      const frontier = [...outputs];
      while (frontier.length > 0) {
        const node = frontier.pop();
        if (isControlFlow(node) || isDynamicShape(node) || isHashTable(node)) {
          if (dynamicNode == null) {
            dynamicNode = node;
            syncInputs = dynamicNode.children.map((child) => child.name).filter((name) => usedNodes.has(name));
          }
        }
        usedNodes.add(node.name);
        if (weightMap[node.name] != null) {
          continue;
        }
        if (inputNodeNames.indexOf(node.name) !== -1) {
          continue;
        }
        if (initNodeNames.indexOf(node.name) !== -1) {
          continue;
        }
        if (node.inputs.length === 0) {
          missingInputs.push(node.name);
          continue;
        }
        node.inputs.forEach((input2) => {
          if (seen.has(input2.name)) {
            return;
          }
          seen.add(input2.name);
          frontier.push(input2);
        });
      }
      return {inputs, outputs, usedNodes, missingInputs, dynamicNode, syncInputs};
    }
    function getNodesInTopologicalOrder(graph2, weightMap, executionInfo) {
      const {usedNodes, inputs} = executionInfo;
      const frontier = [];
      const inputNodes = Object.keys(inputs).map((name) => parseNodeName(name)[0]).map((name) => graph2.nodes[name]);
      const initNodes = graph2.initNodes;
      inputNodes.forEach((input2) => {
        if (usedNodes.has(input2.name)) {
          frontier.push(input2);
        }
      });
      graph2.weights.forEach((weight) => {
        if (usedNodes.has(weight.name)) {
          frontier.push(weight);
        }
      });
      if (initNodes != null) {
        initNodes.forEach((node) => {
          if (usedNodes.has(node.name)) {
            frontier.push(node);
          }
        });
      }
      const seen = new Set();
      const orderedNodes = [];
      while (frontier.length > 0) {
        const node = frontier.pop();
        seen.add(node.name);
        if (!weightMap[node.name]) {
          orderedNodes.push(node);
        }
        node.children.forEach((child) => {
          if (!seen.has(child.name) && usedNodes.has(child.name) && child.inputs.every((input2) => seen.has(input2.name))) {
            frontier.push(child);
          }
        });
      }
      return orderedNodes;
    }
    const CONTROL_FLOW_OPS = [
      "Switch",
      "Merge",
      "Enter",
      "Exit",
      "NextIteration",
      "StatelessIf",
      "StatelessWhile",
      "if",
      "While"
    ];
    const DYNAMIC_SHAPE_OPS = [
      "NonMaxSuppressionV2",
      "NonMaxSuppressionV3",
      "NonMaxSuppressionV5",
      "Where"
    ];
    const HASH_TABLE_OPS = [
      "HashTable",
      "HashTableV2",
      "LookupTableImport",
      "LookupTableImportV2",
      "LookupTableFind",
      "LookupTableFindV2"
    ];
    function isControlFlow(node) {
      return CONTROL_FLOW_OPS.indexOf(node.op) >= 0;
    }
    function isDynamicShape(node) {
      return DYNAMIC_SHAPE_OPS.indexOf(node.op) >= 0;
    }
    function isHashTable(node) {
      return HASH_TABLE_OPS.indexOf(node.op) >= 0;
    }
    /**
     * @license
     * Copyright 2018 Google LLC. All Rights Reserved.
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     * http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     * =============================================================================
     */
    class GraphExecutor {
      constructor(graph2, parent) {
        this.graph = graph2;
        this.parent = parent;
        this.compiledMap = new Map();
        this._weightMap = {};
        this.SEPERATOR = ",";
        this._functions = {};
        this._functionExecutorMap = {};
        this._outputs = graph2.outputs;
        this._inputs = graph2.inputs;
        this._initNodes = graph2.initNodes;
        this._signature = graph2.signature;
        this._functions = graph2.functions;
        if (graph2.functions != null) {
          Object.keys(graph2.functions).forEach((name) => {
            this._functionExecutorMap[name] = new GraphExecutor(graph2.functions[name], this);
          });
        }
      }
      get weightIds() {
        return this.parent ? this.parent.weightIds : this._weightIds;
      }
      get functionExecutorMap() {
        return this.parent ? this.parent.functionExecutorMap : this._functionExecutorMap;
      }
      get weightMap() {
        return this.parent ? this.parent.weightMap : this._weightMap;
      }
      set weightMap(weightMap) {
        const weightIds = Object.keys(weightMap).map((key) => weightMap[key].map((tensor7) => tensor7.id));
        this._weightIds = [].concat(...weightIds);
        this._weightMap = weightMap;
      }
      set resourceManager(resourceManager) {
        this._resourceManager = resourceManager;
      }
      get inputs() {
        return this._inputs.map((node) => {
          return {
            name: node.name,
            shape: node.attrParams["shape"] ? node.attrParams["shape"].value : void 0,
            dtype: node.attrParams["dtype"] ? node.attrParams["dtype"].value : void 0
          };
        });
      }
      get outputs() {
        return this._outputs.map((node) => {
          return {
            name: node.name,
            shape: node.attrParams["shape"] ? node.attrParams["shape"].value : void 0,
            dtype: node.attrParams["dtype"] ? node.attrParams["dtype"].value : void 0
          };
        });
      }
      get inputNodes() {
        return this._inputs.map((node) => node.signatureKey || node.name);
      }
      get outputNodes() {
        return this._outputs.map((node) => {
          const name = node.signatureKey || node.name;
          return node.defaultOutput ? `${name}:${node.defaultOutput}` : name;
        });
      }
      get functions() {
        return Object.keys(this._functions).reduce((map, key) => {
          map[key] = this._functions[key].signature;
          return map;
        }, {});
      }
      getCompilationKey(inputs, outputs) {
        const sortedInputs = inputs.map((node) => node.name).sort();
        const sortedOutputs = outputs.map((node) => node.name).sort();
        return sortedInputs.join(this.SEPERATOR) + "--" + sortedOutputs.join(this.SEPERATOR);
      }
      compile(inputs, outputs) {
        const executionInfo = getExecutionSubgraph(inputs, outputs, this.weightMap, this._initNodes);
        const {missingInputs, dynamicNode, syncInputs} = executionInfo;
        if (dynamicNode != null) {
          throw new Error(`This execution contains the node '${dynamicNode.name}', which has the dynamic op '${dynamicNode.op}'. Please use model.executeAsync() instead. Alternatively, to avoid the dynamic ops, specify the inputs [${syncInputs}]`);
        }
        if (missingInputs.length > 0) {
          const outNames = outputs.map((n) => n.name);
          const inNames = Object.keys(inputs);
          throw new Error(`Cannot compute the outputs [${outNames}] from the provided inputs [${inNames}]. Missing the following inputs: [${missingInputs}]`);
        }
        return getNodesInTopologicalOrder(this.graph, this.weightMap, executionInfo);
      }
      execute(inputs, outputs) {
        inputs = this.mapInputs(inputs);
        const names = Object.keys(inputs).sort();
        this.checkInputs(inputs);
        this.checkInputShapeAndType(inputs);
        outputs = this.mapOutputs(outputs);
        this.checkOutputs(outputs);
        const inputNodes = names.map((name) => this.graph.nodes[parseNodeName(name)[0]]);
        const outputNodeNames = outputs.map((name) => parseNodeName(name)[0]);
        let outputNodes = outputNodeNames.map((name) => this.graph.nodes[name]);
        if (outputNodes.length === 0) {
          outputNodes = this._outputs;
        }
        const compilationKey = this.getCompilationKey(inputNodes, outputNodes);
        let orderedNodes = this.compiledMap.get(compilationKey);
        if (orderedNodes == null) {
          orderedNodes = this.compile(inputs, outputNodes);
          this.compiledMap.set(compilationKey, orderedNodes);
        }
        const tensorArrayMap = {};
        const tensorListMap = {};
        return tidy(() => {
          const context = new ExecutionContext(this.weightMap, tensorArrayMap, tensorListMap, this.functionExecutorMap);
          const tensorsMap = Object.assign({}, this.weightMap);
          Object.keys(inputs).forEach((name) => {
            const [nodeName, index2] = parseNodeName(name);
            const tensors = [];
            tensors[index2] = inputs[name];
            tensorsMap[nodeName] = tensors;
          });
          const tensorsToKeep = this.getFrozenTensorIds(tensorsMap);
          const intermediateTensorConsumerCount = {};
          for (let i = 0; i < orderedNodes.length; i++) {
            const node = orderedNodes[i];
            if (!tensorsMap[node.name]) {
              const tensors = executeOp$h(node, tensorsMap, context, this._resourceManager);
              if (isPromise2(tensors)) {
                throw new Error(`The execution of the op '${node.op}' returned a promise. Please use model.executeAsync() instead.`);
              }
              tensorsMap[node.name] = tensors;
              this.checkTensorForDisposal(node.name, node, tensorsMap, context, tensorsToKeep, outputNodeNames, intermediateTensorConsumerCount);
            }
          }
          if (this.parent == null) {
            context.dispose(tensorsToKeep);
          }
          return outputs.map((name) => getTensor(name, tensorsMap, context));
        });
      }
      getFrozenTensorIds(tensorMap) {
        const ids = [].concat.apply([], Object.keys(tensorMap).map((key) => tensorMap[key]).map((tensors) => tensors.map((tensor7) => tensor7.id)));
        return new Set(ids);
      }
      checkTensorForDisposal(nodeName, node, tensorMap, context, tensorsToKeep, outputNames, intermediateTensorConsumerCount) {
        if (node.category === "control" || outputNames.indexOf(nodeName) !== -1) {
          return;
        }
        tensorMap[nodeName].forEach((tensor7) => {
          if (tensor7 != null) {
            intermediateTensorConsumerCount[tensor7.id] = (intermediateTensorConsumerCount[tensor7.id] || 0) + node.children.length;
          }
        });
        node.inputs.forEach((input2) => {
          if (input2.category !== "control") {
            const tensors = getTensorsForCurrentContenxt(input2.name, tensorMap, context);
            if (tensors != null) {
              tensors.forEach((tensor7) => {
                if (tensor7 && !tensorsToKeep.has(tensor7.id)) {
                  const count2 = intermediateTensorConsumerCount[tensor7.id];
                  if (count2 === 1) {
                    tensor7.dispose();
                    delete intermediateTensorConsumerCount[tensor7.id];
                  } else if (count2 != null) {
                    intermediateTensorConsumerCount[tensor7.id]--;
                  }
                }
              });
            }
          }
        });
      }
      async executeAsync(inputs, outputs) {
        return this._executeAsync(inputs, outputs);
      }
      async _executeAsync(inputs, outputs, isFunctionExecution = false, tensorArrayMap = {}, tensorListMap = {}) {
        if (!isFunctionExecution) {
          inputs = this.mapInputs(inputs);
          this.checkInputs(inputs);
          this.checkInputShapeAndType(inputs);
          outputs = this.mapOutputs(outputs);
          this.checkOutputs(outputs);
        }
        const context = new ExecutionContext(this.weightMap, tensorArrayMap, tensorListMap, this.functionExecutorMap);
        const tensorMap = await this.executeWithControlFlow(inputs, context, outputs, isFunctionExecution);
        const results = outputs.map((name) => getTensor(name, tensorMap, context));
        const outputIds = results.map((t) => t.id);
        const inputIds = Object.keys(inputs).map((name) => inputs[name].id);
        const keepIds = new Set([...outputIds, ...inputIds, ...this.weightIds]);
        Object.keys(tensorMap).forEach((key) => {
          const tensorArray = tensorMap[key];
          tensorArray.forEach((tensor7) => {
            if (tensor7 && !tensor7.isDisposed && !keepIds.has(tensor7.id)) {
              tensor7.dispose();
            }
          });
        });
        if (this.parent == null) {
          context.dispose(keepIds);
        }
        return results;
      }
      async executeFunctionAsync(inputs, tensorArrayMap, tensorListMap) {
        const mappedInputs = inputs.reduce((map, tensor7, index2) => {
          map[this.inputs[index2].name] = tensor7;
          return map;
        }, {});
        return this._executeAsync(mappedInputs, this.outputNodes, true, tensorArrayMap, tensorListMap);
      }
      async executeWithControlFlow(inputs, context, outputNames, isFunctionExecution) {
        const names = Object.keys(inputs);
        const inputNodes = names.map((name) => this.graph.nodes[parseNodeName(name)[0]]);
        const outputNodeNames = outputNames.map((name) => parseNodeName(name)[0]);
        let outputNodes = outputNodeNames.map((name) => this.graph.nodes[name]);
        if (outputNodes.length === 0) {
          outputNodes = this._outputs;
        }
        const {usedNodes, missingInputs, dynamicNode, syncInputs} = getExecutionSubgraph(inputs, outputNodes, this.weightMap, this._initNodes);
        const stack2 = [
          ...inputNodes,
          ...this.graph.weights,
          ...this._initNodes || []
        ].map((node) => {
          return {node, contexts: context.currentContext};
        });
        const tensorsMap = Object.assign({}, this.weightMap);
        Object.keys(inputs).forEach((name) => {
          const [nodeName, index2] = parseNodeName(name);
          const tensors = [];
          tensors[index2] = inputs[name];
          tensorsMap[nodeName] = tensors;
        });
        const intermediateTensorConsumerCount = {};
        const tensorsToKeep = this.getFrozenTensorIds(tensorsMap);
        const added = {};
        while (stack2.length > 0) {
          const promises = this.processStack(inputNodes, stack2, context, tensorsMap, added, tensorsToKeep, outputNodeNames, intermediateTensorConsumerCount, usedNodes);
          await Promise.all(promises);
        }
        if (dynamicNode == null && !isFunctionExecution) {
          console.warn(`This model execution did not contain any nodes with control flow or dynamic output shapes. You can use model.execute() instead.`);
        }
        const missingOutputs = outputNodes.filter((node) => !isControlFlow(node) && !getTensor(node.name, tensorsMap, context)).map((node) => node.name);
        if (missingOutputs.length > 0) {
          let alternativeMsg = "";
          if (dynamicNode != null) {
            alternativeMsg = `Alternatively, to avoid the dynamic ops, use model.execute() and specify the inputs [${syncInputs}]`;
          }
          throw new Error(`Cannot compute the outputs [${missingOutputs}] from the provided inputs [${names}]. Consider providing the following inputs: [${missingInputs}]. ${alternativeMsg}`);
        }
        return tensorsMap;
      }
      processStack(inputNodes, stack2, context, tensorMap, added, tensorsToKeep, outputNames, intermediateTensorConsumerCount, usedNodes) {
        const promises = [];
        while (stack2.length > 0) {
          const item = stack2.pop();
          context.currentContext = item.contexts;
          let nodeName = "";
          if (item.node.op === "Enter" && getParamValue("isConstant", item.node, tensorMap, context)) {
            [nodeName] = getNodeNameAndIndex(item.node.name, context);
          }
          if (tensorMap[item.node.name] == null) {
            const tensors = executeOp$h(item.node, tensorMap, context, this._resourceManager);
            if (!nodeName) {
              [nodeName] = getNodeNameAndIndex(item.node.name, context);
            }
            const currentContext = context.currentContext;
            if (isPromise2(tensors)) {
              promises.push(tensors.then((t) => {
                tensorMap[nodeName] = t;
                context.currentContext = currentContext;
                this.checkTensorForDisposal(nodeName, item.node, tensorMap, context, tensorsToKeep, outputNames, intermediateTensorConsumerCount);
                this.processChildNodes(item.node, stack2, context, tensorMap, added, usedNodes);
                return t;
              }));
            } else {
              tensorMap[nodeName] = tensors;
              this.checkTensorForDisposal(nodeName, item.node, tensorMap, context, tensorsToKeep, outputNames, intermediateTensorConsumerCount);
              this.processChildNodes(item.node, stack2, context, tensorMap, added, usedNodes);
            }
          } else {
            this.processChildNodes(item.node, stack2, context, tensorMap, added, usedNodes);
          }
        }
        return promises;
      }
      processChildNodes(node, stack2, context, tensorMap, added, usedNodes) {
        node.children.forEach((childNode) => {
          const [nodeName] = getNodeNameAndIndex(childNode.name, context);
          if (added[nodeName] || !usedNodes.has(childNode.name)) {
            return;
          }
          if (childNode.op === "Merge") {
            if (childNode.inputNames.some((name) => {
              return !!getTensor(name, tensorMap, context);
            })) {
              added[nodeName] = true;
              stack2.push({contexts: context.currentContext, node: childNode});
            }
          } else if (childNode.inputNames.every((name) => {
            return !!getTensor(name, tensorMap, context);
          })) {
            added[nodeName] = true;
            stack2.push({contexts: context.currentContext, node: childNode});
          }
        });
      }
      dispose() {
        Object.keys(this.weightMap).forEach((key) => this.weightMap[key].forEach((tensor7) => tensor7.dispose()));
      }
      checkInputShapeAndType(inputs) {
        Object.keys(inputs).forEach((name) => {
          const input2 = inputs[name];
          const [nodeName] = parseNodeName(name);
          const node = this.graph.nodes[nodeName];
          if (node.attrParams["shape"] && node.attrParams["shape"].value) {
            const shape = node.attrParams["shape"].value;
            const match = shape.length === input2.shape.length && input2.shape.every((dim, index2) => shape[index2] === -1 || shape[index2] === dim);
            assert2(match, () => `The shape of dict['${node.name}'] provided in model.execute(dict) must be [${shape}], but was [${input2.shape}]`);
          }
          if (node.attrParams["dtype"] && node.attrParams["dtype"].value) {
            assert2(input2.dtype === node.attrParams["dtype"].value, () => `The dtype of dict['${node.name}'] provided in model.execute(dict) must be ${node.attrParams["dtype"].value}, but was ${input2.dtype}`);
          }
        });
      }
      mapInputs(inputs) {
        const result = {};
        for (const inputName in inputs) {
          if (this._signature != null && this._signature.inputs != null && this._signature.inputs[inputName] != null) {
            const tensor7 = this._signature.inputs[inputName];
            result[tensor7.name] = inputs[inputName];
          } else {
            result[inputName] = inputs[inputName];
          }
        }
        return result;
      }
      checkInputs(inputs) {
        const notInGraph = Object.keys(inputs).filter((name) => {
          const [nodeName] = parseNodeName(name);
          return this.graph.nodes[nodeName] == null;
        });
        if (notInGraph.length > 0) {
          throw new Error(`The dict provided in model.execute(dict) has keys: [${notInGraph}] that are not part of graph`);
        }
      }
      mapOutputs(outputs) {
        return outputs.map((name) => {
          if (this._signature != null && this._signature.outputs != null && this._signature.outputs[name] != null) {
            const tensor7 = this._signature.outputs[name];
            return tensor7.name;
          }
          return name;
        }, {});
      }
      checkOutputs(outputs) {
        outputs.forEach((name) => {
          const [normalizedName] = parseNodeName(name);
          if (!this.graph.nodes[normalizedName]) {
            throw new Error(`The output '${name}' is not found in the graph`);
          }
        });
      }
    }
    class ResourceManager {
      constructor(hashTableNameToHandle = {}, hashTableMap = {}) {
        this.hashTableNameToHandle = hashTableNameToHandle;
        this.hashTableMap = hashTableMap;
      }
      addHashTable(name, hashTable2) {
        this.hashTableNameToHandle[name] = hashTable2.handle;
        this.hashTableMap[hashTable2.id] = hashTable2;
      }
      getHashTableHandleByName(name) {
        return this.hashTableNameToHandle[name];
      }
      getHashTableById(id) {
        return this.hashTableMap[id];
      }
      dispose() {
        for (const key in this.hashTableMap) {
          this.hashTableMap[key].clearAndClose();
          delete this.hashTableMap[key];
        }
        for (const name in this.hashTableNameToHandle) {
          this.hashTableNameToHandle[name].dispose();
          delete this.hashTableNameToHandle[name];
        }
      }
    }
    /**
     * @license
     * Copyright 2018 Google LLC. All Rights Reserved.
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     * http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     * =============================================================================
     */
    const TFHUB_SEARCH_PARAM = "?tfjs-format=file";
    const DEFAULT_MODEL_NAME = "model.json";
    class GraphModel {
      constructor(modelUrl, loadOptions = {}) {
        this.modelUrl = modelUrl;
        this.loadOptions = loadOptions;
        this.version = "n/a";
        if (loadOptions == null) {
          this.loadOptions = {};
        }
        this.resourceManager = new ResourceManager();
      }
      get modelVersion() {
        return this.version;
      }
      get inputNodes() {
        return this.executor.inputNodes;
      }
      get outputNodes() {
        return this.executor.outputNodes;
      }
      get inputs() {
        return this.executor.inputs;
      }
      get outputs() {
        return this.executor.outputs;
      }
      get weights() {
        return this.executor.weightMap;
      }
      findIOHandler() {
        const path = this.modelUrl;
        if (path.load != null) {
          this.handler = path;
        } else if (this.loadOptions.requestInit != null) {
          this.handler = browserHTTPRequest(path, this.loadOptions);
        } else {
          const handlers = getLoadHandlers(path, this.loadOptions);
          if (handlers.length === 0) {
            handlers.push(browserHTTPRequest(path, this.loadOptions));
          } else if (handlers.length > 1) {
            throw new Error(`Found more than one (${handlers.length}) load handlers for URL '${[path]}'`);
          }
          this.handler = handlers[0];
        }
      }
      async load() {
        this.findIOHandler();
        if (this.handler.load == null) {
          throw new Error("Cannot proceed with model loading because the IOHandler provided does not have the `load` method implemented.");
        }
        const artifacts = await this.handler.load();
        return this.loadSync(artifacts);
      }
      loadSync(artifacts) {
        this.artifacts = artifacts;
        const graph2 = this.artifacts.modelTopology;
        let signature = {};
        if (this.artifacts.userDefinedMetadata != null) {
          signature = this.artifacts.userDefinedMetadata.signature;
        }
        this.version = `${graph2.versions.producer}.${graph2.versions.minConsumer}`;
        const weightMap = decodeWeights(this.artifacts.weightData, this.artifacts.weightSpecs);
        this.executor = new GraphExecutor(OperationMapper.Instance.transformGraph(graph2, signature));
        this.executor.weightMap = this.convertTensorMapToTensorsMap(weightMap);
        this.executor.resourceManager = this.resourceManager;
        if (artifacts.modelInitializer != null) {
          const initializer = OperationMapper.Instance.transformGraph(artifacts.modelInitializer);
          this.initializer = new GraphExecutor(initializer);
          this.initializer.weightMap = this.executor.weightMap;
          this.initializer.resourceManager = this.resourceManager;
          this.initializer.executeAsync({}, []);
        }
        return true;
      }
      async save(handlerOrURL, config2) {
        if (typeof handlerOrURL === "string") {
          const handlers = getSaveHandlers(handlerOrURL);
          if (handlers.length === 0) {
            throw new Error(`Cannot find any save handlers for URL '${handlerOrURL}'`);
          } else if (handlers.length > 1) {
            throw new Error(`Found more than one (${handlers.length}) save handlers for URL '${handlerOrURL}'`);
          }
          handlerOrURL = handlers[0];
        }
        if (handlerOrURL.save == null) {
          throw new Error("GraphModel.save() cannot proceed because the IOHandler provided does not have the `save` attribute defined.");
        }
        return handlerOrURL.save(this.artifacts);
      }
      predict(inputs, config2) {
        return this.execute(inputs, this.outputNodes);
      }
      normalizeInputs(inputs) {
        if (!(inputs instanceof Tensor2) && !Array.isArray(inputs)) {
          return inputs;
        }
        inputs = Array.isArray(inputs) ? inputs : [inputs];
        if (inputs.length !== this.inputNodes.length) {
          throw new Error(`Input tensor count mismatch,the graph model has ${this.inputNodes.length} placeholders, while there are ${inputs.length} input tensors.`);
        }
        return this.inputNodes.reduce((map, inputName, i) => {
          map[inputName] = inputs[i];
          return map;
        }, {});
      }
      normalizeOutputs(outputs) {
        outputs = outputs || this.outputNodes;
        return !Array.isArray(outputs) ? [outputs] : outputs;
      }
      execute(inputs, outputs) {
        inputs = this.normalizeInputs(inputs);
        outputs = this.normalizeOutputs(outputs);
        const result = this.executor.execute(inputs, outputs);
        return result.length > 1 ? result : result[0];
      }
      async executeAsync(inputs, outputs) {
        inputs = this.normalizeInputs(inputs);
        outputs = this.normalizeOutputs(outputs);
        const result = await this.executor.executeAsync(inputs, outputs);
        return result.length > 1 ? result : result[0];
      }
      convertTensorMapToTensorsMap(map) {
        return Object.keys(map).reduce((newMap, key) => {
          newMap[key] = [map[key]];
          return newMap;
        }, {});
      }
      dispose() {
        this.executor.dispose();
        if (this.initializer) {
          this.initializer.dispose();
        }
        this.resourceManager.dispose();
      }
    }
    async function loadGraphModel2(modelUrl, options = {}) {
      if (modelUrl == null) {
        throw new Error("modelUrl in loadGraphModel() cannot be null. Please provide a url or an IOHandler that loads the model");
      }
      if (options == null) {
        options = {};
      }
      if (options.fromTFHub) {
        if (modelUrl.load == null) {
          if (!modelUrl.endsWith("/")) {
            modelUrl = modelUrl + "/";
          }
          modelUrl = `${modelUrl}${DEFAULT_MODEL_NAME}${TFHUB_SEARCH_PARAM}`;
        }
      }
      const model2 = new GraphModel(modelUrl, options);
      await model2.load();
      return model2;
    }
    /** @license See the LICENSE file. */
    const version$2 = "2.7.0";
    /**
     * @license
     * Copyright 2018 Google LLC. All Rights Reserved.
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     * http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     * =============================================================================
     */
    /**
     * @license
     * Copyright 2018 Google LLC. All Rights Reserved.
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     * http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     *
     * =============================================================================
     */
    function deepMap(input2, mapFn) {
      return deepMapInternal(input2, mapFn);
    }
    function deepMapInternal(input2, mapFn, seen = new Map(), containedIn = new Set()) {
      if (input2 == null) {
        return null;
      }
      if (containedIn.has(input2)) {
        throw new Error("Circular references are not supported.");
      }
      if (seen.has(input2)) {
        return seen.get(input2);
      }
      const result = mapFn(input2);
      if (result.recurse && result.value !== null) {
        throw new Error("A deep map function may not return both a value and recurse=true.");
      }
      if (!result.recurse) {
        seen.set(input2, result.value);
        return result.value;
      } else if (isIterable$1(input2)) {
        const mappedIterable = Array.isArray(input2) ? [] : {};
        containedIn.add(input2);
        for (const k in input2) {
          const child = input2[k];
          const childResult = deepMapInternal(child, mapFn, seen, containedIn);
          mappedIterable[k] = childResult;
        }
        containedIn.delete(input2);
        return mappedIterable;
      } else {
        throw new Error(`Can't recurse into non-iterable type: ${input2}`);
      }
    }
    function deepZip(inputs, zipFn = zipToList) {
      return deepZipInternal(inputs, zipFn);
    }
    function deepZipInternal(inputs, zipFn, containedIn = new Set()) {
      const input2 = inputs[0];
      if (containedIn.has(input2)) {
        throw new Error("Circular references are not supported.");
      }
      const result = zipFn(inputs);
      if (result.recurse && result.value !== null) {
        throw new Error("A deep zip function may not return both a value and recurse=true.");
      }
      if (!result.recurse) {
        return result.value;
      } else if (isIterable$1(input2)) {
        const mappedIterable = Array.isArray(input2) ? [] : {};
        containedIn.add(input2);
        for (const k in input2) {
          const children = inputs.map((x) => x[k]);
          const childResult = deepZipInternal(children, zipFn, containedIn);
          mappedIterable[k] = childResult;
        }
        containedIn.delete(input2);
        return mappedIterable;
      } else {
        throw new Error(`Can't recurse into non-iterable type: ${input2}`);
      }
    }
    function zipToList(x) {
      if (x === null) {
        return null;
      }
      if (isIterable$1(x[0])) {
        return {value: null, recurse: true};
      } else {
        return {value: x, recurse: false};
      }
    }
    async function deepMapAndAwaitAll(input2, mapFn) {
      const seen = new Map();
      deepMapInternal(input2, mapFn, seen);
      for (const key of Array.from(seen.keys())) {
        const value = seen.get(key);
        if (isPromise2(value)) {
          const mappedValue = await value;
          seen.set(key, mappedValue);
        }
      }
      const result = deepMapInternal(input2, mapFn, seen);
      return result;
    }
    function isIterable$1(obj) {
      return obj != null && !ArrayBuffer.isView(obj) && (Array.isArray(obj) || typeof obj === "object" && !(obj instanceof Tensor2));
    }
    function canTensorify(obj) {
      return obj == null || isPrimitive(obj) || Array.isArray(obj) || typeof obj === "object" && obj instanceof Tensor2 || isTypedArray2(obj);
    }
    function isPrimitive(value) {
      return value === null || typeof value !== "object" && typeof value !== "function";
    }
    /**
     * @license
     * Copyright 2018 Google LLC. All Rights Reserved.
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     * http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     *
     * =============================================================================
     */
    function deepClone(container) {
      return deepMap(container, cloneIfTensor);
    }
    function cloneIfTensor(item) {
      if (item instanceof Tensor2) {
        return {value: item.clone(), recurse: false};
      } else if (isIterable$1(item)) {
        return {value: null, recurse: true};
      } else {
        return {value: item, recurse: false};
      }
    }
    /**
     * @license
     * Copyright 2018 Google LLC. All Rights Reserved.
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     * http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     *
     * =============================================================================
     */
    class RingBuffer {
      constructor(capacity) {
        this.capacity = capacity;
        this.begin = 0;
        this.end = 0;
        if (capacity == null) {
          throw new RangeError("Can't create a ring buffer of unknown capacity.");
        }
        if (capacity < 1) {
          throw new RangeError("Can't create ring buffer of capacity < 1.");
        }
        this.data = new Array(capacity);
        this.doubledCapacity = 2 * capacity;
      }
      wrap(index2) {
        while (index2 < 0) {
          index2 += this.doubledCapacity;
        }
        return index2 % this.doubledCapacity;
      }
      get(index2) {
        if (index2 < 0) {
          throw new RangeError("Can't get item at a negative index.");
        }
        return this.data[index2 % this.capacity];
      }
      set(index2, value) {
        if (index2 < 0) {
          throw new RangeError("Can't set item at a negative index.");
        }
        this.data[index2 % this.capacity] = value;
      }
      length() {
        let length = this.end - this.begin;
        if (length < 0) {
          length = this.doubledCapacity + length;
        }
        return length;
      }
      isFull() {
        return this.length() === this.capacity;
      }
      isEmpty() {
        return this.length() === 0;
      }
      push(value) {
        if (this.isFull()) {
          throw new RangeError("Ring buffer is full.");
        }
        this.set(this.end, value);
        this.end = this.wrap(this.end + 1);
      }
      pushAll(values) {
        for (const value of values) {
          this.push(value);
        }
      }
      pop() {
        if (this.isEmpty()) {
          throw new RangeError("Ring buffer is empty.");
        }
        this.end = this.wrap(this.end - 1);
        const result = this.get(this.end);
        this.set(this.end, void 0);
        return result;
      }
      unshift(value) {
        if (this.isFull()) {
          throw new RangeError("Ring buffer is full.");
        }
        this.begin = this.wrap(this.begin - 1);
        this.set(this.begin, value);
      }
      shift() {
        if (this.isEmpty()) {
          throw new RangeError("Ring buffer is empty.");
        }
        const result = this.get(this.begin);
        this.set(this.begin, void 0);
        this.begin = this.wrap(this.begin + 1);
        return result;
      }
      shuffleExcise(relativeIndex) {
        if (this.isEmpty()) {
          throw new RangeError("Ring buffer is empty.");
        }
        const index2 = this.wrap(this.begin + relativeIndex);
        const result = this.get(index2);
        this.set(index2, this.pop());
        return result;
      }
    }
    /**
     * @license
     * Copyright 2018 Google LLC. All Rights Reserved.
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     * http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     *
     * =============================================================================
     */
    class GrowingRingBuffer extends RingBuffer {
      constructor() {
        super(GrowingRingBuffer.INITIAL_CAPACITY);
      }
      isFull() {
        return false;
      }
      push(value) {
        if (super.isFull()) {
          this.expand();
        }
        super.push(value);
      }
      unshift(value) {
        if (super.isFull()) {
          this.expand();
        }
        super.unshift(value);
      }
      expand() {
        const newCapacity = this.capacity * 2;
        const newData = new Array(newCapacity);
        const len = this.length();
        for (let i = 0; i < len; i++) {
          newData[i] = this.get(this.wrap(this.begin + i));
        }
        this.data = newData;
        this.capacity = newCapacity;
        this.doubledCapacity = 2 * this.capacity;
        this.begin = 0;
        this.end = len;
      }
    }
    GrowingRingBuffer.INITIAL_CAPACITY = 32;
    /**
     * @license
     * Copyright 2018 Google LLC. All Rights Reserved.
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     * http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     *
     * =============================================================================
     */
    function iteratorFromItems(items) {
      return new ArrayIterator(items);
    }
    function iteratorFromIncrementing(start) {
      let i = start;
      return iteratorFromFunction(() => ({value: i++, done: false}));
    }
    function iteratorFromFunction(func2) {
      return new FunctionCallIterator(func2);
    }
    function iteratorFromConcatenated(baseIterators, baseErrorHandler) {
      return new ChainedIterator(baseIterators, baseErrorHandler);
    }
    function iteratorFromConcatenatedFunction(iteratorFunc, count2, baseErrorHandler) {
      return iteratorFromConcatenated(iteratorFromFunction(iteratorFunc).take(count2), baseErrorHandler);
    }
    function iteratorFromZipped(iterators, mismatchMode = ZipMismatchMode.FAIL) {
      return new ZipIterator(iterators, mismatchMode);
    }
    class LazyIterator {
      async toArray() {
        const result = [];
        let x = await this.next();
        while (!x.done) {
          result.push(x.value);
          x = await this.next();
        }
        return result;
      }
      async toArrayForTest() {
        const stream = this.prefetch(100);
        const result = [];
        let x = await stream.next();
        while (!x.done) {
          result.push(x.value);
          x = await stream.next();
        }
        return result;
      }
      async resolveFully() {
        let x = await this.next();
        while (!x.done) {
          x = await this.next();
        }
      }
      async resolveWhile(predicate) {
        let x = await this.next();
        let shouldContinue = predicate(x.value);
        while (!x.done && shouldContinue) {
          x = await this.next();
          shouldContinue = predicate(x.value);
        }
      }
      handleErrors(handler) {
        return new ErrorHandlingLazyIterator(this, handler);
      }
      filter(predicate) {
        return new FilterIterator(this, predicate);
      }
      map(transform) {
        return new MapIterator(this, transform);
      }
      mapAsync(transform) {
        return new AsyncMapIterator(this, transform);
      }
      serialMapAsync(transform) {
        return new AsyncMapIterator(this, transform).serial();
      }
      flatmap(transform) {
        return new FlatmapIterator(this, transform);
      }
      async forEachAsync(f) {
        return this.map(f).resolveFully();
      }
      async serialForEach(f) {
        return this.serialMapAsync(f).resolveWhile((x) => x === true);
      }
      rowMajorBatch(batchSize, smallLastBatch = true) {
        return new RowMajorBatchIterator(this, batchSize, smallLastBatch);
      }
      columnMajorBatch(batchSize, smallLastBatch = true, zipFn = zipToList) {
        const rowBatches = this.rowMajorBatch(batchSize, smallLastBatch);
        return rowBatches.map((x) => deepZip(x, zipFn));
      }
      concatenate(iterator, baseErrorHandler) {
        return new ChainedIterator(iteratorFromItems([this, iterator]), baseErrorHandler);
      }
      take(count2) {
        if (count2 < 0 || count2 == null) {
          return this;
        }
        return new TakeIterator(this, count2);
      }
      skip(count2) {
        if (count2 < 0 || count2 == null) {
          return this;
        }
        return new SkipIterator(this, count2);
      }
      prefetch(bufferSize) {
        return new PrefetchIterator(this, bufferSize);
      }
      shuffle(windowSize, seed) {
        return new ShuffleIterator(this, windowSize, seed);
      }
      serial() {
        return new SerialIterator(this);
      }
    }
    class ArrayIterator extends LazyIterator {
      constructor(items) {
        super();
        this.items = items;
        this.trav = 0;
      }
      summary() {
        return `Array of ${this.items.length} items`;
      }
      async next() {
        if (this.trav >= this.items.length) {
          return {value: null, done: true};
        }
        const item = this.items[this.trav];
        this.trav++;
        return {value: deepClone(item), done: false};
      }
    }
    class FunctionCallIterator extends LazyIterator {
      constructor(nextFn) {
        super();
        this.nextFn = nextFn;
      }
      summary() {
        return `Function call`;
      }
      async next() {
        try {
          return this.nextFn();
        } catch (e) {
          e.message = `Error thrown while iterating through a dataset: ${e.message}`;
          throw e;
        }
      }
    }
    class SerialIterator extends LazyIterator {
      constructor(upstream) {
        super();
        this.upstream = upstream;
        this.lastRead = Promise.resolve({value: null, done: false});
      }
      summary() {
        return `${this.upstream.summary()} -> Serial`;
      }
      async next() {
        this.lastRead = this.lastRead.then(() => this.serialNext());
        return this.lastRead;
      }
      async serialNext() {
        return this.upstream.next();
      }
    }
    class SkipIterator extends LazyIterator {
      constructor(upstream, maxCount) {
        super();
        this.upstream = upstream;
        this.maxCount = maxCount;
        this.count = 0;
        this.lastRead = Promise.resolve({value: null, done: false});
      }
      summary() {
        return `${this.upstream.summary()} -> Skip`;
      }
      async next() {
        this.lastRead = this.lastRead.then(() => this.serialNext());
        return this.lastRead;
      }
      async serialNext() {
        while (this.count++ < this.maxCount) {
          const skipped = await this.upstream.next();
          if (skipped.done) {
            return skipped;
          }
          dispose(skipped.value);
        }
        return this.upstream.next();
      }
    }
    class TakeIterator extends LazyIterator {
      constructor(upstream, maxCount) {
        super();
        this.upstream = upstream;
        this.maxCount = maxCount;
        this.count = 0;
      }
      summary() {
        return `${this.upstream.summary()} -> Take`;
      }
      async next() {
        if (this.count++ >= this.maxCount) {
          return {value: null, done: true};
        }
        return this.upstream.next();
      }
    }
    class RowMajorBatchIterator extends LazyIterator {
      constructor(upstream, batchSize, enableSmallLastBatch = true) {
        super();
        this.upstream = upstream;
        this.batchSize = batchSize;
        this.enableSmallLastBatch = enableSmallLastBatch;
        this.lastRead = Promise.resolve({value: null, done: false});
      }
      summary() {
        return `${this.upstream.summary()} -> RowMajorBatch`;
      }
      async next() {
        this.lastRead = this.lastRead.then(() => this.serialNext());
        return this.lastRead;
      }
      async serialNext() {
        const batch = [];
        while (batch.length < this.batchSize) {
          const item = await this.upstream.next();
          if (item.done) {
            if (this.enableSmallLastBatch && batch.length > 0) {
              return {value: batch, done: false};
            }
            return {value: null, done: true};
          }
          batch.push(item.value);
        }
        return {value: batch, done: false};
      }
    }
    class FilterIterator extends LazyIterator {
      constructor(upstream, predicate) {
        super();
        this.upstream = upstream;
        this.predicate = predicate;
        this.lastRead = Promise.resolve({value: null, done: false});
      }
      summary() {
        return `${this.upstream.summary()} -> Filter`;
      }
      async next() {
        this.lastRead = this.lastRead.then(() => this.serialNext());
        return this.lastRead;
      }
      async serialNext() {
        while (true) {
          const item = await this.upstream.next();
          if (item.done || this.predicate(item.value)) {
            return item;
          }
          dispose(item.value);
        }
      }
    }
    class MapIterator extends LazyIterator {
      constructor(upstream, transform) {
        super();
        this.upstream = upstream;
        this.transform = transform;
      }
      summary() {
        return `${this.upstream.summary()} -> Map`;
      }
      async next() {
        const item = await this.upstream.next();
        if (item.done) {
          return {value: null, done: true};
        }
        const inputTensors = getTensorsInContainer2(item.value);
        const mapped = this.transform(item.value);
        const outputTensors = getTensorsInContainer2(mapped);
        for (const t of inputTensors) {
          if (!isTensorInList(t, outputTensors)) {
            t.dispose();
          }
        }
        return {value: mapped, done: false};
      }
    }
    class ErrorHandlingLazyIterator extends LazyIterator {
      constructor(upstream, handler) {
        super();
        this.upstream = upstream;
        this.handler = handler;
        this.count = 0;
        this.lastRead = Promise.resolve({value: null, done: false});
      }
      summary() {
        return `${this.upstream.summary()} -> handleErrors`;
      }
      async next() {
        this.lastRead = this.lastRead.then(() => this.serialNext());
        return this.lastRead;
      }
      async serialNext() {
        while (true) {
          try {
            return await this.upstream.next();
          } catch (e) {
            if (!this.handler(e)) {
              return {value: null, done: true};
            }
          }
        }
      }
    }
    class AsyncMapIterator extends LazyIterator {
      constructor(upstream, transform) {
        super();
        this.upstream = upstream;
        this.transform = transform;
      }
      summary() {
        return `${this.upstream.summary()} -> AsyncMap`;
      }
      async next() {
        const item = await this.upstream.next();
        if (item.done) {
          return {value: null, done: true};
        }
        const inputTensors = getTensorsInContainer2(item.value);
        const mapped = await this.transform(item.value);
        const outputTensors = getTensorsInContainer2(mapped);
        for (const t of inputTensors) {
          if (!isTensorInList(t, outputTensors)) {
            t.dispose();
          }
        }
        return {value: mapped, done: false};
      }
    }
    class OneToManyIterator extends LazyIterator {
      constructor() {
        super();
        this.outputQueue = new GrowingRingBuffer();
        this.lastRead = Promise.resolve({value: null, done: false});
      }
      async next() {
        this.lastRead = this.lastRead.then(() => this.serialNext());
        return this.lastRead;
      }
      async serialNext() {
        while (this.outputQueue.length() === 0) {
          if (!await this.pump()) {
            return {value: null, done: true};
          }
        }
        return {value: this.outputQueue.shift(), done: false};
      }
    }
    class FlatmapIterator extends OneToManyIterator {
      constructor(upstream, transform) {
        super();
        this.upstream = upstream;
        this.transform = transform;
      }
      summary() {
        return `${this.upstream.summary()} -> Flatmap`;
      }
      async pump() {
        const item = await this.upstream.next();
        if (item.done) {
          return false;
        }
        const inputTensors = getTensorsInContainer2(item.value);
        const mappedArray = this.transform(item.value);
        const outputTensors = getTensorsInContainer2(mappedArray);
        this.outputQueue.pushAll(mappedArray);
        for (const t of inputTensors) {
          if (!isTensorInList(t, outputTensors)) {
            t.dispose();
          }
        }
        return true;
      }
    }
    class ChainedIterator extends LazyIterator {
      constructor(iterators, baseErrorHandler) {
        super();
        this.baseErrorHandler = baseErrorHandler;
        this.lastRead = null;
        this.iterator = null;
        this.moreIterators = iterators;
      }
      summary() {
        const upstreamSummaries = "TODO: fill in upstream of chained summaries";
        return `${upstreamSummaries} -> Chained`;
      }
      async next() {
        this.lastRead = this.readFromChain(this.lastRead);
        return this.lastRead;
      }
      async readFromChain(lastRead) {
        await lastRead;
        if (this.iterator == null) {
          const iteratorResult = await this.moreIterators.next();
          if (iteratorResult.done) {
            return {value: null, done: true};
          }
          this.iterator = iteratorResult.value;
          if (this.baseErrorHandler != null) {
            this.iterator = this.iterator.handleErrors(this.baseErrorHandler);
          }
        }
        const itemResult = await this.iterator.next();
        if (itemResult.done) {
          this.iterator = null;
          return this.readFromChain(lastRead);
        }
        return itemResult;
      }
    }
    var ZipMismatchMode;
    (function(ZipMismatchMode2) {
      ZipMismatchMode2[ZipMismatchMode2["FAIL"] = 0] = "FAIL";
      ZipMismatchMode2[ZipMismatchMode2["SHORTEST"] = 1] = "SHORTEST";
      ZipMismatchMode2[ZipMismatchMode2["LONGEST"] = 2] = "LONGEST";
    })(ZipMismatchMode || (ZipMismatchMode = {}));
    class ZipIterator extends LazyIterator {
      constructor(iterators, mismatchMode = ZipMismatchMode.FAIL) {
        super();
        this.iterators = iterators;
        this.mismatchMode = mismatchMode;
        this.count = 0;
        this.currentPromise = null;
      }
      summary() {
        const upstreamSummaries = "TODO: fill in upstream of zip summaries";
        return `{${upstreamSummaries}} -> Zip`;
      }
      async nextState(afterState) {
        await afterState;
        let numIterators = 0;
        let iteratorsDone = 0;
        function getNext(container) {
          if (container instanceof LazyIterator) {
            const result = container.next();
            return {
              value: result.then((x) => {
                numIterators++;
                if (x.done) {
                  iteratorsDone++;
                }
                return x.value;
              }),
              recurse: false
            };
          } else {
            return {value: null, recurse: true};
          }
        }
        const mapped = await deepMapAndAwaitAll(this.iterators, getNext);
        if (numIterators === iteratorsDone) {
          return {value: null, done: true};
        }
        if (iteratorsDone > 0) {
          switch (this.mismatchMode) {
            case ZipMismatchMode.FAIL:
              throw new Error(`Zipped streams should have the same length. Mismatched at element ${this.count}.`);
            case ZipMismatchMode.SHORTEST:
              return {value: null, done: true};
            case ZipMismatchMode.LONGEST:
            default:
          }
        }
        this.count++;
        return {value: mapped, done: false};
      }
      async next() {
        this.currentPromise = this.nextState(this.currentPromise);
        return this.currentPromise;
      }
    }
    class PrefetchIterator extends LazyIterator {
      constructor(upstream, bufferSize) {
        super();
        this.upstream = upstream;
        this.bufferSize = bufferSize;
        this.buffer = new RingBuffer(bufferSize);
      }
      summary() {
        return `${this.upstream.summary()} -> Prefetch`;
      }
      refill() {
        while (!this.buffer.isFull()) {
          const v = this.upstream.next();
          this.buffer.push(v);
        }
      }
      next() {
        this.refill();
        return this.buffer.shift();
      }
    }
    class ShuffleIterator extends PrefetchIterator {
      constructor(upstream, windowSize, seed) {
        super(upstream, windowSize);
        this.upstream = upstream;
        this.windowSize = windowSize;
        this.upstreamExhausted = false;
        this.random = seedrandom_1(seed || now3().toString());
        this.lastRead = Promise.resolve({value: null, done: false});
      }
      async next() {
        this.lastRead = this.lastRead.then(() => this.serialNext());
        return this.lastRead;
      }
      randomInt(max3) {
        return Math.floor(this.random() * max3);
      }
      chooseIndex() {
        return this.randomInt(this.buffer.length());
      }
      async serialNext() {
        if (!this.upstreamExhausted) {
          this.refill();
        }
        while (!this.buffer.isEmpty()) {
          const chosenIndex = this.chooseIndex();
          const result = await this.buffer.shuffleExcise(chosenIndex);
          if (result.done) {
            this.upstreamExhausted = true;
          } else {
            this.refill();
            return result;
          }
        }
        return {value: null, done: true};
      }
    }
    /**
     * @license
     * Copyright 2018 Google LLC. All Rights Reserved.
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     * http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     *
     * =============================================================================
     */
    class Dataset {
      constructor() {
        this.size = null;
      }
      batch(batchSize, smallLastBatch = true) {
        const base2 = this;
        assert2(batchSize > 0, () => `batchSize needs to be positive, but it is
      ${batchSize}`);
        let size;
        if (this.size === Infinity || this.size == null) {
          size = this.size;
        } else if (smallLastBatch) {
          size = Math.ceil(this.size / batchSize);
        } else {
          size = Math.floor(this.size / batchSize);
        }
        return datasetFromIteratorFn(async () => {
          return (await base2.iterator()).columnMajorBatch(batchSize, smallLastBatch, deepBatchConcat);
        }, size);
      }
      concatenate(dataset) {
        const base2 = this;
        let size;
        if (this.size === Infinity || dataset.size === Infinity) {
          size = Infinity;
        } else if (this.size != null && dataset.size != null) {
          size = this.size + dataset.size;
        } else {
          size = null;
        }
        return datasetFromIteratorFn(async () => (await base2.iterator()).concatenate(await dataset.iterator()), size);
      }
      filter(predicate) {
        const base2 = this;
        let size;
        if (this.size === Infinity) {
          size = Infinity;
        } else {
          size = null;
        }
        return datasetFromIteratorFn(async () => {
          return (await base2.iterator()).filter((x) => tidy(() => predicate(x)));
        }, size);
      }
      async forEachAsync(f) {
        return (await this.iterator()).forEachAsync(f);
      }
      map(transform) {
        const base2 = this;
        return datasetFromIteratorFn(async () => {
          return (await base2.iterator()).map((x) => tidy(() => transform(x)));
        }, this.size);
      }
      mapAsync(transform) {
        const base2 = this;
        return datasetFromIteratorFn(async () => {
          return (await base2.iterator()).mapAsync(transform);
        }, this.size);
      }
      prefetch(bufferSize) {
        if (bufferSize == null) {
          throw new RangeError("`Dataset.prefetch()` requires bufferSize to be specified.");
        }
        const base2 = this;
        return datasetFromIteratorFn(async () => (await base2.iterator()).prefetch(bufferSize), this.size);
      }
      repeat(count2) {
        const base2 = this;
        let size;
        if (this.size != null && count2 > 0) {
          size = this.size * count2;
        } else if (count2 === 0) {
          size = 0;
        } else if (this.size != null && (count2 === void 0 || count2 < 0)) {
          size = Infinity;
        } else {
          size = null;
        }
        return datasetFromIteratorFn(async () => {
          const iteratorIterator = iteratorFromFunction(async () => ({value: await base2.iterator(), done: false}));
          return iteratorFromConcatenated(iteratorIterator.take(count2));
        }, size);
      }
      skip(count2) {
        const base2 = this;
        let size;
        if (this.size != null && count2 >= 0 && this.size >= count2) {
          size = this.size - count2;
        } else if (this.size != null && (this.size < count2 || count2 === void 0 || count2 < 0)) {
          size = 0;
        } else {
          size = null;
        }
        return datasetFromIteratorFn(async () => (await base2.iterator()).skip(count2), size);
      }
      shuffle(bufferSize, seed, reshuffleEachIteration = true) {
        if (bufferSize == null || bufferSize < 0) {
          if (this.size == null) {
            throw new RangeError("`Dataset.shuffle()` requires bufferSize to be specified.");
          } else {
            throw new RangeError(`\`Dataset.shuffle()\` requires bufferSize to be specified.  If your data fits in main memory (for regular JS objects), and/or GPU memory (for \`tf.Tensor\`s), consider setting bufferSize to the dataset size (${this.size} elements)`);
          }
        }
        const base2 = this;
        const random = seedrandom_1(seed || now3().toString());
        return datasetFromIteratorFn(async () => {
          let seed2 = random.int32();
          if (reshuffleEachIteration) {
            seed2 += random.int32();
          }
          return (await base2.iterator()).shuffle(bufferSize, seed2.toString());
        }, this.size);
      }
      take(count2) {
        const base2 = this;
        let size;
        if (this.size != null && this.size > count2) {
          size = count2;
        } else if (this.size != null && this.size <= count2) {
          size = this.size;
        } else {
          size = null;
        }
        return datasetFromIteratorFn(async () => (await base2.iterator()).take(count2), size);
      }
      async toArray() {
        if (this.size === Infinity) {
          throw new Error("Can not convert infinite data stream to array.");
        }
        return (await this.iterator()).toArray();
      }
      async toArrayForTest() {
        if (this.size === Infinity) {
          throw new Error("Can not convert infinite data stream to array.");
        }
        return (await this.iterator()).toArrayForTest();
      }
    }
    Dataset.MAX_BUFFER_SIZE = 1e4;
    function datasetFromIteratorFn(iteratorFn, size = null) {
      return new class extends Dataset {
        constructor() {
          super(...arguments);
          this.size = size;
        }
        async iterator() {
          return iteratorFn();
        }
      }();
    }
    function array(items) {
      return datasetFromIteratorFn(async () => iteratorFromItems(items), items.length);
    }
    function zip(datasets) {
      if (!isIterable$1(datasets)) {
        throw new Error("The argument to zip() must be an object or array.");
      }
      let size;
      if (Array.isArray(datasets)) {
        for (let i = 0; i < datasets.length; i++) {
          size = size == null ? datasets[i].size : Math.min(size, datasets[i].size);
        }
      } else if (datasets instanceof Object) {
        for (const ds in datasets) {
          size = size == null ? datasets[ds].size : Math.min(size, datasets[ds].size);
        }
      }
      return datasetFromIteratorFn(async () => {
        const streams = await deepMapAndAwaitAll(datasets, (d) => {
          if (d instanceof Dataset) {
            return {value: d.iterator(), recurse: false};
          } else if (isIterable$1(d)) {
            return {value: null, recurse: true};
          } else {
            throw new Error("Leaves of the structure passed to zip() must be Datasets, not primitives.");
          }
        });
        return iteratorFromZipped(streams, ZipMismatchMode.SHORTEST);
      }, size);
    }
    function deepBatchConcat(rows) {
      if (rows === null) {
        return null;
      }
      const exampleRow = rows[0];
      if (canTensorify(exampleRow)) {
        const value = batchConcat(rows);
        return {value, recurse: false};
      }
      return {value: null, recurse: true};
    }
    function batchConcat(arrays) {
      if (arrays.length === 0) {
        throw new Error("Can't make a batch of zero elements.");
      }
      if (arrays[0] instanceof Tensor2) {
        return stack(arrays);
      } else {
        return tensor6(arrays);
      }
    }
    /**
     * @license
     * Copyright 2018 Google LLC. All Rights Reserved.
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     * http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     *
     * =============================================================================
     */
    class TextLineDataset extends Dataset {
      constructor(input2) {
        super();
        this.input = input2;
      }
      async iterator() {
        const inputIterator = await this.input.iterator();
        const utf8Iterator = inputIterator.decodeUTF8();
        const lineIterator = utf8Iterator.split("\n").map((line) => {
          if (line.endsWith("\r")) {
            line = line.slice(0, -1);
          }
          return line;
        });
        return lineIterator;
      }
    }
    /**
     * @license
     * Copyright 2018 Google LLC. All Rights Reserved.
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     * http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     *
     * =============================================================================
     */
    const CODE_QUOTE = '"';
    const STATE_OUT = Symbol("out");
    const STATE_FIELD = Symbol("field");
    const STATE_QUOTE = Symbol("quote");
    const STATE_QUOTE_AFTER_QUOTE = Symbol("quoteafterquote");
    const STATE_WITHIN_QUOTE_IN_QUOTE = Symbol("quoteinquote");
    class CSVDataset extends Dataset {
      constructor(input2, csvConfig) {
        super();
        this.input = input2;
        this.hasHeader = true;
        this.fullColumnNames = null;
        this.columnNamesValidated = false;
        this.columnConfigs = null;
        this.configuredColumnsOnly = false;
        this.delimiter = ",";
        this.delimWhitespace = false;
        this.base = new TextLineDataset(input2);
        if (!csvConfig) {
          csvConfig = {};
        }
        this.hasHeader = csvConfig.hasHeader === false ? false : true;
        this.fullColumnNames = csvConfig.columnNames;
        this.columnConfigs = csvConfig.columnConfigs;
        this.configuredColumnsOnly = csvConfig.configuredColumnsOnly;
        if (csvConfig.delimWhitespace) {
          assert2(csvConfig.delimiter == null, () => "Delimiter should not be provided when delimWhitespace is true.");
          this.delimWhitespace = true;
          this.delimiter = " ";
        } else {
          this.delimiter = csvConfig.delimiter ? csvConfig.delimiter : ",";
        }
      }
      async columnNames() {
        if (!this.columnNamesValidated) {
          await this.setColumnNames();
        }
        return this.configuredColumnsOnly ? Object.keys(this.columnConfigs) : this.fullColumnNames;
      }
      async setColumnNames() {
        const columnNamesFromFile = await this.maybeReadHeaderLine();
        if (!this.fullColumnNames && !columnNamesFromFile) {
          throw new Error("Column names must be provided if there is no header line.");
        } else if (this.fullColumnNames && columnNamesFromFile) {
          assert2(columnNamesFromFile.length === this.fullColumnNames.length, () => "The length of provided columnNames (" + this.fullColumnNames.length.toString() + ") does not match the length of the header line read from file (" + columnNamesFromFile.length.toString() + ").");
        }
        if (!this.fullColumnNames) {
          this.fullColumnNames = columnNamesFromFile;
        }
        const counts = this.fullColumnNames.reduce((countAcc, name) => {
          countAcc[name] = countAcc[name] + 1 || 1;
          return countAcc;
        }, {});
        const duplicateNames = Object.keys(counts).filter((name) => counts[name] > 1);
        assert2(duplicateNames.length === 0, () => "Duplicate column names found: " + duplicateNames.toString());
        if (this.columnConfigs) {
          for (const key of Object.keys(this.columnConfigs)) {
            const index2 = this.fullColumnNames.indexOf(key);
            if (index2 === -1) {
              throw new Error('The key "' + key + '" provided in columnConfigs does not match any of the column names (' + this.fullColumnNames.toString() + ").");
            }
          }
        }
        this.columnNamesValidated = true;
      }
      async maybeReadHeaderLine() {
        if (this.hasHeader) {
          const iter = await this.base.iterator();
          const firstElement = await iter.next();
          if (firstElement.done) {
            throw new Error("No data was found for CSV parsing.");
          }
          const firstLine = firstElement.value;
          const headers = this.parseRow(firstLine, false);
          return headers;
        } else {
          return null;
        }
      }
      async iterator() {
        if (!this.columnNamesValidated) {
          await this.setColumnNames();
        }
        let lines = await this.base.iterator();
        if (this.hasHeader) {
          lines = lines.skip(1);
        }
        return lines.map((x) => this.makeDataElement(x));
      }
      makeDataElement(line) {
        const values = this.parseRow(line);
        const features = {};
        const labels = {};
        for (let i = 0; i < this.fullColumnNames.length; i++) {
          const key = this.fullColumnNames[i];
          const config2 = this.columnConfigs ? this.columnConfigs[key] : null;
          if (this.configuredColumnsOnly && !config2) {
            continue;
          } else {
            const value = values[i];
            let parsedValue = null;
            if (value === "") {
              if (config2 && config2.default !== void 0) {
                parsedValue = config2.default;
              } else if (config2 && (config2.required || config2.isLabel)) {
                throw new Error(`Required column ${key} is empty in this line: ${line}`);
              } else {
                parsedValue = void 0;
              }
            } else {
              const valueAsNum = Number(value);
              if (isNaN(valueAsNum)) {
                if (config2 && config2.dtype === "bool") {
                  parsedValue = this.getBoolean(value);
                } else {
                  parsedValue = value;
                }
              } else if (!config2 || !config2.dtype) {
                parsedValue = valueAsNum;
              } else {
                switch (config2.dtype) {
                  case "float32":
                    parsedValue = valueAsNum;
                    break;
                  case "int32":
                    parsedValue = Math.floor(valueAsNum);
                    break;
                  case "bool":
                    parsedValue = this.getBoolean(value);
                    break;
                  default:
                    parsedValue = valueAsNum;
                }
              }
            }
            config2 && config2.isLabel ? labels[key] = parsedValue : features[key] = parsedValue;
          }
        }
        if (Object.keys(labels).length === 0) {
          return features;
        } else {
          return {xs: features, ys: labels};
        }
      }
      getBoolean(value) {
        if (value === "1" || value.toLowerCase() === "true") {
          return 1;
        } else {
          return 0;
        }
      }
      parseRow(line, validateElementCount = true) {
        const result = [];
        let readOffset = 0;
        const readLength = line.length;
        let currentState = STATE_OUT;
        for (let i = 0; i < readLength; i++) {
          switch (currentState) {
            case STATE_OUT:
              switch (line.charAt(i)) {
                case CODE_QUOTE:
                  readOffset = i + 1;
                  currentState = STATE_QUOTE;
                  break;
                case this.delimiter:
                  readOffset = i + 1;
                  if (this.delimiter === " " && this.delimWhitespace) {
                    break;
                  }
                  result.push("");
                  currentState = STATE_OUT;
                  break;
                default:
                  currentState = STATE_FIELD;
                  readOffset = i;
                  break;
              }
              break;
            case STATE_FIELD:
              switch (line.charAt(i)) {
                case this.delimiter:
                  result.push(line.substring(readOffset, i));
                  currentState = STATE_OUT;
                  readOffset = i + 1;
                  break;
                default:
              }
              break;
            case STATE_QUOTE:
              switch (line.charAt(i)) {
                case CODE_QUOTE:
                  currentState = STATE_QUOTE_AFTER_QUOTE;
                  break;
                default:
              }
              break;
            case STATE_QUOTE_AFTER_QUOTE:
              switch (line.charAt(i)) {
                case this.delimiter:
                  result.push(line.substring(readOffset, i - 1));
                  currentState = STATE_OUT;
                  readOffset = i + 1;
                  break;
                case CODE_QUOTE:
                  currentState = STATE_QUOTE;
                  break;
                default:
                  currentState = STATE_WITHIN_QUOTE_IN_QUOTE;
                  break;
              }
              break;
            case STATE_WITHIN_QUOTE_IN_QUOTE:
              switch (line.charAt(i)) {
                case CODE_QUOTE:
                  currentState = STATE_QUOTE;
                  break;
                default:
              }
              break;
            default:
          }
        }
        if (currentState === STATE_QUOTE_AFTER_QUOTE) {
          result.push(line.substring(readOffset, readLength - 1));
        } else {
          result.push(line.substring(readOffset));
        }
        if (validateElementCount && result.length !== this.fullColumnNames.length) {
          throw new Error(`Invalid row in csv file. Should have ${this.fullColumnNames.length} elements in a row, but got ${result}`);
        }
        return result;
      }
    }
    /**
     * @license
     * Copyright 2019 Google LLC. All Rights Reserved.
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     * http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     *
     * =============================================================================
     */
    class MicrophoneIterator extends LazyIterator {
      constructor(microphoneConfig) {
        super();
        this.microphoneConfig = microphoneConfig;
        this.isClosed = false;
        this.fftSize = microphoneConfig.fftSize || 1024;
        const fftSizeLog2 = Math.log2(this.fftSize);
        if (this.fftSize < 0 || fftSizeLog2 < 4 || fftSizeLog2 > 14 || !Number.isInteger(fftSizeLog2)) {
          throw new Error(`Invalid fftSize: it must be a power of 2 between 2 to 4 and 2 to 14, but got ${this.fftSize}`);
        }
        this.numFrames = microphoneConfig.numFramesPerSpectrogram || 43;
        this.sampleRateHz = microphoneConfig.sampleRateHz;
        this.columnTruncateLength = microphoneConfig.columnTruncateLength || this.fftSize;
        this.audioTrackConstraints = microphoneConfig.audioTrackConstraints;
        this.smoothingTimeConstant = microphoneConfig.smoothingTimeConstant || 0;
        this.includeSpectrogram = microphoneConfig.includeSpectrogram === false ? false : true;
        this.includeWaveform = microphoneConfig.includeWaveform === true ? true : false;
        if (!this.includeSpectrogram && !this.includeWaveform) {
          throw new Error("Both includeSpectrogram and includeWaveform are false. At least one type of data should be returned.");
        }
      }
      summary() {
        return `microphone`;
      }
      static async create(microphoneConfig = {}) {
        if (env2().get("IS_NODE")) {
          throw new Error("microphone API is only supported in browser environment.");
        }
        const microphoneIterator = new MicrophoneIterator(microphoneConfig);
        await microphoneIterator.start();
        return microphoneIterator;
      }
      async start() {
        try {
          this.stream = await navigator.mediaDevices.getUserMedia({
            audio: this.audioTrackConstraints == null ? true : this.audioTrackConstraints,
            video: false
          });
        } catch (e) {
          throw new Error(`Error thrown while initializing video stream: ${e.message}`);
        }
        if (!this.stream) {
          throw new Error("Could not obtain audio from microphone.");
        }
        const ctxConstructor = window.AudioContext || window.webkitAudioContext;
        this.audioContext = new ctxConstructor();
        if (!this.sampleRateHz) {
          this.sampleRateHz = this.audioContext.sampleRate;
        } else if (this.audioContext.sampleRate !== this.sampleRateHz) {
          throw new Error(`Mismatch in sampling rate: Expected: ${this.sampleRateHz}; Actual: ${this.audioContext.sampleRate}`);
        }
        const streamSource = this.audioContext.createMediaStreamSource(this.stream);
        this.analyser = this.audioContext.createAnalyser();
        this.analyser.fftSize = this.fftSize * 2;
        this.analyser.smoothingTimeConstant = this.smoothingTimeConstant;
        streamSource.connect(this.analyser);
        this.freqData = new Float32Array(this.fftSize);
        this.timeData = new Float32Array(this.fftSize);
        return;
      }
      async next() {
        if (this.isClosed) {
          return {value: null, done: true};
        }
        let spectrogramTensor;
        let waveformTensor;
        const audioDataQueue = await this.getAudioData();
        if (this.includeSpectrogram) {
          const freqData = this.flattenQueue(audioDataQueue.freqDataQueue);
          spectrogramTensor = this.getTensorFromAudioDataArray(freqData, [this.numFrames, this.columnTruncateLength, 1]);
        }
        if (this.includeWaveform) {
          const timeData = this.flattenQueue(audioDataQueue.timeDataQueue);
          waveformTensor = this.getTensorFromAudioDataArray(timeData, [this.numFrames * this.fftSize, 1]);
        }
        return {
          value: {spectrogram: spectrogramTensor, waveform: waveformTensor},
          done: false
        };
      }
      async capture() {
        return (await this.next()).value;
      }
      async getAudioData() {
        const freqDataQueue = [];
        const timeDataQueue = [];
        let currentFrames = 0;
        return new Promise((resolve) => {
          const intervalID = setInterval(() => {
            if (this.includeSpectrogram) {
              this.analyser.getFloatFrequencyData(this.freqData);
              if (this.freqData[0] === -Infinity) {
                resolve({freqDataQueue, timeDataQueue});
              }
              freqDataQueue.push(this.freqData.slice(0, this.columnTruncateLength));
            }
            if (this.includeWaveform) {
              this.analyser.getFloatTimeDomainData(this.timeData);
              timeDataQueue.push(this.timeData.slice());
            }
            if (++currentFrames === this.numFrames) {
              clearInterval(intervalID);
              resolve({freqDataQueue, timeDataQueue});
            }
          }, this.fftSize / this.sampleRateHz * 1e3);
        });
      }
      stop() {
        if (!this.isClosed) {
          this.isClosed = true;
          this.analyser.disconnect();
          this.audioContext.close();
          if (this.stream != null && this.stream.getTracks().length > 0) {
            this.stream.getTracks()[0].stop();
          }
        }
      }
      toArray() {
        throw new Error("Can not convert infinite audio stream to array.");
      }
      getSampleRate() {
        return this.sampleRateHz;
      }
      flattenQueue(queue) {
        const frameSize = queue[0].length;
        const freqData = new Float32Array(queue.length * frameSize);
        queue.forEach((data2, i) => freqData.set(data2, i * frameSize));
        return freqData;
      }
      getTensorFromAudioDataArray(freqData, shape) {
        const vals = new Float32Array(sizeFromShape2(shape));
        vals.set(freqData, vals.length - freqData.length);
        return tensor6(vals, shape);
      }
    }
    /**
     * @license
     * Copyright 2018 Google LLC. All Rights Reserved.
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     * http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     *
     * =============================================================================
     */
    class WebcamIterator extends LazyIterator {
      constructor(webcamVideoElement, webcamConfig) {
        super();
        this.webcamVideoElement = webcamVideoElement;
        this.webcamConfig = webcamConfig;
        this.isClosed = true;
        this.resize = false;
        if (this.needToResize()) {
          this.resize = true;
          this.cropSize = [this.webcamConfig.resizeHeight, this.webcamConfig.resizeWidth];
          this.cropBoxInd = tensor1d3([0], "int32");
          if (this.webcamConfig.centerCrop) {
            const widthCroppingRatio = this.webcamConfig.resizeWidth * 1 / this.webcamVideoElement.width;
            const heightCroppingRatio = this.webcamConfig.resizeHeight * 1 / this.webcamVideoElement.height;
            const widthCropStart = (1 - widthCroppingRatio) / 2;
            const heightCropStart = (1 - heightCroppingRatio) / 2;
            const widthCropEnd = widthCropStart + widthCroppingRatio;
            const heightCropEnd = heightCroppingRatio + heightCropStart;
            this.cropBox = tensor2d([heightCropStart, widthCropStart, heightCropEnd, widthCropEnd], [1, 4]);
          } else {
            this.cropBox = tensor2d([0, 0, 1, 1], [1, 4]);
          }
        }
      }
      summary() {
        return `webcam`;
      }
      static async create(webcamVideoElement, webcamConfig = {}) {
        if (env2().get("IS_NODE")) {
          throw new Error("tf.data.webcam is only supported in browser environment.");
        }
        if (!webcamVideoElement) {
          webcamVideoElement = document.createElement("video");
          if (!webcamConfig.resizeWidth || !webcamConfig.resizeHeight) {
            throw new Error("Please provide webcam video element, or resizeWidth and resizeHeight to create a hidden video element.");
          }
          webcamVideoElement.width = webcamConfig.resizeWidth;
          webcamVideoElement.height = webcamConfig.resizeHeight;
        }
        const webcamIterator = new WebcamIterator(webcamVideoElement, webcamConfig);
        await webcamIterator.start();
        return webcamIterator;
      }
      async start() {
        if (this.webcamConfig.facingMode) {
          assert2(this.webcamConfig.facingMode === "user" || this.webcamConfig.facingMode === "environment", () => `Invalid webcam facing mode: ${this.webcamConfig.facingMode}. Please provide 'user' or 'environment'`);
        }
        try {
          this.stream = await navigator.mediaDevices.getUserMedia({
            video: {
              deviceId: this.webcamConfig.deviceId,
              facingMode: this.webcamConfig.facingMode ? this.webcamConfig.facingMode : "user",
              width: this.webcamVideoElement.width,
              height: this.webcamVideoElement.height
            }
          });
        } catch (e) {
          e.message = `Error thrown while initializing video stream: ${e.message}`;
          throw e;
        }
        if (!this.stream) {
          throw new Error("Could not obtain video from webcam.");
        }
        try {
          this.webcamVideoElement.srcObject = this.stream;
        } catch (error) {
          console.log(error);
          this.webcamVideoElement.src = window.URL.createObjectURL(this.stream);
        }
        this.webcamVideoElement.play();
        this.isClosed = false;
        return new Promise((resolve) => {
          this.webcamVideoElement.onloadedmetadata = () => {
            resolve();
          };
        });
      }
      async next() {
        if (this.isClosed) {
          return {value: null, done: true};
        }
        let img;
        try {
          img = fromPixels(this.webcamVideoElement);
        } catch (e) {
          throw new Error(`Error thrown converting video to pixels: ${JSON.stringify(e)}`);
        }
        if (this.resize) {
          try {
            return {value: this.cropAndResizeFrame(img), done: false};
          } catch (e) {
            throw new Error(`Error thrown cropping the video: ${e.message}`);
          } finally {
            img.dispose();
          }
        } else {
          return {value: img, done: false};
        }
      }
      needToResize() {
        if (this.webcamConfig.resizeWidth && this.webcamConfig.resizeHeight && (this.webcamVideoElement.width !== this.webcamConfig.resizeWidth || this.webcamVideoElement.height !== this.webcamConfig.resizeHeight)) {
          return true;
        }
        return false;
      }
      cropAndResizeFrame(img) {
        return tidy(() => {
          const expandedImage = img.toFloat().expandDims(0);
          let resizedImage;
          resizedImage = image2.cropAndResize(expandedImage, this.cropBox, this.cropBoxInd, this.cropSize, "bilinear");
          const shape = resizedImage.shape;
          return resizedImage.reshape(shape.slice(1));
        });
      }
      async capture() {
        return (await this.next()).value;
      }
      stop() {
        const tracks = this.stream.getTracks();
        tracks.forEach((track) => track.stop());
        try {
          this.webcamVideoElement.srcObject = null;
        } catch (error) {
          console.log(error);
          this.webcamVideoElement.src = null;
        }
        this.isClosed = true;
      }
      toArray() {
        throw new Error("Can not convert infinite video stream to array.");
      }
    }
    /**
     * @license
     * Copyright 2018 Google LLC. All Rights Reserved.
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     * http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     *
     * =============================================================================
     */
    class DataSource {
    }
    /**
     * @license
     * Copyright 2018 Google LLC. All Rights Reserved.
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     * http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     *
     * =============================================================================
     */
    class StringIterator extends LazyIterator {
      split(separator) {
        return new SplitIterator(this, separator);
      }
    }
    class SplitIterator extends StringIterator {
      constructor(upstream, separator) {
        super();
        this.upstream = upstream;
        this.impl = new SplitIteratorImpl(upstream, separator);
      }
      summary() {
        return this.impl.summary();
      }
      async next() {
        return this.impl.next();
      }
    }
    class SplitIteratorImpl extends OneToManyIterator {
      constructor(upstream, separator) {
        super();
        this.upstream = upstream;
        this.separator = separator;
        this.carryover = "";
      }
      summary() {
        return `${this.upstream.summary()} -> Split('${this.separator}')`;
      }
      async pump() {
        const chunkResult = await this.upstream.next();
        if (chunkResult.done) {
          if (this.carryover === "") {
            return false;
          }
          this.outputQueue.push(this.carryover);
          this.carryover = "";
          return true;
        }
        const lines = chunkResult.value.split(this.separator);
        lines[0] = this.carryover + lines[0];
        for (const line of lines.slice(0, -1)) {
          this.outputQueue.push(line);
        }
        this.carryover = lines[lines.length - 1];
        return true;
      }
    }
    /**
     * @license
     * Copyright 2018 Google LLC. All Rights Reserved.
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     * http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     *
     * =============================================================================
     */
    class ByteChunkIterator extends LazyIterator {
      decodeUTF8() {
        return new Utf8Iterator(this);
      }
    }
    class Utf8Iterator extends StringIterator {
      constructor(upstream) {
        super();
        this.upstream = upstream;
        this.impl = new Utf8IteratorImpl(upstream);
      }
      summary() {
        return this.impl.summary();
      }
      async next() {
        return this.impl.next();
      }
    }
    class Utf8IteratorImpl extends OneToManyIterator {
      constructor(upstream) {
        super();
        this.upstream = upstream;
        if (env2().get("IS_BROWSER")) {
          this.decoder = new TextDecoder("utf-8");
        } else {
          const {StringDecoder} = require_string_decoder();
          this.decoder = new StringDecoder("utf8");
        }
      }
      summary() {
        return `${this.upstream.summary()} -> Utf8`;
      }
      async pump() {
        const chunkResult = await this.upstream.next();
        let chunk;
        if (chunkResult.done) {
          return false;
        } else {
          chunk = chunkResult.value;
        }
        let text;
        if (env2().get("IS_BROWSER")) {
          text = this.decoder.decode(chunk, {stream: true});
        } else {
          text = this.decoder.write(Buffer.from(chunk.buffer));
        }
        this.outputQueue.push(text);
        return true;
      }
    }
    /**
     * @license
     * Copyright 2018 Google LLC. All Rights Reserved.
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     * http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     *
     * =============================================================================
     */
    class FileChunkIterator extends ByteChunkIterator {
      constructor(file, options = {}) {
        super();
        this.file = file;
        this.options = options;
        assert2(file instanceof Uint8Array || (env2().get("IS_BROWSER") ? file instanceof File || file instanceof Blob : false), () => "FileChunkIterator only supports File, Blob and Uint8Array right now.");
        this.offset = options.offset || 0;
        this.chunkSize = options.chunkSize || 1024 * 1024;
      }
      summary() {
        return `FileChunks ${this.file}`;
      }
      async next() {
        if (this.offset >= (this.file instanceof Uint8Array ? this.file.byteLength : this.file.size)) {
          return {value: null, done: true};
        }
        const chunk = new Promise((resolve, reject) => {
          const end = this.offset + this.chunkSize;
          if (this.file instanceof Uint8Array) {
            resolve(new Uint8Array(this.file.slice(this.offset, end)));
          } else {
            const fileReader = new FileReader();
            fileReader.onload = (event) => {
              let data2 = fileReader.result;
              if (data2 instanceof ArrayBuffer) {
                data2 = new Uint8Array(data2);
              }
              if (!(data2 instanceof Uint8Array)) {
                return reject(new TypeError("FileReader returned unknown type."));
              }
              resolve(data2);
            };
            fileReader.onabort = (event) => {
              return reject(new Error("Aborted"));
            };
            fileReader.onerror = (event) => {
              return reject(new Error(event.type));
            };
            const slice3 = this.file.slice(this.offset, end);
            fileReader.readAsArrayBuffer(slice3);
          }
          this.offset = end;
        });
        return {value: await chunk, done: false};
      }
    }
    /**
     * @license
     * Copyright 2018 Google LLC. All Rights Reserved.
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     * http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     *
     * =============================================================================
     */
    async function urlChunkIterator(url, options = {}) {
      let urlString;
      let requestInit;
      if (typeof url === "string") {
        urlString = url;
      } else {
        urlString = url.url;
        requestInit = getRequestInitFromRequest(url);
      }
      const response = await fetch$1(urlString, requestInit);
      if (response.ok) {
        const uint8Array = new Uint8Array(await response.arrayBuffer());
        return new FileChunkIterator(uint8Array, options);
      } else {
        throw new Error(response.statusText);
      }
    }
    const getRequestInitFromRequest = (request) => {
      const init2 = {
        method: request.method,
        headers: request.headers,
        body: request.body,
        mode: request.mode,
        credentials: request.credentials,
        cache: request.cache,
        redirect: request.redirect,
        referrer: request.referrer,
        integrity: request.integrity
      };
      return init2;
    };
    /**
     * @license
     * Copyright 2018 Google LLC. All Rights Reserved.
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     * http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     *
     * =============================================================================
     */
    function isLocalPath(source) {
      return typeof source === "string" && source.substr(0, 7) === "file://";
    }
    /**
     * @license
     * Copyright 2018 Google LLC. All Rights Reserved.
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     * http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     *
     * =============================================================================
     */
    class FileDataSource extends DataSource {
      constructor(input2, options = {}) {
        super();
        this.input = input2;
        this.options = options;
      }
      async iterator() {
        if (isLocalPath(this.input) && env2().get("IS_NODE")) {
          const fs = require("fs");
          this.input = fs.readFileSync(this.input.substr(7));
        }
        return new FileChunkIterator(this.input, this.options);
      }
    }
    /**
     * @license
     * Copyright 2018 Google LLC. All Rights Reserved.
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     * http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     *
     * =============================================================================
     */
    class URLDataSource extends DataSource {
      constructor(url, fileOptions = {}) {
        super();
        this.url = url;
        this.fileOptions = fileOptions;
      }
      async iterator() {
        if (isLocalPath(this.url)) {
          return new FileDataSource(this.url, this.fileOptions).iterator();
        } else {
          return urlChunkIterator(this.url, this.fileOptions);
        }
      }
    }
    /**
     * @license
     * Copyright 2018 Google LLC. All Rights Reserved.
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     * http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     *
     * =============================================================================
     */
    function csv(source, csvConfig = {}) {
      return new CSVDataset(new URLDataSource(source), csvConfig);
    }
    function func(f) {
      const iter = iteratorFromFunction(f);
      return datasetFromIteratorFn(async () => iter);
    }
    function generator(generator2) {
      return datasetFromIteratorFn(async () => {
        const gen = await generator2();
        return iteratorFromFunction(() => gen.next());
      });
    }
    async function webcam(webcamVideoElement, webcamConfig) {
      return WebcamIterator.create(webcamVideoElement, webcamConfig);
    }
    async function microphone(microphoneConfig) {
      return MicrophoneIterator.create(microphoneConfig);
    }
    /** @license See the LICENSE file. */
    const version$3 = "2.7.0";
    /**
     * @license
     * Copyright 2018 Google LLC. All Rights Reserved.
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     * http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     * =============================================================================
     */
    var index = /* @__PURE__ */ Object.freeze({
      __proto__: null,
      array,
      Dataset,
      zip,
      CSVDataset,
      TextLineDataset,
      csv,
      func,
      generator,
      microphone,
      webcam,
      FileDataSource,
      URLDataSource,
      version_data: version$3
    });
    /**
     * @license
     * Copyright 2019 Google LLC. All Rights Reserved.
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     * http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     * =============================================================================
     */
    function assertNotComplex(tensor7, opName) {
      if (!Array.isArray(tensor7)) {
        tensor7 = [tensor7];
      }
      tensor7.forEach((t) => {
        if (t != null) {
          assert2(t.dtype !== "complex64", () => `${opName} does not support complex64 tensors in the CPU backend.`);
        }
      });
    }
    /**
     * @license
     * Copyright 2017 Google LLC. All Rights Reserved.
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     * http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     * =============================================================================
     */
    const nonMaxSuppressionV3Impl$1 = nonMaxSuppressionV3Impl;
    const split$4 = split$1;
    const tile$3 = tile$1;
    const topkImpl$1 = topkImpl;
    const whereImpl$1 = whereImpl;
    class MathBackendCPU extends KernelBackend2 {
      constructor() {
        super();
        this.blockSize = 48;
        this.firstUse = true;
        this.data = new DataStorage2(this, engine19());
      }
      write(values, shape, dtype) {
        if (this.firstUse) {
          this.firstUse = false;
          if (env2().get("IS_NODE")) {
            warn2("\n============================\nHi there \u{1F44B}. Looks like you are running TensorFlow.js in Node.js. To speed things up dramatically, install our node backend, which binds to TensorFlow C++, by running npm i @tensorflow/tfjs-node, or npm i @tensorflow/tfjs-node-gpu if you have CUDA. Then call require('@tensorflow/tfjs-node'); (-gpu suffix for CUDA) at the start of your program. Visit https://github.com/tensorflow/tfjs-node for more details.\n============================");
          }
        }
        const dataId = {};
        this.data.set(dataId, {values, dtype, refCount: 1});
        return dataId;
      }
      makeTensorInfo(shape, dtype, values) {
        let outId;
        if (dtype === "string" && values != null && values.length > 0 && isString2(values[0])) {
          const encodedValues = values.map((d) => encodeString2(d));
          outId = this.write(encodedValues, shape, dtype);
        } else {
          outId = this.write(values, shape, dtype);
        }
        return {dataId: outId, shape, dtype};
      }
      incRef(dataId) {
        const tensorData = this.data.get(dataId);
        tensorData.refCount++;
      }
      decRef(dataId) {
        if (this.data.has(dataId)) {
          const tensorData = this.data.get(dataId);
          tensorData.refCount--;
        }
      }
      move(dataId, values, shape, dtype) {
        this.data.set(dataId, {values, dtype, refCount: 1});
      }
      numDataIds() {
        return this.data.numDataIds();
      }
      async read(dataId) {
        return this.readSync(dataId);
      }
      readSync(dataId) {
        const {dtype, complexTensorInfos} = this.data.get(dataId);
        if (dtype === "complex64") {
          const realValues = this.readSync(complexTensorInfos.real.dataId);
          const imagValues = this.readSync(complexTensorInfos.imag.dataId);
          return mergeRealAndImagArrays2(realValues, imagValues);
        }
        return this.data.get(dataId).values;
      }
      bufferSync(t) {
        const data2 = this.readSync(t.dataId);
        let decodedData = data2;
        if (t.dtype === "string") {
          try {
            decodedData = data2.map((d) => decodeString2(d));
          } catch (_a) {
            throw new Error("Failed to decode encoded string bytes into utf-8");
          }
        }
        return buffer2(t.shape, t.dtype, decodedData);
      }
      makeOutput(values, shape, dtype) {
        const dataId = this.write(values, shape, dtype);
        return engine19().makeTensorFromDataId(dataId, shape, dtype, this);
      }
      disposeData(dataId) {
        if (this.data.has(dataId)) {
          const {complexTensorInfos} = this.data.get(dataId);
          if (complexTensorInfos != null) {
            this.disposeData(complexTensorInfos.real.dataId);
            this.disposeData(complexTensorInfos.imag.dataId);
          }
          this.data.delete(dataId);
        }
      }
      disposeIntermediateTensorInfo(tensorInfo) {
        const dataId = tensorInfo.dataId;
        if (this.data.has(dataId)) {
          const tensorData = this.data.get(dataId);
          tensorData.refCount--;
          if (tensorData.refCount < 1) {
            this.disposeData(dataId);
          }
        }
      }
      async time(f) {
        const start = now3();
        f();
        const kernelMs = now3() - start;
        return {kernelMs};
      }
      memory() {
        return {
          unreliable: true,
          reasons: ["The reported memory is an upper bound. Due to automatic garbage collection, the true allocated memory may be less."]
        };
      }
      stridedSlice(x, begin, end, strides) {
        assertNotComplex(x, "stridedSlice");
        const outShape = computeOutShape5(begin, end, strides);
        if (outShape.some((axis) => axis === 0)) {
          return tensor6([], outShape);
        }
        const buffer$1 = buffer2(outShape, x.dtype);
        const xBuf = this.bufferSync(x);
        for (let i = 0; i < buffer$1.size; i++) {
          const loc = buffer$1.indexToLoc(i);
          const newLoc = new Array(loc.length);
          for (let j = 0; j < newLoc.length; j++) {
            newLoc[j] = loc[j] * strides[j] + begin[j];
          }
          buffer$1.set(xBuf.get(...newLoc), ...loc);
        }
        return buffer$1.toTensor();
      }
      diag(x) {
        const xVals = this.readSync(x.dataId);
        const buffer$1 = buffer2([x.size, x.size], x.dtype);
        const vals = buffer$1.values;
        for (let i = 0; i < xVals.length; i++) {
          vals[i * x.size + i] = xVals[i];
        }
        return buffer$1.toTensor();
      }
      unstack(x, axis) {
        const num = x.shape[axis];
        const outShape = new Array(x.rank - 1);
        let outIndex = 0;
        for (let i = 0; i < x.rank; i++) {
          if (i !== axis) {
            outShape[outIndex++] = x.shape[i];
          }
        }
        const begin = new Array(x.rank).fill(0);
        const size = x.shape.slice();
        size[axis] = 1;
        const res = new Array(num);
        for (let i = 0; i < res.length; i++) {
          begin[axis] = i;
          res[i] = slice2(x, begin, size).reshape(outShape);
        }
        return res;
      }
      reverse(x, axis) {
        assertNotComplex(x, "reverse");
        const buffer$1 = buffer2(x.shape, x.dtype);
        const xBuf = this.bufferSync(x);
        for (let i = 0; i < buffer$1.size; i++) {
          const outLoc = buffer$1.indexToLoc(i);
          const inLoc = outLoc.slice();
          axis.forEach((ax) => inLoc[ax] = x.shape[ax] - 1 - inLoc[ax]);
          buffer$1.set(xBuf.get(...inLoc), ...outLoc);
        }
        return buffer$1.toTensor();
      }
      neg(x) {
        assertNotComplex(x, "neg");
        return mul3(scalar3(-1), x);
      }
      addN(tensors) {
        assertNotComplex(tensors, "addN");
        const vals = tensors.map((t) => this.readSync(t.dataId));
        const result = buffer2(tensors[0].shape, tensors[0].dtype);
        const resultVals = result.values;
        for (let i = 0; i < tensors.length; i++) {
          const currVals = vals[i];
          for (let j = 0; j < resultVals.length; j++) {
            resultVals[j] += currVals[j];
          }
        }
        return result.toTensor();
      }
      softmax(logits, dim) {
        const axes = parseAxisParam2([dim], logits.shape);
        const maxLogit = max2(logits, axes);
        const expandedShape = expandShapeToKeepDim2(maxLogit.shape, axes);
        const a = sub(logits, maxLogit.reshape(expandedShape));
        const b = exp(a);
        const sumExp = this.sum(b, axes).reshape(expandedShape);
        return div(b, sumExp);
      }
      pow(a, b) {
        assertNotComplex([a, b], "pow");
        return this.broadcastedBinaryOp(a, b, a.dtype, (aValue, bValue) => Math.pow(aValue, bValue));
      }
      floorDiv(a, b) {
        assertNotComplex([a, b], "floorDiv");
        const op3 = (a6, b2) => Math.floor(a6 / b2);
        const outputDtype = "int32";
        return this.broadcastedBinaryOp(a, b, outputDtype, op3);
      }
      sum(x, axes) {
        assertNotComplex(x, "sum");
        assertAxesAreInnerMostDims2("sum", axes, x.rank);
        const [outShape, reduceShape] = computeOutAndReduceShapes2(x.shape, axes);
        const resultDtype = upcastType2(x.dtype, "int32");
        const result = zeros3(outShape, resultDtype);
        const reduceSize = sizeFromShape2(reduceShape);
        const vals = this.readSync(result.dataId);
        const aVals = this.readSync(x.dataId);
        for (let i = 0; i < vals.length; ++i) {
          const offset = i * reduceSize;
          let sum6 = 0;
          for (let j = 0; j < reduceSize; ++j) {
            sum6 += aVals[offset + j];
          }
          vals[i] = sum6;
        }
        return result;
      }
      prod(x, axes) {
        assertNotComplex(x, "sum");
        const [outShape, reduceShape] = computeOutAndReduceShapes2(x.shape, axes);
        const resultDtype = upcastType2(x.dtype, "int32");
        const result = zeros3(outShape, resultDtype);
        const reduceSize = sizeFromShape2(reduceShape);
        const vals = this.readSync(result.dataId);
        const aVals = this.readSync(x.dataId);
        for (let i = 0; i < vals.length; ++i) {
          const offset = i * reduceSize;
          let prod2 = 1;
          for (let j = 0; j < reduceSize; ++j) {
            prod2 *= aVals[offset + j];
          }
          vals[i] = prod2;
        }
        return result;
      }
      unsortedSegmentSum(x, segmentIds, numSegments) {
        assertNotComplex(x, "unsortedSegmentSum");
        const res = [];
        const numIters = x.rank - segmentIds.rank;
        for (let i = 0; i < numIters; ++i) {
          segmentIds = segmentIds.expandDims(i + 1);
        }
        for (let i = 0; i < numSegments; ++i) {
          const segmentId = scalar3(i, "int32");
          const mask = equal(segmentId, segmentIds).asType("float32");
          const sum6 = mask.mul(x).sum(0);
          res.push(sum6);
        }
        return stack(res);
      }
      argMin(x, axis) {
        assertNotComplex(x, "argMin");
        const axes = [axis];
        assertAxesAreInnerMostDims2("argMin", axes, x.rank);
        const [outShape, reduceShape] = computeOutAndReduceShapes2(x.shape, axes);
        const result = zeros3(outShape, "int32");
        const reduceSize = sizeFromShape2(reduceShape);
        const vals = this.readSync(result.dataId);
        const aVals = this.readSync(x.dataId);
        for (let i = 0; i < vals.length; ++i) {
          const offset = i * reduceSize;
          let min3 = aVals[offset];
          let minIndex = 0;
          for (let j = 0; j < reduceSize; ++j) {
            const value = aVals[offset + j];
            if (value < min3) {
              min3 = value;
              minIndex = j;
            }
          }
          vals[i] = minIndex;
        }
        return result;
      }
      argMax(x, axis) {
        assertNotComplex(x, "argMax");
        const axes = [axis];
        assertAxesAreInnerMostDims2("argMax", axes, x.rank);
        const [outShape, reduceShape] = computeOutAndReduceShapes2(x.shape, axes);
        const result = zeros3(outShape, "int32");
        const reduceSize = sizeFromShape2(reduceShape);
        const vals = this.readSync(result.dataId);
        const aVals = this.readSync(x.dataId);
        for (let i = 0; i < vals.length; ++i) {
          const offset = i * reduceSize;
          let max3 = aVals[offset];
          let maxIndex = 0;
          for (let j = 0; j < reduceSize; ++j) {
            const value = aVals[offset + j];
            if (value > max3) {
              max3 = value;
              maxIndex = j;
            }
          }
          vals[i] = maxIndex;
        }
        return result;
      }
      cumsum(x, axis, exclusive, reverse3) {
        assertNotComplex(x, "cumsum");
        if (axis !== x.rank - 1) {
          throw new Error(`backend.cumsum in CPU expects an inner-most axis=${x.rank - 1} but got axis=${axis}`);
        }
        const resultDtype = upcastType2(x.dtype, "int32");
        const result = zeros3(x.shape, resultDtype);
        const vals = this.readSync(result.dataId);
        const aVals = this.readSync(x.dataId);
        const finalDim = x.shape[x.rank - 1];
        const indexAdjuster = reverse3 ? (i, j) => i + finalDim - j - 1 : (i, j) => i + j;
        for (let i = 0; i < aVals.length; i += finalDim) {
          for (let j = 0; j < finalDim; j++) {
            const idx = indexAdjuster(i, j);
            if (j === 0) {
              vals[idx] = exclusive ? 0 : aVals[idx];
            } else {
              const prevIdx = indexAdjuster(i, j - 1);
              vals[idx] = exclusive ? aVals[prevIdx] + vals[prevIdx] : aVals[idx] + vals[prevIdx];
            }
          }
        }
        return result;
      }
      equal(a, b) {
        assertNotComplex([a, b], "equal");
        return this.broadcastedBinaryOp(a, b, "bool", (aVal, bVal) => {
          return aVal === bVal ? 1 : 0;
        });
      }
      notEqual(a, b) {
        assertNotComplex([a, b], "notEqual");
        return this.broadcastedBinaryOp(a, b, "bool", (aVal, bVal) => {
          return aVal !== bVal ? 1 : 0;
        });
      }
      less(a, b) {
        assertNotComplex([a, b], "less");
        return this.broadcastedBinaryOp(a, b, "bool", (aVal, bVal) => {
          return aVal < bVal ? 1 : 0;
        });
      }
      lessEqual(a, b) {
        assertNotComplex([a, b], "lessEqual");
        return this.broadcastedBinaryOp(a, b, "bool", (aVal, bVal) => {
          return aVal <= bVal ? 1 : 0;
        });
      }
      greater(a, b) {
        assertNotComplex([a, b], "greater");
        return this.broadcastedBinaryOp(a, b, "bool", (aVal, bVal) => {
          return aVal > bVal ? 1 : 0;
        });
      }
      greaterEqual(a, b) {
        assertNotComplex([a, b], "greaterEqual");
        return this.broadcastedBinaryOp(a, b, "bool", (aVal, bVal) => {
          return aVal >= bVal ? 1 : 0;
        });
      }
      logicalAnd(a, b) {
        assertNotComplex([a, b], "logicalAnd");
        return this.broadcastedBinaryOp(a, b, "bool", (aVal, bVal) => {
          return aVal && bVal;
        });
      }
      logicalOr(a, b) {
        assertNotComplex([a, b], "logicalOr");
        return this.broadcastedBinaryOp(a, b, "bool", (aVal, bVal) => {
          return aVal || bVal;
        });
      }
      select(condition, a, b) {
        assertNotComplex([condition, a, b], "select");
        const values = this.readSync(condition.dataId);
        const aValues = this.readSync(a.dataId);
        const bValues = this.readSync(b.dataId);
        const result = zeros3(a.shape, upcastType2(a.dtype, b.dtype));
        const newValues = this.readSync(result.dataId);
        let index2 = 0;
        const offset = condition.rank === 0 || condition.rank > 1 || a.rank === 1 ? 1 : sizeFromShape2(a.shape.slice(1));
        for (let i = 0; i < values.length; i++) {
          for (let j = 0; j < offset; j++) {
            if (values[i] === 1) {
              newValues[index2++] = aValues[i];
            } else {
              newValues[index2++] = bValues[i];
            }
          }
        }
        return result;
      }
      where(condition) {
        assertNotComplex([condition], "where");
        const condVals = this.readSync(condition.dataId);
        return whereImpl$1(condition.shape, condVals);
      }
      topk(x, k, sorted) {
        assertNotComplex(x, "topk");
        const xVals = this.readSync(x.dataId);
        return topkImpl$1(xVals, x.shape, x.dtype, k, sorted);
      }
      min(x, axes) {
        assertNotComplex(x, "min");
        assertAxesAreInnerMostDims2("min", axes, x.rank);
        const [outShape, reduceShape] = computeOutAndReduceShapes2(x.shape, axes);
        const result = zeros3(outShape, x.dtype);
        const reduceSize = sizeFromShape2(reduceShape);
        const vals = this.readSync(result.dataId);
        const aVals = this.readSync(x.dataId);
        for (let i = 0; i < vals.length; ++i) {
          const offset = i * reduceSize;
          let min3 = aVals[offset];
          for (let j = 0; j < reduceSize; ++j) {
            const value = aVals[offset + j];
            if (value < min3) {
              min3 = value;
            }
          }
          vals[i] = min3;
        }
        return result;
      }
      minimum(a, b) {
        assertNotComplex([a, b], "minimum");
        return this.broadcastedBinaryOp(a, b, a.dtype, (aVal, bVal) => Math.min(aVal, bVal));
      }
      mod(a, b) {
        assertNotComplex([a, b], "mod");
        return this.broadcastedBinaryOp(a, b, a.dtype, (aVal, bVal) => {
          const rem = aVal % bVal;
          if (aVal < 0 && bVal < 0 || aVal >= 0 && bVal >= 0) {
            return rem;
          } else {
            return (rem + bVal) % bVal;
          }
        });
      }
      maximum(a, b) {
        assertNotComplex([a, b], "maximum");
        return this.broadcastedBinaryOp(a, b, a.dtype, (aVal, bVal) => Math.max(aVal, bVal));
      }
      all(x, axes) {
        assertNotComplex(x, "all");
        assertAxesAreInnerMostDims2("all", axes, x.rank);
        const [outShape, reduceShape] = computeOutAndReduceShapes2(x.shape, axes);
        const result = zeros3(outShape, x.dtype);
        const reduceSize = sizeFromShape2(reduceShape);
        const vals = this.readSync(result.dataId);
        const aVals = this.readSync(x.dataId);
        for (let i = 0; i < vals.length; ++i) {
          const offset = i * reduceSize;
          let all2 = aVals[offset];
          for (let j = 0; j < reduceSize; ++j) {
            const value = aVals[offset + j];
            all2 = all2 && value;
          }
          vals[i] = all2;
        }
        return result;
      }
      any(x, axes) {
        assertNotComplex(x, "any");
        assertAxesAreInnerMostDims2("any", axes, x.rank);
        const [outShape, reduceShape] = computeOutAndReduceShapes2(x.shape, axes);
        const result = zeros3(outShape, x.dtype);
        const reduceSize = sizeFromShape2(reduceShape);
        const vals = this.readSync(result.dataId);
        const aVals = this.readSync(x.dataId);
        for (let i = 0; i < vals.length; ++i) {
          const offset = i * reduceSize;
          let anyVal = aVals[offset];
          for (let j = 0; j < reduceSize; ++j) {
            const value = aVals[offset + j];
            anyVal = anyVal || value;
          }
          vals[i] = anyVal;
        }
        return result;
      }
      squaredDifference(a, b) {
        assertNotComplex([a, b], "squaredDifference");
        return this.broadcastedBinaryOp(a, b, a.dtype, (aVal, bVal) => {
          const diff = aVal - bVal;
          return diff * diff;
        });
      }
      eluDer(dy, y) {
        assertNotComplex([dy, y], "eluDer");
        const resultValues = new Float32Array(y.size);
        const values = this.readSync(y.dataId);
        const dyValues = this.readSync(dy.dataId);
        for (let i = 0; i < values.length; ++i) {
          const v = values[i];
          if (v >= 1) {
            resultValues[i] = dyValues[i];
          } else {
            resultValues[i] = dyValues[i] * (v + 1);
          }
        }
        return this.makeOutput(resultValues, y.shape, "float32");
      }
      atan2(a, b) {
        assertNotComplex([a, b], "atan2");
        return this.broadcastedBinaryOp(a, b, a.dtype, (aValue, bValue) => Math.atan2(aValue, bValue));
      }
      tile(x, reps) {
        assertNotComplex(x, "tile");
        return tile$3(this.bufferSync(x), reps);
      }
      gather(x, indices, axis) {
        assertNotComplex([x, indices], "gather");
        const newShape = x.shape.slice();
        const indicesValues = this.readSync(indices.dataId);
        newShape[axis] = indicesValues.length;
        const result = buffer2(newShape, x.dtype);
        const xBuf = this.bufferSync(x);
        for (let i = 0; i < result.size; ++i) {
          const newLoc = result.indexToLoc(i);
          const originalLoc = newLoc.slice();
          originalLoc[axis] = indicesValues[newLoc[axis]];
          const originalIndex = xBuf.locToIndex(originalLoc);
          result.values[i] = xBuf.values[originalIndex];
        }
        return result.toTensor();
      }
      batchToSpaceND(x, blockShape, crops) {
        assertNotComplex([x], "batchToSpaceND");
        const prod2 = blockShape.reduce((a, b) => a * b);
        const reshaped = getReshaped2(x.shape, blockShape, prod2);
        const permuted = getPermuted2(reshaped.length, blockShape.length);
        const reshapedPermuted = getReshapedPermuted2(x.shape, blockShape, prod2);
        const sliceBeginCoords = getSliceBeginCoords2(crops, blockShape.length);
        const sliceSize = getSliceSize2(reshapedPermuted, crops, blockShape.length);
        return transpose4(x.reshape(reshaped), permuted).reshape(reshapedPermuted).slice(sliceBeginCoords, sliceSize);
      }
      pool3d(x, convInfo, poolType) {
        assertNotComplex(x, "pool3d");
        const strideDepth = convInfo.strideDepth;
        const strideHeight = convInfo.strideHeight;
        const strideWidth = convInfo.strideWidth;
        const dilationDepth = convInfo.dilationDepth;
        const dilationHeight = convInfo.dilationHeight;
        const dilationWidth = convInfo.dilationWidth;
        const effectiveFilterDepth = convInfo.effectiveFilterDepth;
        const effectiveFilterHeight = convInfo.effectiveFilterHeight;
        const effectiveFilterWidth = convInfo.effectiveFilterWidth;
        const padFront = convInfo.padInfo.front;
        const padTop = convInfo.padInfo.top;
        const padLeft = convInfo.padInfo.left;
        const initialValue = poolType === "max" ? Number.NEGATIVE_INFINITY : Number.POSITIVE_INFINITY;
        const xValues = this.readSync(x.dataId);
        const output = buffer2(convInfo.outShape, x.dtype);
        const outputVals = output.values;
        const outputBatchStrides = convInfo.outShape[1] * convInfo.outShape[2] * convInfo.outShape[3] * convInfo.outShape[4];
        const outputDepthStrides = convInfo.outShape[2] * convInfo.outShape[3] * convInfo.outShape[4];
        const outputRowStrides = convInfo.outShape[3] * convInfo.outShape[4];
        const outputColStrides = convInfo.outShape[4];
        for (let batch = 0; batch < convInfo.batchSize; ++batch) {
          const outputBatchOffset = batch * outputBatchStrides;
          const inputBatchOffset = batch * x.strides[0];
          for (let channel = 0; channel < convInfo.inChannels; ++channel) {
            for (let yDepth = 0; yDepth < convInfo.outDepth; ++yDepth) {
              const xDepthCorner = yDepth * strideDepth - padFront;
              let xDepthMin = xDepthCorner;
              while (xDepthMin < 0) {
                xDepthMin += dilationDepth;
              }
              const xDepthMax = Math.min(convInfo.inDepth, effectiveFilterDepth + xDepthCorner);
              const outputDepthOffset = outputBatchOffset + yDepth * outputDepthStrides;
              for (let yRow = 0; yRow < convInfo.outHeight; ++yRow) {
                const xRowCorner = yRow * strideHeight - padTop;
                let xRowMin = xRowCorner;
                while (xRowMin < 0) {
                  xRowMin += dilationHeight;
                }
                const xRowMax = Math.min(convInfo.inHeight, effectiveFilterHeight + xRowCorner);
                const outputRowOffset = outputDepthOffset + yRow * outputRowStrides;
                for (let yCol = 0; yCol < convInfo.outWidth; ++yCol) {
                  const xColCorner = yCol * strideWidth - padLeft;
                  let xColMin = xColCorner;
                  while (xColMin < 0) {
                    xColMin += dilationWidth;
                  }
                  const xColMax = Math.min(convInfo.inWidth, effectiveFilterWidth + xColCorner);
                  const outputColOffset = outputRowOffset + yCol * outputColStrides;
                  let minMaxValue = initialValue;
                  let avgValue = 0;
                  let count2 = 0;
                  for (let xDepth = xDepthMin; xDepth < xDepthMax; xDepth += dilationDepth) {
                    const xDepthOffset = inputBatchOffset + xDepth * x.strides[1];
                    for (let xRow = xRowMin; xRow < xRowMax; xRow += dilationHeight) {
                      const xRowOffset = xDepthOffset + xRow * x.strides[2];
                      for (let xCol = xColMin; xCol < xColMax; xCol += dilationWidth) {
                        const xColOffset = xRowOffset + xCol * x.strides[3];
                        const pixel = xValues[xColOffset + channel];
                        if (poolType === "max" && pixel > minMaxValue) {
                          minMaxValue = pixel;
                        } else if (poolType === "avg") {
                          avgValue += pixel;
                          count2++;
                        }
                        if (isNaN(minMaxValue)) {
                          break;
                        }
                      }
                      if (isNaN(minMaxValue)) {
                        break;
                      }
                    }
                    if (isNaN(minMaxValue)) {
                      break;
                    }
                  }
                  const outputOffset = outputColOffset + channel;
                  outputVals[outputOffset] = poolType === "avg" ? avgValue / count2 : minMaxValue;
                }
              }
            }
          }
        }
        return output.toTensor();
      }
      avgPool3d(x, convInfo) {
        assertNotComplex(x, "avgPool3d");
        return this.pool3d(x, convInfo, "avg").toFloat();
      }
      avgPool3dBackprop(dy, x, convInfo) {
        assertNotComplex([dy, x], "avgPool3dBackprop");
        const strideDepth = convInfo.strideDepth;
        const strideHeight = convInfo.strideHeight;
        const strideWidth = convInfo.strideWidth;
        const filterDepth = convInfo.filterDepth;
        const filterHeight = convInfo.filterHeight;
        const filterWidth = convInfo.filterWidth;
        const dilationDepth = convInfo.dilationDepth;
        const dilationHeight = convInfo.dilationHeight;
        const dilationWidth = convInfo.dilationWidth;
        const effectiveFilterDepth = convInfo.effectiveFilterDepth;
        const effectiveFilterHeight = convInfo.effectiveFilterHeight;
        const effectiveFilterWidth = convInfo.effectiveFilterWidth;
        const padFront = effectiveFilterDepth - 1 - convInfo.padInfo.front;
        const padLeft = effectiveFilterWidth - 1 - convInfo.padInfo.left;
        const padTop = effectiveFilterHeight - 1 - convInfo.padInfo.top;
        const dx = buffer2(x.shape, "float32");
        const avgMultiplier = 1 / (filterDepth * filterHeight * filterWidth);
        const dyBuf = this.bufferSync(dy);
        for (let batch = 0; batch < convInfo.batchSize; ++batch) {
          for (let channel = 0; channel < convInfo.inChannels; ++channel) {
            for (let dxDepth = 0; dxDepth < convInfo.inDepth; ++dxDepth) {
              for (let dxRow = 0; dxRow < convInfo.inHeight; ++dxRow) {
                for (let dxCol = 0; dxCol < convInfo.inWidth; ++dxCol) {
                  const dyDepthCorner = dxDepth - padFront;
                  const dyRowCorner = dxRow - padTop;
                  const dyColCorner = dxCol - padLeft;
                  let dotProd = 0;
                  for (let wDepth = 0; wDepth < effectiveFilterDepth; wDepth += dilationDepth) {
                    const dyDepth = (dyDepthCorner + wDepth) / strideDepth;
                    if (dyDepth < 0 || dyDepth >= convInfo.outDepth || Math.floor(dyDepth) !== dyDepth) {
                      continue;
                    }
                    for (let wRow = 0; wRow < effectiveFilterHeight; wRow += dilationHeight) {
                      const dyRow = (dyRowCorner + wRow) / strideHeight;
                      if (dyRow < 0 || dyRow >= convInfo.outHeight || Math.floor(dyRow) !== dyRow) {
                        continue;
                      }
                      for (let wCol = 0; wCol < effectiveFilterWidth; wCol += dilationWidth) {
                        const dyCol = (dyColCorner + wCol) / strideWidth;
                        if (dyCol < 0 || dyCol >= convInfo.outWidth || Math.floor(dyCol) !== dyCol) {
                          continue;
                        }
                        const pixel = dyBuf.get(batch, dyDepth, dyRow, dyCol, channel);
                        dotProd += pixel;
                      }
                    }
                  }
                  dx.set(dotProd * avgMultiplier, batch, dxDepth, dxRow, dxCol, channel);
                }
              }
            }
          }
        }
        return dx.toTensor();
      }
      maxPool3d(x, convInfo) {
        assertNotComplex(x, "maxPool3d");
        return this.pool3d(x, convInfo, "max").toFloat();
      }
      maxPool3dPositions(x, convInfo) {
        const maxPositions = buffer2(convInfo.outShape, "int32");
        const strideDepth = convInfo.strideDepth;
        const strideHeight = convInfo.strideHeight;
        const strideWidth = convInfo.strideWidth;
        const dilationDepth = convInfo.dilationDepth;
        const dilationHeight = convInfo.dilationHeight;
        const dilationWidth = convInfo.dilationWidth;
        const effectiveFilterDepth = convInfo.effectiveFilterDepth;
        const effectiveFilterHeight = convInfo.effectiveFilterHeight;
        const effectiveFilterWidth = convInfo.effectiveFilterWidth;
        const padFront = convInfo.padInfo.front;
        const padTop = convInfo.padInfo.top;
        const padLeft = convInfo.padInfo.left;
        const xBuf = this.bufferSync(x);
        for (let batch = 0; batch < convInfo.batchSize; ++batch) {
          for (let channel = 0; channel < convInfo.inChannels; ++channel) {
            for (let yDepth = 0; yDepth < convInfo.outDepth; ++yDepth) {
              const xDepthCorner = yDepth * strideDepth - padFront;
              let xDepthMin = xDepthCorner;
              while (xDepthMin < 0) {
                xDepthMin += dilationDepth;
              }
              const xDepthMax = Math.min(convInfo.inDepth, effectiveFilterDepth + xDepthCorner);
              for (let yRow = 0; yRow < convInfo.outHeight; ++yRow) {
                const xRowCorner = yRow * strideHeight - padTop;
                let xRowMin = xRowCorner;
                while (xRowMin < 0) {
                  xRowMin += dilationHeight;
                }
                const xRowMax = Math.min(convInfo.inHeight, effectiveFilterHeight + xRowCorner);
                for (let yCol = 0; yCol < convInfo.outWidth; ++yCol) {
                  const xColCorner = yCol * strideWidth - padLeft;
                  let xColMin = xColCorner;
                  while (xColMin < 0) {
                    xColMin += dilationWidth;
                  }
                  const xColMax = Math.min(convInfo.inWidth, effectiveFilterWidth + xColCorner);
                  let maxValue = Number.NEGATIVE_INFINITY;
                  let maxPosition = -1;
                  for (let xDepth = xDepthMin; xDepth < xDepthMax; xDepth += dilationDepth) {
                    const wDepth = xDepth - xDepthCorner;
                    for (let xRow = xRowMin; xRow < xRowMax; xRow += dilationHeight) {
                      const wRow = xRow - xRowCorner;
                      for (let xCol = xColMin; xCol < xColMax; xCol += dilationWidth) {
                        const wCol = xCol - xColCorner;
                        const pixel = xBuf.get(batch, xDepth, xRow, xCol, channel);
                        if (pixel >= maxValue) {
                          maxValue = pixel;
                          maxPosition = wDepth * effectiveFilterHeight * effectiveFilterWidth + wRow * effectiveFilterHeight + wCol;
                        }
                      }
                    }
                  }
                  maxPositions.set(maxPosition, batch, yDepth, yRow, yCol, channel);
                }
              }
            }
          }
        }
        return maxPositions.toTensor();
      }
      maxPool3dBackprop(dy, x, y, convInfo) {
        assertNotComplex([x, y], "maxPool3dBackprop");
        const maxPositions = this.maxPool3dPositions(x, convInfo);
        const strideDepth = convInfo.strideDepth;
        const strideHeight = convInfo.strideHeight;
        const strideWidth = convInfo.strideWidth;
        const dilationDepth = convInfo.dilationDepth;
        const dilationHeight = convInfo.dilationHeight;
        const dilationWidth = convInfo.dilationWidth;
        const effectiveFilterDepth = convInfo.effectiveFilterDepth;
        const effectiveFilterHeight = convInfo.effectiveFilterHeight;
        const effectiveFilterWidth = convInfo.effectiveFilterWidth;
        const padFront = effectiveFilterDepth - 1 - convInfo.padInfo.front;
        const padLeft = effectiveFilterWidth - 1 - convInfo.padInfo.left;
        const padTop = effectiveFilterHeight - 1 - convInfo.padInfo.top;
        const dx = buffer2(x.shape, "float32");
        const maxPosBuf = this.bufferSync(maxPositions);
        const dyBuf = this.bufferSync(dy);
        for (let batch = 0; batch < convInfo.batchSize; ++batch) {
          for (let channel = 0; channel < convInfo.inChannels; ++channel) {
            for (let dxDepth = 0; dxDepth < convInfo.inDepth; ++dxDepth) {
              for (let dxRow = 0; dxRow < convInfo.inHeight; ++dxRow) {
                for (let dxCol = 0; dxCol < convInfo.inWidth; ++dxCol) {
                  const dyDepthCorner = dxDepth - padFront;
                  const dyRowCorner = dxRow - padTop;
                  const dyColCorner = dxCol - padLeft;
                  let dotProd = 0;
                  for (let wDepth = 0; wDepth < effectiveFilterDepth; wDepth += dilationDepth) {
                    const dyDepth = (dyDepthCorner + wDepth) / strideDepth;
                    if (dyDepth < 0 || dyDepth >= convInfo.outDepth || Math.floor(dyDepth) !== dyDepth) {
                      continue;
                    }
                    for (let wRow = 0; wRow < effectiveFilterHeight; wRow += dilationHeight) {
                      const dyRow = (dyRowCorner + wRow) / strideHeight;
                      if (dyRow < 0 || dyRow >= convInfo.outHeight || Math.floor(dyRow) !== dyRow) {
                        continue;
                      }
                      for (let wCol = 0; wCol < effectiveFilterWidth; wCol += dilationWidth) {
                        const dyCol = (dyColCorner + wCol) / strideWidth;
                        if (dyCol < 0 || dyCol >= convInfo.outWidth || Math.floor(dyCol) !== dyCol) {
                          continue;
                        }
                        const maxPos = effectiveFilterDepth * effectiveFilterHeight * effectiveFilterWidth - 1 - maxPosBuf.get(batch, dyDepth, dyRow, dyCol, channel);
                        const curPos = wDepth * effectiveFilterHeight * effectiveFilterWidth + wRow * effectiveFilterWidth + wCol;
                        const mask = maxPos === curPos ? 1 : 0;
                        if (mask === 0) {
                          continue;
                        }
                        const pixel = dyBuf.get(batch, dyDepth, dyRow, dyCol, channel);
                        dotProd += pixel * mask;
                      }
                    }
                  }
                  dx.set(dotProd, batch, dxDepth, dxRow, dxCol, channel);
                }
              }
            }
          }
        }
        return dx.toTensor();
      }
      resizeBilinear(x, newHeight, newWidth, alignCorners) {
        assertNotComplex(x, "resizeBilinear");
        const [batch, oldHeight, oldWidth, numChannels] = x.shape;
        const xValues = this.readSync(x.dataId);
        const result = new Float32Array(sizeFromShape2([batch, newHeight, newWidth, numChannels]));
        const effectiveInputSize = [
          alignCorners && newHeight > 1 ? oldHeight - 1 : oldHeight,
          alignCorners && newWidth > 1 ? oldWidth - 1 : oldWidth
        ];
        const effectiveOutputSize = [
          alignCorners && newHeight > 1 ? newHeight - 1 : newHeight,
          alignCorners && newWidth > 1 ? newWidth - 1 : newWidth
        ];
        let outputIdx = 0;
        const effectiveRowSizeRatio = effectiveInputSize[0] / effectiveOutputSize[0];
        const effectiveColSizeRatio = effectiveInputSize[1] / effectiveOutputSize[1];
        for (let b = 0; b < batch; b++) {
          for (let r = 0; r < newHeight; r++) {
            const sourceFracRow = effectiveRowSizeRatio * r;
            const sourceRowFloor = Math.floor(sourceFracRow);
            const rowFrac = sourceFracRow - sourceRowFloor;
            const sourceRowCeil = Math.min(oldHeight - 1, Math.ceil(sourceFracRow));
            const topRowOffset = b * x.strides[0] + sourceRowFloor * x.strides[1];
            const botRowOffset = b * x.strides[0] + sourceRowCeil * x.strides[1];
            for (let c = 0; c < newWidth; c++) {
              const sourceFracCol = effectiveColSizeRatio * c;
              const sourceColFloor = Math.floor(sourceFracCol);
              const colFrac = sourceFracCol - sourceColFloor;
              const sourceColCeil = Math.min(oldWidth - 1, Math.ceil(sourceFracCol));
              const topLeftOffest = topRowOffset + sourceColFloor * x.strides[2];
              const botLeftOffset = botRowOffset + sourceColFloor * x.strides[2];
              const topRightOffset = topRowOffset + sourceColCeil * x.strides[2];
              const botRightOffest = botRowOffset + sourceColCeil * x.strides[2];
              for (let d = 0; d < numChannels; d++) {
                const topLeft = xValues[topLeftOffest + d];
                const bottomLeft = xValues[botLeftOffset + d];
                const topRight = xValues[topRightOffset + d];
                const bottomRight = xValues[botRightOffest + d];
                const top = topLeft + (topRight - topLeft) * colFrac;
                const bottom = bottomLeft + (bottomRight - bottomLeft) * colFrac;
                const newValue = top + (bottom - top) * rowFrac;
                result[outputIdx++] = newValue;
              }
            }
          }
        }
        return tensor6(result, [batch, newHeight, newWidth, numChannels]);
      }
      resizeBilinearBackprop(dy, x, alignCorners) {
        assertNotComplex([dy, x], "resizeBilinearBackprop");
        const [batch, xHeight, xWidth, depth] = x.shape;
        const [, yHeight, yWidth] = dy.shape;
        const output = new Float32Array(batch * xHeight * xWidth * depth);
        const effectiveXSize = [
          alignCorners && yHeight > 1 ? xHeight - 1 : xHeight,
          alignCorners && yWidth > 1 ? xWidth - 1 : xWidth
        ];
        const effectiveYSize = [
          alignCorners && yHeight > 1 ? yHeight - 1 : yHeight,
          alignCorners && yWidth > 1 ? yWidth - 1 : yWidth
        ];
        const heightScale = effectiveXSize[0] / effectiveYSize[0];
        const widthScale = effectiveXSize[1] / effectiveYSize[1];
        const dyValues = this.readSync(dy.dataId);
        let offset = 0;
        for (let b = 0; b < batch; b++) {
          const bOffset = b * x.strides[0];
          for (let r = 0; r < yHeight; r++) {
            const dxR = r * heightScale;
            const topDxRIndex = Math.floor(dxR);
            const bottomDxRIndex = Math.min(Math.ceil(dxR), xHeight - 1);
            const topDxROffset = bOffset + topDxRIndex * x.strides[1];
            const bottomDxROffset = bOffset + bottomDxRIndex * x.strides[1];
            const dxRLerp = dxR - topDxRIndex;
            const inverseDxRLerp = 1 - dxRLerp;
            for (let c = 0; c < yWidth; c++) {
              const dxC = c * widthScale;
              const leftDxCIndex = Math.floor(dxC);
              const rightDxCIndex = Math.min(Math.ceil(dxC), xWidth - 1);
              const dxCLerp = dxC - leftDxCIndex;
              const inverseDxCLerp = 1 - dxCLerp;
              const topLeftRCOffset = topDxROffset + leftDxCIndex * x.strides[2];
              const topRightRCOffset = topDxROffset + rightDxCIndex * x.strides[2];
              const bottomLeftRCOffset = bottomDxROffset + leftDxCIndex * x.strides[2];
              const bottomRightRCOffset = bottomDxROffset + rightDxCIndex * x.strides[2];
              const inverseDxRLerpTimesInverseDxCLerp = inverseDxRLerp * inverseDxCLerp;
              const inverseDxRLerpTimesDxCLerp = inverseDxRLerp * dxCLerp;
              const dxRLerpTimesInverseDxCLerp = dxRLerp * inverseDxCLerp;
              const dxRLerpTimesDxCLerp = dxRLerp * dxCLerp;
              for (let d = 0; d < depth; d++) {
                const dyVal = dyValues[offset++];
                output[topLeftRCOffset + d] += dyVal * inverseDxRLerpTimesInverseDxCLerp;
                output[topRightRCOffset + d] += dyVal * inverseDxRLerpTimesDxCLerp;
                output[bottomLeftRCOffset + d] += dyVal * dxRLerpTimesInverseDxCLerp;
                output[bottomRightRCOffset + d] += dyVal * dxRLerpTimesDxCLerp;
              }
            }
          }
        }
        return tensor4d(output, [batch, xWidth, xHeight, depth], x.dtype);
      }
      resizeNearestNeighbor(x, newHeight, newWidth, alignCorners) {
        assertNotComplex(x, "resizeNearestNeighbor");
        const [batch, oldHeight, oldWidth, numChannels] = x.shape;
        const xValues = this.readSync(x.dataId);
        const output = new Float32Array(batch * newHeight * newWidth * numChannels);
        const effectiveInputSize = [
          alignCorners && newHeight > 1 ? oldHeight - 1 : oldHeight,
          alignCorners && newWidth > 1 ? oldWidth - 1 : oldWidth
        ];
        const effectiveOutputSize = [
          alignCorners && newHeight > 1 ? newHeight - 1 : newHeight,
          alignCorners && newWidth > 1 ? newWidth - 1 : newWidth
        ];
        const effectiveRowSizeRatio = effectiveInputSize[0] / effectiveOutputSize[0];
        const effectiveColSizeRatio = effectiveInputSize[1] / effectiveOutputSize[1];
        let outputOffset = 0;
        for (let b = 0; b < batch; b++) {
          const batchOffset = b * x.strides[0];
          for (let r = 0; r < newHeight; r++) {
            const sourceFracRow = effectiveRowSizeRatio * r;
            const sourceNearestRow = Math.min(oldHeight - 1, alignCorners ? Math.round(sourceFracRow) : Math.floor(sourceFracRow));
            const rowOffset = batchOffset + sourceNearestRow * x.strides[1];
            for (let c = 0; c < newWidth; c++) {
              const sourceFracCol = effectiveColSizeRatio * c;
              const sourceNearestCol = Math.min(oldWidth - 1, alignCorners ? Math.round(sourceFracCol) : Math.floor(sourceFracCol));
              const colOffset = rowOffset + sourceNearestCol * x.strides[2];
              for (let d = 0; d < numChannels; d++) {
                const newVal = xValues[colOffset + d];
                output[outputOffset++] = newVal;
              }
            }
          }
        }
        return tensor6(output, [batch, newHeight, newWidth, numChannels], x.dtype);
      }
      resizeNearestNeighborBackprop(dy, x, alignCorners) {
        assertNotComplex([dy, x], "resizeNearestNeighborBackprop");
        const [batch, xHeight, xWidth, depth] = x.shape;
        const [, yHeight, yWidth] = dy.shape;
        const output = new Float32Array(batch * xHeight * xWidth * depth);
        const dyValues = this.readSync(dy.dataId);
        const effectiveXSize = [
          alignCorners && yHeight > 1 ? xHeight - 1 : xHeight,
          alignCorners && yWidth > 1 ? xWidth - 1 : xWidth
        ];
        const effectiveYSize = [
          alignCorners && yHeight > 1 ? yHeight - 1 : yHeight,
          alignCorners && yWidth > 1 ? yWidth - 1 : yWidth
        ];
        const heightScale = effectiveXSize[0] / effectiveYSize[0];
        const widthScale = effectiveXSize[1] / effectiveYSize[1];
        const invHeightScale = 1 / heightScale;
        const invWidthScale = 1 / widthScale;
        const winHeight = Math.ceil(invHeightScale) * 2 + 2;
        const winWidth = Math.ceil(invWidthScale) * 2 + 2;
        for (let b = 0; b < batch; b++) {
          const batchOffset = b * x.strides[0];
          for (let r = 0; r < xHeight; r++) {
            const rowOffset = batchOffset + r * x.strides[1];
            const startRLerp = Math.floor(r * invHeightScale);
            const startDyR = Math.floor(startRLerp - winHeight / 2);
            for (let c = 0; c < xWidth; c++) {
              const colOffset = rowOffset + c * x.strides[2];
              const startCLerp = Math.floor(c * invWidthScale);
              const startDyC = Math.floor(startCLerp - winWidth / 2);
              for (let d = 0; d < depth; d++) {
                let accum = 0;
                for (let dyRIndex = 0; dyRIndex < winHeight; dyRIndex++) {
                  const dyR = dyRIndex + startDyR;
                  if (dyR < 0 || dyR >= yHeight) {
                    continue;
                  }
                  const dyROffset = batchOffset + dyR * dy.strides[1];
                  const sourceFracRow = dyR * heightScale;
                  const sourceNearestRow = Math.min(xHeight - 1, alignCorners ? Math.round(sourceFracRow) : Math.floor(sourceFracRow));
                  if (r !== sourceNearestRow) {
                    continue;
                  }
                  for (let dyCIndex = 0; dyCIndex < winWidth; dyCIndex++) {
                    const dyC = dyCIndex + startDyC;
                    if (dyC < 0 || dyC >= yWidth) {
                      continue;
                    }
                    const dyCOffset = dyROffset + dyC * dy.strides[2];
                    const sourceFracCol = dyC * widthScale;
                    const sourceNearestCol = Math.min(xWidth - 1, alignCorners ? Math.round(sourceFracCol) : Math.floor(sourceFracCol));
                    if (c === sourceNearestCol) {
                      accum += dyValues[dyCOffset + d];
                    }
                  }
                }
                output[colOffset + d] = accum;
              }
            }
          }
        }
        return tensor4d(output, x.shape, x.dtype);
      }
      localResponseNormalization4D(x, depthRadius, bias, alpha, beta) {
        assertNotComplex(x, "localResponseNormalization4D");
        const channels = x.shape[3];
        const maxD = channels - 1;
        const xValues = this.readSync(x.dataId);
        const size = x.size;
        const result = new Float32Array(size);
        function sumAcrossChannels(offset) {
          const currentChannel = offset % channels;
          let beginSumOffset = offset - currentChannel + Math.max(0, currentChannel - depthRadius);
          const endSumOffset = offset - currentChannel + Math.min(currentChannel + depthRadius, maxD);
          let sum6 = 0;
          for (; beginSumOffset <= endSumOffset; beginSumOffset++) {
            const z = xValues[beginSumOffset];
            sum6 += z * z;
          }
          return sum6;
        }
        for (let offset = 0; offset < size; offset++) {
          const sum6 = sumAcrossChannels(offset);
          const val = xValues[offset] * Math.pow(bias + alpha * sum6, -beta);
          result[offset] = val;
        }
        return tensor4d(result, x.shape);
      }
      LRNGrad(dy, inputImage, outputImage, depthRadius, bias, alpha, beta) {
        assertNotComplex(dy, "LRNGrad");
        const channels = dy.shape[3];
        const dyValues = this.readSync(dy.dataId);
        const inputImageValues = this.readSync(inputImage.dataId);
        const outputImageValues = this.readSync(outputImage.dataId);
        const result = new Float32Array(dy.size);
        const size = dy.size;
        for (let offset = 0; offset < size; offset++) {
          const currentChannel = offset % channels;
          const depthBegin = offset - currentChannel + Math.max(0, currentChannel - depthRadius);
          const depthEnd = offset - currentChannel + Math.min(channels, currentChannel + depthRadius + 1);
          let norm2 = 0;
          for (let k = depthBegin; k < depthEnd; k++) {
            norm2 += Math.pow(inputImageValues[k], 2);
          }
          norm2 = alpha * norm2 + bias;
          for (let k = depthBegin; k < depthEnd; k++) {
            let dyi = -2 * alpha * beta * inputImageValues[k] * outputImageValues[offset] / norm2;
            if (offset === k) {
              dyi += Math.pow(norm2, -beta);
            }
            dyi *= dyValues[offset];
            result[k] += dyi;
          }
        }
        return tensor4d(result, dy.shape);
      }
      multinomial(logits, normalized, numSamples, seed) {
        assertNotComplex(logits, "multinomial");
        const probabilities = normalized ? logits : softmax2(logits);
        const batchSize = probabilities.shape[0];
        const numEvents = probabilities.shape[1];
        const res = zeros3([batchSize, numSamples], "int32");
        const resVals = this.readSync(res.dataId);
        const probVals = this.readSync(probabilities.dataId);
        for (let b = 0; b < batchSize; ++b) {
          const offset = b * numEvents;
          const cdf = new Float32Array(numEvents - 1);
          cdf[0] = probVals[offset];
          for (let event = 1; event < cdf.length; ++event) {
            cdf[event] = cdf[event - 1] + probVals[offset + event];
          }
          const random = seedrandom_1(seed.toString());
          const outOffset = b * numSamples;
          for (let sampleId = 0; sampleId < numSamples; ++sampleId) {
            const r = random();
            resVals[outOffset + sampleId] = cdf.length;
            for (let event = 0; event < cdf.length; event++) {
              if (r < cdf[event]) {
                resVals[outOffset + sampleId] = event;
                break;
              }
            }
          }
        }
        return res;
      }
      oneHot(indices, depth, onValue, offValue) {
        assertNotComplex(indices, "oneHot");
        const res = new Float32Array(indices.size * depth);
        res.fill(offValue);
        const indicesVal = this.readSync(indices.dataId);
        for (let event = 0; event < indices.size; ++event) {
          if (indicesVal[event] >= 0 && indicesVal[event] < depth) {
            res[event * depth + indicesVal[event]] = onValue;
          }
        }
        return tensor2d(res, [indices.size, depth], "int32");
      }
      nonMaxSuppression(boxes, scores, maxOutputSize, iouThreshold, scoreThreshold) {
        assertNotComplex(boxes, "nonMaxSuppression");
        const boxesVals = this.readSync(boxes.dataId);
        const scoresVals = this.readSync(scores.dataId);
        return nonMaxSuppressionV3Impl$1(boxesVals, scoresVals, maxOutputSize, iouThreshold, scoreThreshold);
      }
      depthToSpace(x, blockSize, dataFormat) {
        assert2(dataFormat === "NHWC", () => `Only NHWC dataFormat supported on CPU for depthToSpace. Got ${dataFormat}`);
        assert2(blockSize > 1, () => `blockSize should be > 1 for depthToSpace, but was: ${blockSize}`);
        const batchSize = x.shape[0];
        const inputHeight = x.shape[1];
        const inputWidth = x.shape[2];
        const inputDepth = x.shape[3];
        const outputHeight = inputHeight * blockSize;
        const outputWidth = inputWidth * blockSize;
        const outputDepth = inputDepth / (blockSize * blockSize);
        const xValues = this.readSync(x.dataId);
        const result = new Float32Array(batchSize * outputHeight * outputWidth * outputDepth);
        let outputIdx = 0;
        for (let b = 0; b < batchSize; ++b) {
          for (let h = 0; h < outputHeight; ++h) {
            const inH = Math.floor(h / blockSize);
            const offsetH = h % blockSize;
            for (let w = 0; w < outputWidth; ++w) {
              const inW = Math.floor(w / blockSize);
              const offsetW = w % blockSize;
              const offsetD = (offsetH * blockSize + offsetW) * outputDepth;
              for (let d = 0; d < outputDepth; ++d) {
                const inD = d + offsetD;
                const inputIdx = inD + inputDepth * (inW + inputWidth * (inH + inputHeight * b));
                result[outputIdx++] = xValues[inputIdx];
              }
            }
          }
        }
        return tensor4d(result, [batchSize, outputHeight, outputWidth, outputDepth]);
      }
      broadcastedBinaryOp(a, b, dtype, op3) {
        const newShape = assertAndGetBroadcastShape2(a.shape, b.shape);
        const result = buffer2(newShape, dtype);
        const aVals = this.readSync(a.dataId);
        const bVals = this.readSync(b.dataId);
        const aBroadcastDims = getBroadcastDims2(a.shape, newShape);
        const bBroadcastDims = getBroadcastDims2(b.shape, newShape);
        const resVals = result.values;
        if (aBroadcastDims.length + bBroadcastDims.length === 0) {
          for (let i = 0; i < resVals.length; ++i) {
            resVals[i] = op3(aVals[i % aVals.length], bVals[i % bVals.length]);
          }
        } else {
          const aBuf = this.bufferSync(a);
          const bBuf = this.bufferSync(b);
          for (let i = 0; i < resVals.length; ++i) {
            const loc = result.indexToLoc(i);
            const aLoc = loc.slice(-a.rank);
            aBroadcastDims.forEach((d) => aLoc[d] = 0);
            const aIndex = aBuf.locToIndex(aLoc);
            const bLoc = loc.slice(-b.rank);
            bBroadcastDims.forEach((d) => bLoc[d] = 0);
            const bIndex = bBuf.locToIndex(bLoc);
            resVals[i] = op3(aVals[aIndex], bVals[bIndex]);
          }
        }
        return result.toTensor();
      }
      split(x, sizeSplits, axis) {
        return split$4(x, sizeSplits, axis);
      }
      dispose() {
      }
      floatPrecision() {
        return 32;
      }
      epsilon() {
        return super.epsilon();
      }
      cropAndResize(images, boxes, boxIndex, cropSize, method, extrapolationValue) {
        const [batch, imageHeight, imageWidth, numChannels] = images.shape;
        const numBoxes = boxes.shape[0];
        const [cropHeight, cropWidth] = cropSize;
        const output = buffer2([numBoxes, cropHeight, cropWidth, numChannels], "float32");
        const boxVals = this.readSync(boxes.dataId);
        const boxIndVals = this.readSync(boxIndex.dataId);
        const imageVals = this.readSync(images.dataId);
        const inStride = images.strides;
        const outStride = output.strides;
        for (let b = 0; b < numBoxes; b++) {
          const startInd = b * 4;
          const y1 = boxVals[startInd];
          const x1 = boxVals[startInd + 1];
          const y2 = boxVals[startInd + 2];
          const x2 = boxVals[startInd + 3];
          const bInd = boxIndVals[b];
          if (bInd >= batch) {
            continue;
          }
          const heightScale = cropHeight > 1 ? (y2 - y1) * (imageHeight - 1) / (cropHeight - 1) : 0;
          const widthScale = cropWidth > 1 ? (x2 - x1) * (imageWidth - 1) / (cropWidth - 1) : 0;
          for (let y = 0; y < cropHeight; y++) {
            const yInd = cropHeight > 1 ? y1 * (imageHeight - 1) + y * heightScale : 0.5 * (y1 + y2) * (imageHeight - 1);
            if (yInd < 0 || yInd > imageHeight - 1) {
              for (let x = 0; x < cropWidth; x++) {
                for (let c = 0; c < numChannels; c++) {
                  const ind = c + x * outStride[2] + y * outStride[1] + b * outStride[0];
                  output.values[ind] = extrapolationValue;
                }
              }
              continue;
            }
            if (method === "bilinear") {
              const topInd = Math.floor(yInd);
              const bottomInd = Math.ceil(yInd);
              const yLerp = yInd - topInd;
              for (let x = 0; x < cropWidth; x++) {
                const xInd = cropWidth > 1 ? x1 * (imageWidth - 1) + x * widthScale : 0.5 * (x1 + x2) * (imageWidth - 1);
                if (xInd < 0 || xInd > imageWidth - 1) {
                  for (let c = 0; c < numChannels; c++) {
                    const ind = c + x * outStride[2] + y * outStride[1] + b * outStride[0];
                    output.values[ind] = extrapolationValue;
                  }
                  continue;
                }
                const leftInd = Math.floor(xInd);
                const rightInd = Math.ceil(xInd);
                const xLerp = xInd - leftInd;
                for (let c = 0; c < numChannels; c++) {
                  let ind = c + leftInd * inStride[2] + topInd * inStride[1] + bInd * inStride[0];
                  const topLeft = imageVals[ind];
                  ind = c + rightInd * inStride[2] + topInd * inStride[1] + bInd * inStride[0];
                  const topRight = imageVals[ind];
                  ind = c + leftInd * inStride[2] + bottomInd * inStride[1] + bInd * inStride[0];
                  const bottomLeft = imageVals[ind];
                  ind = c + rightInd * inStride[2] + bottomInd * inStride[1] + bInd * inStride[0];
                  const bottomRight = imageVals[ind];
                  const top = topLeft + (topRight - topLeft) * xLerp;
                  const bottom = bottomLeft + (bottomRight - bottomLeft) * xLerp;
                  ind = c + x * outStride[2] + y * outStride[1] + b * outStride[0];
                  output.values[ind] = top + (bottom - top) * yLerp;
                }
              }
            } else {
              for (let x = 0; x < cropWidth; ++x) {
                const xInd = cropWidth > 1 ? x1 * (imageWidth - 1) + x * widthScale : 0.5 * (x1 + x2) * (imageWidth - 1);
                if (xInd < 0 || xInd > imageWidth - 1) {
                  for (let c = 0; c < numChannels; c++) {
                    const ind = c + x * outStride[2] + y * outStride[1] + b * outStride[0];
                    output.values[ind] = extrapolationValue;
                  }
                  continue;
                }
                const closestX = Math.round(xInd);
                const closestY = Math.round(yInd);
                for (let c = 0; c < numChannels; c++) {
                  const inInd = c + closestX * inStride[2] + closestY * inStride[1] + bInd * inStride[0];
                  const outInd = c + x * outStride[2] + y * outStride[1] + b * outStride[0];
                  output.values[outInd] = imageVals[inInd];
                }
              }
            }
          }
        }
        return output.toTensor();
      }
      sparseToDense(sparseIndices, sparseValues, outputShape, defaultValue) {
        const {sliceRank, numUpdates, sliceSize, strides, outputSize} = calculateShapes2(sparseValues, sparseIndices, outputShape);
        const sumDupeIndices = false;
        return this.scatter(sparseIndices, sparseValues, outputShape, outputSize, sliceSize, numUpdates, sliceRank, strides, defaultValue, sumDupeIndices);
      }
      gatherND(x, indices) {
        const indicesShape = indices.shape;
        const sliceRank = indicesShape[indicesShape.length - 1];
        const [resultShape, numSlices, sliceSize, strides] = prepareAndValidate2(x, indices);
        if (numSlices === 0) {
          return tensor6([], resultShape, x.dtype);
        }
        const buffer3 = new TensorBuffer2([numSlices, sliceSize], x.dtype);
        const indicesData = this.readSync(indices.dataId);
        const xData = this.readSync(x.dataId);
        for (let i = 0; i < numSlices; i++) {
          const index2 = [];
          let flattenIndex = 0;
          for (let j = 0; j < sliceRank; j++) {
            const dim = indicesData[i * sliceRank + j];
            flattenIndex += dim * strides[j];
            index2.push(dim);
          }
          if (flattenIndex < 0 || flattenIndex >= x.size / sliceSize) {
            throw new Error(`Invalid indices: ${index2} does not index into ${x.shape}`);
          }
          for (let k = 0; k < sliceSize; k++) {
            buffer3.values[i * sliceSize + k] = xData[flattenIndex * sliceSize + k];
          }
        }
        return buffer3.toTensor().reshape(resultShape);
      }
      scatterND(indices, updates, shape) {
        const {sliceRank, numUpdates, sliceSize, strides, outputSize} = calculateShapes2(updates, indices, shape);
        const defaultValue = scalar3(0);
        const sumDupeIndices = true;
        return this.scatter(indices, updates, shape, outputSize, sliceSize, numUpdates, sliceRank, strides, defaultValue, sumDupeIndices);
      }
      onesLike(x) {
        if (x.dtype === "string") {
          throw new Error("onesLike is not supported for string tensors");
        } else {
          return fill2(x.shape, 1, x.dtype);
        }
      }
      zerosLike(x) {
        const values = getArrayFromDType2(x.dtype, sizeFromShape2(x.shape));
        return this.makeOutput(values, x.shape, x.dtype);
      }
      linspace(start, stop, num) {
        return linspaceImpl2(start, stop, num);
      }
      scatter(indices, updates, shape, outputSize, sliceSize, numUpdates, sliceRank, strides, defaultValue, sumDupeIndices) {
        const flattenShape = [outputSize / sliceSize, sliceSize];
        const indicesData = this.readSync(indices.dataId);
        const updatesData = this.readSync(updates.dataId);
        if (outputSize === 0) {
          return tensor6([], shape, updates.dtype);
        }
        const buffer3 = new TensorBuffer2(flattenShape, updates.dtype);
        buffer3.values.fill(this.readSync(defaultValue.dataId)[0]);
        for (let i = 0; i < numUpdates; i++) {
          const index2 = [];
          let flattenIndex = 0;
          for (let j = 0; j < sliceRank; j++) {
            const dim = indicesData[i * sliceRank + j];
            index2.push(dim);
            flattenIndex += dim * strides[j];
          }
          if (flattenIndex < 0 || flattenIndex >= outputSize / sliceSize) {
            throw new Error(`Invalid indices: ${index2} does not index into ${shape}`);
          }
          for (let k = 0; k < sliceSize; k++) {
            if (sumDupeIndices) {
              buffer3.values[flattenIndex * sliceSize + k] += updatesData[i * sliceSize + k];
            } else {
              buffer3.values[flattenIndex * sliceSize + k] = updates.rank === 0 ? updatesData[0] : updatesData[i * sliceSize + k];
            }
          }
        }
        return buffer3.toTensor().reshape(shape);
      }
    }
    /**
     * @license
     * Copyright 2020 Google LLC. All Rights Reserved.
     * Licensed under the Apache License, Version 2.0 (the License);
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     * http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an AS IS BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     * =============================================================================
     */
    function simpleAbsImpl(vals) {
      const resultValues = new Float32Array(vals.length);
      for (let i = 0; i < vals.length; ++i) {
        resultValues[i] = Math.abs(vals[i]);
      }
      return resultValues;
    }
    const abs$1 = (args) => {
      const {x} = args.inputs;
      const cpuBackend = args.backend;
      let resultValues = new Float32Array(sizeFromShape2(x.shape));
      if (x.dtype !== "complex64") {
        const values = cpuBackend.data.get(x.dataId).values;
        resultValues = simpleAbsImpl(values);
      } else {
        const complexVals = cpuBackend.data.get(x.dataId);
        const real2 = complexVals.complexTensorInfos.real;
        const imag2 = complexVals.complexTensorInfos.imag;
        const realVals = cpuBackend.data.get(real2.dataId).values;
        const imagVals = cpuBackend.data.get(imag2.dataId).values;
        for (let i = 0; i < realVals.length; i++) {
          const real3 = realVals[i];
          const imag3 = imagVals[i];
          resultValues[i] = Math.hypot(real3, imag3);
        }
      }
      return cpuBackend.makeOutput(resultValues, x.shape, "float32");
    };
    const absConfig2 = {
      kernelName: Abs3,
      backendName: "cpu",
      kernelFunc: abs$1
    };
    /**
     * @license
     * Copyright 2020 Google LLC. All Rights Reserved.
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     * http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     * =============================================================================
     */
    function createSimpleBinaryKernelImpl(op3) {
      return (aShape, bShape, aVals, bVals, dtype) => {
        const newShape = assertAndGetBroadcastShape2(aShape, bShape);
        const resultRank = newShape.length;
        const resultStrides = computeStrides2(newShape);
        const resultSize = sizeFromShape2(newShape);
        const result = getTypedArrayFromDType2(dtype, resultSize);
        const aRank = aShape.length;
        const bRank = bShape.length;
        const aStrides = computeStrides2(aShape);
        const bStrides = computeStrides2(bShape);
        const aBroadcastDims = getBroadcastDims2(aShape, newShape);
        const bBroadcastDims = getBroadcastDims2(bShape, newShape);
        if (aBroadcastDims.length + bBroadcastDims.length === 0) {
          for (let i = 0; i < result.length; ++i) {
            result[i] = op3(aVals[i % aVals.length], bVals[i % bVals.length]);
          }
        } else {
          for (let i = 0; i < result.length; ++i) {
            const loc = indexToLoc2(i, resultRank, resultStrides);
            const aLoc = loc.slice(-aRank);
            aBroadcastDims.forEach((d) => aLoc[d] = 0);
            const aIndex = locToIndex2(aLoc, aRank, aStrides);
            const bLoc = loc.slice(-bRank);
            bBroadcastDims.forEach((d) => bLoc[d] = 0);
            const bIndex = locToIndex2(bLoc, bRank, bStrides);
            result[i] = op3(aVals[aIndex], bVals[bIndex]);
          }
        }
        return [result, newShape];
      };
    }
    /**
     * @license
     * Copyright 2020 Google LLC. All Rights Reserved.
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     * http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     * =============================================================================
     */
    function complex$1(args) {
      const {inputs, backend: backend3} = args;
      const {real: real2, imag: imag2} = inputs;
      const realVals = backend3.data.get(real2.dataId).values;
      const imagVals = backend3.data.get(imag2.dataId).values;
      const complexInfo = backend3.makeTensorInfo(real2.shape, "complex64");
      const complex4 = backend3.data.get(complexInfo.dataId);
      complex4.complexTensorInfos = {
        real: backend3.makeTensorInfo(real2.shape, "float32", realVals),
        imag: backend3.makeTensorInfo(imag2.shape, "float32", imagVals)
      };
      return complexInfo;
    }
    const complexConfig = {
      kernelName: Complex2,
      backendName: "cpu",
      kernelFunc: complex$1
    };
    /**
     * @license
     * Copyright 2020 Google LLC. All Rights Reserved.
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     * http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     * =============================================================================
     */
    function identity$1(args) {
      const {inputs, backend: backend3} = args;
      const {x} = inputs;
      backend3.incRef(x.dataId);
      return {dataId: x.dataId, shape: x.shape, dtype: x.dtype};
    }
    const identityConfig2 = {
      kernelName: Identity5,
      backendName: "cpu",
      kernelFunc: identity$1
    };
    /**
     * @license
     * Copyright 2020 Google LLC. All Rights Reserved.
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     * http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     * =============================================================================
     */
    function real$1(args) {
      const {inputs, backend: backend3} = args;
      const {input: input2} = inputs;
      const real2 = backend3.data.get(input2.dataId).complexTensorInfos.real;
      const realVal = backend3.data.get(real2.dataId).values;
      return backend3.makeTensorInfo(real2.shape, real2.dtype, realVal);
    }
    const realConfig = {
      kernelName: Real,
      backendName: "cpu",
      kernelFunc: real$1
    };
    /**
     * @license
     * Copyright 2020 Google LLC. All Rights Reserved.
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     * http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     * =============================================================================
     */
    function cast$2(args) {
      const {inputs, backend: backend3, attrs} = args;
      const {x} = inputs;
      const {dtype} = attrs;
      if (dtype === "complex64") {
        if (x.dtype === "complex64") {
          return identity$1({inputs: {x}, backend: backend3});
        }
        const zerosTensor = zeros3(x.shape);
        const floatX = cast$2({inputs: {x}, backend: backend3, attrs: {dtype: "float32"}});
        const result = complex$1({inputs: {real: floatX, imag: zerosTensor}, backend: backend3});
        zerosTensor.dispose();
        backend3.disposeIntermediateTensorInfo(floatX);
        return result;
      }
      if (x.dtype === "complex64") {
        const realPart = real$1({inputs: {input: x}, backend: backend3});
        const result = cast$2({inputs: {x: realPart}, backend: backend3, attrs: {dtype}});
        backend3.disposeIntermediateTensorInfo(realPart);
        return result;
      }
      if (!hasEncodingLoss2(x.dtype, dtype)) {
        const result = identity$1({inputs: {x}, backend: backend3});
        return {dataId: result.dataId, shape: result.shape, dtype};
      }
      if (dtype === "int32") {
        const values = backend3.data.get(x.dataId).values;
        const resultValues = Int32Array.from(values);
        return backend3.makeTensorInfo(x.shape, "int32", resultValues);
      }
      if (dtype === "bool") {
        const xVals = backend3.data.get(x.dataId).values;
        const zero = toTypedArray2([0], x.dtype);
        const [resultData, resultShape] = createSimpleBinaryKernelImpl((a, b) => a !== b ? 1 : 0)(x.shape, [], xVals, zero, "bool");
        return backend3.makeTensorInfo(resultShape, "bool", resultData);
      }
      throw new Error(`Error in Cast: failed to cast ${x.dtype} to ${dtype}`);
    }
    const castConfig2 = {
      kernelName: Cast5,
      backendName: "cpu",
      kernelFunc: cast$2
    };
    /**
     * @license
     * Copyright 2020 Google LLC. All Rights Reserved.
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     * http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     * =============================================================================
     */
    function binaryKernelFunc(name, simpleImpl, complexImpl, dtype) {
      if (complexImpl == null) {
        return ({inputs, backend: backend3}) => {
          const {a, b} = inputs;
          const cpuBackend = backend3;
          assertNotComplex([a, b], name);
          const aVals = cpuBackend.data.get(a.dataId).values;
          const bVals = cpuBackend.data.get(b.dataId).values;
          const $dtype = dtype || a.dtype;
          const [resultData, resultShape] = simpleImpl(a.shape, b.shape, aVals, bVals, $dtype);
          return cpuBackend.makeTensorInfo(resultShape, $dtype, resultData);
        };
      }
      return ({inputs, backend: backend3}) => {
        const {a, b} = inputs;
        const cpuBackend = backend3;
        if (a.dtype === "complex64" || b.dtype === "complex64") {
          const $aComplex = cast$2({inputs: {x: a}, backend: cpuBackend, attrs: {dtype: "complex64"}});
          const $aComplexVals = cpuBackend.data.get($aComplex.dataId);
          const aReal = $aComplexVals.complexTensorInfos.real;
          const aImag = $aComplexVals.complexTensorInfos.imag;
          const aRealVals = cpuBackend.data.get(aReal.dataId).values;
          const aImagVals = cpuBackend.data.get(aImag.dataId).values;
          const $bComplex = cast$2({inputs: {x: b}, backend: cpuBackend, attrs: {dtype: "complex64"}});
          const $bComplexVals = cpuBackend.data.get($bComplex.dataId);
          const bReal = $bComplexVals.complexTensorInfos.real;
          const bImag = $bComplexVals.complexTensorInfos.imag;
          const bRealVals = cpuBackend.data.get(bReal.dataId).values;
          const bImagVals = cpuBackend.data.get(bImag.dataId).values;
          const [resultRealData, resultImagData, resultShape] = complexImpl(a.shape, b.shape, aRealVals, aImagVals, bRealVals, bImagVals);
          const resultReal = cpuBackend.makeTensorInfo(resultShape, "float32", resultRealData);
          const resultImag = cpuBackend.makeTensorInfo(resultShape, "float32", resultImagData);
          const result = complex$1({inputs: {real: resultReal, imag: resultImag}, backend: cpuBackend});
          cpuBackend.disposeIntermediateTensorInfo($aComplex);
          cpuBackend.disposeIntermediateTensorInfo($bComplex);
          cpuBackend.disposeIntermediateTensorInfo(resultReal);
          cpuBackend.disposeIntermediateTensorInfo(resultImag);
          return result;
        } else {
          const aVals = cpuBackend.data.get(a.dataId).values;
          const bVals = cpuBackend.data.get(b.dataId).values;
          const $dtype = dtype || a.dtype;
          const [resultData, resultShape] = simpleImpl(a.shape, b.shape, aVals, bVals, $dtype);
          return cpuBackend.makeTensorInfo(resultShape, $dtype, resultData);
        }
      };
    }
    function createComplexBinaryKernelImpl(op3) {
      return (aShape, bShape, aRealVals, aImagVals, bRealVals, bImagVals) => {
        const resultShape = assertAndGetBroadcastShape2(aShape, bShape);
        const resultSize = sizeFromShape2(resultShape);
        const resultRank = resultShape.length;
        const resultStrides = computeStrides2(resultShape);
        const resultRealVals = getTypedArrayFromDType2("float32", resultSize);
        const resultImagVals = getTypedArrayFromDType2("float32", resultSize);
        const aBroadcastDims = getBroadcastDims2(aShape, resultShape);
        const bBroadcastDims = getBroadcastDims2(bShape, resultShape);
        const aVals = mergeRealAndImagArrays2(aRealVals, aImagVals);
        const bVals = mergeRealAndImagArrays2(bRealVals, bImagVals);
        const aRank = aShape.length;
        const aStrides = computeStrides2(aShape);
        const bRank = bShape.length;
        const bStrides = computeStrides2(bShape);
        if (aBroadcastDims.length + bBroadcastDims.length === 0) {
          for (let i = 0; i < resultRealVals.length; i++) {
            const aIdx = i % aVals.length;
            const bIdx = i % bVals.length;
            const result = op3(aVals[aIdx * 2], aVals[aIdx * 2 + 1], bVals[bIdx * 2], bVals[bIdx * 2 + 1]);
            resultRealVals[i] = result.real;
            resultImagVals[i] = result.imag;
          }
        } else {
          for (let i = 0; i < resultRealVals.length; i++) {
            const loc = indexToLoc2(i, resultRank, resultStrides);
            const aLoc = loc.slice(-aRank);
            aBroadcastDims.forEach((d) => aLoc[d] = 0);
            const aIndex = locToIndex2(aLoc, aRank, aStrides);
            const bLoc = loc.slice(-bRank);
            bBroadcastDims.forEach((d) => bLoc[d] = 0);
            const bIndex = locToIndex2(bLoc, bRank, bStrides);
            const opResult = op3(aVals[aIndex * 2], aVals[aIndex * 2 + 1], bVals[bIndex * 2], bVals[bIndex * 2 + 1]);
            resultRealVals[i] = opResult.real;
            resultImagVals[i] = opResult.imag;
          }
        }
        return [resultRealVals, resultImagVals, resultShape];
      };
    }
    /**
     * @license
     * Copyright 2020 Google LLC. All Rights Reserved.
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     * http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     * =============================================================================
     */
    const addImpl = createSimpleBinaryKernelImpl((a, b) => a + b);
    const addComplexImpl = createComplexBinaryKernelImpl((aReal, aImag, bReal, bImag) => {
      return {real: aReal + bReal, imag: aImag + bImag};
    });
    const add$4 = binaryKernelFunc(Add3, addImpl, addComplexImpl);
    const addConfig2 = {
      kernelName: Add3,
      backendName: "cpu",
      kernelFunc: add$4
    };
    /**
     * @license
     * Copyright 2020 Google LLC. All Rights Reserved.
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     * http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     * =============================================================================
     */
    function createSimpleUnaryImpl(op3) {
      return (values, dtype, attrs) => {
        const newValues = getTypedArrayFromDType2(dtype, values.length);
        for (let i = 0; i < values.length; ++i) {
          newValues[i] = op3(values[i], attrs);
        }
        return newValues;
      };
    }
    /**
     * @license
     * Copyright 2020 Google LLC. All Rights Reserved.
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     * http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     * =============================================================================
     */
    function unaryKernelFunc(name, op3, dtype) {
      return ({inputs, attrs, backend: backend3}) => {
        const {x} = inputs;
        assertNotComplex(x, name);
        if (x.dtype === "string" || dtype === "string") {
          throw new Error("unaryKernelFunc does not support string input/output");
        }
        const cpuBackend = backend3;
        const values = cpuBackend.data.get(x.dataId).values;
        const xSize = sizeFromShape2(x.shape);
        const $dtype = dtype || x.dtype;
        const newValues = getArrayFromDType2($dtype, xSize);
        for (let i = 0; i < xSize; ++i) {
          newValues[i] = op3(values[i], attrs);
        }
        return cpuBackend.makeTensorInfo(x.shape, $dtype, newValues);
      };
    }
    function unaryKernelFuncFromImpl(name, unaryImpl, dtype) {
      return ({inputs, attrs, backend: backend3}) => {
        const {x} = inputs;
        assertNotComplex(x, name);
        if (x.dtype === "string" || dtype === "string") {
          throw new Error("unaryKernelFunc does not support string input/output");
        }
        const cpuBackend = backend3;
        const values = cpuBackend.data.get(x.dataId).values;
        const $dtype = dtype || x.dtype;
        const newValues = unaryImpl(values, $dtype, attrs);
        return cpuBackend.makeTensorInfo(x.shape, $dtype, newValues);
      };
    }
    /**
     * @license
     * Copyright 2020 Google LLC. All Rights Reserved.
     * Licensed under the Apache License, Version 2.0 (the License);
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     * http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an AS IS BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     * =============================================================================
     */
    const ceilImpl = createSimpleUnaryImpl((xi) => Math.ceil(xi));
    const ceil$1 = unaryKernelFuncFromImpl(Ceil, ceilImpl);
    const ceilConfig = {
      kernelName: Ceil,
      backendName: "cpu",
      kernelFunc: ceil$1
    };
    /**
     * @license
     * Copyright 2020 Google LLC. All Rights Reserved.
     * Licensed under the Apache License, Version 2.0 (the License);
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     * http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an AS IS BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     * =============================================================================
     */
    const expImpl = createSimpleUnaryImpl((xi) => Math.exp(xi));
    const exp$1 = unaryKernelFuncFromImpl(Exp3, expImpl);
    const expConfig2 = {
      kernelName: Exp3,
      backendName: "cpu",
      kernelFunc: exp$1
    };
    /**
     * @license
     * Copyright 2020 Google LLC. All Rights Reserved.
     * Licensed under the Apache License, Version 2.0 (the License);
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     * http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an AS IS BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     * =============================================================================
     */
    const expm1Impl = createSimpleUnaryImpl((xi) => Math.expm1(xi));
    const expm1$1 = unaryKernelFuncFromImpl(Expm1, expm1Impl);
    const expm1Config = {
      kernelName: Expm1,
      backendName: "cpu",
      kernelFunc: expm1$1
    };
    /**
     * @license
     * Copyright 2020 Google LLC. All Rights Reserved.
     * Licensed under the Apache License, Version 2.0 (the License);
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     * http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an AS IS BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     * =============================================================================
     */
    const floorImpl = createSimpleUnaryImpl((xi) => Math.floor(xi));
    const floor$1 = unaryKernelFuncFromImpl(Floor, floorImpl);
    const floorConfig = {
      kernelName: Floor,
      backendName: "cpu",
      kernelFunc: floor$1
    };
    /**
     * @license
     * Copyright 2020 Google LLC. All Rights Reserved.
     * Licensed under the Apache License, Version 2.0 (the License);
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     * http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an AS IS BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     * =============================================================================
     */
    const logImpl = createSimpleUnaryImpl((xi) => Math.log(xi));
    const log$2 = unaryKernelFuncFromImpl(Log3, logImpl);
    const logConfig2 = {
      kernelName: Log3,
      backendName: "cpu",
      kernelFunc: log$2
    };
    /**
     * @license
     * Copyright 2020 Google LLC. All Rights Reserved.
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     * http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     * =============================================================================
     */
    function maxImpl(aVals, reduceSize, outShape, dtype) {
      const vals = getTypedArrayFromDType2(dtype, sizeFromShape2(outShape));
      for (let i = 0; i < vals.length; ++i) {
        const offset = i * reduceSize;
        let max3 = aVals[offset];
        for (let j = 0; j < reduceSize; ++j) {
          const value = aVals[offset + j];
          if (value > max3) {
            max3 = value;
          }
        }
        vals[i] = max3;
      }
      return vals;
    }
    /**
     * @license
     * Copyright 2020 Google LLC. All Rights Reserved.
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     * http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     * =============================================================================
     */
    const multiplyImpl = createSimpleBinaryKernelImpl((aValue, bValue) => aValue * bValue);
    const multiplyComplexImpl = createComplexBinaryKernelImpl((aReal, aImag, bReal, bImag) => {
      return {
        real: aReal * bReal - aImag * bImag,
        imag: aReal * bImag + aImag * bReal
      };
    });
    const multiply$2 = binaryKernelFunc(Multiply3, multiplyImpl, multiplyComplexImpl);
    const multiplyConfig2 = {
      kernelName: Multiply3,
      backendName: "cpu",
      kernelFunc: multiply$2
    };
    /**
     * @license
     * Copyright 2020 Google LLC. All Rights Reserved.
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     * http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     * =============================================================================
     */
    const notEqualImpl = createSimpleBinaryKernelImpl((a, b) => a !== b ? 1 : 0);
    const notEqual$1 = binaryKernelFunc(NotEqual3, notEqualImpl, null, "bool");
    const notEqualConfig2 = {
      kernelName: NotEqual3,
      backendName: "cpu",
      kernelFunc: notEqual$1
    };
    /**
     * @license
     * Copyright 2020 Google LLC. All Rights Reserved.
     * Licensed under the Apache License, Version 2.0 (the License);
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     * http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an AS IS BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     * =============================================================================
     */
    const rsqrtImpl = createSimpleUnaryImpl((xi) => 1 / Math.sqrt(xi));
    const rsqrt$1 = unaryKernelFuncFromImpl(Rsqrt3, rsqrtImpl);
    const rsqrtConfig2 = {
      kernelName: Rsqrt3,
      backendName: "cpu",
      kernelFunc: rsqrt$1
    };
    /**
     * @license
     * Copyright 2020 Google LLC. All Rights Reserved.
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     * http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     * =============================================================================
     */
    function sliceImpl(vals, begin, size, shape, dtype) {
      const isContinous = isSliceContinous2(shape, begin, size);
      const length = sizeFromShape2(size);
      const xStrides = computeStrides2(shape);
      if (isContinous) {
        const flatOffset = computeFlatOffset2(begin, xStrides);
        return vals.subarray(flatOffset, flatOffset + length);
      }
      const outVals = getTypedArrayFromDType2(dtype, length);
      for (let i = 0; i < length; ++i) {
        const rank = size.length;
        const strides = computeStrides2(size);
        const loc = indexToLoc2(i, rank, strides);
        const xLoc = loc.map((idx, j) => idx + begin[j]);
        const xIndex = locToIndex2(xLoc, shape.length, xStrides);
        outVals[i] = vals[xIndex];
      }
      return outVals;
    }
    function slice$1(args) {
      const {inputs, backend: backend3, attrs} = args;
      const {x} = inputs;
      const {begin, size} = attrs;
      assertNotComplex(x, "slice");
      const [$begin, $size] = parseSliceParams2(x, begin, size);
      assertParamsValid2(x, $begin, $size);
      const vals = backend3.data.get(x.dataId).values;
      const outVals = sliceImpl(vals, $begin, $size, x.shape, x.dtype);
      return backend3.makeTensorInfo($size, x.dtype, outVals);
    }
    const sliceConfig2 = {
      kernelName: Slice6,
      backendName: "cpu",
      kernelFunc: slice$1
    };
    /**
     * @license
     * Copyright 2020 Google LLC. All Rights Reserved.
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     * http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     * =============================================================================
     */
    const squaredDifferenceImpl = createSimpleBinaryKernelImpl((a, b) => {
      const diff = a - b;
      return diff * diff;
    });
    const squaredDifference$1 = binaryKernelFunc(SquaredDifference3, squaredDifferenceImpl);
    const squaredDifferenceConfig2 = {
      kernelName: SquaredDifference3,
      backendName: "cpu",
      kernelFunc: squaredDifference$1
    };
    /**
     * @license
     * Copyright 2020 Google LLC. All Rights Reserved.
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     * http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     * =============================================================================
     */
    const subImpl = createSimpleBinaryKernelImpl((aValue, bValue) => aValue - bValue);
    const subComplexImpl = createComplexBinaryKernelImpl((aReal, aImag, bReal, bImag) => {
      return {real: aReal - bReal, imag: aImag - bImag};
    });
    const sub$1 = binaryKernelFunc(Sub3, subImpl, subComplexImpl);
    const subConfig2 = {
      kernelName: Sub3,
      backendName: "cpu",
      kernelFunc: sub$1
    };
    /**
     * @license
     * Copyright 2020 Google LLC. All Rights Reserved.
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     * http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     * =============================================================================
     */
    function transposeImpl(xVals, xShape, dtype, perm, newShape) {
      const xRank = xShape.length;
      const xSize = sizeFromShape2(xShape);
      const xStrides = computeStrides2(xShape);
      const newStrides = computeStrides2(newShape);
      const result = getTypedArrayFromDType2(dtype, sizeFromShape2(newShape));
      for (let i = 0; i < xSize; ++i) {
        const loc = indexToLoc2(i, xRank, xStrides);
        const newLoc = new Array(loc.length);
        for (let i2 = 0; i2 < newLoc.length; i2++) {
          newLoc[i2] = loc[perm[i2]];
        }
        const newIndex = locToIndex2(newLoc, xRank, newStrides);
        result[newIndex] = xVals[i];
      }
      return result;
    }
    /**
     * @license
     * Copyright 2020 Google LLC. All Rights Reserved.
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     * http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     * =============================================================================
     */
    function uniqueImpl(values, axis, shape, dtype) {
      const $axis = parseAxisParam2(axis, shape)[0];
      const newShape = [1, shape[0], 1];
      for (let i = 0; i < $axis; i++) {
        newShape[0] *= shape[i];
      }
      newShape[1] = shape[$axis];
      for (let i = $axis + 1; i < shape.length; i++) {
        newShape[2] *= shape[i];
      }
      const uniqueElements = {};
      const indices = new Int32Array(shape[$axis]);
      const inputBuffer = new TensorBuffer2(newShape, dtype, values);
      const uniqueIndices = [];
      const is1DTensor = newShape[0] === 1 && newShape[2] === 1;
      for (let i = 0; i < shape[$axis]; i++) {
        let element;
        if (is1DTensor) {
          element = values[i].toString();
        } else {
          const axisValues = [];
          for (let m = 0; m < newShape[0]; m++) {
            for (let n = 0; n < newShape[2]; n++) {
              axisValues.push(inputBuffer.get(m, i, n));
            }
          }
          element = axisValues.join(",");
        }
        if (uniqueElements[element] !== void 0) {
          indices[i] = uniqueElements[element];
        } else {
          const uniqueIndex = Object.keys(uniqueElements).length;
          uniqueElements[element] = uniqueIndex;
          indices[i] = uniqueIndex;
          uniqueIndices.push(i);
        }
      }
      const outputTmpShape = newShape.slice();
      outputTmpShape[1] = Object.keys(uniqueElements).length;
      const outputBuffer = new TensorBuffer2(outputTmpShape, dtype);
      uniqueIndices.forEach((uniqueElementIndex, i) => {
        for (let m = 0; m < newShape[0]; m++) {
          for (let n = 0; n < newShape[2]; n++) {
            outputBuffer.set(inputBuffer.get(m, uniqueElementIndex, n), m, i, n);
          }
        }
      });
      const outputShape = shape.slice();
      outputShape[$axis] = outputTmpShape[1];
      return {
        outputValues: outputBuffer.values,
        outputShape,
        indices
      };
    }
    /**
     * @license
     * Copyright 2020 Google LLC. All Rights Reserved.
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     * http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     * =============================================================================
     */
    var shared = /* @__PURE__ */ Object.freeze({
      __proto__: null,
      simpleAbsImpl,
      addImpl,
      ceilImpl,
      expImpl,
      expm1Impl,
      floorImpl,
      logImpl,
      maxImpl,
      multiplyImpl,
      notEqualImpl,
      rsqrtImpl,
      sliceImpl,
      squaredDifferenceImpl,
      subImpl,
      transposeImpl,
      uniqueImpl
    });
    /** @license See the LICENSE file. */
    const version$4 = "2.7.0";
    /**
     * @license
     * Copyright 2020 Google LLC. All Rights Reserved.
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     * http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     * =============================================================================
     */
    registerBackend2("cpu", () => new MathBackendCPU(), 1);
    /**
     * @license
     * Copyright 2020 Google LLC. All Rights Reserved.
     * Licensed under the Apache License, Version 2.0 (the License);
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     * http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an AS IS BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     * =============================================================================
     */
    const elu$3 = unaryKernelFunc(Elu2, (xi) => xi >= 0 ? xi : Math.exp(xi) - 1);
    const eluConfig = {
      kernelName: Elu2,
      backendName: "cpu",
      kernelFunc: elu$3
    };
    /**
     * @license
     * Copyright 2020 Google LLC. All Rights Reserved.
     * Licensed under the Apache License, Version 2.0 (the License);
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     * http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an AS IS BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     * =============================================================================
     */
    const preluImpl = createSimpleBinaryKernelImpl((xValue, aValue) => xValue < 0 ? aValue * xValue : xValue);
    function prelu$2(args) {
      const {inputs, backend: backend3} = args;
      const {x, alpha} = inputs;
      assertNotComplex([x, alpha], "prelu");
      const aVals = backend3.data.get(x.dataId).values;
      const bVals = backend3.data.get(alpha.dataId).values;
      const [resultData, resultShape] = preluImpl(x.shape, alpha.shape, aVals, bVals, x.dtype);
      return backend3.makeTensorInfo(resultShape, x.dtype, resultData);
    }
    const preluConfig2 = {
      kernelName: Prelu3,
      backendName: "cpu",
      kernelFunc: prelu$2
    };
    /**
     * @license
     * Copyright 2020 Google LLC. All Rights Reserved.
     * Licensed under the Apache License, Version 2.0 (the License);
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     * http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an AS IS BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     * =============================================================================
     */
    const relu$1 = unaryKernelFunc(Relu3, (xi) => Math.max(0, xi));
    const reluConfig2 = {
      kernelName: Relu3,
      backendName: "cpu",
      kernelFunc: relu$1
    };
    /**
     * @license
     * Copyright 2020 Google LLC. All Rights Reserved.
     * Licensed under the Apache License, Version 2.0 (the License);
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     * http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an AS IS BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     * =============================================================================
     */
    const relu6$1 = unaryKernelFunc(Relu63, (xi) => Math.min(Math.max(0, xi), 6));
    const relu6Config2 = {
      kernelName: Relu63,
      backendName: "cpu",
      kernelFunc: relu6$1
    };
    /**
     * @license
     * Copyright 2020 Google LLC. All Rights Reserved.
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     * http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     * =============================================================================
     */
    function applyActivation$1(backend3, x, activation2, preluActivationWeights) {
      if (activation2 === "linear") {
        return identity$1({inputs: {x}, backend: backend3});
      } else if (activation2 === "relu") {
        return relu$1({inputs: {x}, backend: backend3});
      } else if (activation2 === "elu") {
        return elu$3({inputs: {x}, backend: backend3});
      } else if (activation2 === "relu6") {
        return relu6$1({inputs: {x}, backend: backend3});
      } else if (activation2 === "prelu") {
        return prelu$2({inputs: {x, alpha: preluActivationWeights}, backend: backend3});
      }
      throw new Error(`Activation ${activation2} has not been implemented for the CPU backend.`);
    }
    /**
     * @license
     * Copyright 2020 Google LLC. All Rights Reserved.
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     * http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     * =============================================================================
     */
    function reshape$2(args) {
      const {inputs, backend: backend3, attrs} = args;
      const {x} = inputs;
      const {shape} = attrs;
      const xSize = sizeFromShape2(x.shape);
      const $shape = inferFromImplicitShape2(shape, xSize);
      const $xSize = sizeFromShape2($shape);
      assert2(xSize === $xSize, () => `The new shape (${$shape}) has ${$xSize} elements and the old shape (${x.shape}) has ${xSize} elements. The new shape and old shape must have the same number of elements.`);
      backend3.incRef(x.dataId);
      const xData = backend3.data.get(x.dataId);
      if (xData.complexTensorInfos != null) {
        const real2 = xData.complexTensorInfos.real;
        const imag2 = xData.complexTensorInfos.imag;
        real2.shape = $shape;
        imag2.shape = $shape;
      }
      return {dataId: x.dataId, shape: $shape, dtype: x.dtype};
    }
    const reshapeConfig2 = {
      kernelName: Reshape6,
      backendName: "cpu",
      kernelFunc: reshape$2
    };
    /**
     * @license
     * Copyright 2020 Google LLC. All Rights Reserved.
     * Licensed under the Apache License, Version 2.0 (the License);
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     * http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an AS IS BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     * =============================================================================
     */
    function batchMatMul2(args) {
      const {inputs, backend: backend3, attrs} = args;
      const {a, b} = inputs;
      const {transposeA, transposeB} = attrs;
      assertNotComplex([a, b], "matMul");
      const aRank = a.shape.length;
      const bRank = b.shape.length;
      const innerShapeA = transposeA ? a.shape[aRank - 2] : a.shape[aRank - 1];
      const innerShapeB = transposeB ? b.shape[bRank - 1] : b.shape[bRank - 2];
      const outerShapeA = transposeA ? a.shape[aRank - 1] : a.shape[aRank - 2];
      const outerShapeB = transposeB ? b.shape[bRank - 2] : b.shape[bRank - 1];
      const outerDimsA = a.shape.slice(0, -2);
      const outerDimsB = b.shape.slice(0, -2);
      const batchDimA = sizeFromShape2(outerDimsA);
      const batchDimB = sizeFromShape2(outerDimsB);
      const batchDimsCompatible = batchDimA === batchDimB || batchDimA === 1 || batchDimB === 1;
      assert2(aRank >= 2 && bRank >= 2 && batchDimsCompatible, () => `Error in matMul: the input batch dimensions must either be the same or at least one input batch dimension must be 1. Got input batch dimensions of (${outerDimsA}) and (${outerDimsB}).`);
      const outShapeOuterDims = batchDimA > batchDimB ? a.shape.slice(0, -2) : b.shape.slice(0, -2);
      const outShape = outShapeOuterDims.concat([outerShapeA, outerShapeB]);
      assert2(innerShapeA === innerShapeB, () => `Error in matMul: inner shapes (${innerShapeA}) and (${innerShapeB}) of Tensors with shapes ${a.shape} and ${b.shape} and transposeA=${transposeA} and transposeB=${transposeB} must match.`);
      const a3dShape = transposeA ? [batchDimA, innerShapeA, outerShapeA] : [batchDimA, outerShapeA, innerShapeA];
      const b3dShape = transposeB ? [batchDimB, outerShapeB, innerShapeB] : [batchDimB, innerShapeB, outerShapeB];
      const a3d = reshape$2({inputs: {x: a}, backend: backend3, attrs: {shape: a3dShape}});
      const b3d = reshape$2({inputs: {x: b}, backend: backend3, attrs: {shape: b3dShape}});
      const sharedDim = transposeA ? a3d.shape[1] : a3d.shape[2];
      const leftDim = transposeA ? a3d.shape[2] : a3d.shape[1];
      const rightDim = transposeB ? b3d.shape[1] : b3d.shape[2];
      const batchDim = Math.max(batchDimA, batchDimB);
      const a3dValues = backend3.data.get(a3d.dataId).values;
      const b3dValues = backend3.data.get(b3d.dataId).values;
      const a3dStrides = computeStrides2(a3d.shape);
      const b3dStrides = computeStrides2(b3d.shape);
      const [aBatch, aOuterStep, aInnerStep] = transposeA ? [a3dStrides[0], 1, a3dStrides[1]] : [a3dStrides[0], a3dStrides[1], 1];
      const [bInnerStep, bOuterStep, bBatch] = transposeB ? [1, b3dStrides[1], b3dStrides[0]] : [b3dStrides[1], 1, b3dStrides[0]];
      const size = leftDim * rightDim;
      const result = buffer2([batchDim, leftDim, rightDim], a3d.dtype);
      const resVals = result.values;
      const blockSize = backend3.blockSize;
      for (let bi = 0; bi < batchDim; bi++) {
        for (let i0 = 0; i0 < leftDim; i0 += blockSize) {
          for (let j0 = 0; j0 < rightDim; j0 += blockSize) {
            for (let k0 = 0; k0 < sharedDim; k0 += blockSize) {
              const iBlock = Math.min(i0 + blockSize, leftDim);
              const jBlock = Math.min(j0 + blockSize, rightDim);
              const kBlock = Math.min(k0 + blockSize, sharedDim);
              for (let i = i0; i < iBlock; i++) {
                for (let j = j0; j < jBlock; j++) {
                  let sum6 = 0;
                  for (let k = k0; k < kBlock; k++) {
                    const batchOffsetA = Math.min(bi, batchDimA - 1) * aBatch;
                    const batchOffsetB = Math.min(bi, batchDimB - 1) * bBatch;
                    const aVal = a3dValues[batchOffsetA + i * aOuterStep + k * aInnerStep];
                    const bVal = b3dValues[k * bInnerStep + j * bOuterStep + batchOffsetB];
                    sum6 += aVal * bVal;
                  }
                  resVals[bi * size + (i * rightDim + j)] += sum6;
                }
              }
            }
          }
        }
      }
      backend3.disposeIntermediateTensorInfo(a3d);
      backend3.disposeIntermediateTensorInfo(b3d);
      return backend3.makeTensorInfo(outShape, result.dtype, result.values);
    }
    const batchMatMulConfig2 = {
      kernelName: BatchMatMul3,
      backendName: "cpu",
      kernelFunc: batchMatMul2
    };
    /**
     * @license
     * Copyright 2020 Google LLC. All Rights Reserved.
     * Licensed under the Apache License, Version 2.0 (the License);
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     * http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an AS IS BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     * =============================================================================
     */
    function _fusedMatMul(args) {
      const {inputs, backend: backend3, attrs} = args;
      const {a, b, bias, preluActivationWeights} = inputs;
      const {transposeA, transposeB, activation: activation2} = attrs;
      let current;
      let addRes;
      let activationRes;
      const intermediates = [];
      const matMulRes = batchMatMul2({inputs: {a, b}, attrs: {transposeA, transposeB}, backend: backend3});
      current = matMulRes;
      if (bias) {
        addRes = add$4({inputs: {a: current, b: bias}, backend: backend3});
        intermediates.push(current);
        current = addRes;
      }
      if (activation2) {
        activationRes = applyActivation$1(backend3, current, activation2, preluActivationWeights);
        intermediates.push(current);
        current = activationRes;
      }
      for (const i of intermediates) {
        backend3.disposeIntermediateTensorInfo(i);
      }
      return current;
    }
    const _fusedMatMulConfig = {
      kernelName: _FusedMatMul2,
      backendName: "cpu",
      kernelFunc: _fusedMatMul
    };
    /**
     * @license
     * Copyright 2020 Google LLC. All Rights Reserved.
     * Licensed under the Apache License, Version 2.0 (the License);
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     * http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an AS IS BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     * =============================================================================
     */
    const acos$1 = unaryKernelFunc(Acos, (xi) => Math.acos(xi));
    const acosConfig = {
      kernelName: Acos,
      backendName: "cpu",
      kernelFunc: acos$1
    };
    /**
     * @license
     * Copyright 2020 Google LLC. All Rights Reserved.
     * Licensed under the Apache License, Version 2.0 (the License);
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     * http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an AS IS BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     * =============================================================================
     */
    const acosh$1 = unaryKernelFunc(Acosh, (xi) => Math.acosh(xi));
    const acoshConfig = {
      kernelName: Acosh,
      backendName: "cpu",
      kernelFunc: acosh$1
    };
    /**
     * @license
     * Copyright 2020 Google LLC. All Rights Reserved.
     * Licensed under the Apache License, Version 2.0 (the License);
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     * http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an AS IS BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     * =============================================================================
     */
    const asin$1 = unaryKernelFunc(Asin, (xi) => Math.asin(xi));
    const asinConfig = {
      kernelName: Asin,
      backendName: "cpu",
      kernelFunc: asin$1
    };
    /**
     * @license
     * Copyright 2020 Google LLC. All Rights Reserved.
     * Licensed under the Apache License, Version 2.0 (the License);
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     * http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an AS IS BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     * =============================================================================
     */
    const asinh$1 = unaryKernelFunc(Asinh, (xi) => Math.asinh(xi));
    const asinhConfig = {
      kernelName: Asinh,
      backendName: "cpu",
      kernelFunc: asinh$1
    };
    /**
     * @license
     * Copyright 2020 Google LLC. All Rights Reserved.
     * Licensed under the Apache License, Version 2.0 (the License);
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     * http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an AS IS BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     * =============================================================================
     */
    const atan$1 = unaryKernelFunc(Atan, (xi) => Math.atan(xi));
    const atanConfig = {
      kernelName: Atan,
      backendName: "cpu",
      kernelFunc: atan$1
    };
    /**
     * @license
     * Copyright 2020 Google LLC. All Rights Reserved.
     * Licensed under the Apache License, Version 2.0 (the License);
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     * http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an AS IS BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     * =============================================================================
     */
    const atanh$1 = unaryKernelFunc(Atanh, (xi) => Math.atanh(xi));
    const atanhConfig = {
      kernelName: Atanh,
      backendName: "cpu",
      kernelFunc: atanh$1
    };
    /**
     * @license
     * Copyright 2020 Google LLC. All Rights Reserved.
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     * http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     * =============================================================================
     */
    function pool$1(xValues, xShape, dtype, strides, convInfo, poolType) {
      const strideHeight = convInfo.strideHeight;
      const strideWidth = convInfo.strideWidth;
      const dilationHeight = convInfo.dilationHeight;
      const dilationWidth = convInfo.dilationWidth;
      const effectiveFilterHeight = convInfo.effectiveFilterHeight;
      const effectiveFilterWidth = convInfo.effectiveFilterWidth;
      const padTop = convInfo.padInfo.top;
      const padLeft = convInfo.padInfo.left;
      const initialValue = poolType === "max" ? Number.NEGATIVE_INFINITY : Number.POSITIVE_INFINITY;
      const output = buffer2(convInfo.outShape, dtype);
      const outputVals = output.values;
      const outputBatchStrides = convInfo.outShape[1] * convInfo.outShape[2] * convInfo.outShape[3];
      const outputRowStrides = convInfo.outShape[2] * convInfo.outShape[3];
      const outputColStrides = convInfo.outShape[3];
      for (let b = 0; b < convInfo.batchSize; ++b) {
        const outputBatchOffset = b * outputBatchStrides;
        const inputBatchOffset = b * strides[0];
        for (let d = 0; d < convInfo.inChannels; ++d) {
          for (let yR = 0; yR < convInfo.outHeight; ++yR) {
            const xRCorner = yR * strideHeight - padTop;
            const xRMin = Math.max(0, xRCorner);
            const xRMax = Math.min(convInfo.inHeight, effectiveFilterHeight + xRCorner);
            const outputRowOffset = outputBatchOffset + yR * outputRowStrides;
            for (let yC = 0; yC < convInfo.outWidth; ++yC) {
              const xCCorner = yC * strideWidth - padLeft;
              const xCMin = Math.max(0, xCCorner);
              const xCMax = Math.min(convInfo.inWidth, effectiveFilterWidth + xCCorner);
              let minMaxValue = initialValue;
              let avgValue = 0;
              let count2 = 0;
              for (let xR = xRMin; xR < xRMax; xR += dilationHeight) {
                const xROffset = inputBatchOffset + xR * strides[1];
                for (let xC = xCMin; xC < xCMax; xC += dilationWidth) {
                  const xCOffset = xROffset + xC * strides[2];
                  const pixel = xValues[xCOffset + d];
                  if (poolType === "max" && pixel > minMaxValue) {
                    minMaxValue = pixel;
                  } else if (poolType === "avg") {
                    avgValue += pixel;
                    count2++;
                  }
                }
                if (isNaN(minMaxValue)) {
                  break;
                }
              }
              const outputOffset = outputRowOffset + yC * outputColStrides + d;
              outputVals[outputOffset] = poolType === "avg" ? avgValue / count2 : minMaxValue;
            }
          }
        }
      }
      return output;
    }
    function maxPoolPositions(xValues, xShape, dtype, convInfo, flattenPositions = false, includeBatchInIndex = false) {
      const maxPositions = buffer2(convInfo.outShape, "int32");
      const strideHeight = convInfo.strideHeight;
      const strideWidth = convInfo.strideWidth;
      const dilationHeight = convInfo.dilationHeight;
      const dilationWidth = convInfo.dilationWidth;
      const effectiveFilterHeight = convInfo.effectiveFilterHeight;
      const effectiveFilterWidth = convInfo.effectiveFilterWidth;
      const padTop = convInfo.padInfo.top;
      const padLeft = convInfo.padInfo.left;
      const xBuf = buffer2(xShape, dtype, xValues);
      for (let b = 0; b < convInfo.batchSize; ++b) {
        for (let d = 0; d < convInfo.inChannels; ++d) {
          for (let yR = 0; yR < convInfo.outHeight; ++yR) {
            const xRCorner = yR * strideHeight - padTop;
            let xRMin = xRCorner;
            while (xRMin < 0) {
              xRMin += dilationHeight;
            }
            const xRMax = Math.min(convInfo.inHeight, effectiveFilterHeight + xRCorner);
            for (let yC = 0; yC < convInfo.outWidth; ++yC) {
              const xCCorner = yC * strideWidth - padLeft;
              let xCMin = xCCorner;
              while (xCMin < 0) {
                xCMin += dilationWidth;
              }
              const xCMax = Math.min(convInfo.inWidth, effectiveFilterWidth + xCCorner);
              let maxValue = Number.NEGATIVE_INFINITY;
              let maxPosition = -1;
              for (let xR = xRMin; xR < xRMax; xR += dilationHeight) {
                const wR = xR - xRCorner;
                for (let xC = xCMin; xC < xCMax; xC += dilationWidth) {
                  const wC = xC - xCCorner;
                  const pixel = xBuf.get(b, xR, xC, d);
                  if (pixel > maxValue) {
                    maxValue = pixel;
                    if (flattenPositions) {
                      maxPosition = includeBatchInIndex ? ((b * convInfo.inHeight + xR) * convInfo.inWidth + xC) * convInfo.inChannels + d : (xR * convInfo.inWidth + xC) * convInfo.inChannels + d;
                    } else {
                      maxPosition = wR * effectiveFilterWidth + wC;
                    }
                  }
                }
              }
              maxPositions.set(maxPosition, b, yR, yC, d);
            }
          }
        }
      }
      return maxPositions;
    }
    /**
     * @license
     * Copyright 2020 Google LLC. All Rights Reserved.
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     * http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     * =============================================================================
     */
    function avgPool$1(args) {
      const {inputs, backend: backend3, attrs} = args;
      const {x} = inputs;
      assertNotComplex(x, "avgPool");
      const {filterSize, strides, pad: pad3, dimRoundingMode} = attrs;
      const dilations = 1;
      assert2(eitherStridesOrDilationsAreOne2(strides, dilations), () => `Error in avgPool: Either strides or dilations must be 1. Got strides ${strides} and dilations '${dilations}'`);
      const convInfo = computePool2DInfo2(x.shape, filterSize, strides, dilations, pad3, dimRoundingMode);
      let res;
      if (convInfo.filterWidth === 1 && convInfo.filterHeight === 1 && arraysEqual2(convInfo.inShape, convInfo.outShape)) {
        res = identity$1({inputs: {x}, backend: backend3});
      } else {
        const xValues = backend3.data.get(x.dataId).values;
        const strides2 = computeStrides2(x.shape);
        const buffer3 = pool$1(xValues, x.shape, x.dtype, strides2, convInfo, "avg");
        res = backend3.makeTensorInfo(convInfo.outShape, x.dtype, buffer3.values);
      }
      return res;
    }
    const avgPoolConfig2 = {
      kernelName: AvgPool3,
      backendName: "cpu",
      kernelFunc: avgPool$1
    };
    /**
     * @license
     * Copyright 2020 Google LLC. All Rights Reserved.
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     * http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     * =============================================================================
     */
    function avgPoolBackprop$1(args) {
      const {inputs, backend: backend3, attrs} = args;
      const {dy, input: input2} = inputs;
      const x = input2;
      assertNotComplex([dy, input2], "avgPoolBackprop");
      const {filterSize, strides, pad: pad3} = attrs;
      const convInfo = computePool2DInfo2(x.shape, filterSize, strides, 1, pad3);
      const strideHeight = convInfo.strideHeight;
      const strideWidth = convInfo.strideWidth;
      const filterHeight = convInfo.filterHeight;
      const filterWidth = convInfo.filterWidth;
      const dilationHeight = convInfo.dilationHeight;
      const dilationWidth = convInfo.dilationWidth;
      const effectiveFilterHeight = convInfo.effectiveFilterHeight;
      const effectiveFilterWidth = convInfo.effectiveFilterWidth;
      const padLeft = effectiveFilterWidth - 1 - convInfo.padInfo.left;
      const padTop = effectiveFilterHeight - 1 - convInfo.padInfo.top;
      const dx = buffer2(x.shape, "float32");
      const avgMultiplier = 1 / (filterHeight * filterWidth);
      const dyData = backend3.data.get(dy.dataId).values;
      const dyBuf = buffer2(dy.shape, "float32", dyData);
      for (let b = 0; b < convInfo.batchSize; ++b) {
        for (let d = 0; d < convInfo.inChannels; ++d) {
          for (let dxR = 0; dxR < convInfo.inHeight; ++dxR) {
            for (let dxC = 0; dxC < convInfo.inWidth; ++dxC) {
              const dyRCorner = dxR - padTop;
              const dyCCorner = dxC - padLeft;
              let dotProd = 0;
              for (let wR = 0; wR < effectiveFilterHeight; wR += dilationHeight) {
                const dyR = (dyRCorner + wR) / strideHeight;
                if (dyR < 0 || dyR >= convInfo.outHeight || Math.floor(dyR) !== dyR) {
                  continue;
                }
                for (let wC = 0; wC < effectiveFilterWidth; wC += dilationWidth) {
                  const dyC = (dyCCorner + wC) / strideWidth;
                  if (dyC < 0 || dyC >= convInfo.outWidth || Math.floor(dyC) !== dyC) {
                    continue;
                  }
                  const pixel = dyBuf.get(b, dyR, dyC, d);
                  dotProd += pixel;
                }
              }
              dx.set(dotProd * avgMultiplier, b, dxR, dxC, d);
            }
          }
        }
      }
      return backend3.makeTensorInfo(dx.shape, dx.dtype, dx.values);
    }
    const avgPoolBackpropConfig = {
      kernelName: AvgPoolBackprop,
      backendName: "cpu",
      kernelFunc: avgPoolBackprop$1
    };
    /**
     * @license
     * Copyright 2020 Google LLC. All Rights Reserved.
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     * http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     * =============================================================================
     */
    function batchNorm$1(args) {
      const {inputs, backend: backend3, attrs} = args;
      const {x, scale: scale2, offset, mean: mean2, variance: variance2} = inputs;
      assert2(mean2.shape.length === variance2.shape.length, () => "Batch normalization gradient requires mean and variance to have equal ranks.");
      assert2(offset == null || mean2.shape.length === offset.shape.length, () => "Batch normalization gradient requires mean and offset to have equal ranks.");
      assert2(scale2 == null || mean2.shape.length === scale2.shape.length, () => "Batch normalization gradient requires mean and scale to have equal ranks.");
      assertNotComplex([x, mean2, variance2, scale2, offset], "batchNorm");
      let {varianceEpsilon} = attrs;
      if (varianceEpsilon == null) {
        varianceEpsilon = 1e-3;
      }
      const xVals = backend3.data.get(x.dataId).values;
      const mVals = backend3.data.get(mean2.dataId).values;
      const varVals = backend3.data.get(variance2.dataId).values;
      const sVals = scale2 ? backend3.data.get(scale2.dataId).values : new Float32Array([1]);
      const offVals = offset ? backend3.data.get(offset.dataId).values : new Float32Array([0]);
      const outVals = new Float32Array(xVals.length);
      const offValsLength = offVals.length;
      const sValsLength = sVals.length;
      const varValsLength = varVals.length;
      const mValsLength = mVals.length;
      let offi = 0;
      let mi = 0;
      let si = 0;
      let vi = 0;
      for (let i = 0; i < xVals.length; ++i) {
        outVals[i] = offVals[offi++] + (xVals[i] - mVals[mi++]) * sVals[si++] / Math.sqrt(varVals[vi++] + varianceEpsilon);
        if (offi >= offValsLength) {
          offi = 0;
        }
        if (mi >= mValsLength) {
          mi = 0;
        }
        if (si >= sValsLength) {
          si = 0;
        }
        if (vi >= varValsLength) {
          vi = 0;
        }
      }
      return backend3.makeTensorInfo(x.shape, x.dtype, outVals);
    }
    const batchNormConfig = {
      kernelName: FusedBatchNorm3,
      backendName: "cpu",
      kernelFunc: batchNorm$1
    };
    /**
     * @license
     * Copyright 2020 Google LLC. All Rights Reserved.
     * Licensed under the Apache License, Version 2.0 (the License);
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     * http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an AS IS BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     * =============================================================================
     */
    const clip2 = unaryKernelFunc(ClipByValue3, (xi, attrs) => {
      const clipAttrs = attrs;
      if (xi > clipAttrs.clipValueMax) {
        return clipAttrs.clipValueMax;
      }
      return xi < clipAttrs.clipValueMin ? clipAttrs.clipValueMin : xi;
    });
    const clipConfig = {
      kernelName: ClipByValue3,
      backendName: "cpu",
      kernelFunc: clip2
    };
    /**
     * @license
     * Copyright 2020 Google LLC. All Rights Reserved.
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     * http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     * =============================================================================
     */
    function imag$1(args) {
      const {inputs, backend: backend3} = args;
      const {input: input2} = inputs;
      const imag2 = backend3.data.get(input2.dataId).complexTensorInfos.imag;
      const imagVal = backend3.data.get(imag2.dataId).values;
      return backend3.makeTensorInfo(imag2.shape, imag2.dtype, imagVal);
    }
    const imagConfig = {
      kernelName: Imag,
      backendName: "cpu",
      kernelFunc: imag$1
    };
    /**
     * @license
     * Copyright 2020 Google LLC. All Rights Reserved.
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     * http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     * =============================================================================
     */
    function concat$1(args) {
      const {inputs, backend: backend3, attrs} = args;
      const {axis} = attrs;
      const $axis = parseAxisParam2(axis, inputs[0].shape)[0];
      let outShape = computeOutShape$1(inputs.map((t) => t.shape), $axis);
      if (sizeFromShape2(outShape) === 0) {
        return backend3.makeTensorInfo(outShape, inputs[0].dtype, []);
      }
      const $inputs = inputs.filter((t) => sizeFromShape2(t.shape) > 0);
      if ($inputs.length === 1) {
        return $inputs[0];
      }
      const shapes = $inputs.map((t) => t.shape);
      assertParamsConsistent2(shapes, $axis);
      if ($inputs[0].dtype === "complex64") {
        const reals = $inputs.map((t) => real$1({inputs: {input: t}, backend: backend3}));
        const imags = $inputs.map((t) => imag$1({inputs: {input: t}, backend: backend3}));
        const realConcated = concat$1({inputs: reals, backend: backend3, attrs: {axis: $axis}});
        const imagConcated = concat$1({inputs: imags, backend: backend3, attrs: {axis: $axis}});
        const result = complex$1({inputs: {real: realConcated, imag: imagConcated}, backend: backend3});
        reals.forEach((r) => backend3.disposeIntermediateTensorInfo(r));
        imags.forEach((i) => backend3.disposeIntermediateTensorInfo(i));
        backend3.disposeIntermediateTensorInfo(realConcated);
        backend3.disposeIntermediateTensorInfo(imagConcated);
        return result;
      }
      const inputs2D = $inputs.map((t) => {
        const innerSize = sizeFromShape2(t.shape.slice($axis));
        const shape = [-1, innerSize];
        return reshape$2({inputs: {x: t}, backend: backend3, attrs: {shape}});
      });
      outShape = computeOutShape$1(inputs2D.map((t) => t.shape), 1);
      const outVals = getTypedArrayFromDType2($inputs[0].dtype, sizeFromShape2(outShape));
      if (inputs2D[0].shape[0] === 1) {
        let offset = 0;
        inputs2D.forEach((t) => {
          const val = backend3.data.get(t.dataId).values;
          const size = sizeFromShape2(t.shape);
          outVals.set(val, offset);
          offset += size;
        });
      } else {
        let colOffset = 0;
        inputs2D.forEach((t) => {
          const tVals = backend3.data.get(t.dataId).values;
          let tIdx = 0;
          for (let row = 0; row < t.shape[0]; ++row) {
            const resIdx = row * outShape[1] + colOffset;
            for (let col = 0; col < t.shape[1]; ++col) {
              outVals[resIdx + col] = tVals[tIdx++];
            }
          }
          colOffset += t.shape[1];
        });
      }
      const finalOutShape = computeOutShape$1($inputs.map((t) => t.shape), $axis);
      const outInfo = backend3.makeTensorInfo(finalOutShape, inputs[0].dtype, outVals);
      inputs2D.forEach((t) => backend3.disposeIntermediateTensorInfo(t));
      return outInfo;
    }
    const concatConfig2 = {
      kernelName: Concat3,
      backendName: "cpu",
      kernelFunc: concat$1
    };
    /**
     * @license
     * Copyright 2020 Google LLC. All Rights Reserved.
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     * http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     * =============================================================================
     */
    function conv2D(args) {
      const {inputs, backend: backend3, attrs} = args;
      const {x, filter} = inputs;
      const {strides, pad: pad3, dataFormat, dilations, dimRoundingMode} = attrs;
      assertNotComplex([x, filter], "conv2d");
      const $dataFormat = convertConv2DDataFormat2(dataFormat);
      const convInfo = computeConv2DInfo2(x.shape, filter.shape, strides, dilations, pad3, dimRoundingMode, false, $dataFormat);
      const filterHeight = convInfo.filterHeight;
      const filterWidth = convInfo.filterWidth;
      const dilationHeight = convInfo.dilationHeight;
      const dilationWidth = convInfo.dilationWidth;
      const padLeft = convInfo.padInfo.left;
      const padTop = convInfo.padInfo.top;
      const isChannelsLast = convInfo.dataFormat === "channelsLast";
      const y = new TensorBuffer2(convInfo.outShape, x.dtype);
      const xStrides = computeStrides2(x.shape);
      const filterStrides = computeStrides2(filter.shape);
      const xBatchStride = xStrides[0];
      const xRowStride = isChannelsLast ? xStrides[1] : xStrides[2];
      const xColStride = isChannelsLast ? xStrides[2] : 1;
      const xChannelStride = isChannelsLast ? 1 : xStrides[1];
      const yBatchStride = y.strides[0];
      const yRowStride = isChannelsLast ? y.strides[1] : y.strides[2];
      const yColStride = isChannelsLast ? y.strides[2] : 1;
      const yChannelStride = isChannelsLast ? 1 : y.strides[1];
      const xVals = backend3.data.get(x.dataId).values;
      const wVals = backend3.data.get(filter.dataId).values;
      const yVals = y.values;
      for (let b = 0; b < convInfo.batchSize; ++b) {
        const xOffset1 = b * xBatchStride;
        const yOffset1 = b * yBatchStride;
        for (let yR = 0; yR < convInfo.outHeight; ++yR) {
          const yOffset2 = yOffset1 + yR * yRowStride;
          const xRCorner = yR * convInfo.strideHeight - padTop;
          for (let wR = 0; wR < filterHeight; ++wR) {
            const xR = xRCorner + wR * dilationHeight;
            if (xR < 0 || xR >= convInfo.inHeight) {
              continue;
            }
            const wOffset1 = wR * filterStrides[0];
            const xOffset2 = xOffset1 + xR * xRowStride;
            for (let yC = 0; yC < convInfo.outWidth; ++yC) {
              const yOffset3 = yOffset2 + yC * yColStride;
              const xCCorner = yC * convInfo.strideWidth - padLeft;
              for (let wC = 0; wC < filterWidth; ++wC) {
                const xC = xCCorner + wC * dilationWidth;
                if (xC < 0 || xC >= convInfo.inWidth) {
                  continue;
                }
                const wOffset2 = wOffset1 + wC * filterStrides[1];
                const xOffset3 = xOffset2 + xC * xColStride;
                let wOffset3 = wOffset2;
                for (let d1 = 0; d1 < convInfo.inChannels; ++d1) {
                  const xVal = xVals[xOffset3 + d1 * xChannelStride];
                  for (let d2 = 0; d2 < convInfo.outChannels; ++d2) {
                    yVals[yOffset3 + d2 * yChannelStride] += xVal * wVals[wOffset3 + d2];
                  }
                  wOffset3 += convInfo.outChannels;
                }
              }
            }
          }
        }
      }
      return backend3.makeTensorInfo(y.shape, y.dtype, yVals);
    }
    const conv2DConfig2 = {
      kernelName: Conv2D3,
      backendName: "cpu",
      kernelFunc: conv2D
    };
    /**
     * @license
     * Copyright 2020 Google LLC. All Rights Reserved.
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     * http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     * =============================================================================
     */
    function conv2DBackpropFilter$1(args) {
      const {inputs, backend: backend3, attrs} = args;
      const {x, dy} = inputs;
      const {strides, pad: pad3, dataFormat, dimRoundingMode, filterShape} = attrs;
      assertNotComplex([x, dy], "conv2dBackpropFilter");
      const $dataFormat = convertConv2DDataFormat2(dataFormat);
      const convInfo = computeConv2DInfo2(x.shape, filterShape, strides, 1, pad3, dimRoundingMode, false, $dataFormat);
      const {strideHeight, strideWidth, filterHeight, filterWidth} = convInfo;
      const isChannelsLast = convInfo.dataFormat === "channelsLast";
      const dW = new TensorBuffer2(convInfo.filterShape, "float32");
      const leftPad = convInfo.padInfo.left;
      const topPad = convInfo.padInfo.top;
      const xVals = backend3.data.get(x.dataId).values;
      const dyVals = backend3.data.get(dy.dataId).values;
      const xBuf = new TensorBuffer2(x.shape, x.dtype, xVals);
      const dyBuf = new TensorBuffer2(dy.shape, dy.dtype, dyVals);
      for (let wR = 0; wR < filterHeight; ++wR) {
        const yRMin = Math.max(0, Math.ceil((topPad - wR) / strideHeight));
        const yRMax = Math.min(convInfo.outHeight, (convInfo.inHeight + topPad - wR) / strideHeight);
        for (let wC = 0; wC < filterWidth; ++wC) {
          const yCMin = Math.max(0, Math.ceil((leftPad - wC) / strideWidth));
          const yCMax = Math.min(convInfo.outWidth, (convInfo.inWidth + leftPad - wC) / strideWidth);
          for (let d1 = 0; d1 < convInfo.inChannels; ++d1) {
            for (let d2 = 0; d2 < convInfo.outChannels; ++d2) {
              let dotProd = 0;
              for (let b = 0; b < convInfo.batchSize; ++b) {
                for (let yR = yRMin; yR < yRMax; ++yR) {
                  const xR = wR + yR * strideHeight - topPad;
                  for (let yC = yCMin; yC < yCMax; ++yC) {
                    const xC = wC + yC * strideWidth - leftPad;
                    if (isChannelsLast) {
                      dotProd += xBuf.get(b, xR, xC, d1) * dyBuf.get(b, yR, yC, d2);
                    } else {
                      dotProd += xBuf.get(b, d1, xR, xC) * dyBuf.get(b, d2, yR, yC);
                    }
                  }
                }
              }
              dW.set(dotProd, wR, wC, d1, d2);
            }
          }
        }
      }
      return backend3.makeTensorInfo(dW.shape, dW.dtype, dW.values);
    }
    const conv2DBackpropFilterConfig = {
      kernelName: Conv2DBackpropFilter,
      backendName: "cpu",
      kernelFunc: conv2DBackpropFilter$1
    };
    /**
     * @license
     * Copyright 2020 Google LLC. All Rights Reserved.
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     * http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     * =============================================================================
     */
    function conv2DBackpropInput$1(args) {
      const {inputs, backend: backend3, attrs} = args;
      const {dy, filter} = inputs;
      const {inputShape, strides, pad: pad3, dataFormat, dimRoundingMode} = attrs;
      assertNotComplex([dy, filter], "conv2dBackpropInput");
      const filterStrides = computeStrides2(filter.shape);
      const dyStrides = computeStrides2(dy.shape);
      let $dataFormat = convertConv2DDataFormat2(dataFormat);
      const convInfo = computeConv2DInfo2(inputShape, filter.shape, strides, 1, pad3, dimRoundingMode, false, $dataFormat);
      const dx = new TensorBuffer2(convInfo.inShape, "float32");
      const dxValues = dx.values;
      const dyValues = backend3.data.get(dy.dataId).values;
      const fltValues = backend3.data.get(filter.dataId).values;
      const [fltS0, fltS1, fltS2] = filterStrides;
      const {batchSize, filterHeight, filterWidth, inChannels, inHeight, inWidth, outChannels, outHeight, outWidth, strideHeight, strideWidth} = convInfo;
      $dataFormat = convInfo.dataFormat;
      const topPad = filterHeight - 1 - convInfo.padInfo.top;
      const leftPad = filterWidth - 1 - convInfo.padInfo.left;
      const isChannelsLast = $dataFormat === "channelsLast";
      const xBatchStride = dx.strides[0];
      const xRowStride = isChannelsLast ? dx.strides[1] : dx.strides[2];
      const xColStride = isChannelsLast ? dx.strides[2] : 1;
      const xChannelStride = isChannelsLast ? 1 : dx.strides[1];
      const yBatchStride = dyStrides[0];
      const yRowStride = isChannelsLast ? dyStrides[1] : dyStrides[2];
      const yColStride = isChannelsLast ? dyStrides[2] : 1;
      const yChannelStride = isChannelsLast ? 1 : dyStrides[1];
      for (let b = 0; b < batchSize; ++b) {
        for (let d1 = 0; d1 < inChannels; ++d1) {
          for (let xR = 0; xR < inHeight; ++xR) {
            const xRCorner = xR - topPad;
            const xRMin = Math.max(0, Math.ceil(xRCorner / strideHeight));
            const yRMax = Math.min(outHeight, (filterHeight + xRCorner) / strideHeight);
            for (let xC = 0; xC < inWidth; ++xC) {
              const xCCorner = xC - leftPad;
              const xCMin = Math.max(0, Math.ceil(xCCorner / strideWidth));
              const yCMax = Math.min(outWidth, (filterWidth + xCCorner) / strideWidth);
              let dotProd = 0;
              for (let yR = xRMin; yR < yRMax; ++yR) {
                const wR = yR * strideHeight - xRCorner;
                for (let yC = xCMin; yC < yCMax; ++yC) {
                  const wC = yC * strideWidth - xCCorner;
                  const dyOffset = yBatchStride * b + yRowStride * yR + yColStride * yC;
                  const fltOffset = fltS0 * (filterHeight - 1 - wR) + fltS1 * (filterWidth - 1 - wC) + fltS2 * d1;
                  for (let d2 = 0; d2 < outChannels; ++d2) {
                    const pixel = dyValues[dyOffset + yChannelStride * d2];
                    const weight = fltValues[fltOffset + d2];
                    dotProd += pixel * weight;
                  }
                }
              }
              const dxOffset = xBatchStride * b + xRowStride * xR + xColStride * xC + xChannelStride * d1;
              dxValues[dxOffset] = dotProd;
            }
          }
        }
      }
      return backend3.makeTensorInfo(dx.shape, dx.dtype, dx.values);
    }
    const conv2DBackpropInputConfig2 = {
      kernelName: Conv2DBackpropInput3,
      backendName: "cpu",
      kernelFunc: conv2DBackpropInput$1
    };
    /**
     * @license
     * Copyright 2020 Google LLC. All Rights Reserved.
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     * http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     * =============================================================================
     */
    function conv3D(args) {
      const {inputs, backend: backend3, attrs} = args;
      const {x, filter} = inputs;
      const {strides, pad: pad3, dilations} = attrs;
      assertNotComplex([x, filter], "conv3d");
      const convInfo = computeConv3DInfo2(x.shape, filter.shape, strides, dilations, pad3);
      const {filterDepth, filterHeight, filterWidth, dilationDepth, dilationHeight, dilationWidth, padInfo} = convInfo;
      const padFront = padInfo.front;
      const padLeft = padInfo.left;
      const padTop = padInfo.top;
      const y = new TensorBuffer2(convInfo.outShape, x.dtype);
      const xVals = backend3.data.get(x.dataId).values;
      const wVals = backend3.data.get(filter.dataId).values;
      const yVals = y.values;
      const xStrides = computeStrides2(x.shape);
      const filterStrides = computeStrides2(filter.shape);
      for (let b = 0; b < convInfo.batchSize; ++b) {
        const xOffset1 = b * xStrides[0];
        const yOffset1 = b * y.strides[0];
        for (let yF = 0; yF < convInfo.outDepth; ++yF) {
          const yOffset2 = yOffset1 + yF * y.strides[1];
          const xFCorner = yF * convInfo.strideDepth - padFront;
          for (let wF = 0; wF < filterDepth; ++wF) {
            const xF = xFCorner + wF * dilationDepth;
            if (xF < 0 || xF >= convInfo.inDepth) {
              continue;
            }
            const wOffset1 = wF * filterStrides[0];
            const xOffset2 = xOffset1 + xF * xStrides[1];
            for (let yR = 0; yR < convInfo.outHeight; ++yR) {
              const yOffset3 = yOffset2 + yR * y.strides[2];
              const xRCorner = yR * convInfo.strideHeight - padTop;
              for (let wR = 0; wR < filterHeight; ++wR) {
                const xR = xRCorner + wR * dilationHeight;
                if (xR < 0 || xR >= convInfo.inHeight) {
                  continue;
                }
                const wOffset2 = wOffset1 + wR * filterStrides[1];
                const xOffset3 = xOffset2 + xR * xStrides[2];
                for (let yC = 0; yC < convInfo.outWidth; ++yC) {
                  const yOffset4 = yOffset3 + yC * convInfo.outChannels;
                  const xCCorner = yC * convInfo.strideWidth - padLeft;
                  for (let wC = 0; wC < filterWidth; ++wC) {
                    const xC = xCCorner + wC * dilationWidth;
                    if (xC < 0 || xC >= convInfo.inWidth) {
                      continue;
                    }
                    const wOffset3 = wOffset2 + wC * filterStrides[2];
                    const xOffset4 = xOffset3 + xC * convInfo.inChannels;
                    let wOffset4 = wOffset3;
                    for (let d1 = 0; d1 < convInfo.inChannels; ++d1) {
                      const xVal = xVals[xOffset4 + d1];
                      for (let d2 = 0; d2 < convInfo.outChannels; ++d2) {
                        yVals[yOffset4 + d2] += xVal * wVals[wOffset4 + d2];
                      }
                      wOffset4 += convInfo.outChannels;
                    }
                  }
                }
              }
            }
          }
        }
      }
      return backend3.makeTensorInfo(y.shape, y.dtype, y.values);
    }
    const conv3DConfig = {
      kernelName: Conv3D,
      backendName: "cpu",
      kernelFunc: conv3D
    };
    /**
     * @license
     * Copyright 2020 Google LLC. All Rights Reserved.
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     * http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     * =============================================================================
     */
    function conv3DBackpropFilterV2(args) {
      const {inputs, backend: backend3, attrs} = args;
      const {x, dy} = inputs;
      const {strides, pad: pad3, filterShape} = attrs;
      assertNotComplex([x, dy], "conv3dBackpropFilterV2");
      const xStrides = computeStrides2(x.shape);
      const dyStrides = computeStrides2(dy.shape);
      const convInfo = computeConv3DInfo2(x.shape, filterShape, strides, 1, pad3);
      const strideDepth = convInfo.strideDepth;
      const strideHeight = convInfo.strideHeight;
      const strideWidth = convInfo.strideWidth;
      const filterDepth = convInfo.filterDepth;
      const filterHeight = convInfo.filterHeight;
      const filterWidth = convInfo.filterWidth;
      const dw = new TensorBuffer2(convInfo.filterShape, "float32");
      const dwValues = dw.values;
      const [dwS0, dwS1, dwS2, dwS3] = dw.strides;
      const dyValues = backend3.data.get(dy.dataId).values;
      const [dyS0, dyS1, dyS2, dyS3] = dyStrides;
      const xValues = backend3.data.get(x.dataId).values;
      const [xS0, xS1, xS2, xS3] = xStrides;
      const frontPad = convInfo.padInfo.front;
      const leftPad = convInfo.padInfo.left;
      const topPad = convInfo.padInfo.top;
      for (let wF = 0; wF < filterDepth; ++wF) {
        const yFMin = Math.max(0, Math.ceil((frontPad - wF) / strideDepth));
        const yFMax = Math.min(convInfo.outDepth, (convInfo.inDepth + frontPad - wF) / strideDepth);
        const wOffset1 = wF * dwS0;
        for (let wR = 0; wR < filterHeight; ++wR) {
          const yRMin = Math.max(0, Math.ceil((topPad - wR) / strideHeight));
          const yRMax = Math.min(convInfo.outHeight, (convInfo.inHeight + topPad - wR) / strideHeight);
          const wOffset2 = wR * dwS1 + wOffset1;
          for (let wC = 0; wC < filterWidth; ++wC) {
            const yCMin = Math.max(0, Math.ceil((leftPad - wC) / strideWidth));
            const yCMax = Math.min(convInfo.outWidth, (convInfo.inWidth + leftPad - wC) / strideWidth);
            const wOffset3 = wC * dwS2 + wOffset2;
            for (let d1 = 0; d1 < convInfo.inChannels; ++d1) {
              const wOffset4 = d1 * dwS3 + wOffset3;
              for (let d2 = 0; d2 < convInfo.outChannels; ++d2) {
                let dotProd = 0;
                for (let b = 0; b < convInfo.batchSize; ++b) {
                  const xOffset1 = b * xS0;
                  const yOffset1 = b * dyS0;
                  for (let yF = yFMin; yF < yFMax; ++yF) {
                    const xF = wF + yF * strideDepth - frontPad;
                    const xOffset2 = xF * xS1 + xOffset1;
                    const yOffset2 = yF * dyS1 + yOffset1;
                    for (let yR = yRMin; yR < yRMax; ++yR) {
                      const xR = wR + yR * strideHeight - topPad;
                      const xOffset3 = xR * xS2 + xOffset2;
                      const yOffset3 = yR * dyS2 + yOffset2;
                      for (let yC = yCMin; yC < yCMax; ++yC) {
                        const xC = wC + yC * strideWidth - leftPad;
                        const xOffset4 = xC * xS3 + xOffset3;
                        const yOffset4 = yC * dyS3 + yOffset3;
                        dotProd += xValues[xOffset4 + d1] * dyValues[yOffset4 + d2];
                      }
                    }
                  }
                }
                dwValues[wOffset4 + d2] = dotProd;
              }
            }
          }
        }
      }
      return backend3.makeTensorInfo(dw.shape, dw.dtype, dw.values);
    }
    const conv3DBackpropFilterV2Config = {
      kernelName: Conv3DBackpropFilterV2,
      backendName: "cpu",
      kernelFunc: conv3DBackpropFilterV2
    };
    /**
     * @license
     * Copyright 2020 Google LLC. All Rights Reserved.
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     * http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     * =============================================================================
     */
    function conv3DBackpropInputV2(args) {
      const {inputs, backend: backend3, attrs} = args;
      const {dy, filter} = inputs;
      const {pad: pad3, strides, inputShape} = attrs;
      assertNotComplex([dy], "conv3dBackpropInputV2");
      const dyStrides = computeStrides2(dy.shape);
      const filterStrides = computeStrides2(filter.shape);
      const convInfo = computeConv3DInfo2(inputShape, filter.shape, strides, 1, pad3);
      const dx = new TensorBuffer2(convInfo.inShape, "float32");
      const dxValues = dx.values;
      const [dxS0, dxS1, dxS2, dxS3] = dx.strides;
      const dyValues = backend3.data.get(dy.dataId).values;
      const [dyS0, dyS1, dyS2, dyS3] = dyStrides;
      const fltValues = backend3.data.get(filter.dataId).values;
      const [fltS0, fltS1, fltS2, fltS3] = filterStrides;
      const {batchSize, filterDepth, filterHeight, filterWidth, inChannels, inDepth, inHeight, inWidth, outChannels, outDepth, outHeight, outWidth, strideDepth, strideHeight, strideWidth} = convInfo;
      const frontPad = filterDepth - 1 - convInfo.padInfo.front;
      const topPad = filterHeight - 1 - convInfo.padInfo.top;
      const leftPad = filterWidth - 1 - convInfo.padInfo.left;
      for (let b = 0; b < batchSize; ++b) {
        for (let d1 = 0; d1 < inChannels; ++d1) {
          for (let xF = 0; xF < inDepth; ++xF) {
            const xFCorner = xF - frontPad;
            const xFMin = Math.max(0, Math.ceil(xFCorner / strideDepth));
            const yFMax = Math.min(outDepth, (filterDepth + xFCorner) / strideDepth);
            for (let xR = 0; xR < inHeight; ++xR) {
              const xRCorner = xR - topPad;
              const xRMin = Math.max(0, Math.ceil(xRCorner / strideHeight));
              const yRMax = Math.min(outHeight, (filterHeight + xRCorner) / strideHeight);
              for (let xC = 0; xC < inWidth; ++xC) {
                const xCCorner = xC - leftPad;
                const xCMin = Math.max(0, Math.ceil(xCCorner / strideWidth));
                const yCMax = Math.min(outWidth, (filterWidth + xCCorner) / strideWidth);
                let dotProd = 0;
                for (let yF = xFMin; yF < yFMax; ++yF) {
                  const wF = yF * strideDepth - xFCorner;
                  for (let yR = xRMin; yR < yRMax; ++yR) {
                    const wR = yR * strideHeight - xRCorner;
                    for (let yC = xCMin; yC < yCMax; ++yC) {
                      const wC = yC * strideWidth - xCCorner;
                      const dyOffset = dyS0 * b + dyS1 * yF + dyS2 * yR + dyS3 * yC;
                      const fltOffset = fltS0 * (filterDepth - 1 - wF) + fltS1 * (filterHeight - 1 - wR) + fltS2 * (filterWidth - 1 - wC) + fltS3 * d1;
                      for (let d2 = 0; d2 < outChannels; ++d2) {
                        const pixel = dyValues[dyOffset + d2];
                        const weight = fltValues[fltOffset + d2];
                        dotProd += pixel * weight;
                      }
                    }
                  }
                }
                dxValues[dxS0 * b + dxS1 * xF + dxS2 * xR + dxS3 * xC + d1] = dotProd;
              }
            }
          }
        }
      }
      return backend3.makeTensorInfo(dx.shape, dx.dtype, dx.values);
    }
    const conv3DBackpropInputV2Config = {
      kernelName: Conv3DBackpropInputV2,
      backendName: "cpu",
      kernelFunc: conv3DBackpropInputV2
    };
    /**
     * @license
     * Copyright 2020 Google LLC. All Rights Reserved.
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     * http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     * =============================================================================
     */
    const cos$1 = unaryKernelFunc(Cos3, (xi) => Math.cos(xi));
    const cosConfig2 = {
      kernelName: Cos3,
      backendName: "cpu",
      kernelFunc: cos$1
    };
    /**
     * @license
     * Copyright 2020 Google LLC. All Rights Reserved.
     * Licensed under the Apache License, Version 2.0 (the License);
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     * http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an AS IS BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     * =============================================================================
     */
    const cosh$1 = unaryKernelFunc(Cosh, (xi) => Math.cosh(xi));
    const coshConfig = {
      kernelName: Cosh,
      backendName: "cpu",
      kernelFunc: cosh$1
    };
    /**
     * @license
     * Copyright 2020 Google LLC. All Rights Reserved.
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     * http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     * =============================================================================
     */
    function depthwiseConv2dNative(args) {
      const {inputs, backend: backend3, attrs} = args;
      const {x, filter} = inputs;
      const {strides, pad: pad3, dilations, dimRoundingMode} = attrs;
      assertNotComplex([x, filter], "depthwiseConv2DNative");
      const xStrides = computeStrides2(x.shape);
      const filterStrides = computeStrides2(filter.shape);
      let $dilations = dilations;
      if ($dilations == null) {
        $dilations = [1, 1];
      }
      assert2(eitherStridesOrDilationsAreOne2(strides, $dilations), () => `Error in depthwiseConv2d: Either strides or dilations must be 1. Got strides ${strides} and dilations '${$dilations}'`);
      const convInfo = computeConv2DInfo2(x.shape, filter.shape, strides, $dilations, pad3, dimRoundingMode, true);
      const {filterHeight, filterWidth, dilationHeight, dilationWidth, padInfo} = convInfo;
      const padLeft = padInfo.left;
      const padTop = padInfo.top;
      const chMul = convInfo.outChannels / convInfo.inChannels;
      const y = new TensorBuffer2(convInfo.outShape, x.dtype);
      const xVals = backend3.data.get(x.dataId).values;
      const wVals = backend3.data.get(filter.dataId).values;
      const yVals = y.values;
      for (let b = 0; b < convInfo.batchSize; ++b) {
        const xOffset1 = b * xStrides[0];
        const yOffset1 = b * y.strides[0];
        for (let yR = 0; yR < convInfo.outHeight; ++yR) {
          const yOffset2 = yOffset1 + yR * y.strides[1];
          const xRCorner = yR * convInfo.strideHeight - padLeft;
          for (let wR = 0; wR < filterHeight; ++wR) {
            const xR = xRCorner + wR * dilationHeight;
            if (xR < 0 || xR >= convInfo.inHeight) {
              continue;
            }
            const wOffset1 = wR * filterStrides[0];
            const xOffset2 = xOffset1 + xR * xStrides[1];
            for (let yC = 0; yC < convInfo.outWidth; ++yC) {
              const yOffset3 = yOffset2 + yC * y.strides[2];
              const xCCorner = yC * convInfo.strideWidth - padTop;
              for (let wC = 0; wC < filterWidth; ++wC) {
                const xC = xCCorner + wC * dilationWidth;
                if (xC < 0 || xC >= convInfo.inWidth) {
                  continue;
                }
                const wOffset2 = wOffset1 + wC * filterStrides[1];
                const xOffset3 = xOffset2 + xC * convInfo.inChannels;
                let yOffset4 = yOffset3;
                let wOffset3 = wOffset2;
                for (let d1 = 0; d1 < convInfo.inChannels; ++d1) {
                  const xVal = xVals[xOffset3 + d1];
                  for (let q = 0; q < chMul; ++q) {
                    yVals[yOffset4 + q] += xVal * wVals[wOffset3 + q];
                  }
                  yOffset4 += chMul;
                  wOffset3 += chMul;
                }
              }
            }
          }
        }
      }
      return backend3.makeTensorInfo(y.shape, y.dtype, y.values);
    }
    const depthwiseConv2dNativeConfig2 = {
      kernelName: DepthwiseConv2dNative3,
      backendName: "cpu",
      kernelFunc: depthwiseConv2dNative
    };
    /**
     * @license
     * Copyright 2020 Google LLC. All Rights Reserved.
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     * http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     * =============================================================================
     */
    function depthwiseConv2dNativeBackpropFilter$1(args) {
      const {inputs, backend: backend3, attrs} = args;
      const {x, dy} = inputs;
      const {strides, dilations, pad: pad3, dimRoundingMode, filterShape} = attrs;
      assertNotComplex([x, dy], "depthwiseConv2dNativeBackpropFilter");
      const convInfo = computeConv2DInfo2(x.shape, filterShape, strides, dilations, pad3, dimRoundingMode, true);
      const {strideHeight, strideWidth, filterHeight, filterWidth} = convInfo;
      const dW = new TensorBuffer2(convInfo.filterShape, "float32");
      const leftPad = convInfo.padInfo.left;
      const topPad = convInfo.padInfo.top;
      const chMul = convInfo.outChannels / convInfo.inChannels;
      const xVals = backend3.data.get(x.dataId).values;
      const xBuf = new TensorBuffer2(x.shape, x.dtype, xVals);
      const dyVals = backend3.data.get(dy.dataId).values;
      const dyBuf = new TensorBuffer2(dy.shape, dy.dtype, dyVals);
      for (let wR = 0; wR < filterHeight; ++wR) {
        const yRMin = Math.max(0, Math.ceil((topPad - wR) / strideHeight));
        const yRMax = Math.min(convInfo.outHeight, (convInfo.inHeight + topPad - wR) / strideHeight);
        for (let wC = 0; wC < filterWidth; ++wC) {
          const yCMin = Math.max(0, Math.ceil((leftPad - wC) / strideWidth));
          const yCMax = Math.min(convInfo.outWidth, (convInfo.inWidth + leftPad - wC) / strideWidth);
          for (let d2 = 0; d2 < convInfo.outChannels; ++d2) {
            const d1 = Math.trunc(d2 / chMul);
            const dm = d2 % chMul;
            let dotProd = 0;
            for (let b = 0; b < convInfo.batchSize; ++b) {
              for (let yR = yRMin; yR < yRMax; ++yR) {
                const xR = wR + yR * strideHeight - topPad;
                for (let yC = yCMin; yC < yCMax; ++yC) {
                  const xC = wC + yC * strideWidth - leftPad;
                  dotProd += xBuf.get(b, xR, xC, d1) * dyBuf.get(b, yR, yC, d2);
                }
              }
            }
            dW.set(dotProd, wR, wC, d1, dm);
          }
        }
      }
      return backend3.makeTensorInfo(dW.shape, dW.dtype, dW.values);
    }
    const depthwiseConv2dNativeBackpropFilterConfig = {
      kernelName: DepthwiseConv2dNativeBackpropFilter,
      backendName: "cpu",
      kernelFunc: depthwiseConv2dNativeBackpropFilter$1
    };
    /**
     * @license
     * Copyright 2020 Google LLC. All Rights Reserved.
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     * http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     * =============================================================================
     */
    function depthwiseConv2dNativeBackpropInput$1(args) {
      const {inputs, backend: backend3, attrs} = args;
      const {dy, filter} = inputs;
      const {strides, dilations, pad: pad3, dimRoundingMode, inputShape} = attrs;
      assertNotComplex([dy, filter], "depthwiseConv2DNativeBackpropInput");
      const dyStrides = computeStrides2(dy.shape);
      const filterStrides = computeStrides2(filter.shape);
      const convInfo = computeConv2DInfo2(inputShape, filter.shape, strides, dilations, pad3, dimRoundingMode, true);
      const dx = new TensorBuffer2(convInfo.inShape, "float32");
      const dxValues = dx.values;
      const [dxS0, dxS1, dxS2] = dx.strides;
      const dyValues = backend3.data.get(dy.dataId).values;
      const [dyS0, dyS1, dyS2] = dyStrides;
      const fltValues = backend3.data.get(filter.dataId).values;
      const [fltS0, fltS1, fltS2] = filterStrides;
      const {batchSize, filterHeight, filterWidth, inChannels, inHeight, inWidth, outChannels, outHeight, outWidth, strideHeight, strideWidth} = convInfo;
      const topPad = filterHeight - 1 - convInfo.padInfo.top;
      const leftPad = filterWidth - 1 - convInfo.padInfo.left;
      const chMul = outChannels / inChannels;
      for (let b = 0; b < batchSize; ++b) {
        for (let d1 = 0; d1 < inChannels; ++d1) {
          for (let xR = 0; xR < inHeight; ++xR) {
            const xRCorner = xR - topPad;
            const xRMin = Math.max(0, Math.ceil(xRCorner / strideHeight));
            const yRMax = Math.min(outHeight, (filterHeight + xRCorner) / strideHeight);
            for (let xC = 0; xC < inWidth; ++xC) {
              const xCCorner = xC - leftPad;
              const xCMin = Math.max(0, Math.ceil(xCCorner / strideWidth));
              const yCMax = Math.min(outWidth, (filterWidth + xCCorner) / strideWidth);
              let dotProd = 0;
              for (let yR = xRMin; yR < yRMax; ++yR) {
                const wR = yR * strideHeight - xRCorner;
                for (let yC = xCMin; yC < yCMax; ++yC) {
                  const wC = yC * strideWidth - xCCorner;
                  const dyOffset = dyS0 * b + dyS1 * yR + dyS2 * yC;
                  const fltOffset = fltS0 * (filterHeight - 1 - wR) + fltS1 * (filterWidth - 1 - wC) + fltS2 * d1;
                  for (let dm = 0; dm < chMul; ++dm) {
                    const d2 = d1 * chMul + dm;
                    const pixel = dyValues[dyOffset + d2];
                    const weight = fltValues[fltOffset + dm];
                    dotProd += pixel * weight;
                  }
                }
              }
              dxValues[dxS0 * b + dxS1 * xR + dxS2 * xC + d1] = dotProd;
            }
          }
        }
      }
      return backend3.makeTensorInfo(dx.shape, dx.dtype, dx.values);
    }
    const depthwiseConv2dNativeBackpropInputConfig = {
      kernelName: DepthwiseConv2dNativeBackpropInput,
      backendName: "cpu",
      kernelFunc: depthwiseConv2dNativeBackpropInput$1
    };
    /**
     * @license
     * Copyright 2020 Google LLC. All Rights Reserved.
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     * http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     * =============================================================================
     */
    const dilation2dConfig = {
      kernelName: Dilation2D,
      backendName: "cpu",
      kernelFunc: ({inputs, backend: backend3, attrs}) => {
        const {x, filter} = inputs;
        const {strides, pad: pad3, dilations} = attrs;
        const cpuBackend = backend3;
        const xVals = cpuBackend.data.get(x.dataId).values;
        const xRank = x.shape.length;
        const filterVals = cpuBackend.data.get(filter.dataId).values;
        const filterRank = filter.shape.length;
        const {batchSize, inHeight, inWidth, inChannels, outHeight, outWidth, padInfo, strideHeight, strideWidth, filterHeight, filterWidth, dilationHeight, dilationWidth, outShape} = computeDilation2DInfo2(x.shape, filter.shape, strides, pad3, "NHWC", dilations);
        const outSize = sizeFromShape2(outShape);
        const outRank = outShape.length;
        const outputVals = getArrayFromDType2(x.dtype, outSize);
        for (let b = 0; b < batchSize; ++b) {
          for (let hOut = 0; hOut < outHeight; ++hOut) {
            const hBeg = hOut * strideHeight - padInfo.top;
            for (let wOut = 0; wOut < outWidth; ++wOut) {
              const wBeg = wOut * strideWidth - padInfo.left;
              for (let d = 0; d < inChannels; ++d) {
                let curVal = Number.MIN_SAFE_INTEGER;
                for (let h = 0; h < filterHeight; ++h) {
                  const hIn = hBeg + h * dilationHeight;
                  if (hIn >= 0 && hIn < inHeight) {
                    for (let w = 0; w < filterWidth; ++w) {
                      const wIn = wBeg + w * dilationWidth;
                      if (wIn >= 0 && wIn < inWidth) {
                        const xIndex = locToIndex2([b, hIn, wIn, d], xRank, computeStrides2(x.shape));
                        const filterIndex = locToIndex2([h, w, d], filterRank, computeStrides2(filter.shape));
                        const val = xVals[xIndex] + filterVals[filterIndex];
                        if (val > curVal) {
                          curVal = val;
                        }
                      }
                    }
                  }
                }
                const outputIndex = locToIndex2([b, hOut, wOut, d], outRank, computeStrides2(outShape));
                outputVals[outputIndex] = curVal;
              }
            }
          }
        }
        const dataId = cpuBackend.write(toTypedArray2(outputVals, x.dtype), outShape, x.dtype);
        return {dataId, shape: outShape, dtype: x.dtype};
      }
    };
    /**
     * @license
     * Copyright 2020 Google LLC. All Rights Reserved.
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     * http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     * =============================================================================
     */
    const dilation2dBackpropFilterConfig = {
      kernelName: Dilation2DBackpropFilter,
      backendName: "cpu",
      kernelFunc: ({inputs, backend: backend3, attrs}) => {
        const {x, filter, dy} = inputs;
        const {strides, pad: pad3, dilations} = attrs;
        const cpuBackend = backend3;
        const $x = toNestedArray2(x.shape, cpuBackend.data.get(x.dataId).values);
        const $filter = toNestedArray2(filter.shape, cpuBackend.data.get(filter.dataId).values);
        const {batchSize, inHeight, inWidth, inChannels, outHeight, outWidth, padInfo, strideHeight, strideWidth, filterHeight, filterWidth, dilationHeight, dilationWidth, outShape} = computeDilation2DInfo2(x.shape, filter.shape, strides, pad3, "NHWC", dilations);
        assert2(dy.rank === outShape.length, () => `Error in ${Dilation2DBackpropFilter}, dy must have the same rank as output ${outShape.length}, but got ${dy.rank}`);
        const $dy = toNestedArray2(outShape, cpuBackend.data.get(dy.dataId).values);
        const gradients2 = makeZerosNestedTypedArray2(filter.shape, filter.dtype);
        for (let b = 0; b < batchSize; ++b) {
          for (let hOut = 0; hOut < outHeight; ++hOut) {
            const hBeg = hOut * strideHeight - padInfo.top;
            for (let wOut = 0; wOut < outWidth; ++wOut) {
              const wBeg = wOut * strideWidth - padInfo.left;
              for (let d = 0; d < inChannels; ++d) {
                let curVal = Number.MIN_SAFE_INTEGER;
                let hMax = 0;
                let wMax = 0;
                for (let h = 0; h < filterHeight; ++h) {
                  const hIn = hBeg + h * dilationHeight;
                  if (hIn >= 0 && hIn < inHeight) {
                    for (let w = 0; w < filterWidth; ++w) {
                      const wIn = wBeg + w * dilationWidth;
                      if (wIn >= 0 && wIn < inWidth) {
                        const val = $x[b][hIn][wIn][d] + $filter[h][w][d];
                        if (val > curVal) {
                          curVal = val;
                          hMax = h;
                          wMax = w;
                        }
                      }
                    }
                  }
                }
                gradients2[hMax][wMax][d] += $dy[b][hOut][wOut][d];
              }
            }
          }
        }
        const dataId = cpuBackend.write(toTypedArray2(gradients2, x.dtype), filter.shape, filter.dtype);
        return {dataId, shape: filter.shape, dtype: filter.dtype};
      }
    };
    /**
     * @license
     * Copyright 2020 Google LLC. All Rights Reserved.
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     * http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     * =============================================================================
     */
    const dilation2dBackpropInputConfig = {
      kernelName: Dilation2DBackpropInput,
      backendName: "cpu",
      kernelFunc: ({inputs, backend: backend3, attrs}) => {
        const {x, filter, dy} = inputs;
        const {strides, pad: pad3, dilations} = attrs;
        const cpuBackend = backend3;
        const $x = toNestedArray2(x.shape, cpuBackend.data.get(x.dataId).values);
        const $filter = toNestedArray2(filter.shape, cpuBackend.data.get(filter.dataId).values);
        const {batchSize, inHeight, inWidth, inChannels, outHeight, outWidth, padInfo, strideHeight, strideWidth, filterHeight, filterWidth, dilationHeight, dilationWidth, outShape} = computeDilation2DInfo2(x.shape, filter.shape, strides, pad3, "NHWC", dilations);
        assert2(dy.rank === outShape.length, () => `Error in ${Dilation2DBackpropInput}, dy must have the same rank as output ${outShape.length}, but got ${dy.rank}`);
        const $dy = toNestedArray2(outShape, cpuBackend.data.get(dy.dataId).values);
        const gradients2 = makeZerosNestedTypedArray2(x.shape, x.dtype);
        for (let b = 0; b < batchSize; ++b) {
          for (let hOut = 0; hOut < outHeight; ++hOut) {
            const hBeg = hOut * strideHeight - padInfo.top;
            for (let wOut = 0; wOut < outWidth; ++wOut) {
              const wBeg = wOut * strideWidth - padInfo.left;
              for (let d = 0; d < inChannels; ++d) {
                let curVal = Number.MIN_SAFE_INTEGER;
                let hInMax = hBeg < 0 ? 0 : hBeg;
                let wInMax = wBeg < 0 ? 0 : wBeg;
                for (let h = 0; h < filterHeight; ++h) {
                  const hIn = hBeg + h * dilationHeight;
                  if (hIn >= 0 && hIn < inHeight) {
                    for (let w = 0; w < filterWidth; ++w) {
                      const wIn = wBeg + w * dilationWidth;
                      if (wIn >= 0 && wIn < inWidth) {
                        const val = $x[b][hIn][wIn][d] + $filter[h][w][d];
                        if (val > curVal) {
                          curVal = val;
                          hInMax = hIn;
                          wInMax = wIn;
                        }
                      }
                    }
                  }
                }
                gradients2[b][hInMax][wInMax][d] += $dy[b][hOut][wOut][d];
              }
            }
          }
        }
        const dataId = cpuBackend.write(toTypedArray2(gradients2, x.dtype), x.shape, x.dtype);
        return {dataId, shape: x.shape, dtype: x.dtype};
      }
    };
    /**
     * @license
     * Copyright 2020 Google LLC. All Rights Reserved.
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     * http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     * =============================================================================
     */
    const divImpl = createSimpleBinaryKernelImpl((a, b) => a / b);
    const div$1 = binaryKernelFunc(Div3, divImpl);
    const divConfig2 = {
      kernelName: Div3,
      backendName: "cpu",
      kernelFunc: div$1
    };
    /**
     * @license
     * Copyright 2020 Google LLC. All Rights Reserved.
     * Licensed under the Apache License, Version 2.0 (the License);
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     * http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an AS IS BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     * =============================================================================
     */
    const p = ERF_P2;
    const a1 = ERF_A12;
    const a2 = ERF_A22;
    const a3 = ERF_A32;
    const a4 = ERF_A42;
    const a5 = ERF_A52;
    const erf$1 = unaryKernelFunc(Erf, (xi) => {
      const sign2 = Math.sign(xi);
      const v = Math.abs(xi);
      const t = 1 / (1 + p * v);
      return sign2 * (1 - ((((a5 * t + a4) * t + a3) * t + a2) * t + a1) * t * Math.exp(-v * v));
    });
    const erfConfig = {
      kernelName: Erf,
      backendName: "cpu",
      kernelFunc: erf$1
    };
    /**
     * @license
     * Copyright 2020 Google LLC. All Rights Reserved.
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     * http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     * =============================================================================
     */
    function fftBatch(input2, inverse, cpuBackend) {
      const inputShape = input2.shape;
      const batch = inputShape[0];
      const innerDim = inputShape[1];
      const inputVals = cpuBackend.data.get(input2.dataId);
      const real2D = inputVals.complexTensorInfos.real;
      const imag2D = inputVals.complexTensorInfos.imag;
      const resultShape = [batch, innerDim];
      const resultSize = sizeFromShape2(resultShape);
      const resultReal = getTypedArrayFromDType2("float32", resultSize);
      const resultImag = getTypedArrayFromDType2("float32", resultSize);
      for (let b = 0; b < batch; b++) {
        const r = slice$1({
          inputs: {x: real2D},
          backend: cpuBackend,
          attrs: {begin: [b, 0], size: [1, innerDim]}
        });
        const i = slice$1({
          inputs: {x: imag2D},
          backend: cpuBackend,
          attrs: {begin: [b, 0], size: [1, innerDim]}
        });
        const input3 = complex$1({inputs: {real: r, imag: i}, backend: cpuBackend});
        const {real: real2, imag: imag2} = fftImpl(input3, inverse, cpuBackend);
        const res = mergeRealAndImagArrays2(real2, imag2);
        for (let d = 0; d < innerDim; d++) {
          const c = getComplexWithIndex2(res, d);
          resultReal[b * innerDim + d] = c.real;
          resultImag[b * innerDim + d] = c.imag;
        }
        cpuBackend.disposeIntermediateTensorInfo(r);
        cpuBackend.disposeIntermediateTensorInfo(i);
        cpuBackend.disposeIntermediateTensorInfo(input3);
      }
      const $realInfo = cpuBackend.makeTensorInfo(resultShape, "float32", resultReal);
      const $imagInfo = cpuBackend.makeTensorInfo(resultShape, "float32", resultImag);
      const result = complex$1({inputs: {real: $realInfo, imag: $imagInfo}, backend: cpuBackend});
      cpuBackend.disposeIntermediateTensorInfo($realInfo);
      cpuBackend.disposeIntermediateTensorInfo($imagInfo);
      return result;
    }
    function fftImpl(input2, inverse, cpuBackend) {
      const inputSize = sizeFromShape2(input2.shape);
      const inputVals = cpuBackend.data.get(input2.dataId);
      const realVals = cpuBackend.data.get(inputVals.complexTensorInfos.real.dataId).values;
      const imagVals = cpuBackend.data.get(inputVals.complexTensorInfos.imag.dataId).values;
      if (isExponentOf2(inputSize)) {
        const result = fftRadix2(realVals, imagVals, inputSize, inverse, cpuBackend);
        const resultShape = [input2.shape[0], input2.shape[1]];
        if (inverse) {
          const realInfo = cpuBackend.makeTensorInfo(resultShape, "float32", result.real);
          const imagInfo = cpuBackend.makeTensorInfo(resultShape, "float32", result.imag);
          const sizeInfo = cpuBackend.makeTensorInfo([], "float32", createScalarValue2(inputSize, "float32"));
          const sizeInfoCopy = identity$1({inputs: {x: sizeInfo}, backend: cpuBackend});
          const divRealInfo = divConfig2.kernelFunc({inputs: {a: realInfo, b: sizeInfo}, backend: cpuBackend});
          const divImagInfo = divConfig2.kernelFunc({inputs: {a: imagInfo, b: sizeInfoCopy}, backend: cpuBackend});
          const divRealVals = cpuBackend.data.get(divRealInfo.dataId).values;
          const divImagVals = cpuBackend.data.get(divImagInfo.dataId).values;
          cpuBackend.disposeIntermediateTensorInfo(realInfo);
          cpuBackend.disposeIntermediateTensorInfo(imagInfo);
          cpuBackend.disposeIntermediateTensorInfo(sizeInfo);
          cpuBackend.disposeIntermediateTensorInfo(sizeInfoCopy);
          cpuBackend.disposeIntermediateTensorInfo(divRealInfo);
          cpuBackend.disposeIntermediateTensorInfo(divImagInfo);
          return {real: divRealVals, imag: divImagVals};
        }
        return result;
      } else {
        const data2 = mergeRealAndImagArrays2(realVals, imagVals);
        const rawOutput = fourierTransformByMatmul(data2, inputSize, inverse);
        return splitRealAndImagArrays2(rawOutput);
      }
    }
    function isExponentOf2(size) {
      return (size & size - 1) === 0;
    }
    function fftRadix2(realVals, imagVals, size, inverse, cpuBackend) {
      if (size === 1) {
        return {real: realVals, imag: imagVals};
      }
      const data2 = mergeRealAndImagArrays2(realVals, imagVals);
      const half = size / 2;
      const evenComplex = complexWithEvenIndex2(data2);
      const evenRealVals = evenComplex.real;
      const evenImagVals = evenComplex.imag;
      const evenShape = [evenRealVals.length];
      const evenRealInfo = cpuBackend.makeTensorInfo(evenShape, "float32", evenRealVals);
      const evenImagInfo = cpuBackend.makeTensorInfo(evenShape, "float32", evenImagVals);
      const evenTensorInfo = complex$1({inputs: {real: evenRealInfo, imag: evenImagInfo}, backend: cpuBackend});
      const oddComplex = complexWithOddIndex2(data2);
      const oddRealVals = oddComplex.real;
      const oddImagVals = oddComplex.imag;
      const oddShape = [oddRealVals.length];
      const oddRealInfo = cpuBackend.makeTensorInfo(oddShape, "float32", oddRealVals);
      const oddImagInfo = cpuBackend.makeTensorInfo(oddShape, "float32", oddImagVals);
      const oddTensorInfo = complex$1({inputs: {real: oddRealInfo, imag: oddImagInfo}, backend: cpuBackend});
      const $evenComplex = fftRadix2(evenRealVals, evenImagVals, half, inverse, cpuBackend);
      const $evenRealVals = $evenComplex.real;
      const $evenImagVals = $evenComplex.imag;
      const $evenShape = [$evenRealVals.length];
      const $evenRealInfo = cpuBackend.makeTensorInfo($evenShape, "float32", $evenRealVals);
      const $evenImagInfo = cpuBackend.makeTensorInfo($evenShape, "float32", $evenImagVals);
      const $evenTensorInfo = complex$1({
        inputs: {real: $evenRealInfo, imag: $evenImagInfo},
        backend: cpuBackend
      });
      const $oddComplex = fftRadix2(oddRealVals, oddImagVals, half, inverse, cpuBackend);
      const $oddRealVals = $oddComplex.real;
      const $oddImagVals = $oddComplex.imag;
      const $oddShape = [$oddRealVals.length];
      const $oddRealInfo = cpuBackend.makeTensorInfo($oddShape, "float32", $oddRealVals);
      const $oddImagInfo = cpuBackend.makeTensorInfo($oddShape, "float32", $oddImagVals);
      const $oddTensorInfo = complex$1({inputs: {real: $oddRealInfo, imag: $oddImagInfo}, backend: cpuBackend});
      const e = exponents2(size, inverse);
      const eShape = [e.real.length];
      const eRealInfo = cpuBackend.makeTensorInfo(eShape, "float32", e.real);
      const eImagInfo = cpuBackend.makeTensorInfo(eShape, "float32", e.imag);
      const complexInfo = complex$1({inputs: {real: eRealInfo, imag: eImagInfo}, backend: cpuBackend});
      const exponentInfo = multiply$2({inputs: {a: complexInfo, b: $oddTensorInfo}, backend: cpuBackend});
      const addPart = add$4({
        inputs: {a: $evenTensorInfo, b: exponentInfo},
        backend: cpuBackend
      });
      const subPart = sub$1({
        inputs: {a: $evenTensorInfo, b: exponentInfo},
        backend: cpuBackend
      });
      const addPartReal = real$1({inputs: {input: addPart}, backend: cpuBackend});
      const subPartReal = real$1({inputs: {input: subPart}, backend: cpuBackend});
      const addPartImag = imag$1({inputs: {input: addPart}, backend: cpuBackend});
      const subPartImag = imag$1({inputs: {input: subPart}, backend: cpuBackend});
      const $real = concat$1({
        inputs: [addPartReal, subPartReal],
        backend: cpuBackend,
        attrs: {axis: 0}
      });
      const $imag = concat$1({
        inputs: [addPartImag, subPartImag],
        backend: cpuBackend,
        attrs: {axis: 0}
      });
      const $realVals = cpuBackend.data.get($real.dataId).values;
      const $imagVals = cpuBackend.data.get($imag.dataId).values;
      cpuBackend.disposeIntermediateTensorInfo(evenRealInfo);
      cpuBackend.disposeIntermediateTensorInfo(evenImagInfo);
      cpuBackend.disposeIntermediateTensorInfo(evenTensorInfo);
      cpuBackend.disposeIntermediateTensorInfo(oddRealInfo);
      cpuBackend.disposeIntermediateTensorInfo(oddImagInfo);
      cpuBackend.disposeIntermediateTensorInfo(oddTensorInfo);
      cpuBackend.disposeIntermediateTensorInfo($evenRealInfo);
      cpuBackend.disposeIntermediateTensorInfo($evenImagInfo);
      cpuBackend.disposeIntermediateTensorInfo($evenTensorInfo);
      cpuBackend.disposeIntermediateTensorInfo($oddRealInfo);
      cpuBackend.disposeIntermediateTensorInfo($oddImagInfo);
      cpuBackend.disposeIntermediateTensorInfo($oddTensorInfo);
      cpuBackend.disposeIntermediateTensorInfo(eRealInfo);
      cpuBackend.disposeIntermediateTensorInfo(eImagInfo);
      cpuBackend.disposeIntermediateTensorInfo(complexInfo);
      cpuBackend.disposeIntermediateTensorInfo(exponentInfo);
      cpuBackend.disposeIntermediateTensorInfo(addPart);
      cpuBackend.disposeIntermediateTensorInfo(subPart);
      cpuBackend.disposeIntermediateTensorInfo(addPartReal);
      cpuBackend.disposeIntermediateTensorInfo(addPartImag);
      cpuBackend.disposeIntermediateTensorInfo(subPartReal);
      cpuBackend.disposeIntermediateTensorInfo(subPartImag);
      cpuBackend.disposeIntermediateTensorInfo($real);
      cpuBackend.disposeIntermediateTensorInfo($imag);
      return {real: $realVals, imag: $imagVals};
    }
    function fourierTransformByMatmul(data2, size, inverse) {
      const ret = new Float32Array(size * 2);
      for (let r = 0; r < size; r++) {
        let real2 = 0;
        let imag2 = 0;
        for (let c = 0; c < size; c++) {
          const e = exponent2(r * c, size, inverse);
          const term = getComplexWithIndex2(data2, c);
          real2 += term.real * e.real - term.imag * e.imag;
          imag2 += term.real * e.imag + term.imag * e.real;
        }
        if (inverse) {
          real2 /= size;
          imag2 /= size;
        }
        assignToTypedArray2(ret, real2, imag2, r);
      }
      return ret;
    }
    /**
     * @license
     * Copyright 2020 Google LLC. All Rights Reserved.
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     * http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     * =============================================================================
     */
    function fft$1(args) {
      const {inputs, backend: backend3} = args;
      const {input: input2} = inputs;
      const inputSize = sizeFromShape2(input2.shape);
      const innerDimensionSize = input2.shape[input2.shape.length - 1];
      const batch = inputSize / innerDimensionSize;
      const input2D = reshape$2({
        inputs: {x: input2},
        backend: backend3,
        attrs: {shape: [batch, innerDimensionSize]}
      });
      const result = fftBatch(input2D, false, backend3);
      const resultReshaped = reshape$2({inputs: {x: result}, backend: backend3, attrs: {shape: input2.shape}});
      backend3.disposeIntermediateTensorInfo(input2D);
      backend3.disposeIntermediateTensorInfo(result);
      return resultReshaped;
    }
    const fftConfig = {
      kernelName: FFT,
      backendName: "cpu",
      kernelFunc: fft$1
    };
    /**
     * @license
     * Copyright 2020 Google LLC. All Rights Reserved.
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     * http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     * =============================================================================
     */
    function fill$1(args) {
      const {backend: backend3, attrs} = args;
      const {shape, value, dtype} = attrs;
      const $dtype = dtype || inferDtype2(value);
      const values = getArrayFromDType2($dtype, sizeFromShape2(shape));
      fillValues(values, value, $dtype);
      return backend3.makeTensorInfo(shape, $dtype, values);
    }
    const fillConfig2 = {
      kernelName: Fill3,
      backendName: "cpu",
      kernelFunc: fill$1
    };
    function fillValues(values, value, dtype) {
      if (dtype === "string") {
        values.fill(value);
      } else {
        values.fill(value);
      }
    }
    /**
     * @license
     * Copyright 2020 Google LLC. All Rights Reserved.
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     * http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     * =============================================================================
     */
    const flipLeftRightConfig2 = {
      kernelName: FlipLeftRight3,
      backendName: "cpu",
      kernelFunc: ({inputs, attrs, backend: backend3}) => {
        const {image: image3} = inputs;
        const cpuBackend = backend3;
        const output = getTypedArrayFromDType2(image3.dtype, sizeFromShape2(image3.shape));
        const [batch, imageHeight, imageWidth, numChannels] = image3.shape;
        const imageVals = cpuBackend.data.get(image3.dataId).values;
        for (let batchIdx = 0; batchIdx < batch; batchIdx++) {
          const batchOffset = batchIdx * imageWidth * imageHeight * numChannels;
          for (let row = 0; row < imageHeight; row++) {
            const rowOffset = row * (imageWidth * numChannels);
            for (let col = 0; col < imageWidth; col++) {
              const colOffset = col * numChannels;
              for (let channel = 0; channel < numChannels; channel++) {
                const coords2 = [batch, row, col, channel];
                const x = coords2[2];
                const coordX = Math.round(imageWidth - x);
                const outIdx = batchOffset + rowOffset + colOffset + channel;
                let outputValue = imageVals[outIdx];
                if (coordX >= 0 && coordX < imageWidth) {
                  const rotatedColOffset = coordX * numChannels;
                  const imageIdx = batchOffset + rowOffset + rotatedColOffset + channel;
                  outputValue = imageVals[imageIdx];
                }
                output[outIdx] = outputValue;
              }
            }
          }
        }
        const dataId = cpuBackend.write(output, image3.shape, image3.dtype);
        return {dataId, shape: image3.shape, dtype: image3.dtype};
      }
    };
    /**
     * @license
     * Copyright 2020 Google LLC. All Rights Reserved.
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     * http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     * =============================================================================
     */
    function fusedConv2D(args) {
      const {inputs, backend: backend3, attrs} = args;
      const {x, filter, bias, preluActivationWeights} = inputs;
      const {strides, pad: pad3, dataFormat, dilations, dimRoundingMode, activation: activation2} = attrs;
      let result = conv2D({
        inputs: {x, filter},
        backend: backend3,
        attrs: {strides, pad: pad3, dataFormat, dilations, dimRoundingMode}
      });
      if (bias) {
        const resultOld = result;
        result = add$4({inputs: {a: result, b: bias}, backend: backend3});
        backend3.disposeIntermediateTensorInfo(resultOld);
      }
      if (activation2) {
        const resultOld = result;
        result = applyActivation$1(backend3, result, activation2, preluActivationWeights);
        backend3.disposeIntermediateTensorInfo(resultOld);
      }
      return result;
    }
    const fusedConv2DConfig2 = {
      kernelName: FusedConv2D3,
      backendName: "cpu",
      kernelFunc: fusedConv2D
    };
    /**
     * @license
     * Copyright 2020 Google LLC. All Rights Reserved.
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     * http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     * =============================================================================
     */
    function fusedDepthwiseConv2D(args) {
      const {inputs, backend: backend3, attrs} = args;
      const {x, filter, bias, preluActivationWeights} = inputs;
      const {strides, pad: pad3, dataFormat, dilations, dimRoundingMode, activation: activation2} = attrs;
      let result = depthwiseConv2dNative({
        inputs: {x, filter},
        backend: backend3,
        attrs: {strides, pad: pad3, dataFormat, dilations, dimRoundingMode}
      });
      if (bias) {
        const oldResult = result;
        result = add$4({inputs: {a: result, b: bias}, backend: backend3});
        backend3.disposeIntermediateTensorInfo(oldResult);
      }
      if (activation2) {
        const oldResult = result;
        result = applyActivation$1(backend3, result, activation2, preluActivationWeights);
        backend3.disposeIntermediateTensorInfo(oldResult);
      }
      return result;
    }
    const fusedDepthwiseConv2DConfig2 = {
      kernelName: FusedDepthwiseConv2D3,
      backendName: "cpu",
      kernelFunc: fusedDepthwiseConv2D
    };
    /**
     * @license
     * Copyright 2020 Google LLC. All Rights Reserved.
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     * http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     * =============================================================================
     */
    function ifft$1(args) {
      const {inputs, backend: backend3} = args;
      const {input: input2} = inputs;
      const inputSize = sizeFromShape2(input2.shape);
      const innerDimensionSize = input2.shape[input2.shape.length - 1];
      const batch = inputSize / innerDimensionSize;
      const input2D = reshape$2({
        inputs: {x: input2},
        backend: backend3,
        attrs: {shape: [batch, innerDimensionSize]}
      });
      const result = fftBatch(input2D, true, backend3);
      const resultReshaped = reshape$2({inputs: {x: result}, backend: backend3, attrs: {shape: input2.shape}});
      backend3.disposeIntermediateTensorInfo(input2D);
      backend3.disposeIntermediateTensorInfo(result);
      return resultReshaped;
    }
    const ifftConfig = {
      kernelName: IFFT,
      backendName: "cpu",
      kernelFunc: ifft$1
    };
    /**
     * @license
     * Copyright 2020 Google LLC. All Rights Reserved.
     * Licensed under the Apache License, Version 2.0 (the License);
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     * http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an AS IS BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     * =============================================================================
     */
    const isFinite$2 = unaryKernelFunc(IsFinite, (xi) => Number.isFinite(xi) ? 1 : 0, "bool");
    const isFiniteConfig = {
      kernelName: IsFinite,
      backendName: "cpu",
      kernelFunc: isFinite$2
    };
    /**
     * @license
     * Copyright 2020 Google LLC. All Rights Reserved.
     * Licensed under the Apache License, Version 2.0 (the License);
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     * http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an AS IS BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     * =============================================================================
     */
    const isInf$1 = unaryKernelFunc(IsInf, (xi) => Math.abs(xi) === Infinity ? 1 : 0, "bool");
    const isInfConfig = {
      kernelName: IsInf,
      backendName: "cpu",
      kernelFunc: isInf$1
    };
    /**
     * @license
     * Copyright 2020 Google LLC. All Rights Reserved.
     * Licensed under the Apache License, Version 2.0 (the License);
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     * http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an AS IS BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     * =============================================================================
     */
    const isNaN$2 = unaryKernelFunc(IsNan, (xi) => Number.isNaN(xi) ? 1 : 0, "bool");
    const isNaNConfig = {
      kernelName: IsNan,
      backendName: "cpu",
      kernelFunc: isNaN$2
    };
    /**
     * @license
     * Copyright 2020 Google LLC. All Rights Reserved.
     * Licensed under the Apache License, Version 2.0 (the License);
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     * http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an AS IS BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     * =============================================================================
     */
    const log1p$1 = unaryKernelFunc(Log1p, (xi) => Math.log1p(xi));
    const log1pConfig = {
      kernelName: Log1p,
      backendName: "cpu",
      kernelFunc: log1p$1
    };
    /**
     * @license
     * Copyright 2020 Google LLC. All Rights Reserved.
     * Licensed under the Apache License, Version 2.0 (the License);
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     * http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an AS IS BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     * =============================================================================
     */
    const logicalNot$1 = unaryKernelFunc(LogicalNot, (xi) => xi ? 0 : 1, "bool");
    const logicalNotConfig = {
      kernelName: LogicalNot,
      backendName: "cpu",
      kernelFunc: logicalNot$1
    };
    /**
     * @license
     * Copyright 2020 Google LLC. All Rights Reserved.
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     * http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     * =============================================================================
     */
    const maxConfig2 = {
      kernelName: Max3,
      backendName: "cpu",
      kernelFunc: ({inputs, attrs, backend: backend3}) => {
        const {x} = inputs;
        const {reductionIndices, keepDims} = attrs;
        const cpuBackend = backend3;
        let xShape = x.shape;
        const xRank = xShape.length;
        const origAxes = parseAxisParam2(reductionIndices, xShape);
        let axes = origAxes;
        const permutedAxes = getAxesPermutation2(axes, xRank);
        let xVals = cpuBackend.data.get(x.dataId).values;
        if (permutedAxes != null) {
          const newShape = new Array(xRank);
          for (let i = 0; i < newShape.length; i++) {
            newShape[i] = xShape[permutedAxes[i]];
          }
          xVals = transposeImpl(xVals, xShape, x.dtype, permutedAxes, newShape);
          axes = getInnerMostAxes2(axes.length, xRank);
          xShape = newShape;
        }
        assertNotComplex(x, "max");
        assertAxesAreInnerMostDims2("max", axes, xRank);
        const [maxOutShape, reduceShape] = computeOutAndReduceShapes2(xShape, axes);
        const reduceSize = sizeFromShape2(reduceShape);
        const result = maxImpl(xVals, reduceSize, maxOutShape, x.dtype);
        const dataId = cpuBackend.write(result, maxOutShape, x.dtype);
        let outShape = maxOutShape;
        if (keepDims) {
          const newShape = expandShapeToKeepDim2(maxOutShape, origAxes);
          outShape = newShape;
        }
        return {dataId, shape: outShape, dtype: x.dtype};
      }
    };
    /**
     * @license
     * Copyright 2020 Google LLC. All Rights Reserved.
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     * http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     * =============================================================================
     */
    function maxPool$1(args) {
      const {inputs, backend: backend3, attrs} = args;
      const {x} = inputs;
      assertNotComplex(x, "maxPool");
      const {filterSize, strides, pad: pad3, dimRoundingMode} = attrs;
      const dilations = 1;
      assert2(eitherStridesOrDilationsAreOne2(strides, dilations), () => `Error in maxPool: Either strides or dilations must be 1. Got strides ${strides} and dilations '${dilations}'`);
      const convInfo = computePool2DInfo2(x.shape, filterSize, strides, dilations, pad3, dimRoundingMode);
      let res;
      if (convInfo.filterWidth === 1 && convInfo.filterHeight === 1 && arraysEqual2(convInfo.inShape, convInfo.outShape)) {
        res = identity$1({inputs: {x}, backend: backend3});
      } else {
        const xValues = backend3.data.get(x.dataId).values;
        const strides2 = computeStrides2(x.shape);
        const buffer3 = pool$1(xValues, x.shape, x.dtype, strides2, convInfo, "max");
        res = backend3.makeTensorInfo(convInfo.outShape, x.dtype, buffer3.values);
      }
      return res;
    }
    const maxPoolConfig2 = {
      kernelName: MaxPool3,
      backendName: "cpu",
      kernelFunc: maxPool$1
    };
    /**
     * @license
     * Copyright 2020 Google LLC. All Rights Reserved.
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     * http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     * =============================================================================
     */
    function maxPoolBackprop$1(args) {
      const {inputs, backend: backend3, attrs} = args;
      const {dy, input: input2, output} = inputs;
      const x = input2;
      assertNotComplex([input2, output], "maxPoolBackprop");
      const {filterSize, strides, pad: pad3, dimRoundingMode} = attrs;
      const convInfo = computePool2DInfo2(x.shape, filterSize, strides, 1, pad3, dimRoundingMode);
      const xValues = backend3.data.get(x.dataId).values;
      const maxPosBuf = buffer2(convInfo.outShape, x.dtype, maxPoolPositions(xValues, x.shape, x.dtype, convInfo).values);
      const strideHeight = convInfo.strideHeight;
      const strideWidth = convInfo.strideWidth;
      const dilationHeight = convInfo.dilationHeight;
      const dilationWidth = convInfo.dilationWidth;
      const effectiveFilterHeight = convInfo.effectiveFilterHeight;
      const effectiveFilterWidth = convInfo.effectiveFilterWidth;
      const padLeft = effectiveFilterWidth - 1 - convInfo.padInfo.left;
      const padTop = effectiveFilterHeight - 1 - convInfo.padInfo.top;
      const dx = buffer2(x.shape, "float32");
      const dyData = backend3.data.get(dy.dataId).values;
      const dyBuf = buffer2(dy.shape, "float32", dyData);
      for (let b = 0; b < convInfo.batchSize; ++b) {
        for (let d = 0; d < convInfo.inChannels; ++d) {
          for (let dxR = 0; dxR < convInfo.inHeight; ++dxR) {
            for (let dxC = 0; dxC < convInfo.inWidth; ++dxC) {
              const dyRCorner = dxR - padTop;
              const dyCCorner = dxC - padLeft;
              let dotProd = 0;
              for (let wR = 0; wR < effectiveFilterHeight; wR += dilationHeight) {
                const dyR = (dyRCorner + wR) / strideHeight;
                if (dyR < 0 || dyR >= convInfo.outHeight || Math.floor(dyR) !== dyR) {
                  continue;
                }
                for (let wC = 0; wC < effectiveFilterWidth; wC += dilationWidth) {
                  const dyC = (dyCCorner + wC) / strideWidth;
                  if (dyC < 0 || dyC >= convInfo.outWidth || Math.floor(dyC) !== dyC) {
                    continue;
                  }
                  const maxPos = effectiveFilterHeight * effectiveFilterWidth - 1 - maxPosBuf.get(b, dyR, dyC, d);
                  const curPos = wR * effectiveFilterWidth + wC;
                  const mask = maxPos === curPos ? 1 : 0;
                  if (mask === 0) {
                    continue;
                  }
                  const pixel = dyBuf.get(b, dyR, dyC, d);
                  dotProd += pixel * mask;
                }
              }
              dx.set(dotProd, b, dxR, dxC, d);
            }
          }
        }
      }
      return backend3.makeTensorInfo(dx.shape, dx.dtype, dx.values);
    }
    const maxPoolBackpropConfig = {
      kernelName: MaxPoolBackprop,
      backendName: "cpu",
      kernelFunc: maxPoolBackprop$1
    };
    /**
     * @license
     * Copyright 2020 Google LLC. All Rights Reserved.
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     * http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     * =============================================================================
     */
    function maxPoolWithArgmaxImpl(xValues, xShape, dtype, includeBatchInIndex, convInfo) {
      const strides = computeStrides2(xShape);
      const maxPools = pool$1(xValues, xShape, dtype, strides, convInfo, "max");
      const maxPositions = maxPoolPositions(xValues, xShape, dtype, convInfo, true, includeBatchInIndex);
      return [maxPools.values, maxPositions.values];
    }
    /**
     * @license
     * Copyright 2020 Google LLC. All Rights Reserved.
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     * http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     * =============================================================================
     */
    const maxPoolWithArgmaxConfig = {
      kernelName: MaxPoolWithArgmax,
      backendName: "cpu",
      kernelFunc: ({inputs, attrs, backend: backend3}) => {
        const {x} = inputs;
        const {filterSize, strides, pad: pad3, includeBatchInIndex} = attrs;
        const cpuBackend = backend3;
        assertNotComplex(x, "MaxPoolWithArgmax");
        const values = cpuBackend.data.get(x.dataId).values;
        const convInfo = computePool2DInfo2(x.shape, filterSize, strides, [1, 1], pad3);
        const [pooled, indexes] = maxPoolWithArgmaxImpl(values, x.shape, x.dtype, includeBatchInIndex, convInfo);
        const pooledDataId = cpuBackend.write(pooled, convInfo.outShape, x.dtype);
        const indexesDataId = cpuBackend.write(indexes, convInfo.outShape, x.dtype);
        return [
          {dataId: pooledDataId, shape: convInfo.outShape, dtype: x.dtype},
          {dataId: indexesDataId, shape: convInfo.outShape, dtype: "int32"}
        ];
      }
    };
    /**
     * @license
     * Copyright 2020 Google LLC. All Rights Reserved.
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     * http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     * =============================================================================
     */
    function mirrorPad$1(args) {
      const {inputs, backend: backend3, attrs} = args;
      const {x} = inputs;
      const {paddings, mode} = attrs;
      assertNotComplex(x, "mirrorPad");
      const outShape = paddings.map((p2, i) => p2[0] + x.shape[i] + p2[1]);
      const start = paddings.map((p2) => p2[0]);
      const end = paddings.map((p2, i) => p2[0] + x.shape[i]);
      const offset = mode === "reflect" ? 0 : 1;
      const xVals = backend3.data.get(x.dataId).values;
      const xRank = x.shape.length;
      const xStrides = computeStrides2(x.shape);
      const resultSize = sizeFromShape2(outShape);
      const resultRank = outShape.length;
      const resultStrides = computeStrides2(outShape);
      const resVals = getTypedArrayFromDType2(x.dtype, resultSize);
      for (let i = 0; i < resultSize; i++) {
        let coords2 = indexToLoc2(i, resultRank, resultStrides);
        for (let i2 = 0; i2 < resultRank; i2++) {
          if (coords2[i2] < start[i2]) {
            coords2[i2] = start[i2] * 2 - coords2[i2] - offset;
          } else if (coords2[i2] >= end[i2]) {
            coords2[i2] = (end[i2] - 1) * 2 - coords2[i2] + offset;
          }
        }
        coords2 = coords2.map((c, i2) => c - start[i2]);
        const inIndex = locToIndex2(coords2, xRank, xStrides);
        resVals[i] = xVals[inIndex];
      }
      const outId = backend3.write(resVals, outShape, x.dtype);
      return {dataId: outId, shape: outShape, dtype: x.dtype};
    }
    const mirrorPadConfig = {
      kernelName: MirrorPad,
      backendName: "cpu",
      kernelFunc: mirrorPad$1
    };
    /**
     * @license
     * Copyright 2020 Google LLC. All Rights Reserved.
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     * http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     * =============================================================================
     */
    const nonMaxSuppressionV4Impl$1 = nonMaxSuppressionV4Impl;
    const nonMaxSuppressionV4Config2 = {
      kernelName: NonMaxSuppressionV43,
      backendName: "cpu",
      kernelFunc: ({inputs, backend: backend3, attrs}) => {
        const {boxes, scores} = inputs;
        const {maxOutputSize, iouThreshold, scoreThreshold, padToMaxOutputSize} = attrs;
        const cpuBackend = backend3;
        assertNotComplex(boxes, "NonMaxSuppressionPadded");
        const boxesVals = cpuBackend.data.get(boxes.dataId).values;
        const scoresVals = cpuBackend.data.get(scores.dataId).values;
        const {selectedIndices, validOutputs} = nonMaxSuppressionV4Impl$1(boxesVals, scoresVals, maxOutputSize, iouThreshold, scoreThreshold, padToMaxOutputSize);
        return [selectedIndices, validOutputs];
      }
    };
    /**
     * @license
     * Copyright 2019 Google LLC. All Rights Reserved.
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     * http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     * =============================================================================
     */
    const nonMaxSuppressionV5Impl$1 = nonMaxSuppressionV5Impl;
    const nonMaxSuppressionV5Config2 = {
      kernelName: NonMaxSuppressionV53,
      backendName: "cpu",
      kernelFunc: ({inputs, backend: backend3, attrs}) => {
        const {boxes, scores} = inputs;
        const {maxOutputSize, iouThreshold, scoreThreshold, softNmsSigma} = attrs;
        const cpuBackend = backend3;
        assertNotComplex(boxes, "NonMaxSuppressionWithScore");
        const boxesVals = cpuBackend.data.get(boxes.dataId).values;
        const scoresVals = cpuBackend.data.get(scores.dataId).values;
        const maxOutputSizeVal = maxOutputSize;
        const iouThresholdVal = iouThreshold;
        const scoreThresholdVal = scoreThreshold;
        const softNmsSigmaVal = softNmsSigma;
        const {selectedIndices, selectedScores} = nonMaxSuppressionV5Impl$1(boxesVals, scoresVals, maxOutputSizeVal, iouThresholdVal, scoreThresholdVal, softNmsSigmaVal);
        return [selectedIndices, selectedScores];
      }
    };
    /**
     * @license
     * Copyright 2020 Google LLC. All Rights Reserved.
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     * http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     * =============================================================================
     */
    function padV2(args) {
      const {inputs, backend: backend3, attrs} = args;
      const {x} = inputs;
      const {paddings, constantValue} = attrs;
      assertNotComplex(x, "pad");
      const outShape = paddings.map((p2, i) => p2[0] + x.shape[i] + p2[1]);
      const start = paddings.map((p2) => p2[0]);
      const xVals = backend3.data.get(x.dataId).values;
      const xSize = sizeFromShape2(x.shape);
      const xRank = x.shape.length;
      const xStrides = computeStrides2(x.shape);
      const resultSize = sizeFromShape2(outShape);
      const resultRank = outShape.length;
      const resultStrides = computeStrides2(outShape);
      const resVals = getTypedArrayFromDType2(x.dtype, resultSize);
      if (constantValue !== 0) {
        resVals.fill(constantValue);
      }
      for (let i = 0; i < xSize; i++) {
        const coords2 = indexToLoc2(i, xRank, xStrides);
        const outCoords = coords2.map((c, i2) => c + start[i2]);
        const outIndex = locToIndex2(outCoords, resultRank, resultStrides);
        resVals[outIndex] = xVals[i];
      }
      const outId = backend3.write(resVals, outShape, x.dtype);
      return {dataId: outId, shape: outShape, dtype: x.dtype};
    }
    const padV2Config2 = {
      kernelName: PadV23,
      backendName: "cpu",
      kernelFunc: padV2
    };
    /**
     * @license
     * Copyright 2020 Google LLC. All Rights Reserved.
     * Licensed under the Apache License, Version 2.0 (the License);
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     * http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an AS IS BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     * =============================================================================
     */
    const reciprocal$1 = unaryKernelFunc(Reciprocal, (xi) => 1 / xi);
    const reciprocalConfig = {
      kernelName: Reciprocal,
      backendName: "cpu",
      kernelFunc: reciprocal$1
    };
    /**
     * @license
     * Copyright 2020 Google LLC. All Rights Reserved.
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     * http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     * =============================================================================
     */
    const rotateWithOffsetConfig2 = {
      kernelName: RotateWithOffset3,
      backendName: "cpu",
      kernelFunc: ({inputs, attrs, backend: backend3}) => {
        const {image: image3} = inputs;
        const {radians, fillValue, center} = attrs;
        const cpuBackend = backend3;
        const output = getTypedArrayFromDType2(image3.dtype, sizeFromShape2(image3.shape));
        const [batch, imageHeight, imageWidth, numChannels] = image3.shape;
        const [centerX, centerY] = getImageCenter2(center, imageHeight, imageWidth);
        const fullOpacityValue = 255;
        const sinFactor = Math.sin(radians);
        const cosFactor = Math.cos(radians);
        const imageVals = cpuBackend.data.get(image3.dataId).values;
        for (let batchIdx = 0; batchIdx < batch; batchIdx++) {
          const batchOffset = batchIdx * imageWidth * imageHeight * numChannels;
          for (let row = 0; row < imageHeight; row++) {
            const rowOffset = row * (imageWidth * numChannels);
            for (let col = 0; col < imageWidth; col++) {
              const colOffset = col * numChannels;
              for (let channel = 0; channel < numChannels; channel++) {
                const coords2 = [batch, row, col, channel];
                const x = coords2[2];
                const y = coords2[1];
                let coordX = (x - centerX) * cosFactor - (y - centerY) * sinFactor;
                let coordY = (x - centerX) * sinFactor + (y - centerY) * cosFactor;
                coordX = Math.round(coordX + centerX);
                coordY = Math.round(coordY + centerY);
                let outputValue = fillValue;
                if (typeof fillValue !== "number") {
                  if (channel === 3) {
                    outputValue = fullOpacityValue;
                  } else {
                    outputValue = fillValue[channel];
                  }
                }
                if (coordX >= 0 && coordX < imageWidth && coordY >= 0 && coordY < imageHeight) {
                  const rotatedRowOffset = coordY * (imageWidth * numChannels);
                  const rotatedColOffset = coordX * numChannels;
                  const imageIdx = batchOffset + rotatedRowOffset + rotatedColOffset + channel;
                  outputValue = imageVals[imageIdx];
                }
                const outIdx = batchOffset + rowOffset + colOffset + channel;
                output[outIdx] = outputValue;
              }
            }
          }
        }
        const dataId = cpuBackend.write(output, image3.shape, image3.dtype);
        return {dataId, shape: image3.shape, dtype: image3.dtype};
      }
    };
    /**
     * @license
     * Copyright 2020 Google LLC. All Rights Reserved.
     * Licensed under the Apache License, Version 2.0 (the License);
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     * http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an AS IS BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     * =============================================================================
     */
    const round$1 = unaryKernelFunc(Round, (xi) => {
      const base2 = Math.floor(xi);
      if (xi - base2 < 0.5) {
        return Math.floor(xi);
      } else if (xi - base2 > 0.5) {
        return Math.ceil(xi);
      } else {
        if (base2 % 2 === 0) {
          return base2;
        } else {
          return base2 + 1;
        }
      }
    });
    const roundConfig = {
      kernelName: Round,
      backendName: "cpu",
      kernelFunc: round$1
    };
    /**
     * @license
     * Copyright 2020 Google LLC. All Rights Reserved.
     * Licensed under the Apache License, Version 2.0 (the License);
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     * http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an AS IS BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     * =============================================================================
     */
    const scaleAlpha = SELU_SCALEALPHA2;
    const scale = SELU_SCALE2;
    const selu$1 = unaryKernelFunc(Selu, (xi) => {
      if (xi >= 0) {
        return scale * xi;
      } else {
        return scaleAlpha * (Math.exp(xi) - 1);
      }
    });
    const seluConfig = {
      kernelName: Selu,
      backendName: "cpu",
      kernelFunc: selu$1
    };
    /**
     * @license
     * Copyright 2020 Google LLC. All Rights Reserved.
     * Licensed under the Apache License, Version 2.0 (the License);
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     * http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an AS IS BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     * =============================================================================
     */
    const sigmoid$1 = unaryKernelFunc(Sigmoid3, (xi) => 1 / (1 + Math.exp(-xi)));
    const sigmoidConfig2 = {
      kernelName: Sigmoid3,
      backendName: "cpu",
      kernelFunc: sigmoid$1
    };
    /**
     * @license
     * Copyright 2020 Google LLC. All Rights Reserved.
     * Licensed under the Apache License, Version 2.0 (the License);
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     * http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an AS IS BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     * =============================================================================
     */
    const sign$2 = unaryKernelFunc(Sign, (xi) => {
      if (xi < 0) {
        return -1;
      } else if (xi > 0) {
        return 1;
      } else {
        return 0;
      }
    });
    const signConfig = {
      kernelName: Sign,
      backendName: "cpu",
      kernelFunc: sign$2
    };
    /**
     * @license
     * Copyright 2020 Google LLC. All Rights Reserved.
     * Licensed under the Apache License, Version 2.0 (the License);
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     * http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an AS IS BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     * =============================================================================
     */
    const sin$1 = unaryKernelFunc(Sin3, (xi) => Math.sin(xi));
    const sinConfig2 = {
      kernelName: Sin3,
      backendName: "cpu",
      kernelFunc: sin$1
    };
    /**
     * @license
     * Copyright 2020 Google LLC. All Rights Reserved.
     * Licensed under the Apache License, Version 2.0 (the License);
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     * http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an AS IS BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     * =============================================================================
     */
    const sinh$1 = unaryKernelFunc(Sinh, (xi) => Math.sinh(xi));
    const sinhConfig = {
      kernelName: Sinh,
      backendName: "cpu",
      kernelFunc: sinh$1
    };
    /**
     * @license
     * Copyright 2020 Google LLC. All Rights Reserved.
     * Licensed under the Apache License, Version 2.0 (the License);
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     * http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an AS IS BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     * =============================================================================
     */
    const epsilon$1 = 11920928955078125e-23;
    const threshold = Math.log(epsilon$1) + 2;
    const softplus$1 = unaryKernelFunc(Softplus, (xi) => {
      const tooLarge = xi > -threshold;
      const tooSmall = xi < threshold;
      const expX = Math.exp(xi);
      let result;
      if (tooSmall) {
        result = expX;
      } else if (tooLarge) {
        result = xi;
      } else {
        result = Math.log(1 + expX);
      }
      return result;
    });
    const softplusConfig = {
      kernelName: Softplus,
      backendName: "cpu",
      kernelFunc: softplus$1
    };
    /**
     * @license
     * Copyright 2020 Google LLC. All Rights Reserved.
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     * http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     * =============================================================================
     */
    function transpose$1(args) {
      const {inputs, attrs, backend: backend3} = args;
      const {x} = inputs;
      const {perm} = attrs;
      assertNotComplex(x, "transpose");
      const xRank = x.shape.length;
      const newShape = new Array(xRank);
      for (let i = 0; i < newShape.length; i++) {
        newShape[i] = x.shape[perm[i]];
      }
      const values = backend3.data.get(x.dataId).values;
      const result = transposeImpl(values, x.shape, x.dtype, perm, newShape);
      const dataId = backend3.write(result, newShape, x.dtype);
      return {dataId, shape: newShape, dtype: x.dtype};
    }
    const transposeConfig2 = {
      kernelName: Transpose5,
      backendName: "cpu",
      kernelFunc: transpose$1
    };
    /**
     * @license
     * Copyright 2020 Google LLC. All Rights Reserved.
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     * http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     * =============================================================================
     */
    function spaceToBatchND$1(args) {
      const {inputs, backend: backend3, attrs} = args;
      const {x} = inputs;
      const {blockShape, paddings} = attrs;
      assertNotComplex([x], "spaceToBatchND");
      const prod2 = sizeFromShape2(blockShape);
      const completePaddings = [[0, 0]];
      completePaddings.push(...paddings);
      for (let i = 1 + blockShape.length; i < x.shape.length; ++i) {
        completePaddings.push([0, 0]);
      }
      const paddedX = padV2Config2.kernelFunc({
        inputs: {x},
        backend: backend3,
        attrs: {paddings: completePaddings, constantValue: 0}
      });
      const reshapedPaddedShape = getReshaped2(paddedX.shape, blockShape, prod2, false);
      const permutedReshapedPaddedPermutation = getPermuted2(reshapedPaddedShape.length, blockShape.length, false);
      const flattenShape = getReshapedPermuted2(paddedX.shape, blockShape, prod2, false);
      const reshapeInputs = {x: paddedX};
      const reshapeAttrs = {shape: reshapedPaddedShape};
      const paddedXReshaped = reshape$2({inputs: reshapeInputs, backend: backend3, attrs: reshapeAttrs});
      const transposeInputs = {x: paddedXReshaped};
      const transposeAttrs = {perm: permutedReshapedPaddedPermutation};
      const paddedXT = transpose$1({inputs: transposeInputs, backend: backend3, attrs: transposeAttrs});
      const resultReshapeInputs = {x: paddedXT};
      const resultReshapeAttrs = {shape: flattenShape};
      const result = reshape$2({inputs: resultReshapeInputs, backend: backend3, attrs: resultReshapeAttrs});
      backend3.disposeIntermediateTensorInfo(paddedX);
      backend3.disposeIntermediateTensorInfo(paddedXReshaped);
      backend3.disposeIntermediateTensorInfo(paddedXT);
      return result;
    }
    const spaceToBatchNDConfig = {
      kernelName: SpaceToBatchND,
      backendName: "cpu",
      kernelFunc: spaceToBatchND$1
    };
    /**
     * @license
     * Copyright 2020 Google LLC. All Rights Reserved.
     * Licensed under the Apache License, Version 2.0 (the License);
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     * http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an AS IS BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     * =============================================================================
     */
    const sqrt$1 = unaryKernelFunc(Sqrt3, (xi) => Math.sqrt(xi));
    const sqrtConfig2 = {
      kernelName: Sqrt3,
      backendName: "cpu",
      kernelFunc: sqrt$1
    };
    /**
     * @license
     * Copyright 2019 Google LLC. All Rights Reserved.
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     * http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     * =============================================================================
     */
    const squareConfig2 = {
      kernelName: Square3,
      backendName: "cpu",
      kernelFunc: ({inputs, backend: backend3}) => {
        const {x} = inputs;
        const cpuBackend = backend3;
        assertNotComplex(x, "square");
        const values = cpuBackend.data.get(x.dataId).values;
        const newValues = new Float32Array(values.length);
        for (let i = 0; i < values.length; ++i) {
          const value = values[i];
          newValues[i] = value * value;
        }
        const dataId = cpuBackend.write(newValues, x.shape, x.dtype);
        return {dataId, shape: x.shape, dtype: x.dtype};
      }
    };
    /**
     * @license
     * Copyright 2020 Google LLC. All Rights Reserved.
     * Licensed under the Apache License, Version 2.0 (the License);
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     * http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an AS IS BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     * =============================================================================
     */
    const step$1 = unaryKernelFunc(Step2, (xi, attrs) => {
      const stepAttrs = attrs;
      if (isNaN(xi)) {
        return NaN;
      } else {
        return xi > 0 ? 1 : stepAttrs.alpha;
      }
    });
    const stepConfig = {
      kernelName: Step2,
      backendName: "cpu",
      kernelFunc: step$1
    };
    /**
     * @license
     * Copyright 2020 Google LLC. All Rights Reserved.
     * Licensed under the Apache License, Version 2.0 (the License);
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     * http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an AS IS BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     * =============================================================================
     */
    const tan$1 = unaryKernelFunc(Tan, (xi) => Math.tan(xi));
    const tanConfig = {
      kernelName: Tan,
      backendName: "cpu",
      kernelFunc: tan$1
    };
    /**
     * @license
     * Copyright 2020 Google LLC. All Rights Reserved.
     * Licensed under the Apache License, Version 2.0 (the License);
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     * http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an AS IS BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     * =============================================================================
     */
    const tanh$2 = unaryKernelFunc(Tanh3, (xi) => Math.tanh(xi));
    const tanhConfig2 = {
      kernelName: Tanh3,
      backendName: "cpu",
      kernelFunc: tanh$2
    };
    /**
     * @license
     * Copyright 2020 Google LLC. All Rights Reserved.
     * Licensed under the Apache License, Version 2.0 (the License);
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     * http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an AS IS BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     * =============================================================================
     */
    function unique$2(args) {
      const {inputs, attrs, backend: backend3} = args;
      const {axis} = attrs;
      const {x} = inputs;
      assertNotComplex(x, "unique");
      const values = backend3.data.get(x.dataId).values;
      const {outputValues, outputShape, indices} = uniqueImpl(values, axis, x.shape, x.dtype);
      return [
        backend3.makeTensorInfo(outputShape, x.dtype, outputValues),
        backend3.makeTensorInfo([indices.length], "int32", indices)
      ];
    }
    const uniqueConfig = {
      kernelName: Unique,
      backendName: "cpu",
      kernelFunc: unique$2
    };
    /**
     * @license
     * Copyright 2020 Google LLC. All Rights Reserved.
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     * http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     * =============================================================================
     */
    const kernelConfigs2 = [
      _fusedMatMulConfig,
      absConfig2,
      acosConfig,
      acoshConfig,
      addConfig2,
      asinConfig,
      asinhConfig,
      atanConfig,
      atanhConfig,
      avgPoolConfig2,
      avgPoolBackpropConfig,
      batchMatMulConfig2,
      batchNormConfig,
      castConfig2,
      ceilConfig,
      clipConfig,
      complexConfig,
      concatConfig2,
      conv2DBackpropFilterConfig,
      conv2DBackpropInputConfig2,
      conv2DConfig2,
      conv3DBackpropFilterV2Config,
      conv3DBackpropInputV2Config,
      conv3DConfig,
      cosConfig2,
      coshConfig,
      depthwiseConv2dNativeConfig2,
      depthwiseConv2dNativeBackpropFilterConfig,
      depthwiseConv2dNativeBackpropInputConfig,
      dilation2dConfig,
      dilation2dBackpropInputConfig,
      dilation2dBackpropFilterConfig,
      divConfig2,
      eluConfig,
      erfConfig,
      expConfig2,
      expm1Config,
      fftConfig,
      fillConfig2,
      flipLeftRightConfig2,
      floorConfig,
      fusedConv2DConfig2,
      fusedDepthwiseConv2DConfig2,
      identityConfig2,
      ifftConfig,
      imagConfig,
      isFiniteConfig,
      isInfConfig,
      isNaNConfig,
      logConfig2,
      log1pConfig,
      logicalNotConfig,
      maxPoolConfig2,
      maxPoolBackpropConfig,
      maxPoolWithArgmaxConfig,
      maxConfig2,
      mirrorPadConfig,
      multiplyConfig2,
      nonMaxSuppressionV4Config2,
      nonMaxSuppressionV5Config2,
      notEqualConfig2,
      padV2Config2,
      preluConfig2,
      realConfig,
      reciprocalConfig,
      reluConfig2,
      relu6Config2,
      reshapeConfig2,
      rotateWithOffsetConfig2,
      roundConfig,
      rsqrtConfig2,
      seluConfig,
      sigmoidConfig2,
      signConfig,
      sinConfig2,
      sinhConfig,
      sliceConfig2,
      softplusConfig,
      spaceToBatchNDConfig,
      sqrtConfig2,
      squareConfig2,
      squaredDifferenceConfig2,
      stepConfig,
      subConfig2,
      tanConfig,
      tanhConfig2,
      transposeConfig2,
      uniqueConfig
    ];
    for (const kernelConfig of kernelConfigs2) {
      registerKernel2(kernelConfig);
    }
    /**
     * @license
     * Copyright 2020 Google LLC. All Rights Reserved.
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     * http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     * =============================================================================
     */
    /**
     * @license
     * Copyright 2018 Google LLC. All Rights Reserved.
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     * http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     * =============================================================================
     */
    const contexts = {};
    const WEBGL_ATTRIBUTES = {
      alpha: false,
      antialias: false,
      premultipliedAlpha: false,
      preserveDrawingBuffer: false,
      depth: false,
      stencil: false,
      failIfMajorPerformanceCaveat: true
    };
    function clearWebGLContext(webGLVersion) {
      delete contexts[webGLVersion];
    }
    function setWebGLContext(webGLVersion, gl) {
      contexts[webGLVersion] = gl;
    }
    function getWebGLContext(webGLVersion) {
      if (!(webGLVersion in contexts)) {
        const newCtx = getWebGLRenderingContext(webGLVersion);
        if (newCtx !== null) {
          contexts[webGLVersion] = newCtx;
        } else {
          console.log("Could not get context for WebGL version", webGLVersion);
          return null;
        }
      }
      const gl = contexts[webGLVersion];
      if (gl.isContextLost()) {
        delete contexts[webGLVersion];
        return getWebGLContext(webGLVersion);
      }
      gl.disable(gl.DEPTH_TEST);
      gl.disable(gl.STENCIL_TEST);
      gl.disable(gl.BLEND);
      gl.disable(gl.DITHER);
      gl.disable(gl.POLYGON_OFFSET_FILL);
      gl.disable(gl.SAMPLE_COVERAGE);
      gl.enable(gl.SCISSOR_TEST);
      gl.enable(gl.CULL_FACE);
      gl.cullFace(gl.BACK);
      return contexts[webGLVersion];
    }
    function createCanvas(webGLVersion) {
      if (typeof OffscreenCanvas !== "undefined" && webGLVersion === 2) {
        return new OffscreenCanvas(300, 150);
      } else if (typeof document !== "undefined") {
        return document.createElement("canvas");
      } else {
        throw new Error("Cannot create a canvas in this context");
      }
    }
    function getWebGLRenderingContext(webGLVersion) {
      if (webGLVersion !== 1 && webGLVersion !== 2) {
        throw new Error("Cannot get WebGL rendering context, WebGL is disabled.");
      }
      const canvas = createCanvas(webGLVersion);
      canvas.addEventListener("webglcontextlost", (ev) => {
        ev.preventDefault();
        delete contexts[webGLVersion];
      }, false);
      if (webGLVersion === 1) {
        return canvas.getContext("webgl", WEBGL_ATTRIBUTES) || canvas.getContext("experimental-webgl", WEBGL_ATTRIBUTES);
      }
      return canvas.getContext("webgl2", WEBGL_ATTRIBUTES);
    }
    /**
     * @license
     * Copyright 2017 Google LLC. All Rights Reserved.
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     * http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     * =============================================================================
     */
    var PackingScheme;
    (function(PackingScheme2) {
      PackingScheme2[PackingScheme2["DENSE"] = 0] = "DENSE";
      PackingScheme2[PackingScheme2["SHARED_BATCH"] = 1] = "SHARED_BATCH";
    })(PackingScheme || (PackingScheme = {}));
    var TextureUsage;
    (function(TextureUsage2) {
      TextureUsage2[TextureUsage2["RENDER"] = 0] = "RENDER";
      TextureUsage2[TextureUsage2["UPLOAD"] = 1] = "UPLOAD";
      TextureUsage2[TextureUsage2["PIXELS"] = 2] = "PIXELS";
      TextureUsage2[TextureUsage2["DOWNLOAD"] = 3] = "DOWNLOAD";
    })(TextureUsage || (TextureUsage = {}));
    var PhysicalTextureType;
    (function(PhysicalTextureType2) {
      PhysicalTextureType2[PhysicalTextureType2["UNPACKED_FLOAT16"] = 0] = "UNPACKED_FLOAT16";
      PhysicalTextureType2[PhysicalTextureType2["UNPACKED_FLOAT32"] = 1] = "UNPACKED_FLOAT32";
      PhysicalTextureType2[PhysicalTextureType2["PACKED_4X1_UNSIGNED_BYTE"] = 2] = "PACKED_4X1_UNSIGNED_BYTE";
      PhysicalTextureType2[PhysicalTextureType2["PACKED_2X2_FLOAT32"] = 3] = "PACKED_2X2_FLOAT32";
      PhysicalTextureType2[PhysicalTextureType2["PACKED_2X2_FLOAT16"] = 4] = "PACKED_2X2_FLOAT16";
    })(PhysicalTextureType || (PhysicalTextureType = {}));
    function getUnpackedMatrixTextureShapeWidthHeight(rows, columns) {
      return [columns, rows];
    }
    function getUnpackedArraySizeFromMatrixSize(matrixSize, channelsPerTexture) {
      return matrixSize * channelsPerTexture;
    }
    function getColorMatrixTextureShapeWidthHeight(rows, columns) {
      return [columns * 4, rows];
    }
    function getDenseTexShape(shape) {
      const size = sizeFromShape2(shape);
      const texelsNeeded = Math.ceil(size / 4);
      return sizeToSquarishShape2(texelsNeeded);
    }
    function getMatrixSizeFromUnpackedArraySize(unpackedSize, channelsPerTexture) {
      if (unpackedSize % channelsPerTexture !== 0) {
        throw new Error(`unpackedSize (${unpackedSize}) must be a multiple of ${channelsPerTexture}`);
      }
      return unpackedSize / channelsPerTexture;
    }
    function decodeMatrixFromUnpackedColorRGBAArray(unpackedArray, matrix, channels) {
      const requiredSize = unpackedArray.length * channels / 4;
      if (matrix.length < requiredSize) {
        throw new Error(`matrix length (${matrix.length}) must be >= ${requiredSize}`);
      }
      let dst = 0;
      for (let src = 0; src < unpackedArray.length; src += 4) {
        for (let c = 0; c < channels; c++) {
          matrix[dst++] = unpackedArray[src + c];
        }
      }
    }
    function getPackedMatrixTextureShapeWidthHeight(rows, columns) {
      return [
        Math.max(1, Math.ceil(columns / 2)),
        Math.max(1, Math.ceil(rows / 2))
      ];
    }
    function getPackedRGBAArraySizeFromMatrixShape(rows, columns) {
      const [w, h] = getPackedMatrixTextureShapeWidthHeight(rows, columns);
      return w * h * 4;
    }
    function getTextureConfig(gl, textureHalfFloatExtension) {
      const glany = gl;
      let internalFormatFloat;
      let internalFormatHalfFloat;
      let internalFormatPackedHalfFloat;
      let internalFormatPackedFloat;
      let textureFormatFloat;
      let downloadTextureFormat;
      let downloadUnpackNumChannels;
      let defaultNumChannels;
      let textureTypeHalfFloat;
      let textureTypeFloat;
      if (env2().getNumber("WEBGL_VERSION") === 2) {
        internalFormatFloat = glany.R32F;
        internalFormatHalfFloat = glany.R16F;
        internalFormatPackedHalfFloat = glany.RGBA16F;
        internalFormatPackedFloat = glany.RGBA32F;
        textureFormatFloat = glany.RED;
        downloadUnpackNumChannels = 4;
        defaultNumChannels = 1;
        textureTypeHalfFloat = glany.HALF_FLOAT;
        textureTypeFloat = glany.FLOAT;
      } else {
        internalFormatFloat = gl.RGBA;
        internalFormatHalfFloat = gl.RGBA;
        internalFormatPackedHalfFloat = gl.RGBA;
        internalFormatPackedFloat = glany.RGBA;
        textureFormatFloat = gl.RGBA;
        downloadUnpackNumChannels = 4;
        defaultNumChannels = 4;
        textureTypeHalfFloat = textureHalfFloatExtension != null ? textureHalfFloatExtension.HALF_FLOAT_OES : null;
        textureTypeFloat = gl.FLOAT;
      }
      downloadTextureFormat = gl.RGBA;
      return {
        internalFormatFloat,
        internalFormatHalfFloat,
        internalFormatPackedHalfFloat,
        internalFormatPackedFloat,
        textureFormatFloat,
        downloadTextureFormat,
        downloadUnpackNumChannels,
        defaultNumChannels,
        textureTypeHalfFloat,
        textureTypeFloat
      };
    }
    /**
     * @license
     * Copyright 2017 Google LLC. All Rights Reserved.
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     * http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     * =============================================================================
     */
    function callAndCheck(gl, func2) {
      const returnValue = func2();
      if (env2().getBool("DEBUG")) {
        checkWebGLError(gl);
      }
      return returnValue;
    }
    function checkWebGLError(gl) {
      const error = gl.getError();
      if (error !== gl.NO_ERROR) {
        throw new Error("WebGL Error: " + getWebGLErrorMessage(gl, error));
      }
    }
    const MIN_FLOAT16 = 596e-10;
    const MAX_FLOAT16 = 65504;
    function canBeRepresented(num) {
      if (env2().getBool("WEBGL_RENDER_FLOAT32_ENABLED") || num === 0 || MIN_FLOAT16 < Math.abs(num) && Math.abs(num) < MAX_FLOAT16) {
        return true;
      }
      return false;
    }
    function getWebGLErrorMessage(gl, status2) {
      switch (status2) {
        case gl.NO_ERROR:
          return "NO_ERROR";
        case gl.INVALID_ENUM:
          return "INVALID_ENUM";
        case gl.INVALID_VALUE:
          return "INVALID_VALUE";
        case gl.INVALID_OPERATION:
          return "INVALID_OPERATION";
        case gl.INVALID_FRAMEBUFFER_OPERATION:
          return "INVALID_FRAMEBUFFER_OPERATION";
        case gl.OUT_OF_MEMORY:
          return "OUT_OF_MEMORY";
        case gl.CONTEXT_LOST_WEBGL:
          return "CONTEXT_LOST_WEBGL";
        default:
          return `Unknown error code ${status2}`;
      }
    }
    function getExtensionOrThrow(gl, extensionName) {
      return throwIfNull(gl, () => gl.getExtension(extensionName), 'Extension "' + extensionName + '" not supported on this browser.');
    }
    function createVertexShader(gl, vertexShaderSource) {
      const vertexShader = throwIfNull(gl, () => gl.createShader(gl.VERTEX_SHADER), "Unable to create vertex WebGLShader.");
      callAndCheck(gl, () => gl.shaderSource(vertexShader, vertexShaderSource));
      callAndCheck(gl, () => gl.compileShader(vertexShader));
      if (gl.getShaderParameter(vertexShader, gl.COMPILE_STATUS) === false) {
        console.log(gl.getShaderInfoLog(vertexShader));
        throw new Error("Failed to compile vertex shader.");
      }
      return vertexShader;
    }
    function createFragmentShader(gl, fragmentShaderSource) {
      const fragmentShader = throwIfNull(gl, () => gl.createShader(gl.FRAGMENT_SHADER), "Unable to create fragment WebGLShader.");
      callAndCheck(gl, () => gl.shaderSource(fragmentShader, fragmentShaderSource));
      callAndCheck(gl, () => gl.compileShader(fragmentShader));
      if (gl.getShaderParameter(fragmentShader, gl.COMPILE_STATUS) === false) {
        logShaderSourceAndInfoLog(fragmentShaderSource, gl.getShaderInfoLog(fragmentShader));
        throw new Error("Failed to compile fragment shader.");
      }
      return fragmentShader;
    }
    const lineNumberRegex = /ERROR: [0-9]+:([0-9]+):/g;
    function logShaderSourceAndInfoLog(shaderSource, shaderInfoLog) {
      const lineNumberRegexResult = lineNumberRegex.exec(shaderInfoLog);
      if (lineNumberRegexResult == null) {
        console.log(`Couldn't parse line number in error: ${shaderInfoLog}`);
        console.log(shaderSource);
        return;
      }
      const lineNumber = +lineNumberRegexResult[1];
      const shaderLines = shaderSource.split("\n");
      const pad3 = shaderLines.length.toString().length + 2;
      const linesWithLineNumbers = shaderLines.map((line, lineNumber2) => rightPad2((lineNumber2 + 1).toString(), pad3) + line);
      let maxLineLength = 0;
      for (let i = 0; i < linesWithLineNumbers.length; i++) {
        maxLineLength = Math.max(linesWithLineNumbers[i].length, maxLineLength);
      }
      const beforeErrorLines = linesWithLineNumbers.slice(0, lineNumber - 1);
      const errorLine = linesWithLineNumbers.slice(lineNumber - 1, lineNumber);
      const afterErrorLines = linesWithLineNumbers.slice(lineNumber);
      console.log(beforeErrorLines.join("\n"));
      console.log(shaderInfoLog.split("\n")[0]);
      console.log(`%c ${rightPad2(errorLine[0], maxLineLength)}`, "border:1px solid red; background-color:#e3d2d2; color:#a61717");
      console.log(afterErrorLines.join("\n"));
    }
    function createProgram(gl) {
      return throwIfNull(gl, () => gl.createProgram(), "Unable to create WebGLProgram.");
    }
    function linkProgram(gl, program) {
      callAndCheck(gl, () => gl.linkProgram(program));
      if (gl.getProgramParameter(program, gl.LINK_STATUS) === false) {
        console.log(gl.getProgramInfoLog(program));
        throw new Error("Failed to link vertex and fragment shaders.");
      }
    }
    function validateProgram(gl, program) {
      callAndCheck(gl, () => gl.validateProgram(program));
      if (gl.getProgramParameter(program, gl.VALIDATE_STATUS) === false) {
        console.log(gl.getProgramInfoLog(program));
        throw new Error("Shader program validation failed.");
      }
    }
    function createStaticVertexBuffer(gl, data2) {
      const buffer3 = throwIfNull(gl, () => gl.createBuffer(), "Unable to create WebGLBuffer");
      callAndCheck(gl, () => gl.bindBuffer(gl.ARRAY_BUFFER, buffer3));
      callAndCheck(gl, () => gl.bufferData(gl.ARRAY_BUFFER, data2, gl.STATIC_DRAW));
      return buffer3;
    }
    function createStaticIndexBuffer(gl, data2) {
      const buffer3 = throwIfNull(gl, () => gl.createBuffer(), "Unable to create WebGLBuffer");
      callAndCheck(gl, () => gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, buffer3));
      callAndCheck(gl, () => gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, data2, gl.STATIC_DRAW));
      return buffer3;
    }
    function getNumChannels() {
      if (env2().getNumber("WEBGL_VERSION") === 2) {
        return 1;
      }
      return 4;
    }
    function createTexture(gl) {
      return throwIfNull(gl, () => gl.createTexture(), "Unable to create WebGLTexture.");
    }
    function validateTextureSize(width, height) {
      const maxTextureSize = env2().getNumber("WEBGL_MAX_TEXTURE_SIZE");
      if (width <= 0 || height <= 0) {
        const requested = `[${width}x${height}]`;
        throw new Error("Requested texture size " + requested + " is invalid.");
      }
      if (width > maxTextureSize || height > maxTextureSize) {
        const requested = `[${width}x${height}]`;
        const max3 = `[${maxTextureSize}x${maxTextureSize}]`;
        throw new Error("Requested texture size " + requested + " greater than WebGL maximum on this browser / GPU " + max3 + ".");
      }
    }
    function createFramebuffer(gl) {
      return throwIfNull(gl, () => gl.createFramebuffer(), "Unable to create WebGLFramebuffer.");
    }
    function bindVertexBufferToProgramAttribute(gl, program, attribute, buffer3, arrayEntriesPerItem, itemStrideInBytes, itemOffsetInBytes) {
      const loc = gl.getAttribLocation(program, attribute);
      if (loc === -1) {
        return false;
      }
      callAndCheck(gl, () => gl.bindBuffer(gl.ARRAY_BUFFER, buffer3));
      callAndCheck(gl, () => gl.vertexAttribPointer(loc, arrayEntriesPerItem, gl.FLOAT, false, itemStrideInBytes, itemOffsetInBytes));
      callAndCheck(gl, () => gl.enableVertexAttribArray(loc));
      return true;
    }
    function bindTextureUnit(gl, texture, textureUnit) {
      validateTextureUnit(gl, textureUnit);
      callAndCheck(gl, () => gl.activeTexture(gl.TEXTURE0 + textureUnit));
      callAndCheck(gl, () => gl.bindTexture(gl.TEXTURE_2D, texture));
    }
    function unbindTextureUnit(gl, textureUnit) {
      validateTextureUnit(gl, textureUnit);
      callAndCheck(gl, () => gl.activeTexture(gl.TEXTURE0 + textureUnit));
      callAndCheck(gl, () => gl.bindTexture(gl.TEXTURE_2D, null));
    }
    function getProgramUniformLocationOrThrow(gl, program, uniformName) {
      return throwIfNull(gl, () => gl.getUniformLocation(program, uniformName), 'uniform "' + uniformName + '" not present in program.');
    }
    function getProgramUniformLocation(gl, program, uniformName) {
      return gl.getUniformLocation(program, uniformName);
    }
    function bindTextureToProgramUniformSampler(gl, texture, uniformSamplerLocation, textureUnit) {
      callAndCheck(gl, () => bindTextureUnit(gl, texture, textureUnit));
      callAndCheck(gl, () => gl.uniform1i(uniformSamplerLocation, textureUnit));
    }
    function bindCanvasToFramebuffer(gl) {
      callAndCheck(gl, () => gl.bindFramebuffer(gl.FRAMEBUFFER, null));
      callAndCheck(gl, () => gl.viewport(0, 0, gl.canvas.width, gl.canvas.height));
      callAndCheck(gl, () => gl.scissor(0, 0, gl.canvas.width, gl.canvas.height));
    }
    function bindColorTextureToFramebuffer(gl, texture, framebuffer) {
      callAndCheck(gl, () => gl.bindFramebuffer(gl.FRAMEBUFFER, framebuffer));
      callAndCheck(gl, () => gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, texture, 0));
    }
    function unbindColorTextureFromFramebuffer(gl, framebuffer) {
      callAndCheck(gl, () => gl.bindFramebuffer(gl.FRAMEBUFFER, framebuffer));
      callAndCheck(gl, () => gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, null, 0));
    }
    function validateFramebuffer(gl) {
      const status2 = gl.checkFramebufferStatus(gl.FRAMEBUFFER);
      if (status2 !== gl.FRAMEBUFFER_COMPLETE) {
        throw new Error("Error binding framebuffer: " + getFramebufferErrorMessage(gl, status2));
      }
    }
    function getFramebufferErrorMessage(gl, status2) {
      switch (status2) {
        case gl.FRAMEBUFFER_INCOMPLETE_ATTACHMENT:
          return "FRAMEBUFFER_INCOMPLETE_ATTACHMENT";
        case gl.FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT:
          return "FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT";
        case gl.FRAMEBUFFER_INCOMPLETE_DIMENSIONS:
          return "FRAMEBUFFER_INCOMPLETE_DIMENSIONS";
        case gl.FRAMEBUFFER_UNSUPPORTED:
          return "FRAMEBUFFER_UNSUPPORTED";
        default:
          return `unknown error ${status2}`;
      }
    }
    function throwIfNull(gl, returnTOrNull, failureMessage) {
      const tOrNull = callAndCheck(gl, () => returnTOrNull());
      if (tOrNull == null) {
        throw new Error(failureMessage);
      }
      return tOrNull;
    }
    function validateTextureUnit(gl, textureUnit) {
      const maxTextureUnit = gl.MAX_COMBINED_TEXTURE_IMAGE_UNITS - 1;
      const glTextureUnit = textureUnit + gl.TEXTURE0;
      if (glTextureUnit < gl.TEXTURE0 || glTextureUnit > maxTextureUnit) {
        const textureUnitRange = `[gl.TEXTURE0, gl.TEXTURE${maxTextureUnit}]`;
        throw new Error(`textureUnit must be in ${textureUnitRange}.`);
      }
    }
    function getBatchDim(shape, dimsToSkip = 2) {
      return sizeFromShape2(shape.slice(0, shape.length - dimsToSkip));
    }
    function getRowsCols(shape) {
      if (shape.length === 0) {
        throw Error("Cannot get rows and columns of an empty shape array.");
      }
      return [
        shape.length > 1 ? shape[shape.length - 2] : 1,
        shape[shape.length - 1]
      ];
    }
    function getShapeAs3D(shape) {
      let shapeAs3D = [1, 1, 1];
      const isScalar = shape.length === 0 || shape.length === 1 && shape[0] === 1;
      if (!isScalar) {
        shapeAs3D = [getBatchDim(shape), ...getRowsCols(shape)];
      }
      return shapeAs3D;
    }
    function getTextureShapeFromLogicalShape(logShape, isPacked = false) {
      let maxTexSize = env2().getNumber("WEBGL_MAX_TEXTURE_SIZE");
      if (isPacked) {
        maxTexSize = maxTexSize * 2;
        logShape = logShape.map((d, i) => i >= logShape.length - 2 ? nearestLargerEven2(logShape[i]) : logShape[i]);
        if (logShape.length === 1) {
          logShape = [2, logShape[0]];
        }
      }
      if (logShape.length !== 2) {
        const squeezeResult = squeezeShape2(logShape);
        logShape = squeezeResult.newShape;
      }
      let size = sizeFromShape2(logShape);
      if (logShape.length <= 1 && size <= maxTexSize) {
        return [1, size];
      } else if (logShape.length === 2 && logShape[0] <= maxTexSize && logShape[1] <= maxTexSize) {
        return logShape;
      } else if (logShape.length === 3 && logShape[0] * logShape[1] <= maxTexSize && logShape[2] <= maxTexSize) {
        return [logShape[0] * logShape[1], logShape[2]];
      } else if (logShape.length === 3 && logShape[0] <= maxTexSize && logShape[1] * logShape[2] <= maxTexSize) {
        return [logShape[0], logShape[1] * logShape[2]];
      } else if (logShape.length === 4 && logShape[0] * logShape[1] * logShape[2] <= maxTexSize && logShape[3] <= maxTexSize) {
        return [logShape[0] * logShape[1] * logShape[2], logShape[3]];
      } else if (logShape.length === 4 && logShape[0] <= maxTexSize && logShape[1] * logShape[2] * logShape[3] <= maxTexSize) {
        return [logShape[0], logShape[1] * logShape[2] * logShape[3]];
      } else {
        if (isPacked) {
          const batchDim = getBatchDim(logShape);
          let rows = 2, cols = 2;
          if (logShape.length) {
            [rows, cols] = getRowsCols(logShape);
          }
          size = batchDim * (rows / 2) * (cols / 2);
          return sizeToSquarishShape2(size).map((d) => d * 2);
        }
        return sizeToSquarishShape2(size);
      }
    }
    function isEven(n) {
      return n % 2 === 0;
    }
    function isReshapeFree(shape1, shape2) {
      shape1 = shape1.slice(-2);
      shape2 = shape2.slice(-2);
      if (arraysEqual2(shape1, shape2)) {
        return true;
      }
      if (!shape1.length || !shape2.length) {
        return true;
      }
      if (shape1[0] === 0 || shape1[1] === 0 || shape2[0] === 0 || shape2[1] === 0) {
        return true;
      }
      if (shape1.length !== shape2.length) {
        const shape1Cols = shape1.slice(-1)[0];
        const shape2Cols = shape2.slice(-1)[0];
        if (shape1Cols === shape2Cols) {
          return true;
        }
        if (isEven(shape1Cols) && isEven(shape2Cols) && (shape1[0] === 1 || shape2[0] === 1)) {
          return true;
        }
      }
      return shape1[1] === shape2[1] && isEven(shape1[0]) && isEven(shape2[0]);
    }
    let MAX_TEXTURE_SIZE;
    let MAX_TEXTURES_IN_SHADER;
    function getWebGLMaxTextureSize(webGLVersion) {
      if (MAX_TEXTURE_SIZE == null) {
        const gl = getWebGLContext(webGLVersion);
        MAX_TEXTURE_SIZE = gl.getParameter(gl.MAX_TEXTURE_SIZE);
      }
      return MAX_TEXTURE_SIZE;
    }
    function resetMaxTextureSize() {
      MAX_TEXTURE_SIZE = null;
    }
    function resetMaxTexturesInShader() {
      MAX_TEXTURES_IN_SHADER = null;
    }
    function getMaxTexturesInShader(webGLVersion) {
      if (MAX_TEXTURES_IN_SHADER == null) {
        const gl = getWebGLContext(webGLVersion);
        MAX_TEXTURES_IN_SHADER = gl.getParameter(gl.MAX_TEXTURE_IMAGE_UNITS);
      }
      return Math.min(16, MAX_TEXTURES_IN_SHADER);
    }
    function getWebGLDisjointQueryTimerVersion(webGLVersion) {
      if (webGLVersion === 0) {
        return 0;
      }
      let queryTimerVersion;
      const gl = getWebGLContext(webGLVersion);
      if (hasExtension(gl, "EXT_disjoint_timer_query_webgl2") && webGLVersion === 2) {
        queryTimerVersion = 2;
      } else if (hasExtension(gl, "EXT_disjoint_timer_query")) {
        queryTimerVersion = 1;
      } else {
        queryTimerVersion = 0;
      }
      return queryTimerVersion;
    }
    function hasExtension(gl, extensionName) {
      const ext = gl.getExtension(extensionName);
      return ext != null;
    }
    function isWebGLVersionEnabled(webGLVersion) {
      try {
        const gl = getWebGLContext(webGLVersion);
        if (gl != null) {
          return true;
        }
      } catch (e) {
        console.log("Error when getting WebGL context: ", e);
        return false;
      }
      return false;
    }
    function isCapableOfRenderingToFloatTexture(webGLVersion) {
      if (webGLVersion === 0) {
        return false;
      }
      const gl = getWebGLContext(webGLVersion);
      if (webGLVersion === 1) {
        if (!hasExtension(gl, "OES_texture_float")) {
          return false;
        }
      } else {
        if (!hasExtension(gl, "EXT_color_buffer_float")) {
          return false;
        }
      }
      const isFrameBufferComplete = createFloatTextureAndBindToFramebuffer(gl);
      return isFrameBufferComplete;
    }
    function isDownloadFloatTextureEnabled(webGLVersion) {
      if (webGLVersion === 0) {
        return false;
      }
      const gl = getWebGLContext(webGLVersion);
      if (webGLVersion === 1) {
        if (!hasExtension(gl, "OES_texture_float")) {
          return false;
        }
        if (!hasExtension(gl, "WEBGL_color_buffer_float")) {
          return false;
        }
      } else {
        if (hasExtension(gl, "EXT_color_buffer_float")) {
          return createFloatTextureAndBindToFramebuffer(gl);
        }
        const COLOR_BUFFER_HALF_FLOAT = "EXT_color_buffer_half_float";
        if (hasExtension(gl, COLOR_BUFFER_HALF_FLOAT)) {
          const textureHalfFloatExtension = gl.getExtension(COLOR_BUFFER_HALF_FLOAT);
          return createHalfFloatTextureAndBindToFramebuffer(gl, textureHalfFloatExtension);
        }
        return false;
      }
      const isFrameBufferComplete = createFloatTextureAndBindToFramebuffer(gl);
      return isFrameBufferComplete;
    }
    function createFloatTextureAndBindToFramebuffer(gl) {
      const texConfig = getTextureConfig(gl);
      const texture = gl.createTexture();
      gl.bindTexture(gl.TEXTURE_2D, texture);
      const width = 1;
      const height = 1;
      gl.texImage2D(gl.TEXTURE_2D, 0, texConfig.internalFormatFloat, width, height, 0, texConfig.textureFormatFloat, texConfig.textureTypeFloat, null);
      const frameBuffer = gl.createFramebuffer();
      gl.bindFramebuffer(gl.FRAMEBUFFER, frameBuffer);
      gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, texture, 0);
      const isFrameBufferComplete = gl.checkFramebufferStatus(gl.FRAMEBUFFER) === gl.FRAMEBUFFER_COMPLETE;
      gl.bindTexture(gl.TEXTURE_2D, null);
      gl.bindFramebuffer(gl.FRAMEBUFFER, null);
      gl.deleteTexture(texture);
      gl.deleteFramebuffer(frameBuffer);
      return isFrameBufferComplete;
    }
    function createHalfFloatTextureAndBindToFramebuffer(gl, textureHalfFloatExtension) {
      const texConfig = getTextureConfig(gl, textureHalfFloatExtension);
      const texture = gl.createTexture();
      gl.bindTexture(gl.TEXTURE_2D, texture);
      const width = 1;
      const height = 1;
      gl.texImage2D(gl.TEXTURE_2D, 0, texConfig.internalFormatHalfFloat, width, height, 0, texConfig.textureFormatFloat, texConfig.textureTypeHalfFloat, null);
      const frameBuffer = gl.createFramebuffer();
      gl.bindFramebuffer(gl.FRAMEBUFFER, frameBuffer);
      gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, texture, 0);
      const isFrameBufferComplete = gl.checkFramebufferStatus(gl.FRAMEBUFFER) === gl.FRAMEBUFFER_COMPLETE;
      gl.bindTexture(gl.TEXTURE_2D, null);
      gl.bindFramebuffer(gl.FRAMEBUFFER, null);
      gl.deleteTexture(texture);
      gl.deleteFramebuffer(frameBuffer);
      return isFrameBufferComplete;
    }
    function isWebGLFenceEnabled(webGLVersion) {
      if (webGLVersion !== 2) {
        return false;
      }
      const gl = getWebGLContext(webGLVersion);
      const isEnabled = gl.fenceSync != null;
      return isEnabled;
    }
    function assertNotComplex$1(tensor7, opName) {
      if (!Array.isArray(tensor7)) {
        tensor7 = [tensor7];
      }
      tensor7.forEach((t) => {
        if (t != null) {
          assert2(t.dtype !== "complex64", () => `${opName} does not support complex64 tensors in the WebGL backend.`);
        }
      });
    }
    /**
     * @license
     * Copyright 2019 Google LLC. All Rights Reserved.
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     * http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     * =============================================================================
     */
    const ENV$1 = env2();
    ENV$1.registerFlag("HAS_WEBGL", () => ENV$1.getNumber("WEBGL_VERSION") > 0);
    ENV$1.registerFlag("WEBGL_VERSION", () => {
      if (isWebGLVersionEnabled(2)) {
        return 2;
      } else if (isWebGLVersionEnabled(1)) {
        return 1;
      }
      return 0;
    });
    ENV$1.registerFlag("WEBGL_CHECK_NUMERICAL_PROBLEMS", () => false);
    ENV$1.registerFlag("WEBGL_BUFFER_SUPPORTED", () => ENV$1.get("WEBGL_VERSION") === 2);
    ENV$1.registerFlag("WEBGL_CPU_FORWARD", () => true);
    ENV$1.registerFlag("WEBGL_FORCE_F16_TEXTURES", () => false);
    ENV$1.registerFlag("WEBGL_PACK", () => ENV$1.getBool("HAS_WEBGL"));
    ENV$1.registerFlag("WEBGL_PACK_NORMALIZATION", () => ENV$1.getBool("WEBGL_PACK"));
    ENV$1.registerFlag("WEBGL_PACK_CLIP", () => ENV$1.getBool("WEBGL_PACK"));
    ENV$1.registerFlag("WEBGL_PACK_DEPTHWISECONV", () => false);
    ENV$1.registerFlag("WEBGL_PACK_BINARY_OPERATIONS", () => ENV$1.getBool("WEBGL_PACK"));
    ENV$1.registerFlag("WEBGL_PACK_UNARY_OPERATIONS", () => ENV$1.getBool("WEBGL_PACK"));
    ENV$1.registerFlag("WEBGL_PACK_ARRAY_OPERATIONS", () => ENV$1.getBool("WEBGL_PACK"));
    ENV$1.registerFlag("WEBGL_PACK_IMAGE_OPERATIONS", () => ENV$1.getBool("WEBGL_PACK"));
    ENV$1.registerFlag("WEBGL_PACK_REDUCE", () => ENV$1.getBool("WEBGL_PACK"));
    ENV$1.registerFlag("WEBGL_LAZILY_UNPACK", () => ENV$1.getBool("WEBGL_PACK"));
    ENV$1.registerFlag("WEBGL_CONV_IM2COL", () => ENV$1.getBool("WEBGL_PACK"));
    ENV$1.registerFlag("WEBGL_MAX_TEXTURE_SIZE", () => getWebGLMaxTextureSize(ENV$1.getNumber("WEBGL_VERSION")));
    ENV$1.registerFlag("WEBGL_MAX_TEXTURES_IN_SHADER", () => getMaxTexturesInShader(ENV$1.getNumber("WEBGL_VERSION")));
    ENV$1.registerFlag("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION", () => {
      const webGLVersion = ENV$1.getNumber("WEBGL_VERSION");
      if (webGLVersion === 0) {
        return 0;
      }
      return getWebGLDisjointQueryTimerVersion(webGLVersion);
    });
    ENV$1.registerFlag("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE", () => ENV$1.getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION") > 0 && !isMobile());
    ENV$1.registerFlag("WEBGL_RENDER_FLOAT32_CAPABLE", () => isCapableOfRenderingToFloatTexture(ENV$1.getNumber("WEBGL_VERSION")));
    ENV$1.registerFlag("WEBGL_RENDER_FLOAT32_ENABLED", () => {
      return ENV$1.getBool("WEBGL_FORCE_F16_TEXTURES") ? false : ENV$1.getBool("WEBGL_RENDER_FLOAT32_CAPABLE");
    });
    ENV$1.registerFlag("WEBGL_DOWNLOAD_FLOAT_ENABLED", () => isDownloadFloatTextureEnabled(ENV$1.getNumber("WEBGL_VERSION")));
    ENV$1.registerFlag("WEBGL_FENCE_API_ENABLED", () => isWebGLFenceEnabled(ENV$1.getNumber("WEBGL_VERSION")));
    ENV$1.registerFlag("WEBGL_SIZE_UPLOAD_UNIFORM", () => {
      const useUniforms = ENV$1.getBool("WEBGL_RENDER_FLOAT32_ENABLED");
      return useUniforms ? 4 : 0;
    });
    ENV$1.registerFlag("WEBGL_DELETE_TEXTURE_THRESHOLD", () => {
      return -1;
    }, (threshold2) => {
      if (threshold2 < 0 && threshold2 !== -1) {
        throw new Error(`WEBGL_DELETE_TEXTURE_THRESHOLD must be -1 (indicating never delete) or at least 0, but got ${threshold2}.`);
      }
    });
    /**
     * @license
     * Copyright 2020 Google LLC. All Rights Reserved.
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     * http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     * =============================================================================
     */
    const {simpleAbsImpl: simpleAbsImplCPU, addImpl: addImplCPU, ceilImpl: ceilImplCPU, expImpl: expImplCPU, expm1Impl: expm1ImplCPU, floorImpl: floorImplCPU, logImpl: logImplCPU, maxImpl: maxImplCPU, multiplyImpl: multiplyImplCPU, rsqrtImpl: rsqrtImplCPU, sliceImpl: sliceImplCPU, subImpl: subImplCPU, transposeImpl: transposeImplCPU, uniqueImpl: uniqueImplCPU} = shared;
    /**
     * @license
     * Copyright 2019 Google LLC. All Rights Reserved.
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     * http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     * =============================================================================
     */
    class AddNProgram {
      constructor(outputShape, shapes) {
        this.outputShape = [];
        this.outputShape = outputShape;
        this.variableNames = shapes.map((_, i) => `T${i}`);
        const snippets = [];
        this.variableNames.forEach((variable2) => {
          snippets.push(`float v${variable2} = get${variable2}AtOutCoords();`);
        });
        const operation12 = this.variableNames.map((variable2) => {
          return `v${variable2}`;
        }).join(" + ");
        this.userCode = `
      void main() {
        ${snippets.join("\n        ")}

        float result = ${operation12};
        setOutput(result);
      }
    `;
      }
    }
    /**
     * @license
     * Copyright 2019 Google LLC. All Rights Reserved.
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     * http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     * =============================================================================
     */
    class AddNPackedProgram {
      constructor(outputShape, shapes) {
        this.outputShape = [];
        this.packedInputs = true;
        this.packedOutput = true;
        this.outputShape = outputShape;
        this.variableNames = shapes.map((_, i) => `T${i}`);
        const snippets = [];
        this.variableNames.forEach((variable2) => {
          snippets.push(`vec4 v${variable2} = get${variable2}AtOutCoords();`);
        });
        const operation12 = this.variableNames.map((variable2) => {
          return `v${variable2}`;
        }).join(" + ");
        this.userCode = `
      void main() {
        ${snippets.join("\n        ")}

        vec4 result = ${operation12};
        setOutput(result);
      }
    `;
      }
    }
    /**
     * @license
     * Copyright 2017 Google LLC. All Rights Reserved.
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     * http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     * =============================================================================
     */
    class ArgMinMaxProgram {
      constructor(reduceInfo, op3, firstPass) {
        this.variableNames = ["A"];
        const {windowSize, batchSize, outSize} = reduceInfo;
        if (!firstPass) {
          this.variableNames.push("bestIndicesA");
        }
        this.outputShape = [batchSize, outSize];
        const compOp = op3 === "max" ? ">" : "<";
        const indexSnippet = firstPass ? "inOffset + i;" : "round(getBestIndicesA(batch, inOffset + i));";
        this.userCode = `
      void main() {
        ivec2 coords = getOutputCoords();
        int batch = coords[0];
        int outIdx = coords[1];
        int inOffset = outIdx * ${windowSize};

        int bestIndex = inOffset;
        float bestValue = getA(batch, bestIndex);

        for (int i = 0; i < ${windowSize}; i++) {
          int inIdx = ${indexSnippet};
          float candidate = getA(batch, inIdx);
          if (candidate ${compOp} bestValue) {
            bestValue = candidate;
            bestIndex = inIdx;
          }
        }
        setOutput(float(bestIndex));
      }
    `;
      }
    }
    /**
     * @license
     * Copyright 2018 Google LLC. All Rights Reserved.
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     * http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     * =============================================================================
     */
    function getVecChannels(name, rank) {
      return ["x", "y", "z", "w", "u", "v"].slice(0, rank).map((d) => `${name}.${d}`);
    }
    function getChannels(name, rank) {
      if (rank === 1) {
        return [name];
      }
      return getVecChannels(name, rank);
    }
    function getSourceCoords(rank, dims) {
      if (rank === 1) {
        return "rc";
      }
      let coords2 = "";
      for (let i = 0; i < rank; i++) {
        coords2 += dims[i];
        if (i < rank - 1) {
          coords2 += ",";
        }
      }
      return coords2;
    }
    /**
     * @license
     * Copyright 2018 Google LLC. All Rights Reserved.
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     * http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     * =============================================================================
     */
    function getGlslDifferences() {
      let version5;
      let attribute;
      let varyingVs;
      let varyingFs;
      let texture2D;
      let output;
      let defineOutput;
      let defineSpecialNaN;
      let defineSpecialInf;
      let defineRound;
      if (env2().getNumber("WEBGL_VERSION") === 2) {
        version5 = "#version 300 es";
        attribute = "in";
        varyingVs = "out";
        varyingFs = "in";
        texture2D = "texture";
        output = "outputColor";
        defineOutput = "out vec4 outputColor;";
        defineSpecialNaN = `
      bool isnan_custom(float val) {
        return (val > 0.0 || val < 0.0) ? false : val != 0.0;
      }

      bvec4 isnan_custom(vec4 val) {
        return bvec4(isnan_custom(val.x),
          isnan_custom(val.y), isnan_custom(val.z), isnan_custom(val.w));
      }

      #define isnan(value) isnan_custom(value)
    `;
        defineSpecialInf = ``;
        defineRound = `
      #define round(value) newRound(value)
      int newRound(float value) {
        return int(floor(value + 0.5));
      }

      ivec4 newRound(vec4 value) {
        return ivec4(floor(value + vec4(0.5)));
      }
    `;
      } else {
        version5 = "";
        attribute = "attribute";
        varyingVs = "varying";
        varyingFs = "varying";
        texture2D = "texture2D";
        output = "gl_FragColor";
        defineOutput = "";
        defineSpecialNaN = `
      #define isnan(value) isnan_custom(value)
      bool isnan_custom(float val) {
        return (val > 0. || val < 1. || val == 0.) ? false : true;
      }
      bvec4 isnan_custom(vec4 val) {
        return bvec4(isnan(val.x), isnan(val.y), isnan(val.z), isnan(val.w));
      }
    `;
        defineSpecialInf = `
      uniform float INFINITY;

      bool isinf(float val) {
        return abs(val) == INFINITY;
      }
      bvec4 isinf(vec4 val) {
        return equal(abs(val), vec4(INFINITY));
      }
    `;
        defineRound = `
      int round(float value) {
        return int(floor(value + 0.5));
      }

      ivec4 round(vec4 value) {
        return ivec4(floor(value + vec4(0.5)));
      }
    `;
      }
      return {
        version: version5,
        attribute,
        varyingVs,
        varyingFs,
        texture2D,
        output,
        defineOutput,
        defineSpecialNaN,
        defineSpecialInf,
        defineRound
      };
    }
    /**
     * @license
     * Copyright 2018 Google LLC. All Rights Reserved.
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     * http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     * =============================================================================
     */
    function getLogicalCoordinatesFromFlatIndex(coords2, shape, index2 = "index") {
      const strides = computeStrides2(shape);
      return strides.map((stride, i) => {
        const line1 = `int ${coords2[i]} = ${index2} / ${stride}`;
        const line2 = i === strides.length - 1 ? `int ${coords2[i + 1]} = ${index2} - ${coords2[i]} * ${stride}` : `index -= ${coords2[i]} * ${stride}`;
        return `${line1}; ${line2};`;
      }).join("");
    }
    function buildVec(x) {
      if (x.length === 1) {
        return `${x[0]}`;
      }
      return `vec${x.length}(${x.join(",")})`;
    }
    function dotify(x, y) {
      if (x.length !== y.length) {
        throw new Error(`Vectors to be dotted must be of the same length -got ${x.length} and ${y.length}`);
      }
      const slices = [];
      const nearestVec4 = Math.floor(x.length / 4);
      const nearestVec4Remainder = x.length % 4;
      for (let i = 0; i < nearestVec4; i++) {
        const xSlice = x.slice(i * 4, i * 4 + 4);
        const ySlice = y.slice(i * 4, i * 4 + 4);
        slices.push(`${buildVec(xSlice)}, ${buildVec(ySlice)}`);
      }
      if (nearestVec4Remainder !== 0) {
        let xSlice = x.slice(nearestVec4 * 4);
        let ySlice = y.slice(nearestVec4 * 4);
        if (xSlice.length === 1) {
          xSlice = xSlice.map((d) => `float(${d})`);
          ySlice = ySlice.map((d) => `float(${d})`);
        }
        slices.push(`${buildVec(xSlice)}, ${buildVec(ySlice)}`);
      }
      return slices.map((d, i) => `dot(${d})`).join("+");
    }
    function getFlatIndexFrom3D(shape) {
      const strides = computeStrides2(shape).map((d) => d.toString());
      return `
  int getFlatIndex(ivec3 coords) {
    return coords.x * ${strides[0]} + coords.y * ${strides[1]} + coords.z;
  }
`;
    }
    const ENCODE_FLOAT_SNIPPET = `
  const float FLOAT_MAX = 1.70141184e38;
  const float FLOAT_MIN = 1.17549435e-38;

  lowp vec4 encode_float(highp float v) {
    if (isnan(v)) {
      return vec4(255, 255, 255, 255);
    }

    highp float av = abs(v);

    if(av < FLOAT_MIN) {
      return vec4(0.0, 0.0, 0.0, 0.0);
    } else if(v > FLOAT_MAX) {
      return vec4(0.0, 0.0, 128.0, 127.0) / 255.0;
    } else if(v < -FLOAT_MAX) {
      return vec4(0.0, 0.0,  128.0, 255.0) / 255.0;
    }

    highp vec4 c = vec4(0,0,0,0);

    highp float e = floor(log2(av));
    highp float m = exp2(fract(log2(av))) - 1.0;

    c[2] = floor(128.0 * m);
    m -= c[2] / 128.0;
    c[1] = floor(32768.0 * m);
    m -= c[1] / 32768.0;
    c[0] = floor(8388608.0 * m);

    highp float ebias = e + 127.0;
    c[3] = floor(ebias / 2.0);
    ebias -= c[3] * 2.0;
    c[2] += floor(ebias) * 128.0;

    c[3] += 128.0 * step(0.0, -v);

    return c / 255.0;
  }
`;
    /**
     * @license
     * Copyright 2017 Google LLC. All Rights Reserved.
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     * http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     * =============================================================================
     */
    const {getBroadcastDims: getBroadcastDims$1} = backend_util;
    function makeShader(inputsInfo, outputShape, userCode, usesPackedTextures) {
      const prefixSnippets = [];
      inputsInfo.forEach((x) => {
        const size = sizeFromShape2(x.shapeInfo.logicalShape);
        if (x.shapeInfo.isUniform) {
          prefixSnippets.push(`uniform float ${x.name}${size > 1 ? `[${size}]` : ""};`);
        } else {
          prefixSnippets.push(`uniform sampler2D ${x.name};`);
          prefixSnippets.push(`uniform int offset${x.name};`);
        }
      });
      const inputPrefixSnippet = prefixSnippets.join("\n");
      const inputSamplingSnippet = inputsInfo.map((x) => getInputSamplingSnippet(x, outputShape, usesPackedTextures)).join("\n");
      const outTexShape = outputShape.texShape;
      const glsl = getGlslDifferences();
      const floatTextureSampleSnippet = getFloatTextureSampleSnippet(glsl);
      let outputSamplingSnippet;
      let floatTextureSetOutputSnippet;
      let shaderPrefix = getShaderPrefix(glsl);
      if (outputShape.isPacked) {
        outputSamplingSnippet = getPackedOutputSamplingSnippet(outputShape.logicalShape, outTexShape);
        floatTextureSetOutputSnippet = getFloatTextureSetRGBASnippet(glsl);
      } else {
        outputSamplingSnippet = getOutputSamplingSnippet(outputShape.logicalShape, outTexShape);
        floatTextureSetOutputSnippet = getFloatTextureSetRSnippet(glsl);
      }
      if (usesPackedTextures) {
        shaderPrefix += SHADER_PACKED_PREFIX;
      }
      const source = [
        shaderPrefix,
        floatTextureSampleSnippet,
        floatTextureSetOutputSnippet,
        inputPrefixSnippet,
        outputSamplingSnippet,
        inputSamplingSnippet,
        userCode
      ].join("\n");
      return source;
    }
    function getSamplerFromInInfo(inInfo) {
      const shape = inInfo.shapeInfo.logicalShape;
      switch (shape.length) {
        case 0:
          return getSamplerScalar(inInfo);
        case 1:
          return getSampler1D(inInfo);
        case 2:
          return getSampler2D(inInfo);
        case 3:
          return getSampler3D(inInfo);
        case 4:
          return getSampler4D(inInfo);
        case 5:
          return getSampler5D(inInfo);
        case 6:
          return getSampler6D(inInfo);
        default:
          throw new Error(`${shape.length}-D input sampling is not yet supported`);
      }
    }
    function getPackedSamplerFromInInfo(inInfo) {
      const shape = inInfo.shapeInfo.logicalShape;
      switch (shape.length) {
        case 0:
          return getPackedSamplerScalar(inInfo);
        case 1:
          return getPackedSampler1D(inInfo);
        case 2:
          return getPackedSampler2D(inInfo);
        case 3:
          return getPackedSampler3D(inInfo);
        default:
          return getPackedSamplerND(inInfo);
      }
    }
    function getInputSamplingSnippet(inInfo, outShapeInfo, usesPackedTextures = false) {
      let res = "";
      if (usesPackedTextures) {
        res += getPackedSamplerFromInInfo(inInfo);
      } else {
        res += getSamplerFromInInfo(inInfo);
      }
      const inShape = inInfo.shapeInfo.logicalShape;
      const outShape = outShapeInfo.logicalShape;
      if (inShape.length <= outShape.length) {
        if (usesPackedTextures) {
          res += getPackedSamplerAtOutputCoords(inInfo, outShapeInfo);
        } else {
          res += getSamplerAtOutputCoords(inInfo, outShapeInfo);
        }
      }
      return res;
    }
    function getPackedOutputSamplingSnippet(outShape, outTexShape) {
      switch (outShape.length) {
        case 0:
          return getOutputScalarCoords();
        case 1:
          return getOutputPacked1DCoords(outShape, outTexShape);
        case 2:
          return getOutputPacked2DCoords(outShape, outTexShape);
        case 3:
          return getOutputPacked3DCoords(outShape, outTexShape);
        default:
          return getOutputPackedNDCoords(outShape, outTexShape);
      }
    }
    function getOutputSamplingSnippet(outShape, outTexShape) {
      switch (outShape.length) {
        case 0:
          return getOutputScalarCoords();
        case 1:
          return getOutput1DCoords(outShape, outTexShape);
        case 2:
          return getOutput2DCoords(outShape, outTexShape);
        case 3:
          return getOutput3DCoords(outShape, outTexShape);
        case 4:
          return getOutput4DCoords(outShape, outTexShape);
        case 5:
          return getOutput5DCoords(outShape, outTexShape);
        case 6:
          return getOutput6DCoords(outShape, outTexShape);
        default:
          throw new Error(`${outShape.length}-D output sampling is not yet supported`);
      }
    }
    function getFloatTextureSampleSnippet(glsl) {
      return `
    float sampleTexture(sampler2D textureSampler, vec2 uv) {
      return ${glsl.texture2D}(textureSampler, uv).r;
    }
  `;
    }
    function getFloatTextureSetRSnippet(glsl) {
      return `
    void setOutput(float val) {
      ${glsl.output} = vec4(val, 0, 0, 0);
    }
  `;
    }
    function getFloatTextureSetRGBASnippet(glsl) {
      return `
    void setOutput(vec4 val) {
      ${glsl.output} = val;
    }
  `;
    }
    function getShaderPrefix(glsl) {
      const SHADER_PREFIX = `${glsl.version}
    precision highp float;
    precision highp int;
    precision highp sampler2D;
    ${glsl.varyingFs} vec2 resultUV;
    ${glsl.defineOutput}
    const vec2 halfCR = vec2(0.5, 0.5);

    struct ivec5
    {
      int x;
      int y;
      int z;
      int w;
      int u;
    };

    struct ivec6
    {
      int x;
      int y;
      int z;
      int w;
      int u;
      int v;
    };

    uniform float NAN;
    ${glsl.defineSpecialNaN}
    ${glsl.defineSpecialInf}
    ${glsl.defineRound}

    int imod(int x, int y) {
      return x - y * (x / y);
    }

    int idiv(int a, int b, float sign) {
      int res = a / b;
      int mod = imod(a, b);
      if (sign < 0. && mod != 0) {
        res -= 1;
      }
      return res;
    }

    //Based on the work of Dave Hoskins
    //https://www.shadertoy.com/view/4djSRW
    #define HASHSCALE1 443.8975
    float random(float seed){
      vec2 p = resultUV * seed;
      vec3 p3  = fract(vec3(p.xyx) * HASHSCALE1);
      p3 += dot(p3, p3.yzx + 19.19);
      return fract((p3.x + p3.y) * p3.z);
    }

    ${SAMPLE_1D_SNIPPET}
    ${SAMPLE_2D_SNIPPET}
    ${SAMPLE_3D_SNIPPET}
  `;
      return SHADER_PREFIX;
    }
    const SAMPLE_1D_SNIPPET = `
vec2 uvFromFlat(int texNumR, int texNumC, int index) {
  int texR = index / texNumC;
  int texC = index - texR * texNumC;
  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);
}
vec2 packedUVfrom1D(int texNumR, int texNumC, int index) {
  int texelIndex = index / 2;
  int texR = texelIndex / texNumC;
  int texC = texelIndex - texR * texNumC;
  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);
}
`;
    const SAMPLE_2D_SNIPPET = `
vec2 packedUVfrom2D(int texelsInLogicalRow, int texNumR,
  int texNumC, int row, int col) {
  int texelIndex = (row / 2) * texelsInLogicalRow + (col / 2);
  int texR = texelIndex / texNumC;
  int texC = texelIndex - texR * texNumC;
  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);
}
`;
    const SAMPLE_3D_SNIPPET = `
vec2 packedUVfrom3D(int texNumR, int texNumC,
    int texelsInBatch, int texelsInLogicalRow, int b,
    int row, int col) {
  int index = b * texelsInBatch + (row / 2) * texelsInLogicalRow + (col / 2);
  int texR = index / texNumC;
  int texC = index - texR * texNumC;
  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);
}
`;
    const SHADER_PACKED_PREFIX = `
  float getChannel(vec4 frag, vec2 innerDims) {
    vec2 modCoord = mod(innerDims, 2.);
    return modCoord.x == 0. ?
      (modCoord.y == 0. ? frag.r : frag.g) :
      (modCoord.y == 0. ? frag.b : frag.a);
  }
  float getChannel(vec4 frag, int dim) {
    float modCoord = mod(float(dim), 2.);
    return modCoord == 0. ? frag.r : frag.g;
  }
`;
    function getOutputScalarCoords() {
      return `
    int getOutputCoords() {
      return 0;
    }
  `;
    }
    function getOutputPacked1DCoords(shape, texShape) {
      const packedTexShape = [Math.ceil(texShape[0] / 2), Math.ceil(texShape[1] / 2)];
      if (packedTexShape[0] === 1) {
        return `
      int getOutputCoords() {
        return 2 * int(resultUV.x * ${packedTexShape[1]}.0);
      }
    `;
      }
      if (packedTexShape[1] === 1) {
        return `
      int getOutputCoords() {
        return 2 * int(resultUV.y * ${packedTexShape[0]}.0);
      }
    `;
      }
      return `
    int getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(${packedTexShape[0]}, ${packedTexShape[1]}));
      return 2 * (resTexRC.x * ${packedTexShape[1]} + resTexRC.y);
    }
  `;
    }
    function getOutput1DCoords(shape, texShape) {
      if (texShape[0] === 1) {
        return `
      int getOutputCoords() {
        return int(resultUV.x * ${texShape[1]}.0);
      }
    `;
      }
      if (texShape[1] === 1) {
        return `
      int getOutputCoords() {
        return int(resultUV.y * ${texShape[0]}.0);
      }
    `;
      }
      return `
    int getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(${texShape[0]}, ${texShape[1]}));
      return resTexRC.x * ${texShape[1]} + resTexRC.y;
    }
  `;
    }
    function getOutputPacked3DCoords(shape, texShape) {
      const packedTexShape = [Math.ceil(texShape[0] / 2), Math.ceil(texShape[1] / 2)];
      const texelsInLogicalRow = Math.ceil(shape[2] / 2);
      const texelsInBatch = texelsInLogicalRow * Math.ceil(shape[1] / 2);
      return `
    ivec3 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(${packedTexShape[0]}, ${packedTexShape[1]}));
      int index = resTexRC.x * ${packedTexShape[1]} + resTexRC.y;

      int b = index / ${texelsInBatch};
      index -= b * ${texelsInBatch};

      int r = 2 * (index / ${texelsInLogicalRow});
      int c = imod(index, ${texelsInLogicalRow}) * 2;

      return ivec3(b, r, c);
    }
  `;
    }
    function getOutput3DCoords(shape, texShape) {
      const coordsFromIndexSnippet = getLogicalCoordinatesFromFlatIndex(["r", "c", "d"], shape);
      return `
    ivec3 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(${texShape[0]}, ${texShape[1]}));
      int index = resTexRC.x * ${texShape[1]} + resTexRC.y;
      ${coordsFromIndexSnippet}
      return ivec3(r, c, d);
    }
  `;
    }
    function getOutputPackedNDCoords(shape, texShape) {
      const packedTexShape = [Math.ceil(texShape[0] / 2), Math.ceil(texShape[1] / 2)];
      const texelsInLogicalRow = Math.ceil(shape[shape.length - 1] / 2);
      const texelsInBatch = texelsInLogicalRow * Math.ceil(shape[shape.length - 2] / 2);
      let texelsInBatchN = texelsInBatch;
      let batches = ``;
      let coords2 = "b, r, c";
      for (let b = 2; b < shape.length - 1; b++) {
        texelsInBatchN *= shape[shape.length - b - 1];
        batches = `
      int b${b} = index / ${texelsInBatchN};
      index -= b${b} * ${texelsInBatchN};
    ` + batches;
        coords2 = `b${b}, ` + coords2;
      }
      return `
    ivec${shape.length} getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(${packedTexShape[0]}, ${packedTexShape[1]}));
      int index = resTexRC.x * ${packedTexShape[1]} + resTexRC.y;

      ${batches}

      int b = index / ${texelsInBatch};
      index -= b * ${texelsInBatch};

      int r = 2 * (index / ${texelsInLogicalRow});
      int c = imod(index, ${texelsInLogicalRow}) * 2;

      return ivec${shape.length}(${coords2});
    }
  `;
    }
    function getOutput4DCoords(shape, texShape) {
      const coordsFromIndexSnippet = getLogicalCoordinatesFromFlatIndex(["r", "c", "d", "d2"], shape);
      return `
    ivec4 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
        vec2(${texShape[0]}, ${texShape[1]}));
      int index = resTexRC.x * ${texShape[1]} + resTexRC.y;
      ${coordsFromIndexSnippet}
      return ivec4(r, c, d, d2);
    }
  `;
    }
    function getOutput5DCoords(shape, texShape) {
      const coordsFromIndexSnippet = getLogicalCoordinatesFromFlatIndex(["r", "c", "d", "d2", "d3"], shape);
      return `
    ivec5 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx * vec2(${texShape[0]},
                             ${texShape[1]}));

      int index = resTexRC.x * ${texShape[1]} + resTexRC.y;

      ${coordsFromIndexSnippet}

      ivec5 outShape = ivec5(r, c, d, d2, d3);
      return outShape;
    }
  `;
    }
    function getOutput6DCoords(shape, texShape) {
      const coordsFromIndexSnippet = getLogicalCoordinatesFromFlatIndex(["r", "c", "d", "d2", "d3", "d4"], shape);
      return `
    ivec6 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
        vec2(${texShape[0]}, ${texShape[1]}));
      int index = resTexRC.x * ${texShape[1]} + resTexRC.y;

      ${coordsFromIndexSnippet}

      ivec6 result = ivec6(r, c, d, d2, d3, d4);
      return result;
    }
  `;
    }
    function getOutputPacked2DCoords(shape, texShape) {
      const packedTexShape = [Math.ceil(texShape[0] / 2), Math.ceil(texShape[1] / 2)];
      if (arraysEqual2(shape, texShape)) {
        return `
      ivec2 getOutputCoords() {
        return 2 * ivec2(resultUV.yx * vec2(${packedTexShape[0]}, ${packedTexShape[1]}));
      }
    `;
      }
      const texelsInLogicalRow = Math.ceil(shape[1] / 2);
      return `
    ivec2 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(${packedTexShape[0]}, ${packedTexShape[1]}));

      int index = resTexRC.x * ${packedTexShape[1]} + resTexRC.y;
      int r = 2 * (index / ${texelsInLogicalRow});
      int c = imod(index, ${texelsInLogicalRow}) * 2;

      return ivec2(r, c);
    }
  `;
    }
    function getOutput2DCoords(shape, texShape) {
      if (arraysEqual2(shape, texShape)) {
        return `
      ivec2 getOutputCoords() {
        return ivec2(resultUV.yx * vec2(${texShape[0]}, ${texShape[1]}));
      }
    `;
      }
      if (shape[1] === 1) {
        return `
      ivec2 getOutputCoords() {
        ivec2 resTexRC = ivec2(resultUV.yx *
                               vec2(${texShape[0]}, ${texShape[1]}));
        int index = resTexRC.x * ${texShape[1]} + resTexRC.y;
        return ivec2(index, 0);
      }
    `;
      }
      if (shape[0] === 1) {
        return `
      ivec2 getOutputCoords() {
        ivec2 resTexRC = ivec2(resultUV.yx *
                               vec2(${texShape[0]}, ${texShape[1]}));
        int index = resTexRC.x * ${texShape[1]} + resTexRC.y;
        return ivec2(0, index);
      }
    `;
      }
      return `
    ivec2 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(${texShape[0]}, ${texShape[1]}));
      int index = resTexRC.x * ${texShape[1]} + resTexRC.y;
      int r = index / ${shape[1]};
      int c = index - r * ${shape[1]};
      return ivec2(r, c);
    }
  `;
    }
    function getFlatOffsetUniformName(texName) {
      return `offset${texName}`;
    }
    function getPackedSamplerScalar(inputInfo) {
      const texName = inputInfo.name;
      const funcName = "get" + texName.charAt(0).toUpperCase() + texName.slice(1);
      const glsl = getGlslDifferences();
      return `
    vec4 ${funcName}() {
      return ${glsl.texture2D}(${texName}, halfCR);
    }
  `;
    }
    function getSamplerScalar(inputInfo) {
      const texName = inputInfo.name;
      const funcName = "get" + texName.charAt(0).toUpperCase() + texName.slice(1);
      if (inputInfo.shapeInfo.isUniform) {
        return `float ${funcName}() {return ${texName};}`;
      }
      const [texNumR, texNumC] = inputInfo.shapeInfo.texShape;
      if (texNumR === 1 && texNumC === 1) {
        return `
      float ${funcName}() {
        return sampleTexture(${texName}, halfCR);
      }
    `;
      }
      const [tNumR, tNumC] = inputInfo.shapeInfo.texShape;
      const offset = getFlatOffsetUniformName(texName);
      return `
    float ${funcName}() {
      vec2 uv = uvFromFlat(${tNumR}, ${tNumC}, ${offset});
      return sampleTexture(${texName}, uv);
    }
  `;
    }
    function getPackedSampler1D(inputInfo) {
      const texName = inputInfo.name;
      const funcName = "get" + texName.charAt(0).toUpperCase() + texName.slice(1);
      const texShape = inputInfo.shapeInfo.texShape;
      const packedTexShape = [Math.ceil(texShape[0] / 2), Math.ceil(texShape[1] / 2)];
      const glsl = getGlslDifferences();
      return `
    vec4 ${funcName}(int index) {
      vec2 uv = packedUVfrom1D(
        ${packedTexShape[0]}, ${packedTexShape[1]}, index);
      return ${glsl.texture2D}(${texName}, uv);
    }
  `;
    }
    function getSampler1D(inputInfo) {
      const texName = inputInfo.name;
      const funcName = "get" + texName.charAt(0).toUpperCase() + texName.slice(1);
      if (inputInfo.shapeInfo.isUniform) {
        return `
      float ${funcName}(int index) {
        ${getUniformSampler(inputInfo)}
      }
    `;
      }
      const texShape = inputInfo.shapeInfo.texShape;
      const tNumR = texShape[0];
      const tNumC = texShape[1];
      if (tNumC === 1 && tNumR === 1) {
        return `
      float ${funcName}(int index) {
        return sampleTexture(${texName}, halfCR);
      }
    `;
      }
      const offset = getFlatOffsetUniformName(texName);
      if (tNumC === 1) {
        return `
      float ${funcName}(int index) {
        vec2 uv = vec2(0.5, (float(index + ${offset}) + 0.5) / ${tNumR}.0);
        return sampleTexture(${texName}, uv);
      }
    `;
      }
      if (tNumR === 1) {
        return `
      float ${funcName}(int index) {
        vec2 uv = vec2((float(index + ${offset}) + 0.5) / ${tNumC}.0, 0.5);
        return sampleTexture(${texName}, uv);
      }
    `;
      }
      return `
    float ${funcName}(int index) {
      vec2 uv = uvFromFlat(${tNumR}, ${tNumC}, index + ${offset});
      return sampleTexture(${texName}, uv);
    }
  `;
    }
    function getPackedSampler2D(inputInfo) {
      const shape = inputInfo.shapeInfo.logicalShape;
      const texName = inputInfo.name;
      const funcName = "get" + texName.charAt(0).toUpperCase() + texName.slice(1);
      const texShape = inputInfo.shapeInfo.texShape;
      const texNumR = texShape[0];
      const texNumC = texShape[1];
      const glsl = getGlslDifferences();
      if (texShape != null && arraysEqual2(shape, texShape)) {
        return `
      vec4 ${funcName}(int row, int col) {
        vec2 uv = (vec2(col, row) + halfCR) / vec2(${texNumC}.0, ${texNumR}.0);

        return ${glsl.texture2D}(${texName}, uv);
      }
    `;
      }
      const packedTexShape = [Math.ceil(texShape[0] / 2), Math.ceil(texShape[1] / 2)];
      const valuesPerRow = Math.ceil(shape[1] / 2);
      return `
    vec4 ${funcName}(int row, int col) {
      vec2 uv = packedUVfrom2D(${valuesPerRow}, ${packedTexShape[0]}, ${packedTexShape[1]}, row, col);
      return ${glsl.texture2D}(${texName}, uv);
    }
  `;
    }
    function getSampler2D(inputInfo) {
      const shape = inputInfo.shapeInfo.logicalShape;
      const texName = inputInfo.name;
      const funcName = "get" + texName.charAt(0).toUpperCase() + texName.slice(1);
      const texShape = inputInfo.shapeInfo.texShape;
      if (texShape != null && arraysEqual2(shape, texShape)) {
        const texNumR2 = texShape[0];
        const texNumC2 = texShape[1];
        return `
    float ${funcName}(int row, int col) {
      vec2 uv = (vec2(col, row) + halfCR) / vec2(${texNumC2}.0, ${texNumR2}.0);
      return sampleTexture(${texName}, uv);
    }
  `;
      }
      const {newShape, keptDims} = squeezeShape2(shape);
      const squeezedShape = newShape;
      if (squeezedShape.length < shape.length) {
        const newInputInfo = squeezeInputInfo(inputInfo, squeezedShape);
        const params = ["row", "col"];
        return `
      ${getSamplerFromInInfo(newInputInfo)}
      float ${funcName}(int row, int col) {
        return ${funcName}(${getSqueezedParams(params, keptDims)});
      }
    `;
      }
      if (inputInfo.shapeInfo.isUniform) {
        return `
      float ${funcName}(int row, int col) {
        int index = round(dot(vec2(row, col), vec2(${shape[1]}, 1)));
        ${getUniformSampler(inputInfo)}
      }
    `;
      }
      const texNumR = texShape[0];
      const texNumC = texShape[1];
      const offset = getFlatOffsetUniformName(texName);
      if (texNumC === 1) {
        return `
    float ${funcName}(int row, int col) {
      float index = dot(vec3(row, col, ${offset}), vec3(${shape[1]}, 1, 1));
      vec2 uv = vec2(0.5, (index + 0.5) / ${texNumR}.0);
      return sampleTexture(${texName}, uv);
    }
  `;
      }
      if (texNumR === 1) {
        return `
    float ${funcName}(int row, int col) {
      float index = dot(vec3(row, col, ${offset}), vec3(${shape[1]}, 1, 1));
      vec2 uv = vec2((index + 0.5) / ${texNumC}.0, 0.5);
      return sampleTexture(${texName}, uv);
    }
  `;
      }
      return `
  float ${funcName}(int row, int col) {
    // Explicitly use integer operations as dot() only works on floats.
    int index = row * ${shape[1]} + col + ${offset};
    vec2 uv = uvFromFlat(${texNumR}, ${texNumC}, index);
    return sampleTexture(${texName}, uv);
  }
`;
    }
    function getPackedSampler3D(inputInfo) {
      const shape = inputInfo.shapeInfo.logicalShape;
      const texName = inputInfo.name;
      const funcName = "get" + texName.charAt(0).toUpperCase() + texName.slice(1);
      const texShape = inputInfo.shapeInfo.texShape;
      const packedTexShape = [Math.ceil(texShape[0] / 2), Math.ceil(texShape[1] / 2)];
      if (shape[0] === 1) {
        const squeezedShape = shape.slice(1);
        const keptDims = [1, 2];
        const newInputInfo = squeezeInputInfo(inputInfo, squeezedShape);
        const params = ["b", "row", "col"];
        return `
        ${getPackedSamplerFromInInfo(newInputInfo)}
        vec4 ${funcName}(int b, int row, int col) {
          return ${funcName}(${getSqueezedParams(params, keptDims)});
        }
      `;
      }
      const texNumR = packedTexShape[0];
      const texNumC = packedTexShape[1];
      const valuesPerRow = Math.ceil(shape[2] / 2);
      const texelsInBatch = valuesPerRow * Math.ceil(shape[1] / 2);
      const glsl = getGlslDifferences();
      return `
    vec4 ${funcName}(int b, int row, int col) {
      vec2 uv = packedUVfrom3D(
        ${texNumR}, ${texNumC}, ${texelsInBatch}, ${valuesPerRow}, b, row, col);
      return ${glsl.texture2D}(${texName}, uv);
    }
  `;
    }
    function getSampler3D(inputInfo) {
      const shape = inputInfo.shapeInfo.logicalShape;
      const texName = inputInfo.name;
      const funcName = "get" + texName.charAt(0).toUpperCase() + texName.slice(1);
      const stride0 = shape[1] * shape[2];
      const stride1 = shape[2];
      const {newShape, keptDims} = squeezeShape2(shape);
      const squeezedShape = newShape;
      if (squeezedShape.length < shape.length) {
        const newInputInfo = squeezeInputInfo(inputInfo, squeezedShape);
        const params = ["row", "col", "depth"];
        return `
        ${getSamplerFromInInfo(newInputInfo)}
        float ${funcName}(int row, int col, int depth) {
          return ${funcName}(${getSqueezedParams(params, keptDims)});
        }
      `;
      }
      if (inputInfo.shapeInfo.isUniform) {
        return `
      float ${funcName}(int row, int col, int depth) {
        int index = round(dot(vec3(row, col, depth),
                          vec3(${stride0}, ${stride1}, 1)));
        ${getUniformSampler(inputInfo)}
      }
    `;
      }
      const texShape = inputInfo.shapeInfo.texShape;
      const texNumR = texShape[0];
      const texNumC = texShape[1];
      const flatOffset = inputInfo.shapeInfo.flatOffset;
      if (texNumC === stride0 && flatOffset == null) {
        return `
        float ${funcName}(int row, int col, int depth) {
          float texR = float(row);
          float texC = dot(vec2(col, depth), vec2(${stride1}, 1));
          vec2 uv = (vec2(texC, texR) + halfCR) /
                     vec2(${texNumC}.0, ${texNumR}.0);
          return sampleTexture(${texName}, uv);
        }
      `;
      }
      if (texNumC === stride1 && flatOffset == null) {
        return `
    float ${funcName}(int row, int col, int depth) {
      float texR = dot(vec2(row, col), vec2(${shape[1]}, 1));
      float texC = float(depth);
      vec2 uv = (vec2(texC, texR) + halfCR) / vec2(${texNumC}.0, ${texNumR}.0);
      return sampleTexture(${texName}, uv);
    }
  `;
      }
      const offset = getFlatOffsetUniformName(texName);
      return `
      float ${funcName}(int row, int col, int depth) {
        // Explicitly use integer operations as dot() only works on floats.
        int index = row * ${stride0} + col * ${stride1} + depth + ${offset};
        vec2 uv = uvFromFlat(${texNumR}, ${texNumC}, index);
        return sampleTexture(${texName}, uv);
      }
  `;
    }
    function getPackedSamplerND(inputInfo) {
      const shape = inputInfo.shapeInfo.logicalShape;
      const rank = shape.length;
      const texName = inputInfo.name;
      const funcName = "get" + texName.charAt(0).toUpperCase() + texName.slice(1);
      const texShape = inputInfo.shapeInfo.texShape;
      const packedTexShape = [Math.ceil(texShape[0] / 2), Math.ceil(texShape[1] / 2)];
      const texNumR = packedTexShape[0];
      const texNumC = packedTexShape[1];
      const valuesPerRow = Math.ceil(shape[rank - 1] / 2);
      let texelsInBatch = valuesPerRow * Math.ceil(shape[rank - 2] / 2);
      let params = `int b, int row, int col`;
      let index2 = `b * ${texelsInBatch} + (row / 2) * ${valuesPerRow} + (col / 2)`;
      for (let b = 2; b < rank - 1; b++) {
        params = `int b${b}, ` + params;
        texelsInBatch *= shape[rank - b - 1];
        index2 = `b${b} * ${texelsInBatch} + ` + index2;
      }
      const glsl = getGlslDifferences();
      return `
    vec4 ${funcName}(${params}) {
      int index = ${index2};
      int texR = index / ${texNumC};
      int texC = index - texR * ${texNumC};
      vec2 uv = (vec2(texC, texR) + halfCR) / vec2(${texNumC}, ${texNumR});
      return ${glsl.texture2D}(${texName}, uv);
    }
  `;
    }
    function getSampler4D(inputInfo) {
      const shape = inputInfo.shapeInfo.logicalShape;
      const texName = inputInfo.name;
      const funcName = "get" + texName.charAt(0).toUpperCase() + texName.slice(1);
      const stride2 = shape[3];
      const stride1 = shape[2] * stride2;
      const stride0 = shape[1] * stride1;
      const {newShape, keptDims} = squeezeShape2(shape);
      if (newShape.length < shape.length) {
        const newInputInfo = squeezeInputInfo(inputInfo, newShape);
        const params = ["row", "col", "depth", "depth2"];
        return `
      ${getSamplerFromInInfo(newInputInfo)}
      float ${funcName}(int row, int col, int depth, int depth2) {
        return ${funcName}(${getSqueezedParams(params, keptDims)});
      }
    `;
      }
      if (inputInfo.shapeInfo.isUniform) {
        return `
      float ${funcName}(int row, int col, int depth, int depth2) {
        int index = round(dot(vec4(row, col, depth, depth2),
                          vec4(${stride0}, ${stride1}, ${stride2}, 1)));
        ${getUniformSampler(inputInfo)}
      }
    `;
      }
      const flatOffset = inputInfo.shapeInfo.flatOffset;
      const texShape = inputInfo.shapeInfo.texShape;
      const texNumR = texShape[0];
      const texNumC = texShape[1];
      if (texNumC === stride0 && flatOffset == null) {
        return `
      float ${funcName}(int row, int col, int depth, int depth2) {
        float texR = float(row);
        float texC =
            dot(vec3(col, depth, depth2),
                vec3(${stride1}, ${stride2}, 1));
        vec2 uv = (vec2(texC, texR) + halfCR) /
                   vec2(${texNumC}.0, ${texNumR}.0);
        return sampleTexture(${texName}, uv);
      }
    `;
      }
      if (texNumC === stride2 && flatOffset == null) {
        return `
      float ${funcName}(int row, int col, int depth, int depth2) {
        float texR = dot(vec3(row, col, depth),
                         vec3(${shape[1] * shape[2]}, ${shape[2]}, 1));
        float texC = float(depth2);
        vec2 uv = (vec2(texC, texR) + halfCR) /
                  vec2(${texNumC}.0, ${texNumR}.0);
        return sampleTexture(${texName}, uv);
      }
    `;
      }
      const offset = getFlatOffsetUniformName(texName);
      return `
    float ${funcName}(int row, int col, int depth, int depth2) {
      // Explicitly use integer operations as dot() only works on floats.
      int index = row * ${stride0} + col * ${stride1} +
          depth * ${stride2} + depth2;
      vec2 uv = uvFromFlat(${texNumR}, ${texNumC}, index + ${offset});
      return sampleTexture(${texName}, uv);
    }
  `;
    }
    function getSampler5D(inputInfo) {
      const shape = inputInfo.shapeInfo.logicalShape;
      const texName = inputInfo.name;
      const funcName = "get" + texName.charAt(0).toUpperCase() + texName.slice(1);
      const stride3 = shape[4];
      const stride2 = shape[3] * stride3;
      const stride1 = shape[2] * stride2;
      const stride0 = shape[1] * stride1;
      const {newShape, keptDims} = squeezeShape2(shape);
      if (newShape.length < shape.length) {
        const newInputInfo = squeezeInputInfo(inputInfo, newShape);
        const params = ["row", "col", "depth", "depth2", "depth3"];
        return `
      ${getSamplerFromInInfo(newInputInfo)}
      float ${funcName}(int row, int col, int depth, int depth2, int depth3) {
        return ${funcName}(${getSqueezedParams(params, keptDims)});
      }
    `;
      }
      if (inputInfo.shapeInfo.isUniform) {
        return `
      float ${funcName}(int row, int col, int depth, int depth2, int depth3) {
        float index = dot(
          vec4(row, col, depth, depth2),
          vec4(${stride0}, ${stride1}, ${stride2}, ${stride3})) +
          depth3;
        ${getUniformSampler(inputInfo)}
      }
    `;
      }
      const flatOffset = inputInfo.shapeInfo.flatOffset;
      const texShape = inputInfo.shapeInfo.texShape;
      const texNumR = texShape[0];
      const texNumC = texShape[1];
      if (texNumC === stride0 && flatOffset == null) {
        return `
      float ${funcName}(int row, int col, int depth, int depth2, int depth3) {
        int texR = row;
        float texC = dot(vec4(col, depth, depth2, depth3),
                         vec4(${stride1}, ${stride2}, ${stride3}, 1));
        vec2 uv = (vec2(texC, texR) + halfCR) /
                   vec2(${texNumC}.0, ${texNumR}.0);
        return sampleTexture(${texName}, uv);
      }
    `;
      }
      if (texNumC === stride3 && flatOffset == null) {
        return `
      float ${funcName}(int row, int col, int depth, int depth2, int depth3) {
        float texR = dot(
          vec4(row, col, depth, depth2),
          vec4(${shape[1] * shape[2] * shape[3]},
               ${shape[2] * shape[3]}, ${shape[3]}, 1));
        int texC = depth3;
        vec2 uv = (vec2(texC, texR) + halfCR) /
                  vec2(${texNumC}.0, ${texNumR}.0);
        return sampleTexture(${texName}, uv);
      }
    `;
      }
      const offset = getFlatOffsetUniformName(texName);
      return `
    float ${funcName}(int row, int col, int depth, int depth2, int depth3) {
      // Explicitly use integer operations as dot() only works on floats.
      int index = row * ${stride0} + col * ${stride1} + depth * ${stride2} +
          depth2 * ${stride3} + depth3 + ${offset};
      vec2 uv = uvFromFlat(${texNumR}, ${texNumC}, index);
      return sampleTexture(${texName}, uv);
    }
  `;
    }
    function getSampler6D(inputInfo) {
      const shape = inputInfo.shapeInfo.logicalShape;
      const texName = inputInfo.name;
      const funcName = "get" + texName.charAt(0).toUpperCase() + texName.slice(1);
      const {newShape, keptDims} = squeezeShape2(shape);
      if (newShape.length < shape.length) {
        const newInputInfo = squeezeInputInfo(inputInfo, newShape);
        const params = ["row", "col", "depth", "depth2", "depth3", "depth4"];
        return `
      ${getSamplerFromInInfo(newInputInfo)}
      float ${funcName}(int row, int col, int depth,
                    int depth2, int depth3, int depth4) {
        return ${funcName}(${getSqueezedParams(params, keptDims)});
      }
    `;
      }
      const stride4 = shape[5];
      const stride3 = shape[4] * stride4;
      const stride2 = shape[3] * stride3;
      const stride1 = shape[2] * stride2;
      const stride0 = shape[1] * stride1;
      if (inputInfo.shapeInfo.isUniform) {
        return `
      float ${funcName}(int row, int col, int depth,
                  int depth2, int depth3, int depth4) {
        int index = round(dot(
          vec4(row, col, depth, depth2),
          vec4(${stride0}, ${stride1}, ${stride2}, ${stride3})) +
          dot(
            vec2(depth3, depth4),
            vec2(${stride4}, 1)));
        ${getUniformSampler(inputInfo)}
      }
    `;
      }
      const flatOffset = inputInfo.shapeInfo.flatOffset;
      const texShape = inputInfo.shapeInfo.texShape;
      const texNumR = texShape[0];
      const texNumC = texShape[1];
      if (texNumC === stride0 && flatOffset == null) {
        return `
      float ${funcName}(int row, int col, int depth,
                    int depth2, int depth3, int depth4) {
        int texR = row;
        float texC = dot(vec4(col, depth, depth2, depth3),
          vec4(${stride1}, ${stride2}, ${stride3}, ${stride4})) +
               float(depth4);
        vec2 uv = (vec2(texC, texR) + halfCR) /
                   vec2(${texNumC}.0, ${texNumR}.0);
        return sampleTexture(${texName}, uv);
      }
    `;
      }
      if (texNumC === stride4 && flatOffset == null) {
        return `
      float ${funcName}(int row, int col, int depth,
                    int depth2, int depth3, int depth4) {
        float texR = dot(vec4(row, col, depth, depth2),
          vec4(${shape[1] * shape[2] * shape[3] * shape[4]},
               ${shape[2] * shape[3] * shape[4]},
               ${shape[3] * shape[4]},
               ${shape[4]})) + float(depth3);
        int texC = depth4;
        vec2 uv = (vec2(texC, texR) + halfCR) /
                  vec2(${texNumC}.0, ${texNumR}.0);
        return sampleTexture(${texName}, uv);
      }
    `;
      }
      const offset = getFlatOffsetUniformName(texName);
      return `
    float ${funcName}(int row, int col, int depth,
                  int depth2, int depth3, int depth4) {
      // Explicitly use integer operations as dot() only works on floats.
      int index = row * ${stride0} + col * ${stride1} + depth * ${stride2} +
          depth2 * ${stride3} + depth3 * ${stride4} + depth4 + ${offset};
      vec2 uv = uvFromFlat(${texNumR}, ${texNumC}, index);
      return sampleTexture(${texName}, uv);
    }
  `;
    }
    function getUniformSampler(inputInfo) {
      const texName = inputInfo.name;
      const inSize = sizeFromShape2(inputInfo.shapeInfo.logicalShape);
      if (inSize < 2) {
        return `return ${texName};`;
      }
      return `
    for (int i = 0; i < ${inSize}; i++) {
      if (i == index) {
        return ${texName}[i];
      }
    }
  `;
    }
    function getPackedSamplerAtOutputCoords(inputInfo, outShapeInfo) {
      const texName = inputInfo.name;
      const texFuncSnippet = texName.charAt(0).toUpperCase() + texName.slice(1);
      const funcName = "get" + texFuncSnippet + "AtOutCoords";
      const inRank = inputInfo.shapeInfo.logicalShape.length;
      const outRank = outShapeInfo.logicalShape.length;
      const broadcastDims = getBroadcastDims$1(inputInfo.shapeInfo.logicalShape, outShapeInfo.logicalShape);
      const type = getCoordsDataType(outRank);
      const rankDiff = outRank - inRank;
      let coordsSnippet;
      const fields = ["x", "y", "z", "w", "u", "v"];
      if (inRank === 0) {
        coordsSnippet = "";
      } else if (outRank < 2 && broadcastDims.length >= 1) {
        coordsSnippet = "coords = 0;";
      } else {
        coordsSnippet = broadcastDims.map((d) => `coords.${fields[d + rankDiff]} = 0;`).join("\n");
      }
      let unpackedCoordsSnippet = "";
      if (outRank < 2 && inRank > 0) {
        unpackedCoordsSnippet = "coords";
      } else {
        unpackedCoordsSnippet = inputInfo.shapeInfo.logicalShape.map((s, i) => `coords.${fields[i + rankDiff]}`).join(", ");
      }
      let output = `return outputValue;`;
      const inSize = sizeFromShape2(inputInfo.shapeInfo.logicalShape);
      const isInputScalar = inSize === 1;
      const outSize = sizeFromShape2(outShapeInfo.logicalShape);
      const isOutputScalar = outSize === 1;
      if (inRank === 1 && !isInputScalar && !isOutputScalar) {
        output = `
      return vec4(outputValue.xy, outputValue.xy);
    `;
      } else if (isInputScalar && !isOutputScalar) {
        if (outRank === 1) {
          output = `
        return vec4(outputValue.x, outputValue.x, 0., 0.);
      `;
        } else {
          output = `
        return vec4(outputValue.x);
      `;
        }
      } else if (broadcastDims.length) {
        const rows = inRank - 2;
        const cols = inRank - 1;
        if (broadcastDims.indexOf(rows) > -1 && broadcastDims.indexOf(cols) > -1) {
          output = `return vec4(outputValue.x);`;
        } else if (broadcastDims.indexOf(rows) > -1) {
          output = `return vec4(outputValue.x, outputValue.y, outputValue.x, outputValue.y);`;
        } else if (broadcastDims.indexOf(cols) > -1) {
          output = `return vec4(outputValue.xx, outputValue.zz);`;
        }
      }
      return `
    vec4 ${funcName}() {
      ${type} coords = getOutputCoords();
      ${coordsSnippet}
      vec4 outputValue = get${texFuncSnippet}(${unpackedCoordsSnippet});
      ${output}
    }
  `;
    }
    function getSamplerAtOutputCoords(inputInfo, outShapeInfo) {
      const texName = inputInfo.name;
      const texFuncSnippet = texName.charAt(0).toUpperCase() + texName.slice(1);
      const funcName = "get" + texFuncSnippet + "AtOutCoords";
      const outTexShape = outShapeInfo.texShape;
      const inTexShape = inputInfo.shapeInfo.texShape;
      const inRank = inputInfo.shapeInfo.logicalShape.length;
      const outRank = outShapeInfo.logicalShape.length;
      if (!inputInfo.shapeInfo.isUniform && inRank === outRank && inputInfo.shapeInfo.flatOffset == null && arraysEqual2(inTexShape, outTexShape)) {
        return `
      float ${funcName}() {
        return sampleTexture(${texName}, resultUV);
      }
    `;
      }
      const type = getCoordsDataType(outRank);
      const broadcastDims = getBroadcastDims$1(inputInfo.shapeInfo.logicalShape, outShapeInfo.logicalShape);
      const rankDiff = outRank - inRank;
      let coordsSnippet;
      const fields = ["x", "y", "z", "w", "u", "v"];
      if (inRank === 0) {
        coordsSnippet = "";
      } else if (outRank < 2 && broadcastDims.length >= 1) {
        coordsSnippet = "coords = 0;";
      } else {
        coordsSnippet = broadcastDims.map((d) => `coords.${fields[d + rankDiff]} = 0;`).join("\n");
      }
      let unpackedCoordsSnippet = "";
      if (outRank < 2 && inRank > 0) {
        unpackedCoordsSnippet = "coords";
      } else {
        unpackedCoordsSnippet = inputInfo.shapeInfo.logicalShape.map((s, i) => `coords.${fields[i + rankDiff]}`).join(", ");
      }
      return `
    float ${funcName}() {
      ${type} coords = getOutputCoords();
      ${coordsSnippet}
      return get${texFuncSnippet}(${unpackedCoordsSnippet});
    }
  `;
    }
    function getCoordsDataType(rank) {
      if (rank <= 1) {
        return "int";
      } else if (rank === 2) {
        return "ivec2";
      } else if (rank === 3) {
        return "ivec3";
      } else if (rank === 4) {
        return "ivec4";
      } else if (rank === 5) {
        return "ivec5";
      } else if (rank === 6) {
        return "ivec6";
      } else {
        throw Error(`GPU for rank ${rank} is not yet supported`);
      }
    }
    function squeezeInputInfo(inInfo, squeezedShape) {
      const newInputInfo = JSON.parse(JSON.stringify(inInfo));
      newInputInfo.shapeInfo.logicalShape = squeezedShape;
      return newInputInfo;
    }
    function getSqueezedParams(params, keptDims) {
      return keptDims.map((d) => params[d]).join(", ");
    }
    /**
     * @license
     * Copyright 2019 Google LLC. All Rights Reserved.
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     * http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     * =============================================================================
     */
    class ArgMinMaxPackedProgram {
      constructor(shape, windowSize, op3, firstPass) {
        this.variableNames = ["A"];
        this.packedInputs = true;
        this.packedOutput = true;
        assert2(shape.length > 2, () => `Packed arg${op3.charAt(0).toUpperCase() + op3.slice(1)} supports only inputs with rank above 2.`);
        const inSize = shape[shape.length - 1];
        const outSize = Math.ceil(inSize / windowSize);
        this.outputShape = shape.slice(0, -1);
        if (outSize > 1) {
          this.outputShape.push(outSize);
        }
        if (!firstPass) {
          this.variableNames.push("bestIndicesA");
        }
        const outShape = this.outputShape;
        const rank = outShape.length;
        const dtype = getCoordsDataType(rank);
        const coords2 = getChannels("coords", rank);
        let sourceLocSetup;
        let sourceRank;
        if (outSize === 1) {
          sourceRank = rank + 1;
          const sourceLocDType = getCoordsDataType(sourceRank);
          sourceLocSetup = `
        ${sourceLocDType} sourceLocR = ${sourceLocDType}(${coords2.join()}, 0);
        ++${coords2[rank - 1]};
        ${sourceLocDType} sourceLocG = ${sourceLocDType}(${coords2.join()}, 0);
        ++${coords2[rank - 2]};
        ${sourceLocDType} sourceLocA = ${sourceLocDType}(${coords2.join()}, 0);
        --${coords2[rank - 1]};
        ${sourceLocDType} sourceLocB = ${sourceLocDType}(${coords2.join()}, 0);
        --${coords2[rank - 2]};`;
        } else {
          sourceRank = rank;
          sourceLocSetup = `
        ${dtype} sourceLocR = coords;
        ++${coords2[rank - 1]};
        ${dtype} sourceLocG = coords;
        ++${coords2[rank - 2]};
        ${dtype} sourceLocA = coords;
        --${coords2[rank - 1]};
        ${dtype} sourceLocB = coords;
        --${coords2[rank - 2]};`;
        }
        const channels = ["x", "y", "z", "w", "u", "v"].slice(0, sourceRank);
        const inChannel = "." + channels[sourceRank - 1];
        const intChannels = channels.map((x) => "int " + x);
        const srcRCoords = getChannels("sourceLocR", sourceRank - 1).concat("inIdx.r");
        const srcGCoords = getChannels("sourceLocG", sourceRank - 1).concat("inIdx.g");
        const srcBCoords = getChannels("sourceLocB", sourceRank - 1).concat("inIdx.b");
        const srcACoords = getChannels("sourceLocA", sourceRank - 1).concat("inIdx.a");
        const compOp = op3 === "max" ? "greaterThan" : "lessThan";
        const fetchCandidateIdx = firstPass ? "" : `
          inIdx = round(vec4(getBestIndicesAChannel(${srcRCoords.join()}),
                             getBestIndicesAChannel(${srcGCoords.join()}),
                             getBestIndicesAChannel(${srcBCoords.join()}),
                             getBestIndicesAChannel(${srcACoords.join()})));`;
        const fetchValue = `vec4(
            getAChannel(${srcRCoords.join()}),
            hasNextCol ? getAChannel(${srcGCoords.join()}) : 0.,
            hasNextRow ? getAChannel(${srcBCoords.join()}) : 0.,
            hasNextRow && hasNextCol ? getAChannel(${srcACoords.join()}) : 0.)`;
        const getBestIndicesAChannelSnippet = firstPass ? "" : `
      float getBestIndicesAChannel(${intChannels.join()}) {
        return getChannel(getBestIndicesA(${channels.join()}),
                                          vec2(${channels.slice(-2).join()}));
      }`;
        this.userCode = `
      float getAChannel(${intChannels.join()}) {
        return getChannel(getA(${channels.join()}),
                               vec2(${channels.slice(-2).join()}));
      }
      ${getBestIndicesAChannelSnippet}
      void main() {
        ${dtype} coords = getOutputCoords();
        bool hasNextCol = ${coords2[rank - 1]} < ${outShape[rank - 1] - 1};
        bool hasNextRow = ${coords2[rank - 2]} < ${outShape[rank - 2] - 1};
        ${sourceLocSetup}
        ivec4 srcIdx = ivec4(sourceLocR${inChannel}, sourceLocG${inChannel},
          sourceLocB${inChannel}, sourceLocA${inChannel}) * ${windowSize};
        ivec4 inIdx = srcIdx;
        vec4 bestIndex = vec4(inIdx);
        vec4 bestValue = ${fetchValue};

        for (int i = 0; i < ${windowSize}; i++) {
          inIdx = srcIdx;
          ${fetchCandidateIdx}
          vec4 candidate = ${fetchValue};
          bvec4 nan = isnan(candidate);
          bvec4 replace = bvec4(
            vec4(${compOp}(candidate, bestValue)) * (vec4(1.0) - vec4(nan)));

          bestValue = vec4(replace.x  ? candidate.x : bestValue.x,
                           replace.y  ? candidate.y : bestValue.y,
                           replace.z  ? candidate.z : bestValue.z,
                           replace.w  ? candidate.w : bestValue.w);
          bestIndex = mix(bestIndex, vec4(inIdx), vec4(replace));
          srcIdx++;
        }
        setOutput(bestIndex);
      }
    `;
      }
    }
    /**
     * @license
     * Copyright 2017 Google LLC. All Rights Reserved.
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     * http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     * =============================================================================
     */
    class AvgPool2DBackpropProgram {
      constructor(convInfo) {
        this.variableNames = ["dy"];
        this.outputShape = convInfo.inShape;
        const filterHeight = convInfo.filterHeight;
        const filterWidth = convInfo.filterWidth;
        const strideHeight = convInfo.strideHeight;
        const strideWidth = convInfo.strideWidth;
        const dilationHeight = convInfo.dilationHeight;
        const dilationWidth = convInfo.dilationWidth;
        const effectiveFilterHeight = convInfo.effectiveFilterHeight;
        const effectiveFilterWidth = convInfo.effectiveFilterWidth;
        const padTop = effectiveFilterHeight - 1 - convInfo.padInfo.top;
        const padLeft = effectiveFilterWidth - 1 - convInfo.padInfo.left;
        const avgMultiplier = 1 / (filterHeight * filterWidth);
        this.userCode = `
      const ivec2 pads = ivec2(${padTop}, ${padLeft});
      const float avgMultiplier = float(${avgMultiplier});

      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];

        ivec2 dyRCCorner = coords.yz - pads;
        int dyRCorner = dyRCCorner.x;
        int dyCCorner = dyRCCorner.y;

        // Convolve dy(?, ?, d) with pos mask(:, :, d) to get dx(xR, xC, d).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;
        for (int wR = 0; wR < ${effectiveFilterHeight};
            wR += ${dilationHeight}) {
          float dyR = float(dyRCorner + wR) / ${strideHeight}.0;

          if (dyR < 0.0 || dyR >= ${convInfo.outHeight}.0 || fract(dyR) > 0.0) {
            continue;
          }
          int idyR = int(dyR);

          for (int wC = 0; wC < ${effectiveFilterWidth};
            wC+= ${dilationWidth}) {
            float dyC = float(dyCCorner + wC) / ${strideWidth}.0;

            if (dyC < 0.0 || dyC >= ${convInfo.outWidth}.0 ||
                fract(dyC) > 0.0) {
              continue;
            }
            int idyC = int(dyC);

            float dyValue = getDy(b, idyR, idyC, d);

            dotProd += dyValue * avgMultiplier;
          }
        }
        setOutput(dotProd);
      }
    `;
      }
    }
    class AvgPool3DBackpropProgram {
      constructor(convInfo) {
        this.variableNames = ["dy"];
        this.outputShape = convInfo.inShape;
        const filterDepth = convInfo.filterDepth;
        const filterHeight = convInfo.filterHeight;
        const filterWidth = convInfo.filterWidth;
        const strideDepth = convInfo.strideDepth;
        const strideHeight = convInfo.strideHeight;
        const strideWidth = convInfo.strideWidth;
        const dilationDepth = convInfo.dilationDepth;
        const dilationHeight = convInfo.dilationHeight;
        const dilationWidth = convInfo.dilationWidth;
        const effectiveFilterDepth = convInfo.effectiveFilterDepth;
        const effectiveFilterHeight = convInfo.effectiveFilterHeight;
        const effectiveFilterWidth = convInfo.effectiveFilterWidth;
        const padFront = effectiveFilterDepth - 1 - convInfo.padInfo.front;
        const padTop = effectiveFilterHeight - 1 - convInfo.padInfo.top;
        const padLeft = effectiveFilterWidth - 1 - convInfo.padInfo.left;
        const avgMultiplier = 1 / (filterDepth * filterHeight * filterWidth);
        this.userCode = `
      const ivec3 pads = ivec3(${padFront}, ${padTop}, ${padLeft});
      const float avgMultiplier = float(${avgMultiplier});

      void main() {
        ivec5 coords = getOutputCoords();
        int batch = coords.x;
        int ch = coords.u;

        ivec3 dyCorner = ivec3(coords.y, coords.z, coords.w) - pads;
        int dyDCorner = dyCorner.x;
        int dyRCorner = dyCorner.y;
        int dyCCorner = dyCorner.z;

        // Convolve dy(?, ?, ?, d) with pos mask(:, :, :, ch) to get
        // dx(xD, xR, xC, ch).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;

        for (int wD = 0; wD < ${effectiveFilterDepth};
            wD += ${dilationDepth}) {
          float dyD = float(dyDCorner + wD) / ${strideDepth}.0;

          if (dyD < 0.0 || dyD >= ${convInfo.outDepth}.0 || fract(dyD) > 0.0) {
            continue;
          }
          int idyD = int(dyD);

          for (int wR = 0; wR < ${effectiveFilterHeight};
              wR += ${dilationHeight}) {
            float dyR = float(dyRCorner + wR) / ${strideHeight}.0;

            if (dyR < 0.0 || dyR >= ${convInfo.outHeight}.0 ||
                fract(dyR) > 0.0) {
              continue;
            }
            int idyR = int(dyR);

            for (int wC = 0; wC < ${effectiveFilterWidth};
                wC += ${dilationWidth}) {
              float dyC = float(dyCCorner + wC) / ${strideWidth}.0;

              if (dyC < 0.0 || dyC >= ${convInfo.outWidth}.0 ||
                  fract(dyC) > 0.0) {
                continue;
              }
              int idyC = int(dyC);

              float dyValue = getDy(batch, idyD, idyR, idyC, ch);

              dotProd += dyValue * avgMultiplier;
            }
          }
        }
        setOutput(dotProd);
      }
    `;
      }
    }
    /**
     * @license
     * Copyright 2017 Google LLC. All Rights Reserved.
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     * http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     * =============================================================================
     */
    const CHECK_NAN_SNIPPET = `
  if (isnan(a)) return a;
  if (isnan(b)) return b;
`;
    const INT_DIV = `
  float s = sign(a) * sign(b);
  int ia = round(a);
  int ib = round(b);
  if (ib != 0) {
    // Windows (D3D) wants guaranteed non-zero int division at compile-time.
    return float(idiv(ia, ib, s));
  } else {
    return NAN;
  }
`;
    const POW = `
if(a < 0.0 && floor(b) < b){
  return NAN;
}
if (b == 0.0) {
  return 1.0;
}
return (round(mod(b, 2.0)) != 1) ?
    pow(abs(a), b) : sign(a) * pow(abs(a), b);
`;
    const SQUARED_DIFFERENCE = "return (a - b) * (a - b);";
    const EQUAL = `return float(a == b);`;
    const LESS = `return float(a < b);`;
    const LESS_EQUAL = `return float(a <= b);`;
    const GREATER = `return float(a > b);`;
    const GREATER_EQUAL = `return float(a >= b);`;
    const LOGICAL_AND = `return float(a >= 1.0 && b >= 1.0);`;
    const LOGICAL_OR = `return float(a >= 1.0 || b >= 1.0);`;
    const MAX = CHECK_NAN_SNIPPET + `
  return max(a, b);
`;
    const MIN = CHECK_NAN_SNIPPET + `
  return min(a, b);
`;
    const MOD = `if (b == 0.0) return NAN;
  return mod(a, b);`;
    const ELU_DER = `return (b >= 1.0) ? a : a * (b + 1.0);`;
    const PRELU = `return (a < 0.) ? b * a : a;`;
    class BinaryOpProgram {
      constructor(op3, aShape, bShape) {
        this.variableNames = ["A", "B"];
        this.outputShape = assertAndGetBroadcastShape2(aShape, bShape);
        this.userCode = `
      float binaryOperation(float a, float b) {
        ${op3}
      }

      void main() {
        float a = getAAtOutCoords();
        float b = getBAtOutCoords();
        setOutput(binaryOperation(a, b));
      }
    `;
      }
    }
    /**
     * @license
     * Copyright 2018 Google LLC. All Rights Reserved.
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     * http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     * =============================================================================
     */
    const CHECK_NAN_SNIPPET$1 = `
  result.r = isNaN.r > 0. ? NAN : result.r;
  result.g = isNaN.g > 0. ? NAN : result.g;
  result.b = isNaN.b > 0. ? NAN : result.b;
  result.a = isNaN.a > 0. ? NAN : result.a;
`;
    const INT_DIV$1 = `
  ivec4 ia = round(a);
  ivec4 ib = round(b);
  bvec4 cond = notEqual(ib, ivec4(0));
  ivec4 result = ivec4(0);
  vec4 s = sign(a) * sign(b);

  // Windows (D3D) wants guaranteed non-zero int division at compile-time.
  if (cond[0]) {
    result[0] = idiv(ia[0], ib[0], s[0]);
  }
  if (cond[1]) {
    result[1] = idiv(ia[1], ib[1], s[1]);
  }
  if (cond[2]) {
    result[2] = idiv(ia[2], ib[2], s[2]);
  }
  if (cond[3]) {
    result[3] = idiv(ia[3], ib[3], s[3]);
  }
  return vec4(result);
`;
    const POW$1 = `
  // isModRound1 has 1 for components with round(mod(b, 2.0)) == 1, 0 otherwise.
  vec4 isModRound1 = vec4(equal(round(mod(b, 2.0)), ivec4(1)));
  vec4 multiplier = sign(a) * isModRound1 + (vec4(1.0) - isModRound1);
  vec4 result = multiplier * pow(abs(a), b);

  // Ensure that a^0 = 1, including 0^0 = 1 as this correspond to TF and JS
  bvec4 isExpZero = equal(b, vec4(0.0));
  result.r = isExpZero.r ? 1.0 : result.r;
  result.g = isExpZero.g ? 1.0 : result.g;
  result.b = isExpZero.b ? 1.0 : result.b;
  result.a = isExpZero.a ? 1.0 : result.a;

  vec4 isNaN = vec4(lessThan(a, vec4(0.0))) * vec4(lessThan(floor(b), b));
  ` + CHECK_NAN_SNIPPET$1 + `
  return result;
`;
    const PRELU$1 = `
  vec4 aLessThanZero = vec4(lessThan(a, vec4(0.)));
  return (aLessThanZero * (b * a)) + ((vec4(1.0) - aLessThanZero) * a);
`;
    const ELU_DER$1 = `
  vec4 bGTEZero = vec4(greaterThanEqual(b, vec4(0.)));
  return (bGTEZero * a) + ((vec4(1.0) - bGTEZero) * (a * (b + vec4(1.0))));
`;
    const EQUAL$1 = `
  return vec4(equal(a, b));
`;
    const NOT_EQUAL = `
  return vec4(notEqual(a, b));
`;
    const LESS$1 = `
  return vec4(lessThan(a, b));
`;
    const LESS_EQUAL$1 = `
  return vec4(lessThanEqual(a, b));
`;
    const GREATER$1 = `
  return vec4(greaterThan(a, b));
`;
    const GREATER_EQUAL$1 = `
  return vec4(greaterThanEqual(a, b));
`;
    const LOGICAL_AND$1 = `
  return vec4(
    vec4(greaterThanEqual(a, vec4(1.0))) *
    vec4(greaterThanEqual(b, vec4(1.0))));
`;
    const LOGICAL_OR$1 = `
  return min(
    vec4(greaterThanEqual(a, vec4(1.0))) +
    vec4(greaterThanEqual(b, vec4(1.0))),
    vec4(1.0));
`;
    const MAX$1 = `
  vec4 result = vec4(max(a, b));
  vec4 isNaN = min(vec4(isnan(a)) + vec4(isnan(b)), vec4(1.0));
  ` + CHECK_NAN_SNIPPET$1 + `
  return result;
`;
    const MIN$1 = `
  vec4 result = vec4(min(a, b));
  vec4 isNaN = min(vec4(isnan(a)) + vec4(isnan(b)), vec4(1.0));
  ` + CHECK_NAN_SNIPPET$1 + `
  return result;
`;
    const MOD$1 = `
  vec4 result = mod(a, b);
  vec4 isNaN = vec4(equal(b, vec4(0.0)));
  ` + CHECK_NAN_SNIPPET$1 + `
  return result;
`;
    class BinaryOpPackedProgram {
      constructor(op3, aShape, bShape, checkOutOfBounds = false) {
        this.variableNames = ["A", "B"];
        this.supportsBroadcasting = true;
        this.packedInputs = true;
        this.packedOutput = true;
        this.outputShape = assertAndGetBroadcastShape2(aShape, bShape);
        const rank = this.outputShape.length;
        let checkOutOfBoundsString = "";
        if (checkOutOfBounds) {
          if (rank === 0 || sizeFromShape2(this.outputShape) === 1) {
            checkOutOfBoundsString = `
          result.y = 0.;
          result.z = 0.;
          result.w = 0.;
        `;
          } else {
            const dtype = getCoordsDataType(rank);
            checkOutOfBoundsString = `
          ${dtype} coords = getOutputCoords();
        `;
            if (rank === 1) {
              checkOutOfBoundsString += `
            result.y = (coords + 1) >= ${this.outputShape[0]} ? 0. : result.y;
            result.z = 0.;
            result.w = 0.;
          `;
            } else {
              const channels = getChannels("coords", rank);
              checkOutOfBoundsString += `
            bool nextRowOutOfBounds =
              (${channels[rank - 2]} + 1) >= ${this.outputShape[rank - 2]};
            bool nextColOutOfBounds =
              (${channels[rank - 1]} + 1) >= ${this.outputShape[rank - 1]};
            result.y = nextColOutOfBounds ? 0. : result.y;
            result.z = nextRowOutOfBounds ? 0. : result.z;
            result.w = nextColOutOfBounds || nextRowOutOfBounds ? 0. : result.w;
          `;
            }
          }
        }
        this.userCode = `
      vec4 binaryOperation(vec4 a, vec4 b) {
        ${op3}
      }

      void main() {
        vec4 a = getAAtOutCoords();
        vec4 b = getBAtOutCoords();

        vec4 result = binaryOperation(a, b);
        ${checkOutOfBoundsString}

        setOutput(result);
      }
    `;
      }
    }
    /**
     * @license
     * Copyright 2017 Google LLC. All Rights Reserved.
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     * http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     * =============================================================================
     */
    class ClipProgram {
      constructor(aShape) {
        this.variableNames = ["A"];
        this.outputShape = aShape;
        this.userCode = `
      uniform float minVal;
      uniform float maxVal;

      void main() {
        float value = getAAtOutCoords();
        if (isnan(value)) {
          setOutput(value);
          return;
        }

        setOutput(clamp(value, minVal, maxVal));
      }
    `;
      }
      getCustomSetupFunc(min3, max3) {
        return (gpgpu, webGLProgram) => {
          if (this.minLoc == null) {
            this.minLoc = gpgpu.getUniformLocationNoThrow(webGLProgram, "minVal");
            this.maxLoc = gpgpu.getUniformLocationNoThrow(webGLProgram, "maxVal");
          }
          gpgpu.gl.uniform1f(this.minLoc, min3);
          gpgpu.gl.uniform1f(this.maxLoc, max3);
        };
      }
    }
    /**
     * @license
     * Copyright 2018 Google LLC. All Rights Reserved.
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     * http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     * =============================================================================
     */
    class ClipPackedProgram {
      constructor(aShape) {
        this.variableNames = ["A"];
        this.packedInputs = true;
        this.packedOutput = true;
        this.outputShape = aShape;
        this.userCode = `
      uniform float minVal;
      uniform float maxVal;

      void main() {
        vec4 value = getAAtOutCoords();

        if (any(isnan(value))) {
          setOutput(value);
          return;
        }

        setOutput(clamp(value, vec4(minVal), vec4(maxVal)));
      }
    `;
      }
      getCustomSetupFunc(min3, max3) {
        return (gpgpu, webGLProgram) => {
          if (this.minLoc == null) {
            this.minLoc = gpgpu.getUniformLocationNoThrow(webGLProgram, "minVal");
            this.maxLoc = gpgpu.getUniformLocationNoThrow(webGLProgram, "maxVal");
          }
          gpgpu.gl.uniform1f(this.minLoc, min3);
          gpgpu.gl.uniform1f(this.maxLoc, max3);
        };
      }
    }
    /**
     * @license
     * Copyright 2018 Google LLC. All Rights Reserved.
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     * http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     * =============================================================================
     */
    class ComplexAbsProgram {
      constructor(shape) {
        this.variableNames = ["real", "imag"];
        this.outputShape = shape;
        this.userCode = `
      void main() {
        float re = abs(getRealAtOutCoords());
        float im = abs(getImagAtOutCoords());
        float mx = max(re, im);

        // sadly the length function in glsl is not underflow-safe
        // (at least not on Intel GPUs). So the safe solution is
        // to ensure underflow-safety in all cases.
        setOutput(
          mx == 0.0 ? 0.0 : mx * length(vec2(1, min(re, im)/mx))
        );
      }
    `;
      }
    }
    /**
     * @license
     * Copyright 2017 Google LLC. All Rights Reserved.
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     * http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     * =============================================================================
     */
    class Conv2DDerFilterProgram {
      constructor(convInfo) {
        this.variableNames = ["x", "dy"];
        this.outputShape = convInfo.filterShape;
        const strideHeight = convInfo.strideHeight;
        const strideWidth = convInfo.strideWidth;
        const padTop = convInfo.padInfo.top;
        const padLeft = convInfo.padInfo.left;
        const isChannelsLast = convInfo.dataFormat === "channelsLast";
        this.userCode = `
      void main() {
        ivec4 coords = getOutputCoords();
        int wR = coords.x;
        int wC = coords.y;
        int d1 = coords.z;
        int d2 = coords.w;

        // Convolve x(?, ?, d1) with dy(:, :, d2) to get dw(wR, wC, d1, d2).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;

        for (int b = 0; b < ${convInfo.batchSize}; b++) {
          for (int yR = 0; yR < ${convInfo.outHeight}; yR++) {
            int xR = wR + yR * ${strideHeight} - ${padTop};

            if (xR < 0 || xR >= ${convInfo.inHeight}) {
              continue;
            }

            for (int yC = 0; yC < ${convInfo.outWidth}; yC++) {
              int xC = wC + yC * ${strideWidth} - ${padLeft};

              if (xC < 0 || xC >= ${convInfo.inWidth}) {
                continue;
              }

              if (${isChannelsLast}) {
                float dyValue = getDy(b, yR, yC, d2);
                float xValue = getX(b, xR, xC, d1);
                dotProd += (xValue * dyValue);
              } else {
                float dyValue = getDy(b, d2, yR, yC);
                float xValue = getX(b, d1, xR, xC);
                dotProd += (xValue * dyValue);
              }

            }
          }
        }
        setOutput(dotProd);
      }
    `;
      }
    }
    class Conv2DDerInputProgram {
      constructor(convInfo) {
        this.variableNames = ["dy", "W"];
        this.outputShape = convInfo.inShape;
        const filterHeight = convInfo.filterHeight;
        const filterWidth = convInfo.filterWidth;
        const strideHeight = convInfo.strideHeight;
        const strideWidth = convInfo.strideWidth;
        const isChannelsLast = convInfo.dataFormat === "channelsLast";
        const padTop = filterHeight - 1 - convInfo.padInfo.top;
        const padLeft = filterWidth - 1 - convInfo.padInfo.left;
        const rowDim = isChannelsLast ? 1 : 2;
        const colDim = isChannelsLast ? 2 : 3;
        const channelDim = isChannelsLast ? 3 : 1;
        this.userCode = `
      const ivec2 pads = ivec2(${padTop}, ${padLeft});

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords[0];
        int d1 = coords[${channelDim}];

        ivec2 dyCorner = ivec2(coords[${rowDim}], coords[${colDim}]) - pads;
        int dyRCorner = dyCorner.x;
        int dyCCorner = dyCorner.y;

        // Convolve dy(?, ?, d2) with w(:, :, d1, d2) to compute dx(xR, xC, d1).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;
        for (int wR = 0; wR < ${filterHeight}; wR++) {
          float dyR = float(dyRCorner + wR) / ${strideHeight}.0;

          if (dyR < 0.0 || dyR >= ${convInfo.outHeight}.0 || fract(dyR) > 0.0) {
            continue;
          }
          int idyR = int(dyR);

          int wRPerm = ${filterHeight} - 1 - wR;

          for (int wC = 0; wC < ${filterWidth}; wC++) {
            float dyC = float(dyCCorner + wC) / ${strideWidth}.0;

            if (dyC < 0.0 || dyC >= ${convInfo.outWidth}.0 ||
                fract(dyC) > 0.0) {
              continue;
            }
            int idyC = int(dyC);

            int wCPerm = ${filterWidth} - 1 - wC;

            for (int d2 = 0; d2 < ${convInfo.outChannels}; d2++) {

              if (${isChannelsLast}) {
                float xValue = getDy(batch, idyR, idyC, d2);
                float wValue = getW(wRPerm, wCPerm, d1, d2);
                dotProd += xValue * wValue;
              } else {
                float xValue = getDy(batch, d2, idyR, idyC);
                float wValue = getW(wRPerm, wCPerm, d1, d2);
                dotProd += xValue * wValue;
              }

            }
          }
        }
        setOutput(dotProd);
      }
    `;
      }
    }
    class Conv3DDerFilterProgram {
      constructor(convInfo) {
        this.variableNames = ["x", "dy"];
        this.outputShape = convInfo.filterShape;
        const strideDepth = convInfo.strideDepth;
        const strideHeight = convInfo.strideHeight;
        const strideWidth = convInfo.strideWidth;
        const padFront = convInfo.padInfo.front;
        const padTop = convInfo.padInfo.top;
        const padLeft = convInfo.padInfo.left;
        this.userCode = `
      void main() {
        ivec5 coords = getOutputCoords();
        int wF = coords.x;
        int wR = coords.y;
        int wC = coords.z;
        int d1 = coords.w;
        int d2 = coords.u;

        float dotProd = 0.0;

        for (int b = 0; b < ${convInfo.batchSize}; b++) {
          for (int yF = 0; yF < ${convInfo.outDepth}; yF++) {
            int xF = wF + yF * ${strideDepth} - ${padFront};

            if (xF < 0 || xF >= ${convInfo.inDepth}) {
              continue;
            }

            for (int yR = 0; yR < ${convInfo.outHeight}; yR++) {
              int xR = wR + yR * ${strideHeight} - ${padTop};

              if (xR < 0 || xR >= ${convInfo.inHeight}) {
                continue;
              }

              for (int yC = 0; yC < ${convInfo.outWidth}; yC++) {
                int xC = wC + yC * ${strideWidth} - ${padLeft};

                if (xC < 0 || xC >= ${convInfo.inWidth}) {
                  continue;
                }

                float dyValue = getDy(b, yF, yR, yC, d2);
                float xValue = getX(b, xF, xR, xC, d1);
                dotProd += (xValue * dyValue);
              }
            }
          }
        }
        setOutput(dotProd);
      }
    `;
      }
    }
    class Conv3DDerInputProgram {
      constructor(convInfo) {
        this.variableNames = ["dy", "W"];
        this.outputShape = convInfo.inShape;
        const filterDepth = convInfo.filterDepth;
        const filterHeight = convInfo.filterHeight;
        const filterWidth = convInfo.filterWidth;
        const strideDepth = convInfo.strideDepth;
        const strideHeight = convInfo.strideHeight;
        const strideWidth = convInfo.strideWidth;
        const padFront = filterDepth - 1 - convInfo.padInfo.front;
        const padTop = filterHeight - 1 - convInfo.padInfo.top;
        const padLeft = filterWidth - 1 - convInfo.padInfo.left;
        this.userCode = `
      const ivec3 pads = ivec3(${padFront}, ${padTop}, ${padLeft});

      void main() {
        ivec5 coords = getOutputCoords();
        int batch = coords.x;
        int d1 = coords.u;


        ivec3 dyCorner = ivec3(coords.y, coords.z, coords.w) - pads;
        int dyFCorner = dyCorner.x;
        int dyRCorner = dyCorner.y;
        int dyCCorner = dyCorner.z;

        float dotProd = 0.0;
        for (int wF = 0; wF < ${filterDepth}; wF++) {
          float dyF = float(dyFCorner + wF) / ${strideDepth}.0;

          if (dyF < 0.0 || dyF >= ${convInfo.outDepth}.0 || fract(dyF) > 0.0) {
            continue;
          }
          int idyF = int(dyF);

          int wFPerm = ${filterDepth} - 1 - wF;

          for (int wR = 0; wR < ${filterHeight}; wR++) {
            float dyR = float(dyRCorner + wR) / ${strideHeight}.0;

            if (dyR < 0.0 || dyR >= ${convInfo.outHeight}.0 ||
              fract(dyR) > 0.0) {
              continue;
            }
            int idyR = int(dyR);

            int wRPerm = ${filterHeight} - 1 - wR;

            for (int wC = 0; wC < ${filterWidth}; wC++) {
              float dyC = float(dyCCorner + wC) / ${strideWidth}.0;

              if (dyC < 0.0 || dyC >= ${convInfo.outWidth}.0 ||
                  fract(dyC) > 0.0) {
                continue;
              }
              int idyC = int(dyC);

              int wCPerm = ${filterWidth} - 1 - wC;

              for (int d2 = 0; d2 < ${convInfo.outChannels}; d2++) {
                float xValue = getDy(batch, idyF, idyR, idyC, d2);
                float wValue = getW(wFPerm, wRPerm, wCPerm, d1, d2);
                dotProd += xValue * wValue;
              }
            }
          }
        }
        setOutput(dotProd);
      }
    `;
      }
    }
    /**
     * @license
     * Copyright 2018 Google LLC. All Rights Reserved.
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     * http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     * =============================================================================
     */
    class DepthwiseConv2DDerFilterProgram {
      constructor(convInfo) {
        this.variableNames = ["x", "dy"];
        this.outputShape = convInfo.filterShape;
        const strideHeight = convInfo.strideHeight;
        const strideWidth = convInfo.strideWidth;
        const padTop = convInfo.padInfo.top;
        const padLeft = convInfo.padInfo.left;
        const channelMul = convInfo.outChannels / convInfo.inChannels;
        this.userCode = `
      void main() {
        ivec4 coords = getOutputCoords();
        int wR = coords.x;
        int wC = coords.y;
        int d1 = coords.z;
        int dm = coords.w;
        int d2 = d1 * ${channelMul} + dm;

        float dotProd = 0.0;

        // TO DO: Vec4 over the batch size
        for (int b = 0; b < ${convInfo.batchSize}; b++) {
          for (int yR = 0; yR < ${convInfo.outHeight}; yR++) {
            int xR = wR + yR * ${strideHeight} - ${padTop};

            if (xR < 0 || xR >= ${convInfo.inHeight}) {
              continue;
            }

            for (int yC = 0; yC < ${convInfo.outWidth}; yC++) {
              int xC = wC + yC * ${strideWidth} - ${padLeft};

              if (xC < 0 || xC >= ${convInfo.inWidth}) {
                continue;
              }

              float dyValue = getDy(b, yR, yC, d2);
              float xValue = getX(b, xR, xC, d1);
              dotProd += (xValue * dyValue);
            }
          }
        }
        setOutput(dotProd);
      }
    `;
      }
    }
    class DepthwiseConv2DDerInputProgram {
      constructor(convInfo) {
        this.variableNames = ["dy", "W"];
        this.outputShape = convInfo.inShape;
        const filterHeight = convInfo.filterHeight;
        const filterWidth = convInfo.filterWidth;
        const strideHeight = convInfo.strideHeight;
        const strideWidth = convInfo.strideWidth;
        const padTop = filterHeight - 1 - convInfo.padInfo.top;
        const padLeft = filterWidth - 1 - convInfo.padInfo.left;
        const channelMul = convInfo.outChannels / convInfo.inChannels;
        this.userCode = `
      const ivec2 pads = ivec2(${padTop}, ${padLeft});

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords[0];
        int d1 = coords[3];
        ivec2 dyCorner = coords.yz - pads;
        int dyRCorner = dyCorner.x;
        int dyCCorner = dyCorner.y;

        float dotProd = 0.0;

        for (int wR = 0; wR < ${filterHeight}; wR++) {
          float dyR = float(dyRCorner + wR) / ${strideHeight}.0;

          if (dyR < 0.0 || dyR >= ${convInfo.outHeight}.0 || fract(dyR) > 0.0) {
            continue;
          }
          int idyR = int(dyR);

          int wRPerm = ${filterHeight} - 1 - wR;

          for (int wC = 0; wC < ${filterWidth}; wC++) {
            float dyC = float(dyCCorner + wC) / ${strideWidth}.0;

            if (dyC < 0.0 || dyC >= ${convInfo.outWidth}.0 ||
                fract(dyC) > 0.0) {
              continue;
            }
            int idyC = int(dyC);

            int wCPerm = ${filterWidth} - 1 - wC;

            // TO DO: Vec4 over the channelMul
            for (int dm = 0; dm < ${channelMul}; dm++) {
              int d2 = d1 * ${channelMul} + dm;
              float xValue = getDy(batch, idyR, idyC, d2);
              float wValue = getW(wRPerm, wCPerm, d1, dm);
              dotProd += xValue * wValue;
            }
          }
        }
        setOutput(dotProd);
      }
    `;
      }
    }
    /**
     * @license
     * Copyright 2017 Google LLC. All Rights Reserved.
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     * http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     * =============================================================================
     */
    class Conv2DProgram {
      constructor(convInfo, addBias = false, activation2 = null, hasPreluActivationWeights = false) {
        this.variableNames = ["x", "W"];
        this.outputShape = convInfo.outShape;
        const padTop = convInfo.padInfo.top;
        const padLeft = convInfo.padInfo.left;
        const strideHeight = convInfo.strideHeight;
        const strideWidth = convInfo.strideWidth;
        const dilationHeight = convInfo.dilationHeight;
        const dilationWidth = convInfo.dilationWidth;
        const filterHeight = convInfo.filterHeight;
        const filterWidth = convInfo.filterWidth;
        const inputDepthNearestVec4 = Math.floor(convInfo.inChannels / 4) * 4;
        const inputDepthVec4Remainder = convInfo.inChannels % 4;
        const isChannelsLast = convInfo.dataFormat === "channelsLast";
        const rowDim = isChannelsLast ? 1 : 2;
        const colDim = isChannelsLast ? 2 : 3;
        const channelDim = isChannelsLast ? 3 : 1;
        let activationSnippet = "", applyActivationSnippet = "";
        if (activation2) {
          if (hasPreluActivationWeights) {
            activationSnippet = `float activation(float a) {
          float b = getPreluActivationWeightsAtOutCoords();
          ${activation2}
        }`;
          } else {
            activationSnippet = `
          float activation(float x) {
            ${activation2}
          }
        `;
          }
          applyActivationSnippet = `result = activation(result);`;
        }
        const addBiasSnippet = addBias ? "result += getBiasAtOutCoords();" : "";
        if (addBias) {
          this.variableNames.push("bias");
        }
        if (hasPreluActivationWeights) {
          this.variableNames.push("preluActivationWeights");
        }
        this.userCode = `
      ${activationSnippet}

      const ivec2 strides = ivec2(${strideHeight}, ${strideWidth});
      const ivec2 pads = ivec2(${padTop}, ${padLeft});

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords[0];
        int d2 = coords[${channelDim}];

        ivec2 xRCCorner =
            ivec2(coords[${rowDim}], coords[${colDim}]) * strides - pads;
        int xRCorner = xRCCorner.x;
        int xCCorner = xRCCorner.y;

        // Convolve x(?, ?, d1) with w(:, :, d1, d2) to get y(yR, yC, d2).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;
        for (int wR = 0; wR < ${filterHeight}; wR++) {
          int xR = xRCorner + wR * ${dilationHeight};

          if (xR < 0 || xR >= ${convInfo.inHeight}) {
            continue;
          }

          for (int wC = 0; wC < ${filterWidth}; wC++) {
            int xC = xCCorner + wC * ${dilationWidth};

            if (xC < 0 || xC >= ${convInfo.inWidth}) {
              continue;
            }

            for (int d1 = 0; d1 < ${inputDepthNearestVec4}; d1 += 4) {
              vec4 wValues = vec4(
                getW(wR, wC, d1, d2),
                getW(wR, wC, d1 + 1, d2),
                getW(wR, wC, d1 + 2, d2),
                getW(wR, wC, d1 + 3, d2)
              );

              if (${isChannelsLast}) {
                vec4 xValues = vec4(
                  getX(batch, xR, xC, d1),
                  getX(batch, xR, xC, d1 + 1),
                  getX(batch, xR, xC, d1 + 2),
                  getX(batch, xR, xC, d1 + 3)
                );
                dotProd += dot(xValues, wValues);
              } else {
                vec4 xValues = vec4(
                  getX(batch, d1, xR, xC),
                  getX(batch, d1 + 1, xR, xC),
                  getX(batch, d1 + 2, xR, xC),
                  getX(batch, d1 + 3, xR, xC)
                );
                dotProd += dot(xValues, wValues);
              }
            }

            if (${inputDepthVec4Remainder === 1}) {

              if (${isChannelsLast}) {
                dotProd +=
                    getX(batch, xR, xC, ${inputDepthNearestVec4}) *
                    getW(wR, wC, ${inputDepthNearestVec4}, d2);
              } else {
                dotProd +=
                    getX(batch, ${inputDepthNearestVec4}, xR, xC) *
                    getW(wR, wC, ${inputDepthNearestVec4}, d2);
              }

            } else if (${inputDepthVec4Remainder === 2}) {
              vec2 wValues = vec2(
                getW(wR, wC, ${inputDepthNearestVec4}, d2),
                getW(wR, wC, ${inputDepthNearestVec4} + 1, d2)
              );

              if (${isChannelsLast}) {
                vec2 xValues = vec2(
                  getX(batch, xR, xC, ${inputDepthNearestVec4}),
                  getX(batch, xR, xC, ${inputDepthNearestVec4} + 1)
                );
                dotProd += dot(xValues, wValues);
              } else {
                vec2 xValues = vec2(
                  getX(batch, ${inputDepthNearestVec4}, xR, xC),
                  getX(batch, ${inputDepthNearestVec4} + 1, xR, xC)
                );
                dotProd += dot(xValues, wValues);
              }

            } else if (${inputDepthVec4Remainder === 3}) {
              vec3 wValues = vec3(
                getW(wR, wC, ${inputDepthNearestVec4}, d2),
                getW(wR, wC, ${inputDepthNearestVec4} + 1, d2),
                getW(wR, wC, ${inputDepthNearestVec4} + 2, d2)
              );

              if (${isChannelsLast}) {
                vec3 xValues = vec3(
                  getX(batch, xR, xC, ${inputDepthNearestVec4}),
                  getX(batch, xR, xC, ${inputDepthNearestVec4} + 1),
                  getX(batch, xR, xC, ${inputDepthNearestVec4} + 2)
                );
                dotProd += dot(xValues, wValues);
              } else {
                vec3 xValues = vec3(
                  getX(batch, ${inputDepthNearestVec4}, xR, xC),
                  getX(batch, ${inputDepthNearestVec4} + 1, xR, xC),
                  getX(batch, ${inputDepthNearestVec4} + 2, xR, xC)
                );
                dotProd += dot(xValues, wValues);
              }

            }
          }
        }

        float result = dotProd;
        ${addBiasSnippet}
        ${applyActivationSnippet}
        setOutput(result);
      }
    `;
      }
    }
    class Conv3DProgram {
      constructor(convInfo) {
        this.variableNames = ["x", "W"];
        this.outputShape = convInfo.outShape;
        const padFront = convInfo.padInfo.front;
        const padTop = convInfo.padInfo.top;
        const padLeft = convInfo.padInfo.left;
        const strideDepth = convInfo.strideDepth;
        const strideHeight = convInfo.strideHeight;
        const strideWidth = convInfo.strideWidth;
        const dilationDepth = convInfo.dilationDepth;
        const dilationHeight = convInfo.dilationHeight;
        const dilationWidth = convInfo.dilationWidth;
        const filterDepth = convInfo.filterDepth;
        const filterHeight = convInfo.filterHeight;
        const filterWidth = convInfo.filterWidth;
        const inputDepthNearestVec4 = Math.floor(convInfo.inChannels / 4) * 4;
        const inputDepthVec4Remainder = convInfo.inChannels % 4;
        this.userCode = `
      const ivec3 strides = ivec3(${strideDepth}, ${strideHeight}, ${strideWidth});
      const ivec3 pads = ivec3(${padFront}, ${padTop}, ${padLeft});

      void main() {
        ivec5 coords = getOutputCoords();
        int batch = coords.x;
        int d2 = coords.u;

        ivec3 xFRCCorner = ivec3(coords.y, coords.z, coords.w) * strides - pads;
        int xFCorner = xFRCCorner.x;
        int xRCorner = xFRCCorner.y;
        int xCCorner = xFRCCorner.z;

        // Convolve x(?, ?, ?, d1) with w(:, :, :, d1, d2) to get
        // y(yF, yR, yC, d2). ? = to be determined. : = across all
        // values in that axis.
        float dotProd = 0.0;
        for (int wF = 0; wF < ${filterDepth}; wF++) {
          int xF = xFCorner + wF * ${dilationDepth};

          if (xF < 0 || xF >= ${convInfo.inDepth}) {
            continue;
          }

          for (int wR = 0; wR < ${filterHeight}; wR++) {
            int xR = xRCorner + wR * ${dilationHeight};

            if (xR < 0 || xR >= ${convInfo.inHeight}) {
              continue;
            }

            for (int wC = 0; wC < ${filterWidth}; wC++) {
              int xC = xCCorner + wC * ${dilationWidth};

              if (xC < 0 || xC >= ${convInfo.inWidth}) {
                continue;
              }

              for (int d1 = 0; d1 < ${inputDepthNearestVec4}; d1 += 4) {
                vec4 xValues = vec4(
                  getX(batch, xF, xR, xC, d1),
                  getX(batch, xF, xR, xC, d1 + 1),
                  getX(batch, xF, xR, xC, d1 + 2),
                  getX(batch, xF, xR, xC, d1 + 3)
                );
                vec4 wValues = vec4(
                  getW(wF, wR, wC, d1, d2),
                  getW(wF, wR, wC, d1 + 1, d2),
                  getW(wF, wR, wC, d1 + 2, d2),
                  getW(wF, wR, wC, d1 + 3, d2)
                );

                dotProd += dot(xValues, wValues);
              }

              if (${inputDepthVec4Remainder === 1}) {
                dotProd +=
                  getX(batch, xF, xR, xC, ${inputDepthNearestVec4}) *
                  getW(wF, wR, wC, ${inputDepthNearestVec4}, d2);
              } else if (${inputDepthVec4Remainder === 2}) {
                vec2 xValues = vec2(
                  getX(batch, xF, xR, xC, ${inputDepthNearestVec4}),
                  getX(batch, xF, xR, xC, ${inputDepthNearestVec4} + 1)
                );
                vec2 wValues = vec2(
                  getW(wF, wR, wC, ${inputDepthNearestVec4}, d2),
                  getW(wF, wR, wC, ${inputDepthNearestVec4} + 1, d2)
                );
                dotProd += dot(xValues, wValues);
              } else if (${inputDepthVec4Remainder === 3}) {
                vec3 xValues = vec3(
                  getX(batch, xF, xR, xC, ${inputDepthNearestVec4}),
                  getX(batch, xF, xR, xC, ${inputDepthNearestVec4} + 1),
                  getX(batch, xF, xR, xC, ${inputDepthNearestVec4} + 2)
                );
                vec3 wValues = vec3(
                  getW(wF, wR, wC, ${inputDepthNearestVec4}, d2),
                  getW(wF, wR, wC, ${inputDepthNearestVec4} + 1, d2),
                  getW(wF, wR, wC, ${inputDepthNearestVec4} + 2, d2)
                );
                dotProd += dot(xValues, wValues);
              }
            }
          }
        }
        setOutput(dotProd);
      }
    `;
      }
    }
    /**
     * @license
     * Copyright 2017 Google LLC. All Rights Reserved.
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     * http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     * =============================================================================
     */
    class DepthwiseConv2DProgram {
      constructor(convInfo, addBias = false, activation2 = null, hasPreluActivation = false) {
        this.variableNames = ["x", "W"];
        this.outputShape = convInfo.outShape;
        const xNumRows = convInfo.inHeight;
        const xNumCols = convInfo.inWidth;
        const padTop = convInfo.padInfo.top;
        const padLeft = convInfo.padInfo.left;
        const strideHeight = convInfo.strideHeight;
        const strideWidth = convInfo.strideWidth;
        const dilationHeight = convInfo.dilationHeight;
        const dilationWidth = convInfo.dilationWidth;
        const filterHeight = convInfo.filterHeight;
        const filterWidth = convInfo.filterWidth;
        const channelMul = convInfo.outChannels / convInfo.inChannels;
        let activationSnippet = "", applyActivationSnippet = "";
        if (activation2) {
          if (hasPreluActivation) {
            activationSnippet = `float activation(float a) {
          float b = getPreluActivationWeightsAtOutCoords();
          ${activation2}
        }`;
          } else {
            activationSnippet = `
          float activation(float x) {
            ${activation2}
          }
        `;
          }
          applyActivationSnippet = `result = activation(result);`;
        }
        const addBiasSnippet = addBias ? "result += getBiasAtOutCoords();" : "";
        if (addBias) {
          this.variableNames.push("bias");
        }
        if (hasPreluActivation) {
          this.variableNames.push("preluActivationWeights");
        }
        this.userCode = `
      ${activationSnippet}

      const ivec2 strides = ivec2(${strideHeight}, ${strideWidth});
      const ivec2 pads = ivec2(${padTop}, ${padLeft});

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords.x;
        ivec2 xRCCorner = coords.yz * strides - pads;
        int d2 = coords.w;
        int d1 = d2 / ${channelMul};
        int q = d2 - d1 * ${channelMul};

        int xRCorner = xRCCorner.x;
        int xCCorner = xRCCorner.y;

        // Convolve x(?, ?, d1) with w(:, :, d1, q) to get y(yR, yC, d2).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;
        // TO DO(dsmilkov): Flatten the two for loops and vec4 the operations.
        for (int wR = 0; wR < ${filterHeight}; wR++) {
          int xR = xRCorner + wR * ${dilationHeight};

          if (xR < 0 || xR >= ${xNumRows}) {
            continue;
          }

          for (int wC = 0; wC < ${filterWidth}; wC++) {
            int xC = xCCorner + wC * ${dilationWidth};

            if (xC < 0 || xC >= ${xNumCols}) {
              continue;
            }

            float xVal = getX(batch, xR, xC, d1);
            float wVal = getW(wR, wC, d1, q);
            dotProd += xVal * wVal;
          }
        }

        float result = dotProd;
        ${addBiasSnippet}
        ${applyActivationSnippet}
        setOutput(result);
      }
    `;
      }
    }
    /**
     * @license
     * Copyright 2018 Google LLC. All Rights Reserved.
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     * http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     * =============================================================================
     */
    class DepthwiseConvPacked2DProgram {
      constructor(convInfo, addBias = false, activation2 = null, hasPreluActivation = false) {
        this.variableNames = ["x", "W"];
        this.packedInputs = true;
        this.packedOutput = true;
        this.outputShape = convInfo.outShape;
        const xNumRows = convInfo.inHeight;
        const xNumCols = convInfo.inWidth;
        const padTop = convInfo.padInfo.top;
        const padLeft = convInfo.padInfo.left;
        const strideHeight = convInfo.strideHeight;
        const strideWidth = convInfo.strideWidth;
        const dilationHeight = convInfo.dilationHeight;
        const dilationWidth = convInfo.dilationWidth;
        const filterHeight = convInfo.filterHeight;
        const filterWidth = convInfo.filterWidth;
        const texelsAcross = filterWidth;
        let mainLoop = `int xR; int xC; int xCOffset;`;
        for (let r = 0; r < filterHeight; r++) {
          for (let c = 0; c < filterWidth; c++) {
            mainLoop += `
          vec4 xTexelR${r}C${c * 2} = vec4(0.);
          vec4 wR${r}C${c} = vec4(0.);
          vec4 xR${r}C${c} = vec4(0.);`;
          }
        }
        for (let r = 0; r < filterHeight; r++) {
          for (let texelC = 0; texelC < texelsAcross; texelC++) {
            const c = texelC * 2;
            mainLoop += `
          xR = xRCorner + ${r * dilationHeight};
          xC = xCCorner + ${c * dilationWidth};
        `;
            if (strideWidth === 1) {
              if (c < filterWidth) {
                if (padLeft % 2 === 1) {
                  mainLoop += `
                xCOffset = xC + 1;
                if(xR >= 0 && xR < ${xNumRows} && xCOffset >= 0 && xCOffset < ${xNumCols}) {
                  xTexelR${r}C${c} = getX(batch, xR, xCOffset, d1);

                  // Need to manually clear unused channels in case
                  // we're reading from recycled texture.
                  if(xCOffset + 1 >= ${xNumCols}) {
                    xTexelR${r}C${c}.zw = vec2(0.);
                  }
                } else {
                  xTexelR${r}C${c} = vec4(0.);
                }

                xCOffset = xC + 1 - 2;
                if(xR >= 0 && xR < ${xNumRows} && xCOffset >= 0 && xCOffset < ${xNumCols}) {
                  vec4 previous = getX(batch, xR, xCOffset, d1);

                  // Need to manually clear unused channels in case
                  // we're reading from recycled texture.
                  if(xCOffset + 1 >= ${xNumCols}) {
                    previous.zw = vec2(0.);
                  }

                  xR${r}C${c} = vec4(previous.zw, xTexelR${r}C${c}.xy);
                } else {
                  xR${r}C${c} = vec4(0, 0, xTexelR${r}C${c}.xy);
                }
              `;
                } else {
                  mainLoop += `
                if(xR >= 0 && xR < ${xNumRows} && xC >= 0 && xC < ${xNumCols}) {
                  xTexelR${r}C${c} = getX(batch, xR, xC, d1);
                } else {
                  xTexelR${r}C${c} = vec4(0.);
                }

                xR${r}C${c} = xTexelR${r}C${c};
              `;
                }
                if (c + 1 < filterWidth) {
                  const nextTexelOffset = padLeft % 2 === 0 ? nearestLargerEven2(dilationWidth) : dilationWidth;
                  if (dilationWidth % 2 === 0 && padLeft % 2 === 1 || dilationWidth % 2 !== 0 && padLeft % 2 !== 1) {
                    mainLoop += `
                  xCOffset = xC + ${padLeft % 2} + ${nextTexelOffset};

                  if(xR >= 0 && xR < ${xNumRows} &&
                    xCOffset >= 0 && xCOffset < ${xNumCols}) {
                    xTexelR${r}C${c + 2} = getX(batch, xR, xCOffset, d1);
                  }
                `;
                    if (dilationWidth > 1) {
                      mainLoop += `
                    xCOffset -= 2;
                    if(xR >= 0 && xR < ${xNumRows} &&
                      xCOffset >= 0 && xCOffset < ${xNumCols}) {
                      xTexelR${r}C${c} = getX(batch, xR, xCOffset, d1);
                    } else {
                      xTexelR${r}C${c} = vec4(0.);
                    }
                  `;
                    }
                    mainLoop += `
                  xR${r}C${c + 1} = vec4(
                    xTexelR${r}C${c}.zw, xTexelR${r}C${c + 2}.xy);
                `;
                  } else {
                    mainLoop += `
                  xCOffset = xC + ${nextTexelOffset};

                  if(xR >= 0 && xR < ${xNumRows} &&
                    xCOffset >= 0 && xCOffset < ${xNumCols}) {
                    xTexelR${r}C${c + 2} = getX(batch, xR, xCOffset, d1);
                  }

                  xR${r}C${c + 1} = xTexelR${r}C${c + 2};
                `;
                  }
                }
              }
            } else {
              if (c < filterWidth) {
                mainLoop += `
              if(xR >= 0 && xR < ${xNumRows}) {
            `;
                if (padLeft % 2 === 1) {
                  mainLoop += `
                xCOffset = xC + 1 - ${strideWidth};
                if(xCOffset >= 0 && xCOffset < ${xNumCols}) {
                  xTexelR${r}C${c} = getX(batch, xR, xCOffset, d1);
                } else {
                  xTexelR${r}C${c} = vec4(0.);
                }

                if(xC + 1 >= 0 && xC + 1 < ${xNumCols}) {
                  xTexelR${r}C${c + 2} = getX(batch, xR, xC + 1, d1);
                } else {
                  xTexelR${r}C${c + 2} = vec4(0.);
                }

                xR${r}C${c} = vec4(
                  xTexelR${r}C${c}.zw, xTexelR${r}C${c + 2}.zw);
              `;
                  if (c + 1 < filterWidth) {
                    mainLoop += `
                  vec4 final = vec4(0.);
                  xCOffset = xC + 1 + ${strideWidth};
                  if(xCOffset >= 0 && xCOffset < ${xNumCols}) {
                    final = getX(batch, xR, xCOffset, d1);
                  }
                  xR${r}C${c + 1} = vec4(xTexelR${r}C${c + 2}.xy, final.xy);
                `;
                  }
                } else {
                  mainLoop += `
                if(xC >= 0 && xC < ${xNumCols}) {
                  xTexelR${r}C${c} = getX(batch, xR, xC, d1);
                } else {
                  xTexelR${r}C${c} = vec4(0.);
                }

                xCOffset = xC + ${strideWidth};
                if(xCOffset >= 0 && xCOffset < ${xNumCols}) {
                  xTexelR${r}C${c + 2} = getX(batch, xR, xCOffset, d1);
                } else {
                  xTexelR${r}C${c + 2} = vec4(0.);
                }

                xR${r}C${c} = vec4(
                  xTexelR${r}C${c}.xy, xTexelR${r}C${c + 2}.xy);
              `;
                  if (c + 1 < filterWidth) {
                    mainLoop += `
                  xR${r}C${c + 1} = vec4(
                    xTexelR${r}C${c}.zw, xTexelR${r}C${c + 2}.zw);
                `;
                  }
                }
                mainLoop += `}`;
              }
            }
            if (c < filterWidth) {
              mainLoop += `
            vec4 wTexelR${r}C${c} = getW(${r}, ${c}, d1, q);
            wR${r}C${c} = vec4(wTexelR${r}C${c}.xz, wTexelR${r}C${c}.xz);
          `;
              if (c + 1 < filterWidth) {
                mainLoop += `
              vec4 wTexelR${r}C${c + 1} = getW(${r}, ${c + 1}, d1, q);
              wR${r}C${c + 1} =
                vec4(wTexelR${r}C${c + 1}.xz, wTexelR${r}C${c + 1}.xz);`;
              }
            }
          }
        }
        for (let r = 0; r < filterHeight; r++) {
          for (let c = 0; c < filterWidth; c++) {
            mainLoop += `dotProd += xR${r}C${c} * wR${r}C${c};`;
          }
        }
        let activationSnippet = "", applyActivationSnippet = "";
        if (activation2) {
          if (hasPreluActivation) {
            activationSnippet = `vec4 activation(vec4 a) {
          vec4 b = getPreluActivationWeightsAtOutCoords();
          ${activation2}
        }`;
          } else {
            activationSnippet = `vec4 activation(vec4 x) {
          ${activation2}
        }`;
          }
          applyActivationSnippet = `result = activation(result);`;
        }
        const addBiasSnippet = addBias ? "result += getBiasAtOutCoords();" : "";
        if (addBias) {
          this.variableNames.push("bias");
        }
        if (hasPreluActivation) {
          this.variableNames.push("preluActivationWeights");
        }
        this.userCode = `
      ${activationSnippet}

      const ivec2 strides = ivec2(${strideHeight}, ${strideWidth});
      const ivec2 pads = ivec2(${padTop}, ${padLeft});

      void main() {

        ivec4 coords = getOutputCoords();
        int batch = coords.x;
        ivec2 xRCCorner = coords.yz * strides - pads;
        int d2 = coords.w;
        int d1 = d2;
        int q = 0;
        int xRCorner = xRCCorner.x;
        int xCCorner = xRCCorner.y;

        vec4 dotProd = vec4(0.);

        ${mainLoop}

        vec4 result = dotProd;
        ${addBiasSnippet}
        ${applyActivationSnippet}
        setOutput(result);
      }
    `;
      }
    }
    /**
     * @license
     * Copyright 2017 Google LLC. All Rights Reserved.
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     * http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     * =============================================================================
     */
    class CropAndResizeProgram {
      constructor(imageShape, boxShape, cropSize, method, extrapolationValue) {
        this.variableNames = ["Image", "Boxes", "BoxInd"];
        this.outputShape = [];
        const [batch, imageHeight, imageWidth, depth] = imageShape;
        const [numBoxes] = boxShape;
        const [cropHeight, cropWidth] = cropSize;
        this.outputShape = [numBoxes, cropHeight, cropWidth, depth];
        const methodId = method === "bilinear" ? 1 : 0;
        const [inputHeightFloat, inputWidthFloat] = [`${imageHeight - 1}.0`, `${imageWidth - 1}.0`];
        const [heightRatio, heightScale, inY] = cropHeight > 1 ? [
          `${(imageHeight - 1) / (cropHeight - 1)}`,
          "(y2-y1) * height_ratio",
          `y1*${inputHeightFloat} + float(y)*(height_scale)`
        ] : [
          "0.0",
          "0.0",
          `0.5 * (y1+y2) * ${inputHeightFloat}`
        ];
        const [widthRatio, widthScale, inX] = cropWidth > 1 ? [
          `${(imageWidth - 1) / (cropWidth - 1)}`,
          "(x2-x1) * width_ratio",
          `x1*${inputWidthFloat} + float(x)*(width_scale)`
        ] : [
          "0.0",
          "0.0",
          `0.5 * (x1+x2) * ${inputWidthFloat}`
        ];
        this.userCode = `
      const float height_ratio = float(${heightRatio});
      const float width_ratio = float(${widthRatio});
      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int y = coords[1];
        int x = coords[2];
        int d = coords[3];

        // get box vals
        float y1 = getBoxes(b,0);
        float x1 = getBoxes(b,1);
        float y2 = getBoxes(b,2);
        float x2 = getBoxes(b,3);

        // get image in batch index
        int bInd = round(getBoxInd(b));
        if(bInd < 0 || bInd >= ${batch}) {
          return;
        }

        float height_scale = ${heightScale};
        float width_scale = ${widthScale};

        float in_y = ${inY};
        if( in_y < 0.0 || in_y > ${inputHeightFloat} ) {
          setOutput(float(${extrapolationValue}));
          return;
        }
        float in_x = ${inX};
        if( in_x < 0.0 || in_x > ${inputWidthFloat} ) {
          setOutput(float(${extrapolationValue}));
          return;
        }

        vec2 sourceFracIndexCR = vec2(in_x,in_y);
        if(${methodId} == 1) {
          // Compute the four integer indices.
          ivec2 sourceFloorCR = ivec2(sourceFracIndexCR);
          ivec2 sourceCeilCR = ivec2(ceil(sourceFracIndexCR));

          float topLeft = getImage(b, sourceFloorCR.y, sourceFloorCR.x, d);
          float bottomLeft = getImage(b, sourceCeilCR.y, sourceFloorCR.x, d);
          float topRight = getImage(b, sourceFloorCR.y, sourceCeilCR.x, d);
          float bottomRight = getImage(b, sourceCeilCR.y, sourceCeilCR.x, d);

          vec2 fracCR = sourceFracIndexCR - vec2(sourceFloorCR);

          float top = topLeft + (topRight - topLeft) * fracCR.x;
          float bottom = bottomLeft + (bottomRight - bottomLeft) * fracCR.x;
          float newValue = top + (bottom - top) * fracCR.y;
          setOutput(newValue);
        } else {
          // Compute the coordinators of nearest neighbor point.
          ivec2 sourceNearestCR = ivec2(floor(
            sourceFracIndexCR + vec2(0.5,0.5)));
          float newValue = getImage(b, sourceNearestCR.y, sourceNearestCR.x, d);
          setOutput(newValue);
        }
      }
    `;
      }
    }
    class CumSumProgram {
      constructor(shape, exclusive, reverse3) {
        this.variableNames = ["x"];
        this.outputShape = shape;
        const rank = shape.length;
        const val = exclusive ? "0.0" : `getX(${getCoords(rank, "coords")})`;
        const length = shape[shape.length - 1];
        let condition = "";
        let idxString = "";
        if (exclusive) {
          condition = reverse3 ? `end != ${length - 1}` : "end != 0";
          idxString = reverse3 ? "end + 1" : "end - 1";
        } else {
          condition = reverse3 ? `end + pow2 < ${length}` : "end >= pow2";
          idxString = reverse3 ? "end + pow2" : "end - pow2";
        }
        this.userCode = `
      uniform float index;
      void main() {
        ${getCoordsDataType(rank)} coords = getOutputCoords();
        int end = ${getFinalCoord(rank, "coords")};
        float val = ${val};
        int pow2 = int(pow(2.0, index));
        if (${condition}) {
          int idx = ${idxString};
          ${getFinalCoord(rank, "coords")} = idx;
          val += getX(${getCoords(rank, "coords")});
        }
        setOutput(val);
      }
    `;
      }
      getCustomSetupFunc(index2) {
        return (gpgpu, webGLProgram) => {
          if (this.index == null) {
            this.index = gpgpu.getUniformLocation(webGLProgram, "index");
          }
          gpgpu.gl.uniform1f(this.index, index2);
        };
      }
    }
    function getCoords(rank, name) {
      if (rank === 1) {
        return `${name}`;
      } else if (rank === 2) {
        return `${name}.x, ${name}.y`;
      } else if (rank === 3) {
        return `${name}.x, ${name}.y, ${name}.z`;
      } else if (rank === 4) {
        return `${name}.x, ${name}.y, ${name}.z, ${name}.w`;
      } else {
        throw Error(`Cumulative sum for rank ${rank} is not yet supported`);
      }
    }
    function getFinalCoord(rank, name) {
      if (rank === 1) {
        return `${name}`;
      } else if (rank === 2) {
        return `${name}.y`;
      } else if (rank === 3) {
        return `${name}.z`;
      } else if (rank === 4) {
        return `${name}.w`;
      } else {
        throw Error(`Cumulative sum for rank ${rank} is not yet supported`);
      }
    }
    /**
     * @license
     * Copyright 2019 Google LLC. All Rights Reserved.
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     * http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     * =============================================================================
     */
    class DecodeMatrixProgram {
      constructor(outputShape) {
        this.variableNames = ["A"];
        this.packedInputs = false;
        this.packedOutput = true;
        this.outPackingScheme = PackingScheme.DENSE;
        const texShape = getDenseTexShape(outputShape);
        const glsl = getGlslDifferences();
        this.outputShape = outputShape;
        this.userCode = `
      ivec3 outCoordsFromFlatIndex(int index) {
        ${getLogicalCoordinatesFromFlatIndex(["r", "c", "d"], outputShape)}
        return ivec3(r, c, d);
      }

      void main() {
        ivec2 resTexRC = ivec2(resultUV.yx *
          vec2(${texShape[0]}, ${texShape[1]}));
        int index = 4 * (resTexRC.x * ${texShape[1]} + resTexRC.y);

        vec4 result = vec4(0.);

        for (int i=0; i<4; i++) {
          int flatIndex = index + i;
          ivec3 rc = outCoordsFromFlatIndex(flatIndex);
          result[i] = getA(rc.x, rc.y, rc.z);
        }

        ${glsl.output} = result;
      }
    `;
      }
    }
    /**
     * @license
     * Copyright 2019 Google LLC. All Rights Reserved.
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     * http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     * =============================================================================
     */
    class DecodeMatrixPackedProgram {
      constructor(outputShape) {
        this.variableNames = ["A"];
        this.packedInputs = true;
        this.packedOutput = true;
        this.outPackingScheme = PackingScheme.DENSE;
        const texShape = getDenseTexShape(outputShape);
        const glsl = getGlslDifferences();
        this.outputShape = outputShape;
        this.userCode = `
      ivec3 outCoordsFromFlatIndex(int index) {
        ${getLogicalCoordinatesFromFlatIndex(["r", "c", "d"], outputShape)}
        return ivec3(r, c, d);
      }

      void main() {
        ivec2 resTexRC = ivec2(resultUV.yx *
          vec2(${texShape[0]}, ${texShape[1]}));
        int index = 4 * (resTexRC.x * ${texShape[1]} + resTexRC.y);

        vec4 result = vec4(0.);

        for (int i=0; i<4; i++) {
          int flatIndex = index + i;
          ivec3 rc = outCoordsFromFlatIndex(flatIndex);
          result[i] = getChannel(getA(rc.x, rc.y, rc.z), vec2(rc.y, rc.z));
        }

        ${glsl.output} = result;
      }
    `;
      }
    }
    /**
     * @license
     * Copyright 2018 Google LLC. All Rights Reserved.
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     * http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     * =============================================================================
     */
    class DepthToSpaceProgram {
      constructor(outputShape, blockSize, dataFormat) {
        this.variableNames = ["x"];
        this.outputShape = [];
        this.outputShape = outputShape;
        this.blockSize = blockSize;
        this.dataFormat = dataFormat;
        this.userCode = `
    void main() {
      ivec4 coords = getOutputCoords();
      int b = coords[0];
      int h = ${this.getHeightCoordString()};
      int w = ${this.getWidthCoordString()};
      int d = ${this.getDepthCoordString()};

      int in_h = h / ${blockSize};
      int offset_h = imod(h, ${blockSize});
      int in_w = w / ${blockSize};
      int offset_w = imod(w, ${blockSize});
      int offset_d = (offset_h * ${blockSize} + offset_w) *
        ${this.getOutputDepthSize()};
      int in_d = d + offset_d;

      float result = ${this.getInputSamplingString()};
      setOutput(result);
    }
  `;
      }
      getHeightCoordString() {
        if (this.dataFormat === "NHWC") {
          return `coords[1]`;
        } else {
          return `coords[2]`;
        }
      }
      getWidthCoordString() {
        if (this.dataFormat === "NHWC") {
          return `coords[2]`;
        } else {
          return `coords[3]`;
        }
      }
      getDepthCoordString() {
        if (this.dataFormat === "NHWC") {
          return `coords[3]`;
        } else {
          return `coords[1]`;
        }
      }
      getOutputDepthSize() {
        if (this.dataFormat === "NHWC") {
          return this.outputShape[3];
        } else {
          return this.outputShape[1];
        }
      }
      getInputSamplingString() {
        if (this.dataFormat === "NHWC") {
          return `getX(b, in_h, in_w, in_d)`;
        } else {
          return `getX(b, in_d, in_h, in_w)`;
        }
      }
    }
    /**
     * @license
     * Copyright 2019 Google LLC. All Rights Reserved.
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     * http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     * =============================================================================
     */
    class DiagProgram {
      constructor(size) {
        this.variableNames = ["X"];
        this.outputShape = [size, size];
        this.userCode = `
      void main() {
          ivec2 coords = getOutputCoords();
          float val = coords[0] == coords[1] ? getX(coords[0]) : 0.0;
          setOutput(val);
      }
    `;
      }
    }
    /**
     * @license
     * Copyright 2018 Google LLC. All Rights Reserved.
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     * http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     * =============================================================================
     */
    class EncodeFloatProgram {
      constructor(outputShape) {
        this.variableNames = ["A"];
        this.outTexUsage = TextureUsage.DOWNLOAD;
        const glsl = getGlslDifferences();
        this.outputShape = outputShape;
        this.userCode = `
      ${ENCODE_FLOAT_SNIPPET}

      void main() {
        float x = getAAtOutCoords();
        ${glsl.output} = encode_float(x);
      }
    `;
      }
    }
    /**
     * @license
     * Copyright 2018 Google LLC. All Rights Reserved.
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     * http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     * =============================================================================
     */
    class EncodeFloatPackedProgram {
      constructor(outputShape) {
        this.variableNames = ["A"];
        this.packedInputs = true;
        this.packedOutput = false;
        this.outTexUsage = TextureUsage.DOWNLOAD;
        const glsl = getGlslDifferences();
        this.outputShape = outputShape;
        this.userCode = `
      ${ENCODE_FLOAT_SNIPPET}

      void main() {
        ivec3 coords = getOutputCoords();
        float x = getChannel(getAAtOutCoords(), vec2(coords.y, coords.z));
        ${glsl.output} = encode_float(x);
      }
    `;
      }
    }
    /**
     * @license
     * Copyright 2018 Google LLC. All Rights Reserved.
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     * http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     * =============================================================================
     */
    class EncodeMatrixProgram {
      constructor(outputShape, texShape, inputIsUnsignedByte = false) {
        this.variableNames = ["A"];
        const glsl = getGlslDifferences();
        const [height, width] = texShape;
        this.outputShape = outputShape;
        let output = `result`;
        if (inputIsUnsignedByte) {
          output = `floor(result * 255. + 0.5)`;
        }
        this.userCode = `
      ${getFlatIndexFrom3D(outputShape)}

      void main() {
        ivec3 coords = getOutputCoords();

        int flatIndex = getFlatIndex(coords);
        int offset = imod(flatIndex, 4);

        flatIndex = idiv(flatIndex, 4, 1.);

        int r = flatIndex / ${width};
        int c = imod(flatIndex, ${width});
        vec2 uv = (vec2(c, r) + halfCR) / vec2(${width}.0, ${height}.0);
        vec4 values = ${glsl.texture2D}(A, uv);

        float result;

        if(offset == 0) {
          result = values[0];
        } else if(offset == 1) {
          result = values[1];
        } else if(offset == 2) {
          result = values[2];
        } else {
          result = values[3];
        }

        ${glsl.output} = vec4(${output}, 0., 0., 0.);
      }
    `;
      }
    }
    /**
     * @license
     * Copyright 2018 Google LLC. All Rights Reserved.
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     * http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     * =============================================================================
     */
    class EncodeMatrixPackedProgram {
      constructor(outputShape, texShape, inputIsUnsignedByte = false) {
        this.variableNames = ["A"];
        this.packedInputs = false;
        this.packedOutput = true;
        const glsl = getGlslDifferences();
        const [height, width] = texShape;
        this.outputShape = outputShape;
        let mainLoop = "";
        let output = "result";
        if (inputIsUnsignedByte) {
          output = "floor(result * 255. + 0.5)";
        }
        for (let row = 0; row <= 1; row++) {
          for (let col = 0; col <= 1; col++) {
            const channel = row * 2 + col;
            mainLoop += `
          localCoords = coords;
          if(localCoords[2] + ${col} < ${outputShape[2]}) {
            localCoords[2] += ${col};
            if(localCoords[1] + ${row} < ${outputShape[1]}) {
              localCoords[1] += ${row};

              flatIndex = getFlatIndex(localCoords);
              offset = imod(flatIndex, 4);

              flatIndex = idiv(flatIndex, 4, 1.);

              r = flatIndex / ${width};
              c = imod(flatIndex, ${width});
              uv = (vec2(c, r) + halfCR) / vec2(${width}.0, ${height}.0);
              values = ${glsl.texture2D}(A, uv);

              if(offset == 0) {
                result[${channel}] = values[0];
              } else if(offset == 1) {
                result[${channel}] = values[1];
              } else if(offset == 2) {
                result[${channel}] = values[2];
              } else {
                result[${channel}] = values[3];
              }
            }
          }
        `;
          }
        }
        this.userCode = `
      ${getFlatIndexFrom3D(outputShape)}

      void main() {
        ivec3 coords = getOutputCoords();

        vec4 result = vec4(0.);
        int flatIndex, r, c, offset;
        ivec3 localCoords;
        vec2 uv;
        vec4 values;

        ${mainLoop}

        ${glsl.output} = ${output};
      }
    `;
      }
    }
    /**
     * @license
     * Copyright 2019 Google LLC. All Rights Reserved.
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     * http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     * =============================================================================
     */
    class FillProgram {
      constructor(shape, value) {
        this.outputShape = [];
        this.variableNames = ["x"];
        this.outputShape = shape;
        this.userCode = `
      uniform float value;
      void main() {
        // Input can be obtained from uniform value.
        setOutput(value);
      }
    `;
      }
      getCustomSetupFunc(value) {
        return (gpgpu, webGLProgram) => {
          if (this.valueLoc == null) {
            this.valueLoc = gpgpu.getUniformLocationNoThrow(webGLProgram, "value");
          }
          gpgpu.gl.uniform1f(this.valueLoc, value);
        };
      }
    }
    /**
     * @license
     * Copyright 2017 Google LLC. All Rights Reserved.
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     * http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     * =============================================================================
     */
    class GatherProgram {
      constructor(aShape, indicesLength, axis) {
        this.variableNames = ["A", "indices"];
        const outputShape = aShape.slice();
        outputShape[axis] = indicesLength;
        this.outputShape = outputShape;
        this.rank = outputShape.length;
        const dtype = getCoordsDataType(this.rank);
        const sourceCoords = getSourceCoords$1(aShape, axis);
        this.userCode = `
      void main() {
        ${dtype} resRC = getOutputCoords();
        setOutput(getA(${sourceCoords}));
      }
    `;
      }
    }
    function getSourceCoords$1(aShape, axis) {
      const rank = aShape.length;
      if (rank > 4) {
        throw Error(`Gather for rank ${rank} is not yet supported`);
      }
      if (rank === 1) {
        return `int(getIndices(resRC))`;
      }
      const currentCoords = ["resRC.x", "resRC.y", "resRC.z", "resRC.w"];
      const sourceCoords = [];
      for (let i = 0; i < aShape.length; i++) {
        if (i === axis) {
          sourceCoords.push(`int(getIndices(${currentCoords[i]}))`);
        } else {
          sourceCoords.push(`${currentCoords[i]}`);
        }
      }
      return sourceCoords.join();
    }
    class GatherNDProgram {
      constructor(sliceDim, strides, shape) {
        this.sliceDim = sliceDim;
        this.strides = strides;
        this.variableNames = ["x", "indices"];
        this.outputShape = shape;
        const stridesType = getCoordsDataType(strides.length);
        const dtype = getCoordsDataType(shape.length);
        const strideString = this.sliceDim > 1 ? "strides[j]" : "strides";
        this.userCode = `
        ${stridesType} strides = ${stridesType}(${this.strides});
         void main() {
          ${dtype} coords = getOutputCoords();
          int flattenIndex = 0;
          for (int j = 0; j < ${this.sliceDim}; j++) {
            int index = round(getIndices(coords[0], j));
            flattenIndex += index * ${strideString};
          }
          setOutput(getX(flattenIndex, coords[1]));
        }
      `;
      }
    }
    /**
     * @license
     * Copyright 2017 Google LLC. All Rights Reserved.
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     * http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     * =============================================================================
     */
    function createVertexShader$1(gl) {
      const glsl = getGlslDifferences();
      const vertexShaderSource = `${glsl.version}
    precision highp float;
    ${glsl.attribute} vec3 clipSpacePos;
    ${glsl.attribute} vec2 uv;
    ${glsl.varyingVs} vec2 resultUV;

    void main() {
      gl_Position = vec4(clipSpacePos, 1);
      resultUV = uv;
    }`;
      return createVertexShader(gl, vertexShaderSource);
    }
    function createVertexBuffer(gl) {
      const vertexArray = new Float32Array([-1, 1, 0, 0, 1, -1, -1, 0, 0, 0, 1, 1, 0, 1, 1, 1, -1, 0, 1, 0]);
      return createStaticVertexBuffer(gl, vertexArray);
    }
    function createIndexBuffer(gl) {
      const triangleVertexIndices = new Uint16Array([0, 1, 2, 2, 1, 3]);
      return createStaticIndexBuffer(gl, triangleVertexIndices);
    }
    function createAndConfigureTexture(gl, width, height, internalFormat, textureFormat, textureType) {
      validateTextureSize(width, height);
      const texture = createTexture(gl);
      const tex2d = gl.TEXTURE_2D;
      callAndCheck(gl, () => gl.bindTexture(tex2d, texture));
      callAndCheck(gl, () => gl.texParameteri(tex2d, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE));
      callAndCheck(gl, () => gl.texParameteri(tex2d, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE));
      callAndCheck(gl, () => gl.texParameteri(tex2d, gl.TEXTURE_MIN_FILTER, gl.NEAREST));
      callAndCheck(gl, () => gl.texParameteri(tex2d, gl.TEXTURE_MAG_FILTER, gl.NEAREST));
      callAndCheck(gl, () => gl.texImage2D(tex2d, 0, internalFormat, width, height, 0, textureFormat, textureType, null));
      callAndCheck(gl, () => gl.bindTexture(gl.TEXTURE_2D, null));
      return texture;
    }
    function getInternalFormatForFloat32MatrixTexture(textureConfig) {
      return textureConfig.internalFormatFloat;
    }
    function createFloat32MatrixTexture(gl, rows, columns, textureConfig) {
      const [width, height] = getUnpackedMatrixTextureShapeWidthHeight(rows, columns);
      return createAndConfigureTexture(gl, width, height, getInternalFormatForFloat32MatrixTexture(textureConfig), textureConfig.textureFormatFloat, gl.FLOAT);
    }
    function getInternalFormatForFloat16MatrixTexture(textureConfig) {
      return textureConfig.internalFormatHalfFloat;
    }
    function createFloat16MatrixTexture(gl, rows, columns, textureConfig) {
      const [width, height] = getUnpackedMatrixTextureShapeWidthHeight(rows, columns);
      return createAndConfigureTexture(gl, width, height, getInternalFormatForFloat16MatrixTexture(textureConfig), textureConfig.textureFormatFloat, textureConfig.textureTypeHalfFloat);
    }
    function getInternalFormatForUnsignedBytesMatrixTexture(textureConfig) {
      return textureConfig.downloadTextureFormat;
    }
    function createUnsignedBytesMatrixTexture(gl, rows, columns, textureConfig) {
      const [width, height] = getUnpackedMatrixTextureShapeWidthHeight(rows, columns);
      return createAndConfigureTexture(gl, width, height, getInternalFormatForUnsignedBytesMatrixTexture(textureConfig), gl.RGBA, gl.UNSIGNED_BYTE);
    }
    function getInternalFormatForPackedMatrixTexture(textureConfig) {
      return textureConfig.internalFormatPackedFloat;
    }
    function createPackedMatrixTexture(gl, rows, columns, textureConfig) {
      const [width, height] = getPackedMatrixTextureShapeWidthHeight(rows, columns);
      return createAndConfigureTexture(gl, width, height, getInternalFormatForPackedMatrixTexture(textureConfig), gl.RGBA, gl.FLOAT);
    }
    function getInternalFormatForFloat16PackedMatrixTexture(textureConfig) {
      return textureConfig.internalFormatPackedHalfFloat;
    }
    function createFloat16PackedMatrixTexture(gl, rows, columns, textureConfig) {
      const [width, height] = getPackedMatrixTextureShapeWidthHeight(rows, columns);
      return createAndConfigureTexture(gl, width, height, getInternalFormatForFloat16PackedMatrixTexture(textureConfig), gl.RGBA, textureConfig.textureTypeHalfFloat);
    }
    function bindVertexProgramAttributeStreams(gl, program, vertexBuffer) {
      const posOffset = 0;
      const uvOffset = 3 * 4;
      const stride = 3 * 4 + 2 * 4;
      callAndCheck(gl, () => gl.bindBuffer(gl.ARRAY_BUFFER, vertexBuffer));
      const success = bindVertexBufferToProgramAttribute(gl, program, "clipSpacePos", vertexBuffer, 3, stride, posOffset);
      return success && bindVertexBufferToProgramAttribute(gl, program, "uv", vertexBuffer, 2, stride, uvOffset);
    }
    function uploadDenseMatrixToTexture(gl, texture, width, height, data2, textureConfig) {
      callAndCheck(gl, () => gl.bindTexture(gl.TEXTURE_2D, texture));
      let dataForUpload, texelDataType, internalFormat;
      if (data2 instanceof Uint8Array) {
        dataForUpload = new Uint8Array(width * height * 4);
        texelDataType = gl.UNSIGNED_BYTE;
        internalFormat = gl.RGBA;
      } else {
        dataForUpload = new Float32Array(width * height * 4);
        texelDataType = gl.FLOAT;
        internalFormat = textureConfig.internalFormatPackedFloat;
      }
      dataForUpload.set(data2);
      callAndCheck(gl, () => gl.texImage2D(gl.TEXTURE_2D, 0, internalFormat, width, height, 0, gl.RGBA, texelDataType, dataForUpload));
      callAndCheck(gl, () => gl.bindTexture(gl.TEXTURE_2D, null));
    }
    function uploadPixelDataToTexture(gl, texture, pixels) {
      callAndCheck(gl, () => gl.bindTexture(gl.TEXTURE_2D, texture));
      if (pixels.data instanceof Uint8Array) {
        callAndCheck(gl, () => gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, pixels.width, pixels.height, 0, gl.RGBA, gl.UNSIGNED_BYTE, pixels.data));
      } else {
        callAndCheck(gl, () => gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, pixels));
      }
      callAndCheck(gl, () => gl.bindTexture(gl.TEXTURE_2D, null));
    }
    function createBufferFromOutputTexture(gl2, rows, columns, textureConfig) {
      const buffer3 = gl2.createBuffer();
      callAndCheck(gl2, () => gl2.bindBuffer(gl2.PIXEL_PACK_BUFFER, buffer3));
      const bytesPerFloat = 4;
      const valuesPerTexel = 4;
      const bufferSizeBytes = bytesPerFloat * valuesPerTexel * rows * columns;
      callAndCheck(gl2, () => gl2.bufferData(gl2.PIXEL_PACK_BUFFER, bufferSizeBytes, gl2.STREAM_READ));
      callAndCheck(gl2, () => gl2.readPixels(0, 0, columns, rows, gl2.RGBA, gl2.FLOAT, 0));
      callAndCheck(gl2, () => gl2.bindBuffer(gl2.PIXEL_PACK_BUFFER, null));
      return buffer3;
    }
    function downloadFloat32MatrixFromBuffer(gl, buffer3, size) {
      const gl2 = gl;
      const downloadTarget = new Float32Array(size);
      gl2.bindBuffer(gl2.PIXEL_PACK_BUFFER, buffer3);
      gl2.getBufferSubData(gl2.PIXEL_PACK_BUFFER, 0, downloadTarget);
      gl2.bindBuffer(gl2.PIXEL_PACK_BUFFER, null);
      return downloadTarget;
    }
    function downloadByteEncodedFloatMatrixFromOutputTexture(gl, rows, columns, textureConfig) {
      const [w, h] = getUnpackedMatrixTextureShapeWidthHeight(rows, columns);
      const numChannels = 4;
      const downloadTarget = new Uint8Array(getUnpackedArraySizeFromMatrixSize(rows * columns, numChannels));
      callAndCheck(gl, () => gl.readPixels(0, 0, w, h, textureConfig.downloadTextureFormat, gl.UNSIGNED_BYTE, downloadTarget));
      return new Float32Array(downloadTarget.buffer);
    }
    function downloadPackedMatrixFromBuffer(gl, buffer3, batch, rows, cols, physicalRows, physicalCols, textureConfig) {
      const gl2 = gl;
      const downloadTarget = new Float32Array(getPackedRGBAArraySizeFromMatrixShape(physicalRows, physicalCols));
      gl2.bindBuffer(gl2.PIXEL_PACK_BUFFER, buffer3);
      gl2.getBufferSubData(gl2.PIXEL_PACK_BUFFER, 0, downloadTarget);
      gl2.bindBuffer(gl2.PIXEL_PACK_BUFFER, null);
      return downloadTarget;
    }
    function downloadMatrixFromPackedOutputTexture(gl, physicalRows, physicalCols) {
      const packedRGBA = new Float32Array(physicalRows * physicalCols * 4);
      callAndCheck(gl, () => gl.readPixels(0, 0, physicalCols, physicalRows, gl.RGBA, gl.FLOAT, packedRGBA));
      return packedRGBA;
    }
    /**
     * @license
     * Copyright 2017 Google LLC. All Rights Reserved.
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     * http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     * =============================================================================
     */
    class GPGPUContext {
      constructor(gl) {
        this.outputTexture = null;
        this.program = null;
        this.disposed = false;
        this.vertexAttrsAreBound = false;
        this.itemsToPoll = [];
        const glVersion = env2().getNumber("WEBGL_VERSION");
        if (gl != null) {
          this.gl = gl;
          setWebGLContext(glVersion, gl);
        } else {
          this.gl = getWebGLContext(glVersion);
        }
        let COLOR_BUFFER_FLOAT = "WEBGL_color_buffer_float";
        const COLOR_BUFFER_HALF_FLOAT = "EXT_color_buffer_half_float";
        if (env2().getNumber("WEBGL_VERSION") === 1) {
          const TEXTURE_FLOAT = "OES_texture_float";
          const TEXTURE_HALF_FLOAT = "OES_texture_half_float";
          this.textureFloatExtension = getExtensionOrThrow(this.gl, TEXTURE_FLOAT);
          if (hasExtension(this.gl, TEXTURE_HALF_FLOAT)) {
            this.textureHalfFloatExtension = getExtensionOrThrow(this.gl, TEXTURE_HALF_FLOAT);
          } else if (env2().get("WEBGL_FORCE_F16_TEXTURES")) {
            throw new Error("GL context does not support half float textures, yet the environment flag WEBGL_FORCE_F16_TEXTURES is set to true.");
          }
          this.colorBufferFloatExtension = this.gl.getExtension(COLOR_BUFFER_FLOAT);
          if (hasExtension(this.gl, COLOR_BUFFER_HALF_FLOAT)) {
            this.colorBufferHalfFloatExtension = getExtensionOrThrow(this.gl, COLOR_BUFFER_HALF_FLOAT);
          } else if (env2().get("WEBGL_FORCE_F16_TEXTURES")) {
            throw new Error("GL context does not support color renderable half floats, yet the environment flag WEBGL_FORCE_F16_TEXTURES is set to true.");
          }
        } else {
          COLOR_BUFFER_FLOAT = "EXT_color_buffer_float";
          if (hasExtension(this.gl, COLOR_BUFFER_FLOAT)) {
            this.colorBufferFloatExtension = this.gl.getExtension(COLOR_BUFFER_FLOAT);
          } else if (hasExtension(this.gl, COLOR_BUFFER_HALF_FLOAT)) {
            this.colorBufferHalfFloatExtension = this.gl.getExtension(COLOR_BUFFER_HALF_FLOAT);
          } else {
            throw new Error("GL context does not support color renderable floats");
          }
        }
        this.vertexBuffer = createVertexBuffer(this.gl);
        this.indexBuffer = createIndexBuffer(this.gl);
        this.framebuffer = createFramebuffer(this.gl);
        this.textureConfig = getTextureConfig(this.gl, this.textureHalfFloatExtension);
      }
      get debug() {
        return env2().getBool("DEBUG");
      }
      dispose() {
        if (this.disposed) {
          return;
        }
        if (this.program != null) {
          console.warn("Disposing a GPGPUContext that still has a bound WebGLProgram. This is probably a resource leak, delete the program with GPGPUContext.deleteProgram before disposing.");
        }
        if (this.outputTexture != null) {
          console.warn("Disposing a GPGPUContext that still has a bound output matrix texture.  This is probably a resource leak, delete the output matrix texture with GPGPUContext.deleteMatrixTexture before disposing.");
        }
        const gl = this.gl;
        callAndCheck(gl, () => gl.finish());
        callAndCheck(gl, () => gl.bindFramebuffer(gl.FRAMEBUFFER, null));
        callAndCheck(gl, () => gl.deleteFramebuffer(this.framebuffer));
        callAndCheck(gl, () => gl.bindBuffer(gl.ARRAY_BUFFER, null));
        callAndCheck(gl, () => gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, null));
        callAndCheck(gl, () => gl.deleteBuffer(this.indexBuffer));
        this.disposed = true;
      }
      createFloat32MatrixTexture(rows, columns) {
        this.throwIfDisposed();
        return createFloat32MatrixTexture(this.gl, rows, columns, this.textureConfig);
      }
      createFloat16MatrixTexture(rows, columns) {
        this.throwIfDisposed();
        return createFloat16MatrixTexture(this.gl, rows, columns, this.textureConfig);
      }
      createUnsignedBytesMatrixTexture(rows, columns) {
        this.throwIfDisposed();
        return createUnsignedBytesMatrixTexture(this.gl, rows, columns, this.textureConfig);
      }
      uploadPixelDataToTexture(texture, pixels) {
        this.throwIfDisposed();
        uploadPixelDataToTexture(this.gl, texture, pixels);
      }
      uploadDenseMatrixToTexture(texture, width, height, data2) {
        this.throwIfDisposed();
        uploadDenseMatrixToTexture(this.gl, texture, width, height, data2, this.textureConfig);
      }
      createFloat16PackedMatrixTexture(rows, columns) {
        this.throwIfDisposed();
        return createFloat16PackedMatrixTexture(this.gl, rows, columns, this.textureConfig);
      }
      createPackedMatrixTexture(rows, columns) {
        this.throwIfDisposed();
        return createPackedMatrixTexture(this.gl, rows, columns, this.textureConfig);
      }
      deleteMatrixTexture(texture) {
        this.throwIfDisposed();
        if (this.outputTexture === texture) {
          unbindColorTextureFromFramebuffer(this.gl, this.framebuffer);
          this.outputTexture = null;
        }
        callAndCheck(this.gl, () => this.gl.deleteTexture(texture));
      }
      downloadByteEncodedFloatMatrixFromOutputTexture(texture, rows, columns) {
        return this.downloadMatrixDriver(texture, () => downloadByteEncodedFloatMatrixFromOutputTexture(this.gl, rows, columns, this.textureConfig));
      }
      downloadPackedMatrixFromBuffer(buffer3, batch, rows, columns, physicalRows, physicalCols) {
        return downloadPackedMatrixFromBuffer(this.gl, buffer3, batch, rows, columns, physicalRows, physicalCols, this.textureConfig);
      }
      downloadFloat32MatrixFromBuffer(buffer3, size) {
        return downloadFloat32MatrixFromBuffer(this.gl, buffer3, size);
      }
      createBufferFromTexture(texture, rows, columns) {
        this.bindTextureToFrameBuffer(texture);
        const result = createBufferFromOutputTexture(this.gl, rows, columns, this.textureConfig);
        this.unbindTextureToFrameBuffer();
        return result;
      }
      createAndWaitForFence() {
        const fenceContext = this.createFence(this.gl);
        return this.pollFence(fenceContext);
      }
      createFence(gl) {
        let query;
        let isFencePassed;
        if (env2().getBool("WEBGL_FENCE_API_ENABLED")) {
          const gl2 = gl;
          const sync = gl2.fenceSync(gl2.SYNC_GPU_COMMANDS_COMPLETE, 0);
          gl.flush();
          isFencePassed = () => {
            const status2 = gl2.clientWaitSync(sync, 0, 0);
            return status2 === gl2.ALREADY_SIGNALED || status2 === gl2.CONDITION_SATISFIED;
          };
          query = sync;
        } else if (env2().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION") > 0) {
          query = this.beginQuery();
          this.endQuery();
          isFencePassed = () => this.isQueryAvailable(query, env2().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION"));
        } else {
          isFencePassed = () => true;
        }
        return {query, isFencePassed};
      }
      downloadMatrixFromPackedTexture(texture, physicalRows, physicalCols) {
        return this.downloadMatrixDriver(texture, () => downloadMatrixFromPackedOutputTexture(this.gl, physicalRows, physicalCols));
      }
      createProgram(fragmentShaderSource) {
        this.throwIfDisposed();
        const gl = this.gl;
        const fragmentShader = createFragmentShader(gl, fragmentShaderSource);
        const vertexShader = createVertexShader$1(gl);
        const program = createProgram(gl);
        callAndCheck(gl, () => gl.attachShader(program, vertexShader));
        callAndCheck(gl, () => gl.attachShader(program, fragmentShader));
        linkProgram(gl, program);
        if (this.debug) {
          validateProgram(gl, program);
        }
        if (!this.vertexAttrsAreBound) {
          this.setProgram(program);
          this.vertexAttrsAreBound = bindVertexProgramAttributeStreams(gl, this.program, this.vertexBuffer);
        }
        return program;
      }
      deleteProgram(program) {
        this.throwIfDisposed();
        if (program === this.program) {
          this.program = null;
        }
        if (program != null) {
          callAndCheck(this.gl, () => this.gl.deleteProgram(program));
        }
      }
      setProgram(program) {
        this.throwIfDisposed();
        this.program = program;
        if (this.program != null && this.debug) {
          validateProgram(this.gl, this.program);
        }
        callAndCheck(this.gl, () => this.gl.useProgram(program));
      }
      getUniformLocation(program, uniformName, shouldThrow = true) {
        this.throwIfDisposed();
        if (shouldThrow) {
          return getProgramUniformLocationOrThrow(this.gl, program, uniformName);
        } else {
          return getProgramUniformLocation(this.gl, program, uniformName);
        }
      }
      getAttributeLocation(program, attribute) {
        this.throwIfDisposed();
        return callAndCheck(this.gl, () => this.gl.getAttribLocation(program, attribute));
      }
      getUniformLocationNoThrow(program, uniformName) {
        this.throwIfDisposed();
        return this.gl.getUniformLocation(program, uniformName);
      }
      setInputMatrixTexture(inputMatrixTexture, uniformLocation, textureUnit) {
        this.throwIfDisposed();
        this.throwIfNoProgram();
        bindTextureToProgramUniformSampler(this.gl, inputMatrixTexture, uniformLocation, textureUnit);
      }
      setOutputMatrixTexture(outputMatrixTexture, rows, columns) {
        this.setOutputMatrixTextureDriver(outputMatrixTexture, columns, rows);
      }
      setOutputPackedMatrixTexture(outputPackedMatrixTexture, rows, columns) {
        this.throwIfDisposed();
        const [width, height] = getPackedMatrixTextureShapeWidthHeight(rows, columns);
        this.setOutputMatrixTextureDriver(outputPackedMatrixTexture, width, height);
      }
      setOutputMatrixWriteRegion(startRow, numRows, startColumn, numColumns) {
        this.setOutputMatrixWriteRegionDriver(startColumn, startRow, numColumns, numRows);
      }
      setOutputPackedMatrixWriteRegion(startRow, numRows, startColumn, numColumns) {
        throw new Error("setOutputPackedMatrixWriteRegion not implemented.");
      }
      debugValidate() {
        if (this.program != null) {
          validateProgram(this.gl, this.program);
        }
        validateFramebuffer(this.gl);
      }
      executeProgram() {
        this.throwIfDisposed();
        this.throwIfNoProgram();
        const gl = this.gl;
        if (this.debug) {
          this.debugValidate();
        }
        callAndCheck(gl, () => gl.drawElements(gl.TRIANGLES, 6, gl.UNSIGNED_SHORT, 0));
      }
      blockUntilAllProgramsCompleted() {
        this.throwIfDisposed();
        callAndCheck(this.gl, () => this.gl.finish());
      }
      getQueryTimerExtension() {
        if (this.disjointQueryTimerExtension == null) {
          this.disjointQueryTimerExtension = getExtensionOrThrow(this.gl, env2().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION") === 2 ? "EXT_disjoint_timer_query_webgl2" : "EXT_disjoint_timer_query");
        }
        return this.disjointQueryTimerExtension;
      }
      getQueryTimerExtensionWebGL2() {
        return this.getQueryTimerExtension();
      }
      getQueryTimerExtensionWebGL1() {
        return this.getQueryTimerExtension();
      }
      beginQuery() {
        if (env2().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION") === 2) {
          const gl2 = this.gl;
          const ext2 = this.getQueryTimerExtensionWebGL2();
          const query2 = gl2.createQuery();
          gl2.beginQuery(ext2.TIME_ELAPSED_EXT, query2);
          return query2;
        }
        const ext = this.getQueryTimerExtensionWebGL1();
        const query = ext.createQueryEXT();
        ext.beginQueryEXT(ext.TIME_ELAPSED_EXT, query);
        return query;
      }
      endQuery() {
        if (env2().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION") === 2) {
          const gl2 = this.gl;
          const ext2 = this.getQueryTimerExtensionWebGL2();
          gl2.endQuery(ext2.TIME_ELAPSED_EXT);
          return;
        }
        const ext = this.getQueryTimerExtensionWebGL1();
        ext.endQueryEXT(ext.TIME_ELAPSED_EXT);
      }
      async waitForQueryAndGetTime(query) {
        await repeatedTry2(() => this.disposed || this.isQueryAvailable(query, env2().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")));
        return this.getQueryTime(query, env2().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION"));
      }
      getQueryTime(query, queryTimerVersion) {
        if (queryTimerVersion === 0) {
          return null;
        }
        if (queryTimerVersion === 2) {
          const gl2 = this.gl;
          const timeElapsedNanos = gl2.getQueryParameter(query, gl2.QUERY_RESULT);
          return timeElapsedNanos / 1e6;
        } else {
          const ext = this.getQueryTimerExtensionWebGL1();
          const timeElapsedNanos = ext.getQueryObjectEXT(query, ext.QUERY_RESULT_EXT);
          return timeElapsedNanos / 1e6;
        }
      }
      isQueryAvailable(query, queryTimerVersion) {
        if (queryTimerVersion === 0) {
          return true;
        }
        if (queryTimerVersion === 2) {
          const gl2 = this.gl;
          const ext = this.getQueryTimerExtensionWebGL2();
          const available = gl2.getQueryParameter(query, gl2.QUERY_RESULT_AVAILABLE);
          if (this.disjoint == null) {
            this.disjoint = this.gl.getParameter(ext.GPU_DISJOINT_EXT);
          }
          return available && !this.disjoint;
        } else {
          const ext = this.getQueryTimerExtensionWebGL1();
          const available = ext.getQueryObjectEXT(query, ext.QUERY_RESULT_AVAILABLE_EXT);
          if (this.disjoint == null) {
            this.disjoint = this.gl.getParameter(ext.GPU_DISJOINT_EXT);
          }
          return available && !this.disjoint;
        }
      }
      pollFence(fenceContext) {
        return new Promise((resolve) => {
          this.addItemToPoll(() => fenceContext.isFencePassed(), () => resolve());
        });
      }
      pollItems() {
        const index2 = linearSearchLastTrue(this.itemsToPoll.map((x) => x.isDoneFn));
        for (let i = 0; i <= index2; ++i) {
          const {resolveFn} = this.itemsToPoll[i];
          resolveFn();
        }
        this.itemsToPoll = this.itemsToPoll.slice(index2 + 1);
      }
      addItemToPoll(isDoneFn, resolveFn) {
        this.itemsToPoll.push({isDoneFn, resolveFn});
        if (this.itemsToPoll.length > 1) {
          return;
        }
        repeatedTry2(() => {
          this.pollItems();
          return this.itemsToPoll.length === 0;
        });
      }
      bindTextureToFrameBuffer(texture) {
        this.throwIfDisposed();
        bindColorTextureToFramebuffer(this.gl, texture, this.framebuffer);
        if (this.debug) {
          validateFramebuffer(this.gl);
        }
      }
      unbindTextureToFrameBuffer() {
        if (this.outputTexture != null) {
          bindColorTextureToFramebuffer(this.gl, this.outputTexture, this.framebuffer);
          if (this.debug) {
            validateFramebuffer(this.gl);
          }
        } else {
          unbindColorTextureFromFramebuffer(this.gl, this.framebuffer);
        }
      }
      downloadMatrixDriver(texture, downloadAndDecode) {
        this.bindTextureToFrameBuffer(texture);
        const result = downloadAndDecode();
        this.unbindTextureToFrameBuffer();
        return result;
      }
      setOutputMatrixTextureDriver(outputMatrixTextureMaybePacked, width, height) {
        this.throwIfDisposed();
        const gl = this.gl;
        bindColorTextureToFramebuffer(gl, outputMatrixTextureMaybePacked, this.framebuffer);
        if (this.debug) {
          validateFramebuffer(gl);
        }
        this.outputTexture = outputMatrixTextureMaybePacked;
        callAndCheck(gl, () => gl.viewport(0, 0, width, height));
        callAndCheck(gl, () => gl.scissor(0, 0, width, height));
      }
      setOutputMatrixWriteRegionDriver(x, y, width, height) {
        this.throwIfDisposed();
        callAndCheck(this.gl, () => this.gl.scissor(x, y, width, height));
      }
      throwIfDisposed() {
        if (this.disposed) {
          throw new Error("Attempted to use disposed GPGPUContext.");
        }
      }
      throwIfNoProgram() {
        if (this.program == null) {
          throw new Error("No GPU program is currently set.");
        }
      }
    }
    function linearSearchLastTrue(arr) {
      let i = 0;
      for (; i < arr.length; ++i) {
        const isDone = arr[i]();
        if (!isDone) {
          break;
        }
      }
      return i - 1;
    }
    /**
     * @license
     * Copyright 2017 Google LLC. All Rights Reserved.
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     * http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     * =============================================================================
     */
    function compileProgram(gpgpu, program, inputs, output) {
      const userCode = program.userCode;
      const inputInfos = inputs.map((input2, i) => {
        const shapeInfo = {
          logicalShape: input2.shape,
          texShape: input2.isUniform ? null : input2.texData.texShape,
          isUniform: input2.isUniform,
          isPacked: input2.isUniform ? false : input2.texData.isPacked,
          flatOffset: null
        };
        if (input2.texData != null && input2.texData.slice != null && input2.texData.slice.flatOffset > 0) {
          shapeInfo.flatOffset = input2.texData.slice.flatOffset;
        }
        return {name: program.variableNames[i], shapeInfo};
      });
      const inShapeInfos = inputInfos.map((x) => x.shapeInfo);
      const outShapeInfo = {
        logicalShape: output.shape,
        texShape: output.texData.texShape,
        isUniform: false,
        isPacked: output.texData.isPacked,
        flatOffset: null
      };
      const source = makeShader(inputInfos, outShapeInfo, userCode, program.packedInputs);
      const webGLProgram = gpgpu.createProgram(source);
      let infLoc = null;
      const nanLoc = gpgpu.getUniformLocation(webGLProgram, "NAN", false);
      if (env2().getNumber("WEBGL_VERSION") === 1) {
        infLoc = gpgpu.getUniformLocation(webGLProgram, "INFINITY", false);
      }
      const uniformLocations = {};
      for (let i = 0; i < program.variableNames.length; i++) {
        const varName = program.variableNames[i];
        const shouldThrow = false;
        uniformLocations[varName] = gpgpu.getUniformLocation(webGLProgram, varName, shouldThrow);
        uniformLocations[`offset${varName}`] = gpgpu.getUniformLocation(webGLProgram, `offset${varName}`, shouldThrow);
      }
      return {
        program,
        source,
        webGLProgram,
        uniformLocations,
        inShapeInfos,
        outShapeInfo,
        infLoc,
        nanLoc
      };
    }
    function validateBinaryAndProgram(shapeInfos, inputs) {
      if (shapeInfos.length !== inputs.length) {
        throw Error(`Binary was compiled with ${shapeInfos.length} inputs, but was executed with ${inputs.length} inputs`);
      }
      shapeInfos.forEach((s, i) => {
        const shapeA = s.logicalShape;
        const input2 = inputs[i];
        const shapeB = input2.shape;
        if (!arraysEqual2(shapeA, shapeB)) {
          throw Error(`Binary was compiled with different shapes than the current args. Shapes ${shapeA} and ${shapeB} must match`);
        }
        if (s.isUniform && input2.isUniform) {
          return;
        }
        const texShapeA = s.texShape;
        const texShapeB = input2.isUniform ? null : input2.texData.texShape;
        if (!arraysEqual2(texShapeA, texShapeB)) {
          throw Error(`Binary was compiled with different texture shapes than the current args. Shape ${texShapeA} and ${texShapeB} must match`);
        }
      });
    }
    function runProgram(gpgpu, binary, inputs, output, customSetup) {
      validateBinaryAndProgram(binary.inShapeInfos, inputs);
      validateBinaryAndProgram([binary.outShapeInfo], [output]);
      const outTex = output.texData.texture;
      const outTexShape = output.texData.texShape;
      if (output.texData.isPacked) {
        gpgpu.setOutputPackedMatrixTexture(outTex, outTexShape[0], outTexShape[1]);
      } else {
        gpgpu.setOutputMatrixTexture(outTex, outTexShape[0], outTexShape[1]);
      }
      gpgpu.setProgram(binary.webGLProgram);
      if (env2().getNumber("WEBGL_VERSION") === 1) {
        if (binary.infLoc !== null) {
          gpgpu.gl.uniform1f(binary.infLoc, Infinity);
        }
      }
      if (binary.nanLoc !== null) {
        gpgpu.gl.uniform1f(binary.nanLoc, NaN);
      }
      inputs.forEach((input2, i) => {
        const varName = binary.program.variableNames[i];
        const varLoc = binary.uniformLocations[varName];
        const varOffsetLoc = binary.uniformLocations[`offset${varName}`];
        if (varLoc == null) {
          return;
        }
        if (input2.isUniform) {
          if (sizeFromShape2(input2.shape) < 2) {
            gpgpu.gl.uniform1f(varLoc, input2.uniformValues[0]);
          } else {
            let vals = input2.uniformValues;
            if (!(vals instanceof Float32Array)) {
              vals = new Float32Array(vals);
            }
            gpgpu.gl.uniform1fv(varLoc, vals);
          }
          return;
        }
        if (input2.texData.slice != null && varOffsetLoc != null) {
          gpgpu.gl.uniform1i(varOffsetLoc, input2.texData.slice.flatOffset);
        }
        gpgpu.setInputMatrixTexture(input2.texData.texture, varLoc, i);
      });
      if (customSetup != null) {
        customSetup(gpgpu, binary.webGLProgram);
      }
      gpgpu.executeProgram();
    }
    function makeShaderKey(program, inputs, output) {
      let keyInputs = "";
      inputs.concat(output).forEach((x) => {
        const hasOffset = x.texData != null && x.texData.slice != null && x.texData.slice.flatOffset > 0;
        const texShape = x.isUniform ? "uniform" : x.texData.texShape;
        keyInputs += `${x.shape}_${texShape}_${hasOffset}`;
      });
      const keyUserCode = program.userCode;
      let key = program.constructor.name;
      key += "_" + keyInputs + "_" + keyUserCode;
      return key;
    }
    /**
     * @license
     * Copyright 2019 Google LLC. All Rights Reserved.
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     * http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     * =============================================================================
     */
    class Im2ColPackedProgram {
      constructor(outputShape, inputShape, convInfo) {
        this.variableNames = ["A"];
        this.packedInputs = true;
        this.packedOutput = true;
        this.outputShape = outputShape;
        const {filterWidth, inChannels, strideWidth, strideHeight, padInfo, outWidth, dilationWidth, dilationHeight, dataFormat} = convInfo;
        const {left, top} = padInfo;
        const itemsPerBlockRow = inChannels * filterWidth;
        const glsl = getGlslDifferences();
        const isChannelsLast = dataFormat === "channelsLast";
        const rowDim = isChannelsLast ? 0 : 1;
        const colDim = isChannelsLast ? 1 : 2;
        let unrolled = ``;
        for (let row = 0; row <= 1; row++) {
          for (let col = 0; col <= 1; col++) {
            unrolled += `
          blockIndex = rc.y + ${col};
          pos = rc.x + ${row};

          if(blockIndex < ${outputShape[1]} && pos < ${outputShape[0]}) {
            offsetY = int(blockIndex / (${outWidth})) * ${strideHeight} - ${top};
            d0 = offsetY + ${dilationHeight} * (pos / ${itemsPerBlockRow});

            if(d0 < ${inputShape[rowDim]} && d0 >= 0) {

              offsetX = int(mod(float(blockIndex), ${outWidth}.) * ${strideWidth}. - ${left}.);
              d1 = offsetX + ${dilationWidth} * (int(mod(float(pos), ${itemsPerBlockRow}.) / ${inChannels}.));

              if(d1 < ${inputShape[colDim]} && d1 >= 0) {

                ch = int(mod(float(pos), ${inChannels}.));

                if (${isChannelsLast}) {
                  innerDims = vec2(d1, ch);
                  result[${row * 2 + col}] = getChannel(
                    getA(d0, int(innerDims.x),
                    int(innerDims.y)), innerDims);
                } else {
                  innerDims = vec2(d0, d1);
                  result[${row * 2 + col}] = getChannel(
                    getA(ch, int(innerDims.x),
                    int(innerDims.y)), innerDims);
                }
              }
            }
          }
        `;
          }
        }
        this.userCode = `
      void main() {
        ivec2 rc = getOutputCoords();

        vec4 result = vec4(0);

        int blockIndex, pos, offsetY, d0, offsetX, d1, ch;
        vec2 innerDims;

        ${unrolled}

        ${glsl.output} = result;
      }
    `;
      }
    }
    /**
     * @license
     * Copyright 2017 Google LLC. All Rights Reserved.
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     * http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     * =============================================================================
     */
    class LRNProgram {
      constructor(xShape, radius, bias, alpha, beta) {
        this.variableNames = ["x"];
        this.outputShape = [];
        const rad = radius;
        const maxD = xShape[3] - 1;
        this.outputShape = xShape;
        let powOperator;
        const basis = `float(${bias}) + float(${alpha}) * sum`;
        if (beta === 0.5) {
          powOperator = `inversesqrt(${basis})`;
        } else if (beta === 1) {
          powOperator = `1.0/(${basis})`;
        } else {
          powOperator = `exp(log(${basis}) * float(-${beta}));`;
        }
        this.userCode = `
      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int r = coords[1];
        int c = coords[2];
        int d = coords[3];
        float x = getX(b, r, c, d);
        float sum = 0.0;
        for (int j = -${rad}; j <= ${rad}; j++) {
          int idx = d + j;
          if (idx >= 0 && idx <=  ${maxD}) {
            float z = getX(b, r, c, idx);
            sum += z * z;
          }
        }
        float val = x * ${powOperator};
        setOutput(val);
      }
    `;
      }
    }
    /**
     * @license
     * Copyright 2018 Google LLC. All Rights Reserved.
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     * http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     * =============================================================================
     */
    class LRNGradProgram {
      constructor(inputShape, depthRadius, bias, alpha, beta) {
        this.variableNames = ["inputImage", "outputImage", "dy"];
        this.outputShape = [];
        this.outputShape = inputShape;
        this.depth = inputShape[3];
        this.depthRadius = depthRadius;
        this.bias = bias;
        this.alpha = alpha;
        this.beta = beta;
        this.userCode = `
      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int r = coords[1];
        int c = coords[2];

        float result = 0.0;
        for (int d = 0; d < ${this.depth}; ++d) {
          int depthBegin = int(max(0.0, float(d - ${depthRadius})));
          int depthEnd = int(min(float(${this.depth}),
              float(d + ${depthRadius} + 1)));

          const int MIN_DEPTH_BEGIN = 0;
          const int MAX_DEPTH_END = ${this.depth};

          float norm = 0.0;
          for (int k = MIN_DEPTH_BEGIN; k < MAX_DEPTH_END; ++k) {
            if (k < depthBegin){
              continue;
            }
            else if (k >= depthBegin && k < depthEnd) {
              norm += getInputImage(b, r, c, k) * getInputImage(b, r, c, k);
            }
            else {
              break;
            }
          }

          norm = float(${alpha}) * norm + float(${bias});

          for(int k = MIN_DEPTH_BEGIN; k < MAX_DEPTH_END; ++k){
            if (k < depthBegin){
              continue;
            }
            else if (k >= depthBegin && k < depthEnd){
              float dyi = -2.0 * float(${alpha})
                * float(${beta})
                * getInputImage(b ,r ,c, k) * getOutputImage(b, r, c, d)
                / norm;
              if (k == d) {
                dyi += pow(norm, -1.0 * ${beta});
              }
              if (k == coords[3]) {
                dyi *= getDy(b, r, c, d);
                result += dyi;
              }
            }
            else {
              break;
            }
          }
      }
      setOutput(result);
      }
    `;
      }
    }
    /**
     * @license
     * Copyright 2019 Google LLC. All Rights Reserved.
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     * http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     * =============================================================================
     */
    class LRNPackedProgram {
      constructor(xShape, radius, bias, alpha, beta) {
        this.variableNames = ["x"];
        this.outputShape = [];
        this.packedInputs = true;
        this.packedOutput = true;
        const rad = radius;
        const maxD = xShape[3] - 1;
        this.outputShape = xShape;
        let powOperator;
        const basis = `float(${bias}) + float(${alpha}) * sum`;
        if (beta === 0.5) {
          powOperator = `inversesqrt(${basis})`;
        } else if (beta === 1) {
          powOperator = `1.0/(${basis})`;
        } else {
          powOperator = `exp(log(${basis}) * float(-${beta}));`;
        }
        this.userCode = `
      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords.x;
        int r = coords.y;
        int c = coords.z;
        int d = coords.w;

        bool hasNextCol = d < ${this.outputShape[3]};
        bool hasNextRow = c < ${this.outputShape[2]};

        vec4 sum = vec4(0.);
        vec4 xFragAtOutputCoords = getX(b, r, c, d);

        vec4 xAtOutputCoords = vec4(
          getChannel(xFragAtOutputCoords, vec2(c, d)),
          hasNextCol ?
            getChannel(xFragAtOutputCoords, vec2(c, d + 1)) : 0.0,
          hasNextRow ?
            getChannel(xFragAtOutputCoords , vec2(c + 1, d)) : 0.0,
          (hasNextRow && hasNextCol) ?
            getChannel(xFragAtOutputCoords, vec2(c + 1, d + 1)) : 0.0
        );

        int firstChannel = d - ${rad};
        vec2 cache = vec2(0.);
        if(firstChannel >= 0){
          vec4 firstChannelFrag = getX(b, r, c, firstChannel);
          cache.x = getChannel(firstChannelFrag, vec2(c, firstChannel));
            if(hasNextRow){
              cache.y = getChannel(firstChannelFrag, vec2(c + 1, firstChannel));
            }
        }

        ivec2 depth = ivec2(d, d + 1);
        for (int j = - ${rad}; j <= ${rad}; j++) {
          ivec2 idx = depth + j;
          bvec2 aboveLowerBound = greaterThanEqual(idx, ivec2(0));
          bvec2 belowUpperBound = lessThanEqual(idx, ivec2(${maxD}));

          bool depthInRange = aboveLowerBound.x && belowUpperBound.x;
          bool depthPlusOneInRange = aboveLowerBound.y && belowUpperBound.y;

          if(depthInRange || depthPlusOneInRange){
            vec4 z = vec4(0.);
            vec4 xFragAtCurrentDepth;
            z.xz = cache.xy;
            if(depthPlusOneInRange && hasNextCol){
              xFragAtCurrentDepth = idx.y != d ?
                getX(b, r, c, idx.y) : xFragAtOutputCoords;
              z.y = getChannel(xFragAtCurrentDepth, vec2(c, idx.y));
              if(hasNextRow){
                z.w = getChannel(xFragAtCurrentDepth, vec2(c + 1, idx.y));
              }
            }
            cache.xy = z.yw;
            sum += z * z;
          }
        }
        vec4 result = xAtOutputCoords * ${powOperator};
        setOutput(result);
      }
    `;
      }
    }
    /**
     * @license
     * Copyright 2017 Google LLC. All Rights Reserved.
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     * http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     * =============================================================================
     */
    class MaxPool2DBackpropProgram {
      constructor(convInfo) {
        this.variableNames = ["dy", "maxPos"];
        this.outputShape = convInfo.inShape;
        const strideHeight = convInfo.strideHeight;
        const strideWidth = convInfo.strideWidth;
        const dilationHeight = convInfo.dilationHeight;
        const effectiveFilterHeight = convInfo.effectiveFilterHeight;
        const effectiveFilterWidth = convInfo.effectiveFilterWidth;
        const padTop = effectiveFilterHeight - 1 - convInfo.padInfo.top;
        const padLeft = effectiveFilterWidth - 1 - convInfo.padInfo.left;
        const lastIndex = effectiveFilterHeight * effectiveFilterWidth - 1;
        this.userCode = `
      const ivec2 pads = ivec2(${padTop}, ${padLeft});

      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];

        ivec2 dyRCCorner = coords.yz - pads;
        int dyRCorner = dyRCCorner.x;
        int dyCCorner = dyRCCorner.y;

        // Convolve dy(?, ?, d) with pos mask(:, :, d) to get dx(xR, xC, d).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;
        for (int wR = 0; wR < ${effectiveFilterHeight};
          wR += ${dilationHeight}) {
          float dyR = float(dyRCorner + wR) / ${strideHeight}.0;

          if (dyR < 0.0 || dyR >= ${convInfo.outHeight}.0 || fract(dyR) > 0.0) {
            continue;
          }
          int idyR = int(dyR);

          for (int wC = 0; wC < ${effectiveFilterWidth}; wC++) {
            float dyC = float(dyCCorner + wC) / ${strideWidth}.0;

            if (dyC < 0.0 || dyC >= ${convInfo.outWidth}.0 ||
                fract(dyC) > 0.0) {
              continue;
            }
            int idyC = int(dyC);

            float dyValue = getDy(b, idyR, idyC, d);
            int maxPosValue = ${lastIndex} - int(getMaxPos(b, idyR, idyC, d));

            // Get the current value, check it against the value from the
            // position matrix.
            int curPosValue = wR * ${effectiveFilterWidth} + wC;
            float mask = float(maxPosValue == curPosValue ? 1.0 : 0.0);

            dotProd += dyValue * mask;
          }
        }
        setOutput(dotProd);
      }
    `;
      }
    }
    class MaxPool3DBackpropProgram {
      constructor(convInfo) {
        this.variableNames = ["dy", "maxPos"];
        this.outputShape = convInfo.inShape;
        const strideDepth = convInfo.strideDepth;
        const strideHeight = convInfo.strideHeight;
        const strideWidth = convInfo.strideWidth;
        const dilationDepth = convInfo.dilationDepth;
        const dilationHeight = convInfo.dilationHeight;
        const dilationWidth = convInfo.dilationWidth;
        const effectiveFilterDepth = convInfo.effectiveFilterDepth;
        const effectiveFilterHeight = convInfo.effectiveFilterHeight;
        const effectiveFilterWidth = convInfo.effectiveFilterWidth;
        const padFront = effectiveFilterDepth - 1 - convInfo.padInfo.front;
        const padTop = effectiveFilterHeight - 1 - convInfo.padInfo.top;
        const padLeft = effectiveFilterWidth - 1 - convInfo.padInfo.left;
        const lastIndex = effectiveFilterDepth * effectiveFilterHeight * effectiveFilterWidth - 1;
        this.userCode = `
      const ivec3 pads = ivec3(${padFront}, ${padTop}, ${padLeft});

      void main() {
        ivec5 coords = getOutputCoords();
        int batch = coords.x;
        int ch = coords.u;

        ivec3 dyCorner = ivec3(coords.y, coords.z, coords.w) - pads;
        int dyDCorner = dyCorner.x;
        int dyRCorner = dyCorner.y;
        int dyCCorner = dyCorner.z;

        // Convolve dy(?, ?, ?, ch) with pos mask(:, :, :, d) to get
        // dx(xD, xR, xC, ch).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;

        for (int wD = 0; wD < ${effectiveFilterDepth};
           wD += ${dilationDepth}) {
          float dyD = float(dyDCorner + wD) / ${strideDepth}.0;

          if (dyD < 0.0 || dyD >= ${convInfo.outDepth}.0 || fract(dyD) > 0.0) {
            continue;
          }
          int idyD = int(dyD);

          for (int wR = 0; wR < ${effectiveFilterHeight};
              wR += ${dilationHeight}) {
            float dyR = float(dyRCorner + wR) / ${strideHeight}.0;

            if (dyR < 0.0 || dyR >= ${convInfo.outHeight}.0 ||
                fract(dyR) > 0.0) {
              continue;
            }
            int idyR = int(dyR);

            for (int wC = 0; wC < ${effectiveFilterWidth};
                wC += ${dilationWidth}) {
              float dyC = float(dyCCorner + wC) / ${strideWidth}.0;

              if (dyC < 0.0 || dyC >= ${convInfo.outWidth}.0 ||
                  fract(dyC) > 0.0) {
                continue;
              }
              int idyC = int(dyC);

              float dyValue = getDy(batch, idyD, idyR, idyC, ch);
              int maxPosValue = ${lastIndex} -
                  int(getMaxPos(batch, idyD, idyR, idyC, ch));

              // Get the current value, check it against the value from the
              // position matrix.
              int curPosValue =
                  wD * ${effectiveFilterHeight} * ${effectiveFilterWidth} +
                  wR * ${effectiveFilterWidth} + wC;
              float mask = float(maxPosValue == curPosValue ? 1.0 : 0.0);

              dotProd += dyValue * mask;
            }
          }
        }
        setOutput(dotProd);
      }
    `;
      }
    }
    /**
     * @license
     * Copyright 2018 Google LLC. All Rights Reserved.
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     * http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     * =============================================================================
     */
    class MatMulPackedProgram {
      constructor(aShape, bShape, outputShape, transposeA = false, transposeB = false, addBias = false, activation2 = null, hasPreluActivation = false) {
        this.variableNames = ["matrixA", "matrixB"];
        this.packedInputs = true;
        this.packedOutput = true;
        this.outputShape = outputShape;
        const sharedDim = transposeA ? aShape[1] : aShape[2];
        const sharedDimensionPacked = Math.ceil(sharedDim / 2);
        const aSample = transposeA ? "i * 2, rc.y" : "rc.y, i * 2";
        const bSample = transposeB ? "rc.z, i * 2" : "i * 2, rc.z";
        const aSwizzle = transposeA ? ["a.xxyy", "a.zzww"] : ["a.xxzz", "a.yyww"];
        const bSwizzle = transposeB ? ["b.xzxz", "b.ywyw"] : ["b.xyxy", "b.zwzw"];
        let activationSnippet = "", applyActivationSnippet = "";
        if (activation2) {
          if (hasPreluActivation) {
            activationSnippet = `vec4 activation(vec4 a) {
          vec4 b = getPreluActivationWeightsAtOutCoords();
          ${activation2}
        }`;
          } else {
            activationSnippet = `vec4 activation(vec4 x) {
          ${activation2}
        }`;
          }
          applyActivationSnippet = `result = activation(result);`;
        }
        const addBiasSnippet = addBias ? "result += getBiasAtOutCoords();" : "";
        if (addBias) {
          this.variableNames.push("bias");
        }
        if (hasPreluActivation) {
          this.variableNames.push("preluActivationWeights");
        }
        let batchASnippet = "rc.x";
        let batchBSnippet = "rc.x";
        if (aShape[0] < bShape[0]) {
          batchASnippet = `int(min(float(rc.x), ${aShape[0] - 1}.))`;
        } else if (bShape[0] < aShape[0]) {
          batchBSnippet = `int(min(float(rc.x), ${bShape[0] - 1}.))`;
        }
        this.userCode = `
      ${activationSnippet}

      const float sharedDimension = ${sharedDimensionPacked}.0;

      vec4 dot2x2ARowBCol(ivec3 rc) {
        vec4 result = vec4(0);
        for (int i = 0; i < ${sharedDimensionPacked}; i++) {
          int batchA = ${batchASnippet};
          int batchB = ${batchBSnippet};
          vec4 a = getMatrixA(batchA, ${aSample});
          vec4 b = getMatrixB(batchB, ${bSample});

          // These swizzled products need to be separately added.
          // See: https://github.com/tensorflow/tfjs/issues/1735
          result += (${aSwizzle[0]} * ${bSwizzle[0]});
          result += (${aSwizzle[1]} * ${bSwizzle[1]});
        }
        return result;
      }

      void main() {
        ivec3 rc = getOutputCoords();
        vec4 result = dot2x2ARowBCol(rc);

        ${addBiasSnippet}

        ${applyActivationSnippet}

        setOutput(result);
      }
    `;
      }
    }
    /**
     * @license
     * Copyright 2017 Google LLC. All Rights Reserved.
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     * http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     * =============================================================================
     */
    class MultinomialProgram {
      constructor(batchSize, numOutcomes, numSamples) {
        this.variableNames = ["probs"];
        this.outputShape = [batchSize, numSamples];
        this.userCode = `
      uniform float seed;

      void main() {
        ivec2 coords = getOutputCoords();
        int batch = coords[0];

        float r = random(seed);
        float cdf = 0.0;

        for (int i = 0; i < ${numOutcomes - 1}; i++) {
          cdf += getProbs(batch, i);

          if (r < cdf) {
            setOutput(float(i));
            return;
          }
        }

        // If no other event happened, last event happened.
        setOutput(float(${numOutcomes - 1}));
      }
    `;
      }
      getCustomSetupFunc(seed) {
        return (gpgpu, webGLProgram) => {
          if (this.seedLoc == null) {
            this.seedLoc = gpgpu.getUniformLocation(webGLProgram, "seed");
          }
          gpgpu.gl.uniform1f(this.seedLoc, seed);
        };
      }
    }
    /**
     * @license
     * Copyright 2017 Google LLC. All Rights Reserved.
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     * http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     * =============================================================================
     */
    class OneHotProgram {
      constructor(numIndices, depth, onValue, offValue) {
        this.variableNames = ["indices"];
        this.outputShape = [numIndices, depth];
        this.userCode = `
      void main() {
        ivec2 coords = getOutputCoords();
        int index = round(getIndices(coords.x));
        setOutput(mix(float(${offValue}), float(${onValue}),
                      float(index == coords.y)));
      }
    `;
      }
    }
    /**
     * @license
     * Copyright 2018 Google LLC. All Rights Reserved.
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     * http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     * =============================================================================
     */
    class PackProgram {
      constructor(outputShape) {
        this.variableNames = ["A"];
        this.packedInputs = false;
        this.packedOutput = true;
        this.outputShape = outputShape;
        const rank = outputShape.length;
        if (rank === 0) {
          this.userCode = `
        void main() {
          setOutput(vec4(getA(), 0., 0., 0.));
        }
      `;
        } else {
          const channels = getChannels("rc", rank);
          const dtype = getCoordsDataType(rank);
          const outOfBoundsCondition = getOutOfBoundsCondition(rank, outputShape, channels);
          const setup38 = getSetup(rank, outputShape[outputShape.length - 1], outputShape[outputShape.length - 2], channels);
          const output = getOutput(outputShape, channels);
          this.userCode = `
        void main() {
          ${dtype} rc = getOutputCoords();

          if(${outOfBoundsCondition}) {
            setOutput(vec4(0));
          } else {
            ${setup38}

            setOutput(vec4(${output}));
          }
        }
      `;
        }
      }
    }
    function getSourceCoordsArr(rank, dims) {
      const coords2 = [];
      for (let row = 0; row <= 1; row++) {
        for (let col = 0; col <= 1; col++) {
          let coord = `${row === 0 ? "r" : "rp1"}, ${col === 0 ? "c" : "cp1"}`;
          for (let d = 2; d < rank; d++) {
            coord = `${dims[dims.length - 1 - d]},` + coord;
          }
          coords2.push(coord);
        }
      }
      return coords2;
    }
    function getOutOfBoundsCondition(rank, shape, dims) {
      if (rank === 1) {
        return `rc > ${shape[0]}`;
      }
      let cond = "";
      for (let i = rank - 2; i < rank; i++) {
        cond += `${dims[i]} >= ${shape[i]}`;
        if (i < rank - 1) {
          cond += "||";
        }
      }
      return cond;
    }
    function getSetup(rank, cols, rows, dims) {
      if (rank === 1) {
        return "";
      }
      const innerDims = dims.slice(-2);
      return `
    int r = ${innerDims[0]};
    int c = ${innerDims[1]};
    int rp1 = r + 1;
    int cp1 = c + 1;

    bool cEdge = cp1 >= ${cols};
    bool rEdge = rp1 >= ${rows};
  `;
    }
    function getOutput(shape, dims) {
      const rank = shape.length;
      const sourceCoords = getSourceCoordsArr(rank, dims);
      if (rank === 1) {
        return `getA(rc),
            rc + 1 >= ${shape[0]} ? 0. : getA(rc + 1),
            0, 0`;
      }
      return `getA(${sourceCoords[0]}),
          cEdge ? 0. : getA(${sourceCoords[1]}),
          rEdge ? 0. : getA(${sourceCoords[2]}),
          rEdge || cEdge ? 0. : getA(${sourceCoords[3]})`;
    }
    /**
     * @license
     * Copyright 2017 Google LLC. All Rights Reserved.
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     * http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     * =============================================================================
     */
    class PadProgram {
      constructor(xShape, paddings, constantValue) {
        this.variableNames = ["x"];
        this.outputShape = paddings.map((p2, i) => p2[0] + xShape[i] + p2[1]);
        const rank = xShape.length;
        const type = getCoordsDataType(rank);
        const start = paddings.map((p2) => p2[0]).join(",");
        const end = paddings.map((p2, i) => p2[0] + xShape[i]).join(",");
        const unpackedCoords = ["coords[0]", "coords[1]", "coords[2]", "coords[3]"].slice(0, rank);
        if (rank === 1) {
          this.userCode = `
        int start = ${start};
        int end = ${end};

        void main() {
          int outC = getOutputCoords();
          if (outC < start || outC >= end) {
            setOutput(float(${constantValue}));
          } else {
            setOutput(getX(outC - start));
          }
        }
      `;
          return;
        }
        this.userCode = `
      ${type} start = ${type}(${start});
      ${type} end = ${type}(${end});

      void main() {
        ${type} outC = getOutputCoords();
        if (any(lessThan(outC, start)) || any(greaterThanEqual(outC, end))) {
          setOutput(float(${constantValue}));
        } else {
          ${type} coords = outC - start;
          setOutput(getX(${unpackedCoords}));
        }
      }
    `;
      }
    }
    /**
     * @license
     * Copyright 2019 Google LLC. All Rights Reserved.
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     * http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     * =============================================================================
     */
    class PadPackedProgram {
      constructor(xShape, paddings, constantValue) {
        this.variableNames = ["x"];
        this.packedInputs = true;
        this.packedOutput = true;
        this.outputShape = paddings.map((p2, i) => p2[0] + xShape[i] + p2[1]);
        const rank = xShape.length;
        const dtype = getCoordsDataType(rank);
        const start = paddings.map((p2) => p2[0]).join(",");
        const end = paddings.map((p2, i) => p2[0] + xShape[i]).join(",");
        const coords2 = getChannels("rc", rank);
        const source = getChannels("source", rank);
        const cLimit = `${coords2[rank - 1]} < ${this.outputShape[rank - 1]}`;
        const innerDims = rank === 1 ? "source" : `vec2(${source.slice(-2).join()})`;
        const componentSetup = [
          `${dtype} rc = outputLoc;`,
          `${coords2[rank - 1]} += 1;
       if(${cLimit}) {
      `,
          rank === 1 ? "" : `}
       rc = outputLoc;
       ${coords2[rank - 2]} += 1;
       if(${coords2[rank - 2]} < ${this.outputShape[rank - 2]}) {`,
          rank === 1 ? "" : `  ${coords2[rank - 1]} += 1;
         if(${cLimit}) {`
        ];
        const paddingArea = rank === 1 ? "rc < start || rc >= end" : "any(lessThan(rc, start)) || any(greaterThanEqual(rc, end))";
        let mainLoop = "";
        for (let i = 0, j = rank === 1 ? 2 : 4; i < j; i++) {
          mainLoop += `
        ${componentSetup[i]}
        if (${paddingArea}) {
          result[${i}] = float(${constantValue});
        } else {
          ${dtype} source = rc - start;
          result[${i}] = getChannel(getX(${source.join()}), ${innerDims});
        }
      `;
        }
        mainLoop += rank === 1 ? `} ` : `}}`;
        this.userCode = `
      const ${dtype} start = ${dtype}(${start});
      const ${dtype} end = ${dtype}(${end});

      void main() {
        ${dtype} outputLoc = getOutputCoords();
        vec4 result = vec4(0.);
        ${mainLoop}
        setOutput(result);
      }
    `;
      }
    }
    /**
     * @license
     * Copyright 2017 Google LLC. All Rights Reserved.
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     * http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     * =============================================================================
     */
    class Pool2DProgram {
      constructor(convInfo, poolType, computePositions, flattenPositions = false, includeBatchInIndex = false) {
        this.variableNames = ["x"];
        if (poolType === "avg" && computePositions) {
          throw new Error("Cannot compute positions for average pool.");
        }
        const filterWidth = convInfo.filterWidth;
        const strideHeight = convInfo.strideHeight;
        const strideWidth = convInfo.strideWidth;
        const dilationHeight = convInfo.dilationHeight;
        const dilationWidth = convInfo.dilationWidth;
        const effectiveFilterHeight = convInfo.effectiveFilterHeight;
        const effectiveFilterWidth = convInfo.effectiveFilterWidth;
        const padTop = convInfo.padInfo.top;
        const padLeft = convInfo.padInfo.left;
        this.outputShape = convInfo.outShape;
        const isAvgPool = poolType === "avg";
        const batchFlattenPositionStr = `((batch  * ${convInfo.inHeight} + xR) * ${convInfo.inWidth} + xC) * ${convInfo.inChannels} + d`;
        const flattenPositionStr = `(xR * ${convInfo.inWidth} + xC) * ${convInfo.inChannels} + d`;
        let initializationValue = "0.0";
        if (!isAvgPool) {
          initializationValue = "-1.0 / 1e-20";
        }
        if (computePositions) {
          const compareOp2 = ">=";
          this.userCode = `
        const ivec2 strides = ivec2(${strideHeight}, ${strideWidth});
        const ivec2 pads = ivec2(${padTop}, ${padLeft});

        void main() {
          ivec4 coords = getOutputCoords();
          int batch = coords[0];
          int d = coords[3];

          ivec2 xRCCorner = coords.yz * strides - pads;
          int xRCorner = xRCCorner.x;
          int xCCorner = xRCCorner.y;

          // max/min x(?, ?, d) to get y(yR, yC, d).
          // ? = to be determined
          float minMaxValue = 0.0;
          float minMaxValueFound = 0.0;
          int minMaxPosition = 0;
          float avgValue = 0.0;

          for (int wR = 0; wR < ${effectiveFilterHeight};
              wR += ${dilationHeight}) {
            int xR = xRCorner + wR;

            if (xR < 0 || xR >= ${convInfo.inHeight}) {
              continue;
            }

            for (int wC = 0; wC < ${effectiveFilterWidth};
                wC += ${dilationWidth}) {
              int xC = xCCorner + wC;

              if (xC < 0 || xC >= ${convInfo.inWidth}) {
                continue;
              }

              float value = getX(batch, xR, xC, d);

              // If a min / max value has already been found, use it. If not,
              // use the current value.
              float currMinMaxValue = mix(
                  value, minMaxValue, minMaxValueFound);
              if (value ${compareOp2} currMinMaxValue) {
                minMaxValue = value;
                minMaxValueFound = 1.0;
                minMaxPosition = ${flattenPositions ? includeBatchInIndex ? batchFlattenPositionStr : flattenPositionStr : `wR * ${effectiveFilterWidth} + wC`};
              }
            }
          }
          setOutput(float(minMaxPosition));
        }
      `;
          return;
        }
        const compareOp = "max";
        let returnValue = `${poolType}(${poolType}(${poolType}(minMaxValue[0], minMaxValue[1]), minMaxValue[2]), minMaxValue[3])`;
        if (poolType === "avg") {
          returnValue = `avgValue / count`;
        }
        const filterWidthNearestVec4 = Math.floor(filterWidth / 4) * 4;
        const filterWidthVec4Remainder = filterWidth % 4;
        const updateSnippet = `
      if (${isAvgPool}) {
        avgValue += dot(values, ones);
      } else {
        minMaxValue = ${compareOp}(values, minMaxValue);
      }
    `;
        this.userCode = `
      const ivec2 strides = ivec2(${strideHeight}, ${strideWidth});
      const ivec2 pads = ivec2(${padTop}, ${padLeft});
      const float initializationValue = ${initializationValue};
      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);

      float count = 0.0;

      float getValue(int batch, int xR, int xC, int d) {
        if (xC < 0 || xC >= ${convInfo.inWidth}) {
          return initializationValue;
        }
        count += 1.0;
        return getX(batch, xR, xC, d);
      }

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords[0];
        int d = coords[3];

        ivec2 xRCCorner = coords.yz * strides - pads;
        int xRCorner = xRCCorner.x;
        int xCCorner = xRCCorner.y;

        // max/min x(?, ?, d) to get y(yR, yC, d).
        // ? = to be determined
        vec4 minMaxValue = vec4(${initializationValue});
        float avgValue = 0.0;
        count = 0.0;

        for (int wR = 0; wR < ${effectiveFilterHeight};
            wR += ${dilationHeight}) {
          int xR = xRCorner + wR;

          if (xR < 0 || xR >= ${convInfo.inHeight}) {
            continue;
          }

          for (int wC = 0; wC < ${filterWidthNearestVec4}; wC += 4) {
            int xC = xCCorner + wC * ${dilationWidth};

            vec4 values = vec4(
              getValue(batch, xR, xC, d),
              getValue(batch, xR, xC + ${dilationWidth}, d),
              getValue(batch, xR, xC + 2 * ${dilationWidth}, d),
              getValue(batch, xR, xC + 3 * ${dilationWidth}, d)
            );

            ${updateSnippet}
          }

          int xC = xCCorner + ${filterWidthNearestVec4};
          if (${filterWidthVec4Remainder === 1}) {
            vec4 values = vec4(
              getValue(batch, xR, xC, d),
              initializationValue,
              initializationValue,
              initializationValue
            );

            ${updateSnippet}
          } else if (${filterWidthVec4Remainder === 2}) {
            vec4 values = vec4(
              getValue(batch, xR, xC, d),
              getValue(batch, xR, xC + ${dilationWidth}, d),
              initializationValue,
              initializationValue
            );

            ${updateSnippet}
          } else if (${filterWidthVec4Remainder === 3}) {
            vec4 values = vec4(
              getValue(batch, xR, xC, d),
              getValue(batch, xR, xC + ${dilationWidth}, d),
              getValue(batch, xR, xC + 2 * ${dilationWidth}, d),
              initializationValue
            );

            ${updateSnippet}
          }
        }
        setOutput(${returnValue});
      }
    `;
      }
    }
    class Pool3DProgram {
      constructor(convInfo, poolType, computePositions, flattenPositions = false, includeBatchInIndex = false) {
        this.variableNames = ["x"];
        if (poolType === "avg" && computePositions) {
          throw new Error("Cannot compute positions for average pool.");
        }
        const filterWidth = convInfo.filterWidth;
        const strideDepth = convInfo.strideDepth;
        const strideHeight = convInfo.strideHeight;
        const strideWidth = convInfo.strideWidth;
        const dilationDepth = convInfo.dilationDepth;
        const dilationHeight = convInfo.dilationHeight;
        const dilationWidth = convInfo.dilationWidth;
        const effectiveFilterDepth = convInfo.effectiveFilterDepth;
        const effectiveFilterHeight = convInfo.effectiveFilterHeight;
        const effectiveFilterWidth = convInfo.effectiveFilterWidth;
        const padFront = convInfo.padInfo.front;
        const padTop = convInfo.padInfo.top;
        const padLeft = convInfo.padInfo.left;
        this.outputShape = convInfo.outShape;
        const isAvgPool = poolType === "avg";
        let initializationValue = "0.0";
        if (!isAvgPool) {
          initializationValue = "-1.0 / 1e-20";
        }
        if (computePositions) {
          const compareOp2 = ">=";
          this.userCode = `
        const ivec3 strides =
            ivec3(${strideDepth}, ${strideHeight}, ${strideWidth});
        const ivec3 pads = ivec3(${padFront}, ${padTop}, ${padLeft});

        void main() {
          ivec5 coords = getOutputCoords();
          int batch = coords.x;
          int ch = coords.u;

          ivec3 xCorner = ivec3(coords.y, coords.z, coords.w) * strides - pads;
          int xDCorner = xCorner.x;
          int xRCorner = xCorner.y;
          int xCCorner = xCorner.z;

          // max/min x(?, ?, ?, ch) to get y(yD, yR, yC, ch).
          // ? = to be determined
          float minMaxValue = 0.0;
          float minMaxValueFound = 0.0;
          int minMaxPosition = 0;

          for (int wD = 0; wD < ${effectiveFilterDepth};
              wD += ${dilationDepth}) {
            int xD = xDCorner + wD;

            if (xD < 0 || xD >= ${convInfo.inDepth}) {
              continue;
            }

            for (int wR = 0; wR < ${effectiveFilterHeight};
                wR += ${dilationHeight}) {
              int xR = xRCorner + wR;

              if (xR < 0 || xR >= ${convInfo.inHeight}) {
                continue;
              }

              for (int wC = 0; wC < ${effectiveFilterWidth};
                  wC += ${dilationWidth}) {
                int xC = xCCorner + wC;

                if (xC < 0 || xC >= ${convInfo.inWidth}) {
                  continue;
                }

                float value = getX(batch, xD, xR, xC, ch);

                // If a min / max value has already been found, use it. If not,
                // use the current value.
                float currMinMaxValue = mix(
                    value, minMaxValue, minMaxValueFound);
                if (value ${compareOp2} currMinMaxValue) {
                  minMaxValue = value;
                  minMaxValueFound = 1.0;
                  minMaxPosition = ${flattenPositions ? includeBatchInIndex ? `(((batch * ${convInfo.inDepth} + xD) * ${convInfo.inHeight} + xR) * ${convInfo.inWidth} + xC) * ${convInfo.inChannels} + ch` : `((xD * ${convInfo.inHeight} + xR) * ${convInfo.inWidth} + xC) * ${convInfo.inChannels} + ch` : `wD * ${effectiveFilterHeight} * ${effectiveFilterWidth} +
                      wR * ${effectiveFilterWidth} + wC`};
                }
              }
            }
          }
          setOutput(float(minMaxPosition));
        }
      `;
          return;
        }
        const compareOp = "max";
        let returnValue = `${poolType}(${poolType}(${poolType}(minMaxValue[0], minMaxValue[1]), minMaxValue[2]), minMaxValue[3])`;
        if (poolType === "avg") {
          returnValue = `avgValue / count`;
        }
        const filterWidthNearestVec4 = Math.floor(filterWidth / 4) * 4;
        const filterWidthVec4Remainder = filterWidth % 4;
        const updateSnippet = `
      if (${isAvgPool}) {
        avgValue += dot(values, ones);
      } else {
        minMaxValue = ${compareOp}(values, minMaxValue);
      }
    `;
        this.userCode = `
      const ivec3 strides =
        ivec3(${strideDepth}, ${strideHeight}, ${strideWidth});
      const ivec3 pads = ivec3(${padFront}, ${padTop}, ${padLeft});
      const float initializationValue = ${initializationValue};
      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);

      float count = 0.0;

      float getValue(int batch, int xD, int xR, int xC, int ch) {
        if (xC < 0 || xC >= ${convInfo.inWidth}) {
          return initializationValue;
        }
        count += 1.0;
        return getX(batch, xD, xR, xC, ch);
      }

      void main() {
        ivec5 coords = getOutputCoords();
        int batch = coords.x;
        int ch = coords.u;

        ivec3 xCorner = ivec3(coords.y, coords.z, coords.w) * strides - pads;
        int xDCorner = xCorner.x;
        int xRCorner = xCorner.y;
        int xCCorner = xCorner.z;

        // max/min x(?, ?, ?, d) to get y(yD, yR, yC, ch).
        // ? = to be determined
        vec4 minMaxValue = vec4(${initializationValue});
        float avgValue = 0.0;
        count = 0.0;

        for (int wD = 0; wD < ${effectiveFilterDepth};
            wD += ${dilationDepth}) {
          int xD = xDCorner + wD;

          if (xD < 0 || xD >= ${convInfo.inDepth}) {
            continue;
          }

          for (int wR = 0; wR < ${effectiveFilterHeight};
            wR += ${dilationHeight}) {
            int xR = xRCorner + wR;

            if (xR < 0 || xR >= ${convInfo.inHeight}) {
              continue;
            }

            for (int wC = 0; wC < ${filterWidthNearestVec4}; wC += 4) {
              int xC = xCCorner + wC * ${dilationWidth};

              vec4 values = vec4(
                getValue(batch, xD, xR, xC, ch),
                getValue(batch, xD, xR, xC + ${dilationWidth}, ch),
                getValue(batch, xD, xR, xC + 2 * ${dilationWidth}, ch),
                getValue(batch, xD, xR, xC + 3 * ${dilationWidth}, ch)
              );

              ${updateSnippet}
            }

            int xC = xCCorner + ${filterWidthNearestVec4};
            if (${filterWidthVec4Remainder === 1}) {
              vec4 values = vec4(
                getValue(batch, xD, xR, xC, ch),
                initializationValue,
                initializationValue,
                initializationValue
              );

              ${updateSnippet}
            } else if (${filterWidthVec4Remainder === 2}) {
              vec4 values = vec4(
                getValue(batch, xD, xR, xC, ch),
                getValue(batch, xD, xR, xC + ${dilationWidth}, ch),
                initializationValue,
                initializationValue
              );

              ${updateSnippet}
            } else if (${filterWidthVec4Remainder === 3}) {
              vec4 values = vec4(
                getValue(batch, xD, xR, xC, ch),
                getValue(batch, xD, xR, xC + ${dilationWidth}, ch),
                getValue(batch, xD, xR, xC + 2 * ${dilationWidth}, ch),
                initializationValue
              );

              ${updateSnippet}
            }
          }
          setOutput(${returnValue});
        }
      }
    `;
      }
    }
    /**
     * @license
     * Copyright 2017 Google LLC. All Rights Reserved.
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     * http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     * =============================================================================
     */
    class ReduceProgram {
      constructor(reduceInfo, reduceType) {
        this.variableNames = ["x"];
        const {windowSize, batchSize, inSize, outSize} = reduceInfo;
        this.outputShape = [batchSize, outSize];
        let initializationValue = "0.0";
        let compareOp = ``;
        if (reduceType === "prod") {
          initializationValue = "1.0";
        } else if (reduceType === "min") {
          initializationValue = "1.0 / 1e-20";
          compareOp = `min`;
        } else if (reduceType === "max") {
          initializationValue = "-1.0 / 1e-20";
          compareOp = `max`;
        }
        let returnValue = `${reduceType}(${reduceType}(${reduceType}(minMaxValue[0], minMaxValue[1]), minMaxValue[2]), minMaxValue[3])`;
        if (reduceType === "sum") {
          returnValue = `sumValue`;
        } else if (reduceType === "prod") {
          returnValue = `prodValue`;
        } else if (reduceType === "all") {
          returnValue = `allValue`;
        } else if (reduceType === "any") {
          returnValue = `anyValue`;
        }
        const windowSizeNearestVec4 = Math.floor(windowSize / 4) * 4;
        const windowSizeVec4Remainder = windowSize % 4;
        let updateSnippet = `
      if (${reduceType === "sum"}) {
        sumValue += dot(values, ones);
      } else if (${reduceType === "prod"}) {
        vec2 tmp = vec2(values[0], values[1]) * vec2(values[2], values[3]);
        prodValue *= tmp[0] * tmp[1];
      } else {
        minMaxValue = ${compareOp}(values, minMaxValue);
      }
    `;
        let vecType = `vec4`;
        if (reduceType === "all") {
          initializationValue = "1.0";
          updateSnippet = `
        bool reducedAllValue = all(values);
        float floatedReducedAllValue = float(reducedAllValue);
        allValue = float(allValue >= 1.0 && floatedReducedAllValue >= 1.0);
      `;
          vecType = `bvec4`;
        } else if (reduceType === "any") {
          initializationValue = "0.0";
          updateSnippet = `
        bool reducedAnyValue = any(values);
        float floatedReducedAnyValue = float(reducedAnyValue);
        anyValue = float(anyValue >= 1.0 || floatedReducedAnyValue >= 1.0);
      `;
          vecType = `bvec4`;
        }
        let checkOutOfBounds = "";
        if (inSize % windowSize > 0) {
          checkOutOfBounds = `
        if (inIdx < 0 || inIdx >= ${inSize}) {
          return initializationValue;
        }
      `;
        }
        this.userCode = `
      const float initializationValue = ${initializationValue};
      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);

      float getValue(int batch, int inIdx) {
        ${checkOutOfBounds}
        return getX(batch, inIdx);
      }

      void main() {
        ivec2 coords = getOutputCoords();
        int batch = coords[0];
        int outIdx = coords[1];
        int inOffset = outIdx * ${windowSize};

        vec4 minMaxValue = vec4(${initializationValue});
        float prodValue = 1.0;
        float sumValue = 0.0;
        float allValue = 1.0;
        float anyValue = 0.0;

        for (int i = 0; i < ${windowSizeNearestVec4}; i += 4) {
          int inIdx = inOffset + i;
          ${vecType} values = ${vecType}(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            getValue(batch, inIdx + 2),
            getValue(batch, inIdx + 3)
          );

          ${updateSnippet}
        }

        int inIdx = inOffset + ${windowSizeNearestVec4};
        if (${windowSizeVec4Remainder === 1}) {
          ${vecType} values = ${vecType}(
            getValue(batch, inIdx),
            initializationValue,
            initializationValue,
            initializationValue
          );

          ${updateSnippet}
        } else if (${windowSizeVec4Remainder === 2}) {
          ${vecType} values = ${vecType}(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            initializationValue,
            initializationValue
          );

          ${updateSnippet}
        } else if (${windowSizeVec4Remainder === 3}) {
          ${vecType} values = ${vecType}(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            getValue(batch, inIdx + 2),
            initializationValue
          );

          ${updateSnippet}
        }
        setOutput(${returnValue});
      }
    `;
      }
    }
    /**
     * @license
     * Copyright 2018 Google LLC. All Rights Reserved.
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     * http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     * =============================================================================
     */
    class ReshapePackedProgram {
      constructor(outputShape, inputShape) {
        this.variableNames = ["A"];
        this.packedInputs = true;
        this.packedOutput = true;
        this.outputShape = outputShape;
        let mainLoop = ``;
        for (let i = 0; i < 4; i++) {
          let thisRC = `thisRC = rc;`;
          if (i % 2 === 1) {
            thisRC += `thisRC.z += 1;`;
          }
          if (i > 1) {
            thisRC += `thisRC.y += 1;`;
          }
          mainLoop += `
        ${thisRC}
        ${i > 0 ? `if(thisRC.y < rows && thisRC.z < cols){` : ""}
          int flatIndex = getFlatIndex(thisRC);

          ivec3 inputRC = inputCoordsFromReshapedOutCoords(flatIndex);
          vec2 inputRCInnerDims = vec2(float(inputRC.y),float(inputRC.z));

          result[${i}] =
            getChannel(getA(inputRC.x, inputRC.y, inputRC.z), inputRCInnerDims);
        ${i > 0 ? "}" : ""}
      `;
        }
        this.userCode = `
      ${getReshapedInputCoords(inputShape)}
      ${getFlatIndexFrom3D(outputShape)}

      void main() {
        ivec3 rc = getOutputCoords();

        vec4 result = vec4(0.);

        ivec3 thisRC;
        int rows = ${outputShape[1]};
        int cols = ${outputShape[2]};

        ${mainLoop}

        setOutput(result);
      }
    `;
      }
    }
    function getReshapedInputCoords(shape) {
      const coordsFromIndexSnippet = getLogicalCoordinatesFromFlatIndex(["r", "c", "d"], shape);
      return `
    ivec3 inputCoordsFromReshapedOutCoords(int index) {
      ${coordsFromIndexSnippet}
      return ivec3(r, c, d);
    }
  `;
    }
    /**
     * @license
     * Copyright 2018 Google LLC. All Rights Reserved.
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     * http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     * =============================================================================
     */
    class ResizeBilinearBackpropProgram {
      constructor(dy, x, alignCorners) {
        this.variableNames = ["dy"];
        this.outputShape = [];
        this.outputShape = x.shape;
        const [, xHeight, xWidth] = x.shape;
        const [, yHeight, yWidth] = dy.shape;
        const effectiveXSize = [
          alignCorners && yHeight > 1 ? xHeight - 1 : xHeight,
          alignCorners && yWidth > 1 ? xWidth - 1 : xWidth
        ];
        const effectiveYSize = [
          alignCorners && yHeight > 1 ? yHeight - 1 : yHeight,
          alignCorners && yWidth > 1 ? yWidth - 1 : yWidth
        ];
        const heightScale = effectiveXSize[0] / effectiveYSize[0];
        const widthScale = effectiveXSize[1] / effectiveYSize[1];
        const invHeightScale = 1 / heightScale;
        const invWidthScale = 1 / widthScale;
        const winHeight = Math.ceil(invHeightScale) * 2 + 2;
        const winWidth = Math.ceil(invWidthScale) * 2 + 2;
        this.userCode = `
      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];
        int r = coords[1];
        int c = coords[2];

        float accumulator = 0.0;

        const float heightScale = float(${heightScale});
        const float widthScale = float(${widthScale});

        const float invHeightScale = float(${invHeightScale});
        const float invWidthScale = float(${invWidthScale});

        const int winHeight = int(${winHeight});
        const int winWidth = int(${winWidth});

        // Compute bounds for where in dy we will look
        float startRLerp = floor(float(r) * invHeightScale);
        int startDyR = int(startRLerp - float(winHeight / 2));

        float startCLerp = floor(float(c) * invWidthScale);
        int startDyC = int(startCLerp - float(winWidth / 2));

        // Loop over dy
        for (int dyROffset = 0; dyROffset < winHeight; dyROffset++) {
          int dyR = dyROffset + startDyR;

          // Guard against the window exceeding the bounds of dy
          if (dyR < 0 || dyR >= ${yHeight}) {
            continue;
          }

          for (int dyCOffset = 0; dyCOffset < winWidth; dyCOffset++) {
            int dyC = dyCOffset + startDyC;

            // Guard against the window exceeding the bounds of dy
            if (dyC < 0 || dyC >= ${yWidth}) {
              continue;
            }

            float dxR = float(dyR) * heightScale;
            int topDxRIndex = int(floor(dxR));
            int bottomDxRIndex = int(min(ceil(dxR), ${xHeight - 1}.0));
            float dxRLerp = dxR - float(topDxRIndex);
            float inverseDxRLerp = 1.0 - dxRLerp;

            float dxC = float(dyC) * widthScale;
            int leftDxCIndex = int(floor(dxC));
            int rightDxCIndex = int(min(ceil(dxC), ${xWidth - 1}.0));
            float dxCLerp = dxC - float(leftDxCIndex);
            float inverseDxCLerp = 1.0 - dxCLerp;

            if (r == topDxRIndex && c == leftDxCIndex) {
              // topLeft
              accumulator +=
                getDy(b, dyR, dyC, d) * inverseDxRLerp * inverseDxCLerp;
            }

            if (r == topDxRIndex && c == rightDxCIndex) {
              // topRight
              accumulator += getDy(b, dyR, dyC, d) * inverseDxRLerp * dxCLerp;
            }

            if (r == bottomDxRIndex && c == leftDxCIndex) {
              // bottomLeft
              accumulator += getDy(b, dyR, dyC, d) * dxRLerp * inverseDxCLerp;
            }

            if (r == bottomDxRIndex && c == rightDxCIndex) {
              // bottomRight
              accumulator += getDy(b, dyR, dyC, d) * dxRLerp * dxCLerp;
            }
          }
        }
        // End loop over dy

        setOutput(accumulator);
      }
    `;
      }
    }
    /**
     * @license
     * Copyright 2017 Google LLC. All Rights Reserved.
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     * http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     * =============================================================================
     */
    class ResizeBilinearProgram {
      constructor(inputShape, newHeight, newWidth, alignCorners) {
        this.variableNames = ["A"];
        this.outputShape = [];
        const [batch, oldHeight, oldWidth, depth] = inputShape;
        this.outputShape = [batch, newHeight, newWidth, depth];
        const effectiveInSize = [
          alignCorners && newHeight > 1 ? oldHeight - 1 : oldHeight,
          alignCorners && newWidth > 1 ? oldWidth - 1 : oldWidth
        ];
        const effectiveOutSize = [
          alignCorners && newHeight > 1 ? newHeight - 1 : newHeight,
          alignCorners && newWidth > 1 ? newWidth - 1 : newWidth
        ];
        this.userCode = `
      const vec2 effectiveInputOverOutputRatioRC = vec2(
          ${effectiveInSize[0] / effectiveOutSize[0]},
          ${effectiveInSize[1] / effectiveOutSize[1]});
      const vec2 inputShapeRC = vec2(${oldHeight}.0, ${oldWidth}.0);

      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];
        ivec2 yRC = coords.yz;

        // Fractional source index.
        vec2 sourceFracIndexRC = vec2(yRC) * effectiveInputOverOutputRatioRC;

        // Compute the four integer indices.
        ivec2 sourceFloorRC = ivec2(sourceFracIndexRC);
        ivec2 sourceCeilRC = ivec2(
          min(inputShapeRC - 1.0, ceil(sourceFracIndexRC)));

        float topLeft = getA(b, sourceFloorRC.x, sourceFloorRC.y, d);
        float bottomLeft = getA(b, sourceCeilRC.x, sourceFloorRC.y, d);
        float topRight = getA(b, sourceFloorRC.x, sourceCeilRC.y, d);
        float bottomRight = getA(b, sourceCeilRC.x, sourceCeilRC.y, d);

        vec2 fracRC = sourceFracIndexRC - vec2(sourceFloorRC);

        float top = topLeft + (topRight - topLeft) * fracRC.y;
        float bottom = bottomLeft + (bottomRight - bottomLeft) * fracRC.y;
        float newValue = top + (bottom - top) * fracRC.x;

        setOutput(newValue);
      }
    `;
      }
    }
    /**
     * @license
     * Copyright 2019 Google LLC. All Rights Reserved.
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     * http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     * =============================================================================
     */
    class ResizeBilinearPackedProgram {
      constructor(inputShape, newHeight, newWidth, alignCorners) {
        this.variableNames = ["A"];
        this.packedInputs = true;
        this.packedOutput = true;
        this.outputShape = [];
        const [batch, oldHeight, oldWidth, depth] = inputShape;
        this.outputShape = [batch, newHeight, newWidth, depth];
        const effectiveInSize = [
          alignCorners && newHeight > 1 ? oldHeight - 1 : oldHeight,
          alignCorners && newWidth > 1 ? oldWidth - 1 : oldWidth
        ];
        const effectiveOutSize = [
          alignCorners && newHeight > 1 ? newHeight - 1 : newHeight,
          alignCorners && newWidth > 1 ? newWidth - 1 : newWidth
        ];
        this.userCode = `
      const vec3 effectiveInputOverOutputRatioRC = vec3(
          ${effectiveInSize[0] / effectiveOutSize[0]},
          ${effectiveInSize[1] / effectiveOutSize[1]},
          ${effectiveInSize[1] / effectiveOutSize[1]});
      const vec3 inputShapeRC = vec3(${oldHeight}.0, ${oldWidth}.0,
                                     ${oldWidth}.0);

      float getAValue(int b, int r, int c, int d) {
        return getChannel(getA(b, r, c, d), vec2(c, d));
      }

      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];
        // Calculate values for next column in yRC.z.
        ivec3 yRC = coords.yzz + ivec3(0, 0, 1);

        // Fractional source index.
        vec3 sourceFracIndexRC = vec3(yRC) * effectiveInputOverOutputRatioRC;

        // Compute the four integer indices.
        ivec3 sourceFloorRC = ivec3(sourceFracIndexRC);
        ivec3 sourceCeilRC = ivec3(
          min(inputShapeRC - 1.0, ceil(sourceFracIndexRC)));

        // Should we calculate next column and row elements in 2x2 packed cell.
        bool hasNextCol = d < ${depth - 1};
        bool hasNextRow = coords.z < ${newWidth - 1};

        // In parallel, construct four corners for all four components in
        // packed 2x2 cell.
        vec4 topLeft = vec4(
          getAValue(b, sourceFloorRC.x, sourceFloorRC.y, d),
          hasNextCol ? getAValue(b, sourceFloorRC.x, sourceFloorRC.y, d + 1)
                     : 0.0,
          hasNextRow ? getAValue(b, sourceFloorRC.x, sourceFloorRC.z, d)
                     : 0.0,
          (hasNextRow && hasNextCol) ?
            getAValue(b, sourceFloorRC.x, sourceFloorRC.z, d + 1) : 0.0);

        vec4 bottomLeft = vec4(
          getAValue(b, sourceCeilRC.x, sourceFloorRC.y, d),
          hasNextCol ? getAValue(b, sourceCeilRC.x, sourceFloorRC.y, d + 1)
                     : 0.0,
          hasNextRow ? getAValue(b, sourceCeilRC.x, sourceFloorRC.z, d)
                     : 0.0,
          (hasNextRow && hasNextCol) ?
            getAValue(b, sourceCeilRC.x, sourceFloorRC.z, d + 1) : 0.0);

        vec4 topRight = vec4(
          getAValue(b, sourceFloorRC.x, sourceCeilRC.y, d),
          hasNextCol ? getAValue(b, sourceFloorRC.x, sourceCeilRC.y, d + 1)
                     : 0.0,
          hasNextRow ? getAValue(b, sourceFloorRC.x, sourceCeilRC.z, d)
                     : 0.0,
          (hasNextRow && hasNextCol) ?
            getAValue(b, sourceFloorRC.x, sourceCeilRC.z, d + 1) : 0.0);

        vec4 bottomRight = vec4(
          getAValue(b, sourceCeilRC.x, sourceCeilRC.y, d),
          hasNextCol ? getAValue(b, sourceCeilRC.x, sourceCeilRC.y, d + 1)
                     : 0.0,
          hasNextRow ? getAValue(b, sourceCeilRC.x, sourceCeilRC.z, d)
                     : 0.0,
          (hasNextRow && hasNextCol) ?
            getAValue(b, sourceCeilRC.x, sourceCeilRC.z, d + 1) : 0.0);

        vec3 fracRC = sourceFracIndexRC - vec3(sourceFloorRC);

        vec4 top = mix(topLeft, topRight, fracRC.yyzz);
        vec4 bottom = mix(bottomLeft, bottomRight, fracRC.yyzz);
        vec4 newValue = mix(top, bottom, fracRC.x);

        setOutput(newValue);
      }
    `;
      }
    }
    /**
     * @license
     * Copyright 2018 Google LLC. All Rights Reserved.
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     * http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     * =============================================================================
     */
    class ResizeNearestNeigborBackpropProgram {
      constructor(dy, x, alignCorners) {
        this.variableNames = ["dy"];
        this.outputShape = [];
        this.outputShape = x.shape;
        const [, xHeight, xWidth] = x.shape;
        const [, yHeight, yWidth] = dy.shape;
        const effectiveXSize = [
          alignCorners && yHeight > 1 ? xHeight - 1 : xHeight,
          alignCorners && yWidth > 1 ? xWidth - 1 : xWidth
        ];
        const effectiveYSize = [
          alignCorners && yHeight > 1 ? yHeight - 1 : yHeight,
          alignCorners && yWidth > 1 ? yWidth - 1 : yWidth
        ];
        const heightScale = effectiveXSize[0] / effectiveYSize[0];
        const widthScale = effectiveXSize[1] / effectiveYSize[1];
        const invHeightScale = 1 / heightScale;
        const invWidthScale = 1 / widthScale;
        const winHeight = Math.ceil(invHeightScale) * 2 + 2;
        const winWidth = Math.ceil(invWidthScale) * 2 + 2;
        this.userCode = `
      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];
        int r = coords[1];
        int c = coords[2];

        float accumulator = 0.0;

        const float heightScale = float(${heightScale});
        const float widthScale = float(${widthScale});

        const float invHeightScale = float(${invHeightScale});
        const float invWidthScale = float(${invWidthScale});

        const int winHeight = int(${winHeight});
        const int winWidth = int(${winWidth});

        // Compute bounds for where in dy we will look
        float startRLerp = floor(float(r) * invHeightScale);
        int startDyR = int(floor(startRLerp - float(winHeight / 2)));

        float startCLerp = floor(float(c) * invWidthScale);
        int startDyC = int(floor(startCLerp - float(winWidth / 2)));

        // Loop over dy
        for (int dyROffset = 0; dyROffset < winHeight; dyROffset++) {
          int dyR = dyROffset + startDyR;

          // Guard against the window exceeding the bounds of dy
          if (dyR < 0 || dyR >= ${yHeight}) {
            continue;
          }

          for (int dyCOffset = 0; dyCOffset < winWidth; dyCOffset++) {
            int dyC = dyCOffset + startDyC;

            // Guard against the window exceeding the bounds of dy
            if (dyC < 0 || dyC >= ${yWidth}) {
              continue;
            }

            float sourceFracRow =
              float(${effectiveXSize[0]}) *
                (float(dyR) / float(${effectiveYSize[0]}));

            float sourceFracCol =
                float(${effectiveXSize[1]}) *
                  (float(dyC) / float(${effectiveYSize[1]}));

            int sourceNearestRow = int(min(
                float(int(${xHeight}) - 1),
                ${alignCorners} ? float(round(sourceFracRow)) :
                                  float(floor(sourceFracRow))));

            int sourceNearestCol = int(min(
                float(int(${xWidth}) - 1),
                ${alignCorners} ? float(round(sourceFracCol)) :
                                  float(floor(sourceFracCol))));

            if (r == sourceNearestRow && c == sourceNearestCol) {
              accumulator += getDy(b, dyR, dyC, d);
            }
          }
        }
        // End loop over dy

        setOutput(accumulator);
      }
    `;
      }
    }
    /**
     * @license
     * Copyright 2018 Google LLC. All Rights Reserved.
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     * http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     * =============================================================================
     */
    class ResizeNearestNeighborProgram {
      constructor(inputShape, newHeight, newWidth, alignCorners) {
        this.variableNames = ["A"];
        this.outputShape = [];
        const [batch, oldHeight, oldWidth, depth] = inputShape;
        this.outputShape = [batch, newHeight, newWidth, depth];
        const effectiveInSize = [
          alignCorners && newHeight > 1 ? oldHeight - 1 : oldHeight,
          alignCorners && newWidth > 1 ? oldWidth - 1 : oldWidth
        ];
        const effectiveOutSize = [
          alignCorners && newHeight > 1 ? newHeight - 1 : newHeight,
          alignCorners && newWidth > 1 ? newWidth - 1 : newWidth
        ];
        const roundBase = alignCorners ? "0.5" : "0.0";
        this.userCode = `
      const vec2 effectiveInputOverOutputRatioRC = vec2(
          ${effectiveInSize[0] / effectiveOutSize[0]},
          ${effectiveInSize[1] / effectiveOutSize[1]});
      const vec2 inputShapeRC = vec2(${oldHeight}.0, ${oldWidth}.0);

      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];
        ivec2 yRC = coords.yz;

        // Fractional source index.
        vec2 sourceFracIndexRC = vec2(yRC) * effectiveInputOverOutputRatioRC;

        // Compute the coordinators of nearest neighbor point.
        ivec2 sourceNearestRC = ivec2(
          min(inputShapeRC - 1.0, floor(sourceFracIndexRC + ${roundBase})));

        float newValue = getA(b, sourceNearestRC.x, sourceNearestRC.y, d);

        setOutput(newValue);
      }
    `;
      }
    }
    /**
     * @license
     * Copyright 2017 Google LLC. All Rights Reserved.
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     * http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     * =============================================================================
     */
    class ReverseProgram {
      constructor(xShape, axis) {
        this.variableNames = ["x"];
        const rank = xShape.length;
        if (rank > 4) {
          throw new Error(`WebGL backend: Reverse of rank-${rank} tensor is not yet supported`);
        }
        this.outputShape = xShape;
        if (rank === 1) {
          this.userCode = `
        void main() {
          int coord = getOutputCoords();
          setOutput(getX(${xShape[0]} - coord - 1));
        }
      `;
          return;
        }
        const getInCoord = (i) => {
          if (axis.indexOf(i) !== -1 && xShape[i] !== 1) {
            return `${xShape[i]} - coords[${i}] - 1`;
          }
          return `coords[${i}]`;
        };
        const inCoords = xShape.map((_, i) => getInCoord(i)).join(",");
        const type = getCoordsDataType(rank);
        this.userCode = `
      void main() {
        ${type} coords = getOutputCoords();
        setOutput(getX(${inCoords}));
      }
    `;
      }
    }
    /**
     * @license
     * Copyright 2019 Google LLC. All Rights Reserved.
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     * http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     * =============================================================================
     */
    class ReversePackedProgram {
      constructor(xShape, axis) {
        this.variableNames = ["x"];
        this.packedInputs = true;
        this.packedOutput = true;
        const rank = xShape.length;
        if (rank > 4) {
          throw new Error(`WebGL backend: Reverse of rank-${rank} tensor is not yet supported`);
        }
        this.outputShape = xShape;
        const channels = getChannels("rc", rank);
        const nextColumn = `${channels[rank - 1]} + 1 < ${this.outputShape[rank - 1]}`;
        const nextRow = `${channels[rank - 2]} + 1 < ${this.outputShape[rank - 2]}`;
        const type = getCoordsDataType(rank);
        if (rank === 1) {
          this.userCode = `
        void main(){
          int rc = getOutputCoords();
          vec4 result = vec4(0.);
          result.r = getChannel(getX(${xShape[0]} - rc - 1),
            ${xShape[0]} - rc - 1);
          if(${nextColumn}){
              result.g = getChannel(getX(${xShape[0]} - (rc  + 1) - 1),
                ${xShape[0]} - (rc  + 1) - 1);
          }
          setOutput(result);
        }
      `;
        } else {
          this.userCode = `
        void main() {
          ${type} rc = getOutputCoords();
          vec4 result = vec4(0.);
          result.r = ${getR(channels.slice())};
          if(${nextColumn}){
            result.g = ${getG(channels.slice())};
          }
          if(${nextRow}) {
            result.b = ${getB(channels.slice())};
            if(${nextColumn}) {
              result.a = ${getA(channels.slice())};
            }
          }
          setOutput(result);
        }
    `;
        }
        function getR(channels2) {
          return getChannel(channels2);
        }
        function getG(channels2) {
          channels2[rank - 1] = "(" + channels2[rank - 1] + ` + 1)`;
          return getChannel(channels2);
        }
        function getB(channels2) {
          channels2[rank - 2] = "(" + channels2[rank - 2] + ` + 1)`;
          return getChannel(channels2);
        }
        function getA(channels2) {
          channels2[rank - 1] = "(" + channels2[rank - 1] + ` + 1)`;
          channels2[rank - 2] = "(" + channels2[rank - 2] + ` + 1)`;
          return getChannel(channels2);
        }
        function getChannel(channels2) {
          const inCoordsArray = xShape.map((_, i) => getInCoord(i, channels2));
          const inCoords = inCoordsArray.join(",");
          const innerDims = inCoordsArray.slice(-2).join(",");
          return `getChannel(getX(${inCoords}), vec2(${innerDims}))`;
        }
        function getInCoord(i, channels1) {
          if (axis.indexOf(i) !== -1 && xShape[i] !== 1) {
            return `${xShape[i]} - ${channels1[i]} - 1`;
          } else {
            return `${channels1[i]}`;
          }
        }
      }
    }
    /**
     * @license
     * Copyright 2018 Google LLC. All Rights Reserved.
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     * http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     * =============================================================================
     */
    class ScatterProgram {
      constructor(updateSize, sliceDim, indicesRank, updatesRank, strides, shape, summingDupeIndex = true) {
        this.variableNames = ["updates", "indices", "defaultValue"];
        this.outputShape = shape;
        const stridesType = getCoordsDataType(strides.length);
        const dtype = getCoordsDataType(shape.length);
        let indicesString = "";
        if (indicesRank === 1) {
          indicesString = "i";
        } else if (indicesRank === 2) {
          indicesString = "i, j";
        }
        const indicesSnippet = `getIndices(${indicesString})`;
        let updatesString = "";
        if (updatesRank === 1) {
          updatesString = "i";
        } else if (updatesRank === 2) {
          updatesString = "i, coords[1]";
        }
        const updatesSnippet = `getUpdates(${updatesString})`;
        const strideString = sliceDim > 1 ? "strides[j]" : "strides";
        this.userCode = `
        ${stridesType} strides = ${stridesType}(${strides});

        void main() {
          ${dtype} coords = getOutputCoords();
          float sum = 0.0;
          bool found = false;
          for (int i = 0; i < ${updateSize}; i++) {
            int flattenedIndex = 0;
            for (int j = 0; j < ${sliceDim}; j++) {
              int index = round(${indicesSnippet});
              flattenedIndex += index * ${strideString};
            }
            if (flattenedIndex == coords[0]) {
              sum += ${updatesSnippet};
              found = true;
            }
          }
          setOutput(mix(getDefaultValue(), sum, float(found)));
        }
      `;
      }
    }
    /**
     * @license
     * Copyright 2018 Google LLC. All Rights Reserved.
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     * http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     * =============================================================================
     */
    class SegmentOpProgram {
      constructor(segOpInfo, segOpType) {
        this.variableNames = ["x", "segmentIds"];
        const windowSize = segOpInfo.windowSize;
        const batchSize = segOpInfo.batchSize;
        const inSize = segOpInfo.inSize;
        const numSegments = segOpInfo.numSegments;
        const outSize = numSegments * Math.ceil(inSize / windowSize);
        this.outputShape = [batchSize, outSize];
        const initializationValue = "0.0";
        const returnValue = `sumValue`;
        const windowSizeNearestVec4 = Math.floor(windowSize / 4) * 4;
        const windowSizeVec4Remainder = windowSize % 4;
        const updateSnippet = `
        sumValue += dot(values, segFilter);
    `;
        let checkValueOutOfBounds = "";
        if (inSize % windowSize > 0) {
          checkValueOutOfBounds = `
        if (inIdx < 0 || inIdx >= ${inSize}) {
          return initializationValue;
        }
      `;
        }
        let checkSegmentIdOutOfBounds = "";
        if (inSize % windowSize > 0) {
          checkSegmentIdOutOfBounds = `
        if (inIdx < 0 || inIdx >= ${inSize}) {
          return -1.0;
        }
      `;
        }
        this.userCode = `
      const float initializationValue = ${initializationValue};

      float getValue(int batch, int inIdx) {
        ${checkValueOutOfBounds}
        return getX(batch, inIdx);
      }

      float getSegmentIdAtIndex(int inIdx) {
        ${checkSegmentIdOutOfBounds}
        return getSegmentIds(inIdx);
      }

      void main() {
        ivec2 coords = getOutputCoords();
        int batch = coords[0];
        int outIdx = coords[1];
        int inOffset = int(floor(float(outIdx) / float(
          ${numSegments})) * float(${windowSize}));
        int currentSeg = int(mod(float(outIdx), float(${numSegments})));

        float sumValue = 0.0;

        for (int i = 0; i < ${windowSizeNearestVec4}; i += 4) {
          int inIdx = inOffset + i;
          vec4 values = vec4(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            getValue(batch, inIdx + 2),
            getValue(batch, inIdx + 3)
          );

          vec4 segFilter = vec4(
            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,
            int(getSegmentIdAtIndex(inIdx + 1)) == currentSeg ? 1 : 0,
            int(getSegmentIdAtIndex(inIdx + 2)) == currentSeg ? 1 : 0,
            int(getSegmentIdAtIndex(inIdx + 3)) == currentSeg ? 1 : 0
          );

          ${updateSnippet}
        }

        int inIdx = inOffset + ${windowSizeNearestVec4};
        if (${windowSizeVec4Remainder === 1}) {
          vec4 values = vec4(
            getValue(batch, inIdx),
            initializationValue,
            initializationValue,
            initializationValue
          );

          int inIdxSeg = int(getSegmentIdAtIndex(inIdx));

          vec4 segFilter = vec4(
            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,
            0,
            0,
            0
          );

          ${updateSnippet}
        } else if (${windowSizeVec4Remainder === 2}) {
          vec4 values = vec4(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            initializationValue,
            initializationValue
          );

          vec4 segFilter = vec4(
            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,
            int(getSegmentIdAtIndex(inIdx + 1)) == currentSeg ? 1 : 0,
              0,
              0
          );

          ${updateSnippet}
        } else if (${windowSizeVec4Remainder === 3}) {
          vec4 values = vec4(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            getValue(batch, inIdx + 2),
            initializationValue
          );

          vec4 segFilter = vec4(
            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,
            int(getSegmentIdAtIndex(inIdx + 1)) == currentSeg ? 1 : 0,
            int(getSegmentIdAtIndex(inIdx + 2)) == currentSeg ? 1 : 0,
            0
          );

          ${updateSnippet}
        }
        setOutput(${returnValue});
      }
    `;
      }
    }
    /**
     * @license
     * Copyright 2017 Google LLC. All Rights Reserved.
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     * http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     * =============================================================================
     */
    class SelectProgram {
      constructor(cRank, shape, rank) {
        this.variableNames = ["c", "a", "b"];
        this.outputShape = shape;
        let cCoords;
        let abCoords;
        if (rank > 4) {
          throw Error(`Where for rank ${rank} is not yet supported`);
        }
        if (rank === 1) {
          abCoords = `resRC`;
          cCoords = `resRC`;
        } else {
          const currentCoords = ["resRC.x", "resRC.y", "resRC.z", "resRC.w"];
          const cCoordVars = [];
          const abCoordVars = [];
          for (let i = 0; i < shape.length; i++) {
            abCoordVars.push(`${currentCoords[i]}`);
            if (i < cRank) {
              cCoordVars.push(`${currentCoords[i]}`);
            }
          }
          cCoords = cCoordVars.join();
          abCoords = abCoordVars.join();
        }
        const dtype = getCoordsDataType(rank);
        this.userCode = `
      void main() {
        ${dtype} resRC = getOutputCoords();
        float cVal = getC(${cCoords});
        if (cVal >= 1.0) {
          setOutput(getA(${abCoords}));
        } else {
          setOutput(getB(${abCoords}));
        }
      }
    `;
      }
    }
    /**
     * @license
     * Copyright 2017 Google LLC. All Rights Reserved.
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     * http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     * =============================================================================
     */
    class SliceProgram {
      constructor(destSize) {
        this.variableNames = ["source"];
        this.outputShape = destSize;
        this.rank = destSize.length;
        const dtype = getCoordsDataType(this.rank);
        const uniformPart = `uniform int start[${this.rank}];`;
        const sourceCoords = getCoords$1(this.rank);
        let body2;
        const coordSum = destSize.map((_, i) => {
          return `sourceLoc.${coords[i]} = start[${i}] + coords.${coords[i]};`;
        });
        body2 = `
        ${dtype} sourceLoc;
        ${dtype} coords = getOutputCoords();
        ${coordSum.join("\n")}
      `;
        this.userCode = `
      ${uniformPart}
      void main() {
        ${body2}
        setOutput(getSource(${sourceCoords}));
      }
    `;
      }
      getCustomSetupFunc(start) {
        if (start.length !== this.rank) {
          throw Error(`The rank (${this.rank}) of the program must match the length of start (${start.length})`);
        }
        return (gpgpu, webGLProgram) => {
          if (this.startLoc == null) {
            this.startLoc = gpgpu.getUniformLocationNoThrow(webGLProgram, "start");
            if (this.startLoc == null) {
              return;
            }
          }
          gpgpu.gl.uniform1iv(this.startLoc, start);
        };
      }
    }
    const coords = ["x", "y", "z", "w", "u", "v"];
    function getCoords$1(rank) {
      if (rank === 1) {
        return "sourceLoc";
      } else if (rank <= 6) {
        return coords.slice(0, rank).map((x) => "sourceLoc." + x).join(",");
      } else {
        throw Error(`Slicing for rank ${rank} is not yet supported`);
      }
    }
    /**
     * @license
     * Copyright 2019 Google LLC. All Rights Reserved.
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     * http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     * =============================================================================
     */
    class SlicePackedProgram {
      constructor(destSize) {
        this.variableNames = ["source"];
        this.packedInputs = true;
        this.packedOutput = true;
        this.outputShape = destSize;
        this.rank = destSize.length;
        const dtype = getCoordsDataType(this.rank);
        const coords2 = getChannels("coords", this.rank);
        const sourceLoc = getChannels("sourceLoc", this.rank);
        const innerDims = this.rank === 1 ? "sourceLoc" : `vec2(${sourceLoc.slice(-2).join()})`;
        const getChannel = `getChannel(getSource(${sourceLoc.join()}), ${innerDims})`;
        const upperRow = `
      result.x = ${getChannel};
      if (++${coords2[this.rank - 1]} < ${destSize[this.rank - 1]}) {
        ++${sourceLoc[this.rank - 1]};
        result.y = ${getChannel};
        --${sourceLoc[this.rank - 1]};
      }
    `;
        const lowerRow = this.rank === 1 ? "" : `
      --${coords2[this.rank - 1]};
      if (++${coords2[this.rank - 2]} < ${destSize[this.rank - 2]}) {
        ++${sourceLoc[this.rank - 2]};
        result.z = ${getChannel};
        if (++${coords2[this.rank - 1]} < ${destSize[this.rank - 1]}) {
          ++${sourceLoc[this.rank - 1]};
          result.w = ${getChannel};
        }
      }
    `;
        const sourceLocSetup = this.rank <= 4 ? `sourceLoc = coords +
            ${dtype}(${destSize.map((_, i) => `start[${i}]`).join()});` : destSize.map((_, i) => `${sourceLoc[i]} = ${coords2[i]} + start[${i}];`).join("\n");
        this.userCode = `
      uniform int start[${this.rank}];
      void main() {
        ${dtype} coords = getOutputCoords();
        ${dtype} sourceLoc;
        ${sourceLocSetup}
        vec4 result = vec4(0.);
        ${upperRow}
        ${lowerRow}
        setOutput(result);
      }
    `;
      }
      getCustomSetupFunc(start) {
        if (start.length !== this.rank) {
          throw Error(`The rank (${this.rank}) of the program must match the length of start (${start.length})`);
        }
        return (gpgpu, webGLProgram) => {
          if (this.startLoc == null) {
            this.startLoc = gpgpu.getUniformLocationNoThrow(webGLProgram, "start");
            if (this.startLoc == null) {
              return;
            }
          }
          gpgpu.gl.uniform1iv(this.startLoc, start);
        };
      }
    }
    /**
     * @license
     * Copyright 2017 Google LLC. All Rights Reserved.
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     * http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     * =============================================================================
     */
    class StridedSliceProgram {
      constructor(begin, strides, size) {
        this.variableNames = ["x"];
        this.outputShape = size;
        const rank = size.length;
        const inputDtype = getCoordsDataType(size.length);
        const dtype = getCoordsDataType(size.length);
        let newCoords = "";
        if (rank === 1) {
          newCoords = "coords * strides + begin";
        } else {
          let outputAxis = 0;
          newCoords = size.map((_, i) => {
            outputAxis++;
            return size.length === 1 ? `coords * strides[${i}] + begin[${i}]` : `coords[${outputAxis - 1}] * strides[${i}] + begin[${i}]`;
          }).join(",");
        }
        this.userCode = `
      ${inputDtype} begin = ${inputDtype}(${begin});
      ${inputDtype} strides = ${inputDtype}(${strides});

      void main() {
        ${dtype} coords = getOutputCoords();
        setOutput(getX(${newCoords}));
      }
    `;
      }
    }
    /**
     * @license
     * Copyright 2017 Google LLC. All Rights Reserved.
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     * http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     * =============================================================================
     */
    class TextureManager {
      constructor(gpgpu) {
        this.gpgpu = gpgpu;
        this.numUsedTextures = 0;
        this.numFreeTextures = 0;
        this._numBytesAllocated = 0;
        this._numBytesFree = 0;
        this.freeTextures = {};
        this.logEnabled = false;
        this.usedTextures = {};
      }
      acquireTexture(shapeRC, usage, isPacked) {
        const physicalTexType = getPhysicalFromLogicalTextureType(usage, isPacked);
        const shapeKey = getKeyFromTextureShape(shapeRC, physicalTexType, isPacked);
        if (!(shapeKey in this.freeTextures)) {
          this.freeTextures[shapeKey] = [];
        }
        if (!(shapeKey in this.usedTextures)) {
          this.usedTextures[shapeKey] = [];
        }
        const texBytes = computeBytes(shapeRC, physicalTexType, this.gpgpu.gl, this.gpgpu.textureConfig, isPacked);
        if (this.freeTextures[shapeKey].length > 0) {
          this.numFreeTextures--;
          this.numUsedTextures++;
          this._numBytesFree -= texBytes;
          this.log();
          const newTexture2 = this.freeTextures[shapeKey].shift();
          this.usedTextures[shapeKey].push(newTexture2);
          return newTexture2;
        }
        let newTexture;
        if (physicalTexType === PhysicalTextureType.PACKED_2X2_FLOAT32) {
          newTexture = this.gpgpu.createPackedMatrixTexture(shapeRC[0], shapeRC[1]);
        } else if (physicalTexType === PhysicalTextureType.PACKED_2X2_FLOAT16) {
          newTexture = this.gpgpu.createFloat16PackedMatrixTexture(shapeRC[0], shapeRC[1]);
        } else if (physicalTexType === PhysicalTextureType.UNPACKED_FLOAT32) {
          newTexture = this.gpgpu.createFloat32MatrixTexture(shapeRC[0], shapeRC[1]);
        } else if (physicalTexType === PhysicalTextureType.UNPACKED_FLOAT16) {
          newTexture = this.gpgpu.createFloat16MatrixTexture(shapeRC[0], shapeRC[1]);
        } else if (physicalTexType === PhysicalTextureType.PACKED_4X1_UNSIGNED_BYTE) {
          newTexture = this.gpgpu.createUnsignedBytesMatrixTexture(shapeRC[0], shapeRC[1]);
        }
        this.usedTextures[shapeKey].push(newTexture);
        this.numUsedTextures++;
        this._numBytesAllocated += texBytes;
        this.log();
        return newTexture;
      }
      releaseTexture(texture, shape, logicalTexType, isPacked) {
        if (this.freeTextures == null) {
          return;
        }
        const physicalTexType = getPhysicalFromLogicalTextureType(logicalTexType, isPacked);
        const shapeKey = getKeyFromTextureShape(shape, physicalTexType, isPacked);
        if (!(shapeKey in this.freeTextures)) {
          this.freeTextures[shapeKey] = [];
        }
        const texBytes = computeBytes(shape, physicalTexType, this.gpgpu.gl, this.gpgpu.textureConfig, isPacked);
        const deleteTexThreshold = env2().get("WEBGL_DELETE_TEXTURE_THRESHOLD");
        if (deleteTexThreshold !== -1 && this._numBytesAllocated > deleteTexThreshold) {
          this.gpgpu.deleteMatrixTexture(texture);
          this._numBytesAllocated -= texBytes;
        } else {
          this.freeTextures[shapeKey].push(texture);
          this.numFreeTextures++;
          this._numBytesFree += texBytes;
        }
        this.numUsedTextures--;
        const texList = this.usedTextures[shapeKey];
        const texIndex = texList.indexOf(texture);
        if (texIndex < 0) {
          throw new Error("Cannot release a texture that was never provided by this texture manager");
        }
        texList.splice(texIndex, 1);
        this.log();
      }
      log() {
        if (!this.logEnabled) {
          return;
        }
        const total = this.numFreeTextures + this.numUsedTextures;
        console.log("Free/Used", `${this.numFreeTextures} / ${this.numUsedTextures}`, `(${total})`);
        const freeRatio = this._numBytesFree / this._numBytesAllocated;
        console.log(`Bytes allocated: ${this._numBytesAllocated}`);
        console.log(`Bytes unused: ${this._numBytesFree} (${Math.round(100 * freeRatio)}%)`);
      }
      get numBytesAllocated() {
        return this._numBytesAllocated;
      }
      get numBytesFree() {
        return this._numBytesFree;
      }
      getNumUsedTextures() {
        return this.numUsedTextures;
      }
      getNumFreeTextures() {
        return this.numFreeTextures;
      }
      dispose() {
        if (this.freeTextures == null) {
          return;
        }
        for (const texShape in this.freeTextures) {
          this.freeTextures[texShape].forEach((tex) => {
            this.gpgpu.deleteMatrixTexture(tex);
          });
        }
        for (const texShape in this.usedTextures) {
          this.usedTextures[texShape].forEach((tex) => {
            this.gpgpu.deleteMatrixTexture(tex);
          });
        }
        this.freeTextures = null;
        this.usedTextures = null;
        this.numUsedTextures = 0;
        this.numFreeTextures = 0;
        this._numBytesAllocated = 0;
        this._numBytesFree = 0;
      }
    }
    function numBytesForInternalFormat(gl, internalFormat) {
      const glany = gl;
      if (internalFormat === glany.R32F) {
        return 4;
      } else if (internalFormat === glany.R16F) {
        return 2;
      } else if (internalFormat === glany.RGBA32F) {
        return 16;
      } else if (internalFormat === gl.RGBA) {
        return 16;
      } else if (internalFormat === glany.RGBA16F) {
        return 8;
      }
      throw new Error(`Unknown internal format ${internalFormat}`);
    }
    function computeBytes(shape, physicalTexType, gl, textureConfig, isPacked) {
      const internalFormat = internalFormatForPhysicalTexType(physicalTexType, textureConfig);
      let numElements;
      if (isPacked) {
        const [packedWidth, packedHeight] = getPackedMatrixTextureShapeWidthHeight(shape[0], shape[1]);
        numElements = packedWidth * packedHeight;
      } else {
        const [width, height] = getUnpackedMatrixTextureShapeWidthHeight(shape[0], shape[1]);
        numElements = width * height;
      }
      const bytesPerElement3 = numBytesForInternalFormat(gl, internalFormat);
      return numElements * bytesPerElement3;
    }
    function internalFormatForPhysicalTexType(physicalTexType, textureConfig) {
      switch (physicalTexType) {
        case PhysicalTextureType.PACKED_2X2_FLOAT32:
          return getInternalFormatForPackedMatrixTexture(textureConfig);
        case PhysicalTextureType.PACKED_2X2_FLOAT16:
          return getInternalFormatForFloat16PackedMatrixTexture(textureConfig);
        case PhysicalTextureType.UNPACKED_FLOAT32:
          return getInternalFormatForFloat32MatrixTexture(textureConfig);
        case PhysicalTextureType.UNPACKED_FLOAT16:
          return getInternalFormatForFloat16MatrixTexture(textureConfig);
        case PhysicalTextureType.PACKED_4X1_UNSIGNED_BYTE:
          return getInternalFormatForUnsignedBytesMatrixTexture(textureConfig);
        default:
          throw new Error(`Unknown physical texture type ${physicalTexType}`);
      }
    }
    function getPhysicalTextureForRendering(isPacked) {
      if (env2().getBool("WEBGL_RENDER_FLOAT32_ENABLED")) {
        if (isPacked) {
          return PhysicalTextureType.PACKED_2X2_FLOAT32;
        }
        return PhysicalTextureType.UNPACKED_FLOAT32;
      }
      if (isPacked) {
        return PhysicalTextureType.PACKED_2X2_FLOAT16;
      }
      return PhysicalTextureType.UNPACKED_FLOAT16;
    }
    function getPhysicalFromLogicalTextureType(logicalTexType, isPacked) {
      if (logicalTexType === TextureUsage.UPLOAD) {
        return PhysicalTextureType.PACKED_2X2_FLOAT32;
      } else if (logicalTexType === TextureUsage.RENDER || logicalTexType == null) {
        return getPhysicalTextureForRendering(isPacked);
      } else if (logicalTexType === TextureUsage.DOWNLOAD || logicalTexType === TextureUsage.PIXELS) {
        return PhysicalTextureType.PACKED_4X1_UNSIGNED_BYTE;
      }
      throw new Error(`Unknown logical texture type ${logicalTexType}`);
    }
    function getKeyFromTextureShape(shapeRowsCol, physicalTexType, isPacked) {
      return `${shapeRowsCol[0]}_${shapeRowsCol[1]}_${physicalTexType}_${isPacked}`;
    }
    /**
     * @license
     * Copyright 2017 Google LLC. All Rights Reserved.
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     * http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     * =============================================================================
     */
    class TileProgram {
      constructor(aShape, reps) {
        this.variableNames = ["A"];
        const outputShape = new Array(aShape.length);
        for (let i = 0; i < outputShape.length; i++) {
          outputShape[i] = aShape[i] * reps[i];
        }
        this.outputShape = outputShape;
        this.rank = outputShape.length;
        const dtype = getCoordsDataType(this.rank);
        const sourceCoords = getSourceCoords$2(aShape);
        this.userCode = `
      void main() {
        ${dtype} resRC = getOutputCoords();
        setOutput(getA(${sourceCoords}));
      }
    `;
      }
    }
    function getSourceCoords$2(aShape) {
      const rank = aShape.length;
      if (rank > 5) {
        throw Error(`Tile for rank ${rank} is not yet supported`);
      }
      if (rank === 1) {
        return `imod(resRC, ${aShape[0]})`;
      }
      const currentCoords = ["resRC.x", "resRC.y", "resRC.z", "resRC.w", "resRC.u"];
      const sourceCoords = [];
      for (let i = 0; i < aShape.length; i++) {
        sourceCoords.push(`imod(${currentCoords[i]}, ${aShape[i]})`);
      }
      return sourceCoords.join();
    }
    /**
     * @license
     * Copyright 2017 Google LLC. All Rights Reserved.
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     * http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     * =============================================================================
     */
    class UnaryOpProgram {
      constructor(aShape, opSnippet) {
        this.variableNames = ["A"];
        this.outputShape = aShape;
        this.userCode = `
      float unaryOperation(float x) {
        ${opSnippet}
      }

      void main() {
        float x = getAAtOutCoords();
        float y = unaryOperation(x);

        setOutput(y);
      }
    `;
      }
    }
    const CHECK_NAN_SNIPPET$2 = `if (isnan(x)) return x;`;
    const LINEAR = `return x;`;
    const ABS = `return abs(x);`;
    const RELU = CHECK_NAN_SNIPPET$2 + `
  return (x < 0.0) ? 0.0 : x;
`;
    const RELU6 = CHECK_NAN_SNIPPET$2 + `
  return (x < 0.0) ? 0.0 : min(6.0, x);
`;
    const ELU$1 = `return (x >= 0.0) ? x : (exp(x) - 1.0);`;
    const SELU = `
  // Stable and Attracting Fixed Point (0, 1) for Normalized Weights.
  // see: https://arxiv.org/abs/1706.02515
  float scaleAlpha = ${SELU_SCALEALPHA2};
  float scale = ${SELU_SCALE2};
  return (x >= 0.0) ? scale * x : scaleAlpha * (exp(x) - 1.0);
`;
    function STEP(alpha = 0) {
      return CHECK_NAN_SNIPPET$2 + `
    return x > 0.0 ? 1.0 : float(${alpha});
  `;
    }
    const NEG = `return -x;`;
    const CEIL = `return ceil(x);`;
    const FLOOR = `return floor(x);`;
    const SIGN = `
  if (isnan(x)) { return 0.0; }
  return sign(x);
`;
    const IS_NAN = `return float(isnan(x));`;
    const IS_INF = `return float(isinf(x));`;
    const IS_FINITE = `return float(!isnan(x) && !isinf(x));`;
    const ROUND = `
  // OpenGL ES does not support round function.
  // The algorithm is based on banker's rounding.
  float base = floor(x);
  if ((x - base) < 0.5) {
    return floor(x);
  } else if ((x - base) > 0.5) {
    return ceil(x);
  } else {
    if (mod(base, 2.0) == 0.0) {
      return base;
    } else {
      return base + 1.0;
    }
  }
`;
    const EXP = `return exp(x);`;
    const EXPM1 = `return exp(x) - 1.0;`;
    const LOG = `if (x < 0.0) return NAN;
  return log(x);`;
    const LOG1P = `return log(1.0 + x);`;
    const SQRT = `return sqrt(x);`;
    const RSQRT = `return inversesqrt(x);`;
    const SIGMOID = `return 1.0 / (1.0 + exp(-1.0 * x));`;
    const SOFTPLUS = `
  float epsilon = 1.1920928955078125e-7;
  float threshold = log(epsilon) + 2.0;

  bool too_large = x > -threshold;
  bool too_small = x < threshold;

  float result;
  float exp_x = exp(x);

  if (too_large){
    result = x;
  }
  else if (too_small){
    result = exp_x;
  }
  else{
    result = log(exp_x + 1.0);
  }
  return result;
`;
    const ASIN = CHECK_NAN_SNIPPET$2 + `
  if (abs(x) > 1.) {
    return NAN;
  }
  return asin(x);
`;
    const ACOS = CHECK_NAN_SNIPPET$2 + `
  if (abs(x) > 1.) {
    return NAN;
  }
  return acos(x);
`;
    const ATAN = CHECK_NAN_SNIPPET$2 + `
  return atan(x);
`;
    const SINH = `
  float e2x = exp(x);
  return (e2x - 1.0 / e2x) / 2.0;
`;
    const COSH = `
  float e2x = exp(-x);
  return (e2x + 1.0 / e2x) / 2.0;
`;
    const TANH = `
  float e2x = exp(-2.0 * abs(x));
  return sign(x) * (1.0 - e2x) / (1.0 + e2x);
`;
    const ASINH = CHECK_NAN_SNIPPET$2 + `return log(x + sqrt(x * x + 1.0));`;
    const ACOSH = CHECK_NAN_SNIPPET$2 + `
  if (x < 1.0) return NAN;
  return log(x + sqrt(x * x - 1.0));`;
    const ATANH = CHECK_NAN_SNIPPET$2 + `
  if ((x < -1.0) || (x > 1.0)) return NAN;
  return (log(1.0 + x) - log(1.0 - x)) / 2.0;`;
    const ERF = `
  // Error function is calculated approximately with elementary function.
  // See "Handbook of Mathematical Functions with Formulas,
  // Graphs, and Mathematical Tables", Abramowitz and Stegun.
  float p = ${ERF_P2};
  float a1 = ${ERF_A12};
  float a2 = ${ERF_A22};
  float a3 = ${ERF_A32};
  float a4 = ${ERF_A42};
  float a5 = ${ERF_A52};

  float sign = sign(x);
  x = abs(x);
  float t = 1.0 / (1.0 + p * x);
  return sign * (1.0 - (((((a5*t + a4)*t) + a3)*t + a2)*t + a1)*t*exp(-x*x));
`;
    const RECIPROCAL = `return 1.0 / x;`;
    const LOGICAL_NOT = `return float(!(x >= 1.0));`;
    const CLONE = "return x;";
    /**
     * @license
     * Copyright 2018 Google LLC. All Rights Reserved.
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     * http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     * =============================================================================
     */
    const LINEAR$1 = `return x;`;
    const LOG$1 = `
  vec4 result = log(x);
  vec4 isNaN = vec4(lessThan(x, vec4(0.0)));
  result.r = isNaN.r == 1.0 ? NAN : result.r;
  result.g = isNaN.g == 1.0 ? NAN : result.g;
  result.b = isNaN.b == 1.0 ? NAN : result.b;
  result.a = isNaN.a == 1.0 ? NAN : result.a;

  return result;
`;
    const RELU$1 = `
  vec4 result = x * vec4(greaterThanEqual(x, vec4(0.0)));
  bvec4 isNaN = isnan(x);

  result.r = isNaN.r ? x.r : result.r;
  result.g = isNaN.g ? x.g : result.g;
  result.b = isNaN.b ? x.b : result.b;
  result.a = isNaN.a ? x.a : result.a;

  return result;
`;
    const RELU6$1 = `
  vec4 result = min(x, vec4(6.)) * vec4(greaterThanEqual(x, vec4(0.0)));
  bvec4 isNaN = isnan(x);

  result.r = isNaN.r ? x.r : result.r;
  result.g = isNaN.g ? x.g : result.g;
  result.b = isNaN.b ? x.b : result.b;
  result.a = isNaN.a ? x.a : result.a;

  return result;
`;
    const ELU$2 = `
  vec4 result;

  result.r = (x.r >= 0.0) ? x.r : (exp(x.r) - 1.0);
  result.g = (x.g >= 0.0) ? x.g : (exp(x.g) - 1.0);
  result.b = (x.b >= 0.0) ? x.b : (exp(x.b) - 1.0);
  result.a = (x.a >= 0.0) ? x.a : (exp(x.a) - 1.0);

  return result;
`;
    class UnaryOpPackedProgram {
      constructor(aShape, opSnippet) {
        this.variableNames = ["A"];
        this.packedInputs = true;
        this.packedOutput = true;
        this.outputShape = aShape;
        this.userCode = `
      vec4 unaryOperation(vec4 x) {
        ${opSnippet}
      }

      void main() {
        vec4 x = getAAtOutCoords();
        vec4 y = unaryOperation(x);

        setOutput(y);
      }
    `;
      }
    }
    /**
     * @license
     * Copyright 2018 Google LLC. All Rights Reserved.
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     * http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     * =============================================================================
     */
    class UnpackProgram {
      constructor(outputShape) {
        this.variableNames = ["A"];
        this.packedInputs = true;
        this.packedOutput = false;
        this.outputShape = outputShape;
        const rank = outputShape.length;
        const channels = getChannels("rc", rank);
        const dtype = getCoordsDataType(rank);
        const sourceCoords = getSourceCoords(rank, channels);
        const innerDims = channels.slice(-2);
        const coords2 = rank <= 1 ? "rc" : `vec2(${innerDims.join(",")})`;
        this.userCode = `
      void main() {
        ${dtype} rc = getOutputCoords();
        vec4 packedInput = getA(${sourceCoords});

        setOutput(getChannel(packedInput, ${coords2}));
      }
    `;
      }
    }
    /**
     * @license
     * Copyright 2017 Google LLC. All Rights Reserved.
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     * http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     * =============================================================================
     */
    const {segment_util: segment_util$1} = backend_util;
    const split$5 = split$1;
    const tile$4 = tile$1;
    const topkImpl$2 = topkImpl;
    const whereImpl$2 = whereImpl;
    const EPSILON_FLOAT32$1 = 1e-7;
    const EPSILON_FLOAT16$1 = 1e-4;
    const binaryCaches = {};
    function getBinaryCache(webGLVersion) {
      if (webGLVersion in binaryCaches) {
        return binaryCaches[webGLVersion];
      }
      binaryCaches[webGLVersion] = {};
      return binaryCaches[webGLVersion];
    }
    function mapActivationToShaderProgram(activation2, packed = false) {
      if (activation2 === "linear") {
        if (packed) {
          return LINEAR$1;
        }
        return LINEAR;
      } else if (activation2 === "relu") {
        if (packed) {
          return RELU$1;
        }
        return RELU;
      } else if (activation2 === "elu") {
        if (packed) {
          return ELU$2;
        }
        return ELU$1;
      } else if (activation2 === "relu6") {
        if (packed) {
          return RELU6$1;
        }
        return RELU6;
      } else if (activation2 === "prelu") {
        if (packed) {
          return PRELU$1;
        }
        return PRELU;
      }
      throw new Error(`Activation ${activation2} has not been implemented for the WebGL backend.`);
    }
    const CPU_HANDOFF_SIZE_THRESHOLD = 128;
    const BEFORE_PAGING_CONSTANT = 600;
    function numMBBeforeWarning() {
      if (env2().global.screen == null) {
        return 1024;
      }
      return env2().global.screen.height * env2().global.screen.width * window.devicePixelRatio * BEFORE_PAGING_CONSTANT / 1024 / 1024;
    }
    const MATMUL_SHARED_DIM_THRESHOLD = 1e3;
    class MathBackendWebGL extends KernelBackend2 {
      constructor(gpgpu) {
        super();
        this.pendingRead = new WeakMap();
        this.pendingDisposal = new WeakSet();
        this.dataRefCount = new WeakMap();
        this.numBytesInGPU = 0;
        this.uploadWaitMs = 0;
        this.downloadWaitMs = 0;
        this.warnedAboutMemory = false;
        this.warnedAboutCPUBackend = false;
        this.pendingDeletes = 0;
        this.disposed = false;
        if (!env2().getBool("HAS_WEBGL")) {
          throw new Error("WebGL is not supported on this device");
        }
        if (gpgpu == null) {
          const gl = getWebGLContext(env2().getNumber("WEBGL_VERSION"));
          this.binaryCache = getBinaryCache(env2().getNumber("WEBGL_VERSION"));
          this.gpgpu = new GPGPUContext(gl);
          this.canvas = gl.canvas;
          this.gpgpuCreatedLocally = true;
        } else {
          this.gpgpu = gpgpu;
          this.binaryCache = {};
          this.gpgpuCreatedLocally = false;
          this.canvas = gpgpu.gl.canvas;
        }
        this.textureManager = new TextureManager(this.gpgpu);
        this.numMBBeforeWarning = numMBBeforeWarning();
        this.texData = new DataStorage2(this, engine19());
      }
      numDataIds() {
        return this.texData.numDataIds() + (this.cpuBackend ? this.cpuBackend.numDataIds() : 0) - this.pendingDeletes;
      }
      write(values, shape, dtype) {
        if (env2().getBool("WEBGL_CHECK_NUMERICAL_PROBLEMS") || env2().getBool("DEBUG")) {
          this.checkNumericalProblems(values);
        }
        if (dtype === "complex64" && values != null) {
          throw new Error(`Cannot write to a complex64 dtype. Please use tf.complex(real, imag).`);
        }
        const dataId = {};
        this.texData.set(dataId, {
          shape,
          dtype,
          values,
          usage: TextureUsage.UPLOAD,
          refCount: 1,
          complexParentRefCount: 0
        });
        return dataId;
      }
      incRef(dataId) {
        const texData = this.texData.get(dataId);
        texData.refCount++;
      }
      decRef(dataId) {
        if (this.texData.has(dataId)) {
          const texData = this.texData.get(dataId);
          texData.refCount--;
        }
      }
      move(dataId, values, shape, dtype) {
        if (env2().getBool("DEBUG")) {
          this.checkNumericalProblems(values);
        }
        if (dtype === "complex64") {
          throw new Error(`Cannot write to a complex64 dtype. Please use tf.complex(real, imag).`);
        }
        this.texData.set(dataId, {
          shape,
          dtype,
          values,
          usage: TextureUsage.UPLOAD,
          refCount: 1,
          complexParentRefCount: 0
        });
      }
      disposeIntermediateTensorInfo(tensorInfo) {
        const dataId = tensorInfo.dataId;
        if (this.texData.has(dataId)) {
          const textureData = this.texData.get(dataId);
          textureData.refCount--;
          if (textureData.refCount < 1) {
            this.disposeData(dataId);
          }
        }
      }
      readSync(dataId) {
        const texData = this.texData.get(dataId);
        const {values, dtype, complexTensorInfos, slice: slice3, shape, isPacked} = texData;
        if (slice3 != null) {
          let program;
          if (isPacked) {
            program = new UnaryOpPackedProgram(shape, CLONE);
          } else {
            program = new UnaryOpProgram(shape, CLONE);
          }
          const res = this.runWebGLProgram(program, [{dataId, shape, dtype}], dtype);
          const data2 = this.readSync(res.dataId);
          this.disposeIntermediateTensorInfo(res);
          return data2;
        }
        if (values != null) {
          return this.convertAndCacheOnCPU(dataId);
        }
        if (dtype === "string") {
          return values;
        }
        const shouldTimeProgram = this.activeTimers != null;
        let start;
        if (shouldTimeProgram) {
          start = now3();
        }
        let result;
        if (dtype === "complex64") {
          const realValues = this.readSync(complexTensorInfos.real.dataId);
          const imagValues = this.readSync(complexTensorInfos.imag.dataId);
          result = mergeRealAndImagArrays2(realValues, imagValues);
        } else {
          result = this.getValuesFromTexture(dataId);
        }
        if (shouldTimeProgram) {
          this.downloadWaitMs += now3() - start;
        }
        return this.convertAndCacheOnCPU(dataId, result);
      }
      async read(dataId) {
        if (this.pendingRead.has(dataId)) {
          const subscribers2 = this.pendingRead.get(dataId);
          return new Promise((resolve) => subscribers2.push(resolve));
        }
        const texData = this.texData.get(dataId);
        const {values, shape, slice: slice3, dtype, complexTensorInfos, isPacked} = texData;
        if (slice3 != null) {
          let program;
          if (isPacked) {
            program = new UnaryOpPackedProgram(shape, CLONE);
          } else {
            program = new UnaryOpProgram(shape, CLONE);
          }
          const res = this.runWebGLProgram(program, [{dataId, shape, dtype}], dtype);
          const data2 = this.read(res.dataId);
          this.disposeIntermediateTensorInfo(res);
          return data2;
        }
        if (values != null) {
          return this.convertAndCacheOnCPU(dataId);
        }
        if (!env2().getBool("WEBGL_DOWNLOAD_FLOAT_ENABLED") && env2().getNumber("WEBGL_VERSION") === 2) {
          throw new Error(`tensor.data() with WEBGL_DOWNLOAD_FLOAT_ENABLED=false and WEBGL_VERSION=2 not yet supported.`);
        }
        let buffer3 = null;
        let tmpDownloadTarget;
        if (dtype !== "complex64" && env2().get("WEBGL_BUFFER_SUPPORTED")) {
          tmpDownloadTarget = this.decode(dataId);
          const tmpData = this.texData.get(tmpDownloadTarget.dataId);
          buffer3 = this.gpgpu.createBufferFromTexture(tmpData.texture, ...getDenseTexShape(shape));
        }
        this.pendingRead.set(dataId, []);
        if (dtype !== "complex64") {
          await this.gpgpu.createAndWaitForFence();
        }
        let vals;
        if (dtype === "complex64") {
          const ps = await Promise.all([
            this.read(complexTensorInfos.real.dataId),
            this.read(complexTensorInfos.imag.dataId)
          ]);
          const realValues = ps[0];
          const imagValues = ps[1];
          vals = mergeRealAndImagArrays2(realValues, imagValues);
        } else if (buffer3 == null) {
          vals = this.getValuesFromTexture(dataId);
        } else {
          const size = sizeFromShape2(shape);
          vals = this.gpgpu.downloadFloat32MatrixFromBuffer(buffer3, size);
        }
        if (tmpDownloadTarget != null) {
          this.disposeIntermediateTensorInfo(tmpDownloadTarget);
        }
        const dTypeVals = this.convertAndCacheOnCPU(dataId, vals);
        const subscribers = this.pendingRead.get(dataId);
        this.pendingRead.delete(dataId);
        subscribers.forEach((resolve) => resolve(dTypeVals));
        if (this.pendingDisposal.has(dataId)) {
          this.pendingDisposal.delete(dataId);
          this.disposeData(dataId);
          this.pendingDeletes--;
        }
        return dTypeVals;
      }
      checkNumericalProblems(values) {
        if (values == null) {
          return;
        }
        for (let i = 0; i < values.length; i++) {
          const num = values[i];
          if (!canBeRepresented(num)) {
            if (env2().getBool("WEBGL_RENDER_FLOAT32_CAPABLE")) {
              throw Error(`The value ${num} cannot be represented with your current settings. Consider enabling float32 rendering: 'tf.env().set('WEBGL_RENDER_FLOAT32_ENABLED', true);'`);
            }
            throw Error(`The value ${num} cannot be represented on this device.`);
          }
        }
      }
      getValuesFromTexture(dataId) {
        const {shape, dtype, isPacked} = this.texData.get(dataId);
        const size = sizeFromShape2(shape);
        if (env2().getBool("WEBGL_DOWNLOAD_FLOAT_ENABLED")) {
          const tmpTarget = this.decode(dataId);
          const tmpData2 = this.texData.get(tmpTarget.dataId);
          const vals2 = this.gpgpu.downloadMatrixFromPackedTexture(tmpData2.texture, ...getDenseTexShape(shape)).subarray(0, size);
          this.disposeIntermediateTensorInfo(tmpTarget);
          return vals2;
        }
        const shouldUsePackedProgram = env2().getBool("WEBGL_PACK") && isPacked === true;
        const outputShape = shouldUsePackedProgram ? getShapeAs3D(shape) : shape;
        const program = shouldUsePackedProgram ? new EncodeFloatPackedProgram(outputShape) : new EncodeFloatProgram(outputShape);
        const output = this.runWebGLProgram(program, [{shape: outputShape, dtype, dataId}], "float32");
        const tmpData = this.texData.get(output.dataId);
        const vals = this.gpgpu.downloadByteEncodedFloatMatrixFromOutputTexture(tmpData.texture, tmpData.texShape[0], tmpData.texShape[1]).subarray(0, size);
        this.disposeIntermediateTensorInfo(output);
        return vals;
      }
      async time(f) {
        const oldActiveTimers = this.activeTimers;
        const newActiveTimers = [];
        let outerMostTime = false;
        if (this.programTimersStack == null) {
          this.programTimersStack = newActiveTimers;
          outerMostTime = true;
        } else {
          this.activeTimers.push(newActiveTimers);
        }
        this.activeTimers = newActiveTimers;
        f();
        const flattenedActiveTimerQueries = flatten2(this.activeTimers.map((d) => d.query)).filter((d) => d != null);
        const flattenedActiveTimerNames = flatten2(this.activeTimers.map((d) => d.name)).filter((d) => d != null);
        this.activeTimers = oldActiveTimers;
        if (outerMostTime) {
          this.programTimersStack = null;
        }
        const res = {
          uploadWaitMs: this.uploadWaitMs,
          downloadWaitMs: this.downloadWaitMs,
          kernelMs: null,
          wallMs: null
        };
        if (env2().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE") > 0) {
          const kernelMs = await Promise.all(flattenedActiveTimerQueries);
          res["kernelMs"] = sum5(kernelMs);
          res["getExtraProfileInfo"] = () => kernelMs.map((d, i) => ({name: flattenedActiveTimerNames[i], ms: d})).map((d) => `${d.name}: ${d.ms}`).join(", ");
        } else {
          res["kernelMs"] = {
            error: "WebGL query timers are not supported in this environment."
          };
        }
        this.uploadWaitMs = 0;
        this.downloadWaitMs = 0;
        return res;
      }
      memory() {
        return {
          unreliable: false,
          numBytesInGPU: this.numBytesInGPU,
          numBytesInGPUAllocated: this.textureManager.numBytesAllocated,
          numBytesInGPUFree: this.textureManager.numBytesFree
        };
      }
      startTimer() {
        if (env2().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE") > 0) {
          return this.gpgpu.beginQuery();
        }
        return {startMs: now3(), endMs: null};
      }
      endTimer(query) {
        if (env2().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE") > 0) {
          this.gpgpu.endQuery();
          return query;
        }
        query.endMs = now3();
        return query;
      }
      async getQueryTime(query) {
        if (env2().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE") > 0) {
          return this.gpgpu.waitForQueryAndGetTime(query);
        }
        const timerQuery = query;
        return timerQuery.endMs - timerQuery.startMs;
      }
      disposeData(dataId) {
        if (this.pendingDisposal.has(dataId)) {
          return;
        }
        if (this.pendingRead.has(dataId)) {
          this.pendingDisposal.add(dataId);
          this.pendingDeletes++;
          return;
        }
        if (!this.texData.has(dataId)) {
          return;
        }
        if (this.texData.get(dataId).complexParentRefCount > 0) {
          this.texData.get(dataId).refCount--;
          return;
        }
        this.releaseGPUData(dataId);
        const {complexTensorInfos} = this.texData.get(dataId);
        if (complexTensorInfos != null) {
          this.texData.get(complexTensorInfos.real.dataId).complexParentRefCount--;
          this.disposeIntermediateTensorInfo(complexTensorInfos.real);
          this.texData.get(complexTensorInfos.imag.dataId).complexParentRefCount--;
          this.disposeIntermediateTensorInfo(complexTensorInfos.imag);
        }
        this.texData.delete(dataId);
      }
      releaseGPUData(dataId) {
        const {texture, dtype, texShape, usage, isPacked, slice: slice3} = this.texData.get(dataId);
        const key = slice3 && slice3.origDataId || dataId;
        const refCount = this.dataRefCount.get(key);
        if (refCount > 1) {
          this.dataRefCount.set(key, refCount - 1);
        } else {
          this.dataRefCount.delete(key);
          if (texture != null) {
            this.numBytesInGPU -= this.computeBytes(texShape, dtype);
            this.textureManager.releaseTexture(texture, texShape, usage, isPacked);
          }
        }
        const texData = this.texData.get(dataId);
        texData.texture = null;
        texData.texShape = null;
        texData.isPacked = false;
        texData.slice = null;
      }
      getTexture(dataId) {
        this.uploadToGPU(dataId);
        return this.texData.get(dataId).texture;
      }
      getDataInfo(dataId) {
        return this.texData.get(dataId);
      }
      getCPUBackend() {
        if (!env2().getBool("WEBGL_CPU_FORWARD")) {
          return null;
        }
        if (this.cpuBackend == null) {
          this.cpuBackend = engine19().findBackend("cpu");
        }
        return this.cpuBackend;
      }
      shouldExecuteOnCPU(inputs, sizeThreshold = CPU_HANDOFF_SIZE_THRESHOLD) {
        const cpuBackend = this.getCPUBackend();
        if (!this.warnedAboutCPUBackend && cpuBackend == null) {
          console.warn("Your application contains ops that are small enough to be executed on the CPU backend, however the CPU backend cannot be found. Consider importing the CPU backend (@tensorflow/tfjs-backend-cpu) for better performance.");
          this.warnedAboutCPUBackend = true;
        }
        return cpuBackend != null && inputs.every((input2) => this.texData.get(input2.dataId).texture == null && sizeFromShape2(input2.shape) < sizeThreshold);
      }
      getGPGPUContext() {
        return this.gpgpu;
      }
      slice(x, begin, size) {
        if (this.shouldExecuteOnCPU([x])) {
          const outValues = sliceImplCPU(this.texData.get(x.dataId).values, begin, size, x.shape, x.dtype);
          return this.makeOutput(size, x.dtype, outValues);
        }
        if (sizeFromShape2(size) === 0) {
          return tensor6([], size, x.dtype);
        }
        const {isPacked} = this.texData.get(x.dataId);
        const isContinous = isSliceContinous2(x.shape, begin, size);
        if (isPacked || !isContinous) {
          const program = env2().getBool("WEBGL_PACK_ARRAY_OPERATIONS") ? new SlicePackedProgram(size) : new SliceProgram(size);
          const customSetup = program.getCustomSetupFunc(begin);
          return this.compileAndRun(program, [x], null, customSetup);
        }
        this.uploadToGPU(x.dataId);
        return this.shallowSlice(x, begin, size);
      }
      shallowSlice(x, begin, size) {
        const xTexData = this.texData.get(x.dataId);
        const t = this.makeOutput(size, x.dtype);
        const newTexData = this.texData.get(t.dataId);
        Object.assign(newTexData, xTexData);
        newTexData.shape = size;
        newTexData.dtype = x.dtype;
        let flatOffset = computeFlatOffset2(begin, x.strides);
        if (xTexData.slice) {
          flatOffset += xTexData.slice.flatOffset;
        }
        newTexData.slice = {
          flatOffset,
          origDataId: xTexData.slice && xTexData.slice.origDataId || x.dataId
        };
        const refCount = this.dataRefCount.get(newTexData.slice.origDataId) || 1;
        this.dataRefCount.set(newTexData.slice.origDataId, refCount + 1);
        return t;
      }
      stridedSlice(x, begin, end, strides) {
        const cpuRes = this.tryRunOnCpuOrThrow([x], () => this.cpuBackend.stridedSlice(x, begin, end, strides));
        if (cpuRes) {
          return cpuRes;
        }
        const outShape = computeOutShape5(begin, end, strides);
        if (outShape.some((axis) => axis === 0)) {
          return tensor6([], outShape);
        }
        const program = new StridedSliceProgram(begin, strides, outShape);
        return this.compileAndRun(program, [x]);
      }
      reverse(x, axis) {
        const program = env2().getBool("WEBGL_PACK_ARRAY_OPERATIONS") ? new ReversePackedProgram(x.shape, axis) : new ReverseProgram(x.shape, axis);
        return this.compileAndRun(program, [x]);
      }
      neg(x) {
        const cpuRes = this.tryRunOnCpuOrThrow([x], () => this.cpuBackend.neg(x));
        if (cpuRes) {
          return cpuRes;
        }
        if (env2().getBool("WEBGL_PACK_UNARY_OPERATIONS")) {
          return this.packedUnaryOp(x, NEG, x.dtype);
        }
        const program = new UnaryOpProgram(x.shape, NEG);
        return this.compileAndRun(program, [x]);
      }
      batchMatMul(a, b, transposeA, transposeB) {
        const outerShapeA = transposeA ? a.shape[2] : a.shape[1];
        const outerShapeB = transposeB ? b.shape[1] : b.shape[2];
        const sharedDim = transposeA ? a.shape[1] : a.shape[2];
        const batch = Math.max(a.shape[0], b.shape[0]);
        if ((outerShapeA === 1 || outerShapeB === 1) && sharedDim > MATMUL_SHARED_DIM_THRESHOLD) {
          if (transposeA) {
            a = transpose4(a, [0, 2, 1]);
          }
          if (transposeB) {
            b = transpose4(b, [0, 2, 1]);
          }
          const a3D = outerShapeB === 1 ? a : a.as3D(batch, sharedDim, 1);
          const axis = outerShapeB === 1 ? 2 : 1;
          const b3D = outerShapeB === 1 ? b.as3D(batch, 1, sharedDim) : b;
          const product = mul3(a3D, b3D);
          return product.sum(axis, true);
        }
        const dtype = upcastType2(a.dtype, b.dtype);
        const program = new MatMulPackedProgram(a.shape, b.shape, [batch, outerShapeA, outerShapeB], transposeA, transposeB);
        return this.compileAndRun(program, [a, b], dtype);
      }
      fusedBatchMatMul({a, b, transposeA, transposeB, bias, activation: activation2, preluActivationWeights}) {
        const outerShapeA = transposeA ? a.shape[2] : a.shape[1];
        const outerShapeB = transposeB ? b.shape[1] : b.shape[2];
        const batch = Math.max(a.shape[0], b.shape[0]);
        const dtype = upcastType2(a.dtype, b.dtype);
        const hasBias = bias != null;
        const hasPreluActivationWeights = preluActivationWeights != null;
        const fusedActivation = activation2 ? mapActivationToShaderProgram(activation2, true) : null;
        const program = new MatMulPackedProgram(a.shape, b.shape, [batch, outerShapeA, outerShapeB], transposeA, transposeB, hasBias, fusedActivation, hasPreluActivationWeights);
        const inputs = [a, b];
        if (bias) {
          inputs.push(bias);
        }
        if (preluActivationWeights) {
          inputs.push(preluActivationWeights);
        }
        return this.compileAndRun(program, inputs, dtype);
      }
      localResponseNormalization4D(x, radius, bias, alpha, beta) {
        const program = env2().getBool("WEBGL_PACK_NORMALIZATION") ? new LRNPackedProgram(x.shape, radius, bias, alpha, beta) : new LRNProgram(x.shape, radius, bias, alpha, beta);
        return this.compileAndRun(program, [x]);
      }
      LRNGrad(dy, inputImage, outputImage, depthRadius, bias, alpha, beta) {
        const program = new LRNGradProgram(inputImage.shape, depthRadius, bias, alpha, beta);
        return this.compileAndRun(program, [inputImage, outputImage, dy]);
      }
      tile(x, reps) {
        if (x.dtype === "string") {
          const data2 = this.readSync(x.dataId);
          const decodedData = data2.map((d) => decodeString2(d));
          const buf = buffer2(x.shape, x.dtype, decodedData);
          return tile$4(buf, reps);
        }
        const program = new TileProgram(x.shape, reps);
        return this.compileAndRun(program, [x]);
      }
      pad(x, paddings, constantValue) {
        const program = env2().getBool("WEBGL_PACK_ARRAY_OPERATIONS") ? new PadPackedProgram(x.shape, paddings, constantValue) : new PadProgram(x.shape, paddings, constantValue);
        return this.compileAndRun(program, [x]);
      }
      gather(x, indices, axis) {
        const cpuRes = this.tryRunOnCpuOrThrow([x, indices], () => this.cpuBackend.gather(x, indices, axis));
        if (cpuRes) {
          return cpuRes;
        }
        const program = new GatherProgram(x.shape, indices.size, axis);
        return this.compileAndRun(program, [x, indices]);
      }
      batchToSpaceND(x, blockShape, crops) {
        assert2(x.rank <= 4, () => "batchToSpaceND for rank > 4 with a WebGL backend not implemented yet");
        const prod2 = blockShape.reduce((a, b) => a * b);
        const reshaped = getReshaped2(x.shape, blockShape, prod2);
        const permuted = getPermuted2(reshaped.length, blockShape.length);
        const reshapedPermuted = getReshapedPermuted2(x.shape, blockShape, prod2);
        const sliceBeginCoords = getSliceBeginCoords2(crops, blockShape.length);
        const sliceSize = getSliceSize2(reshapedPermuted, crops, blockShape.length);
        return transpose4(x.reshape(reshaped), permuted).reshape(reshapedPermuted).slice(sliceBeginCoords, sliceSize);
      }
      spaceToBatchND(x, blockShape, paddings) {
        assert2(x.rank <= 4, () => "spaceToBatchND for rank > 4 with a WebGL backend not implemented yet");
        const prod2 = blockShape.reduce((a, b) => a * b);
        const completePaddings = [[0, 0]];
        completePaddings.push(...paddings);
        for (let i = 1 + blockShape.length; i < x.shape.length; ++i) {
          completePaddings.push([0, 0]);
        }
        const paddedX = x.pad(completePaddings);
        const reshapedPaddedShape = getReshaped2(paddedX.shape, blockShape, prod2, false);
        const permutedReshapedPaddedPermutation = getPermuted2(reshapedPaddedShape.length, blockShape.length, false);
        const flattenShape = getReshapedPermuted2(paddedX.shape, blockShape, prod2, false);
        const paddedXT = transpose4(paddedX.reshape(reshapedPaddedShape), permutedReshapedPaddedPermutation);
        return reshape5(paddedXT, flattenShape);
      }
      reduce(x, reduceType, dtype) {
        const batchSize = x.shape[0];
        const inSize = x.shape[1];
        const windowSize = computeOptimalWindowSize2(inSize);
        const outSize = Math.ceil(inSize / windowSize);
        const reduceInfo = {windowSize, inSize, batchSize, outSize};
        const program = new ReduceProgram(reduceInfo, reduceType);
        const output = this.compileAndRun(program, [x], dtype);
        if (output.shape[1] === 1) {
          return output;
        }
        return this.reduce(output, reduceType, dtype);
      }
      argReduce(x, reduceType, bestIndicesA = null) {
        let batchSize = x.shape[0];
        let inSize = x.shape[1];
        if (bestIndicesA != null) {
          batchSize = bestIndicesA.shape[0];
          inSize = bestIndicesA.shape[1];
        }
        const windowSize = computeOptimalWindowSize2(inSize);
        const reduceInfo = {
          windowSize,
          inSize,
          batchSize,
          outSize: Math.ceil(inSize / windowSize)
        };
        const program = new ArgMinMaxProgram(reduceInfo, reduceType, bestIndicesA == null);
        const inputs = [x];
        if (bestIndicesA != null) {
          inputs.push(bestIndicesA);
        }
        const output = this.compileAndRun(program, inputs, "int32");
        if (output.shape[1] === 1) {
          return output;
        }
        return this.argReduce(x, reduceType, output);
      }
      argReducePacked(x, reduceType, bestIndicesA = null) {
        const inShape = bestIndicesA != null ? bestIndicesA.shape : x.shape;
        const inSize = inShape[inShape.length - 1];
        const windowSize = computeOptimalWindowSize2(inSize);
        const program = new ArgMinMaxPackedProgram(inShape, windowSize, reduceType, bestIndicesA == null);
        const inputs = bestIndicesA == null ? [x] : [x, bestIndicesA];
        const output = this.compileAndRun(program, inputs, "int32");
        if (output.rank === x.rank) {
          return this.argReducePacked(x, reduceType, output);
        }
        return output;
      }
      sum(x, axes) {
        assertAxesAreInnerMostDims2("sum", axes, x.rank);
        const [outShape, reduceShape] = computeOutAndReduceShapes2(x.shape, axes);
        const inSize = sizeFromShape2(reduceShape);
        const a2D = x.as2D(-1, inSize);
        const outputDType = sumOutType(x.dtype);
        return this.reduce(a2D, "sum", outputDType).reshape(outShape);
      }
      prod(x, axes) {
        const cpuRes = this.tryRunOnCpuOrThrow([x], () => this.cpuBackend.prod(x, axes));
        if (cpuRes) {
          return cpuRes;
        }
        const [outShape, reduceShape] = computeOutAndReduceShapes2(x.shape, axes);
        const inSize = sizeFromShape2(reduceShape);
        const a2D = x.as2D(-1, inSize);
        const outputDType = sumOutType(x.dtype);
        return this.reduce(a2D, "prod", outputDType).reshape(outShape);
      }
      unsortedSegmentSum(x, segmentIds, numSegments) {
        let axis = 0;
        const permutation = getAxesPermutation2([axis], x.rank);
        let permutedX = x;
        if (permutation != null) {
          permutedX = transpose4(x, permutation);
          axis = getInnerMostAxes2(1, x.rank)[0];
        }
        const outShape = segment_util$1.computeOutShape(permutedX.shape, axis, numSegments);
        const inSize = sizeFromShape2([permutedX.shape[axis]]);
        const a2D = permutedX.as2D(-1, inSize);
        const outputDType = sumOutType(x.dtype);
        let result = this.segOpCompute(a2D, "unsortedSegmentSum", segmentIds, outputDType, numSegments).reshape(outShape);
        if (permutation != null) {
          result = transpose4(result, getUndoAxesPermutation2(permutation));
        }
        return result;
      }
      segOpCompute(x, segOpType, segmentIds, dtype, numSegments) {
        const batchSize = x.shape[0];
        const inSize = x.shape[1];
        const windowSize = segment_util$1.segOpComputeOptimalWindowSize(inSize, numSegments);
        const segOpInfo = {windowSize, inSize, batchSize, numSegments};
        const program = new SegmentOpProgram(segOpInfo, segOpType);
        const output = this.compileAndRun(program, [x, segmentIds], dtype);
        if (output.shape[1] === numSegments) {
          return output;
        }
        segmentIds = range(0, numSegments).tile([inSize / windowSize]);
        return this.segOpCompute(output, segOpType, segmentIds, dtype, numSegments);
      }
      argMinMaxReduce(x, axis, reduceType) {
        const axes = [axis];
        assertAxesAreInnerMostDims2("arg" + reduceType.charAt(0).toUpperCase() + reduceType.slice(1), axes, x.rank);
        if (!env2().getBool("WEBGL_PACK_REDUCE") || x.rank <= 2) {
          const [outShape, reduceShape] = computeOutAndReduceShapes2(x.shape, axes);
          const inSize = sizeFromShape2(reduceShape);
          const a2D = x.as2D(-1, inSize);
          return this.argReduce(a2D, reduceType).reshape(outShape);
        }
        return this.argReducePacked(x, reduceType);
      }
      argMin(x, axis) {
        return this.argMinMaxReduce(x, axis, "min");
      }
      argMax(x, axis) {
        return this.argMinMaxReduce(x, axis, "max");
      }
      cumsum(x, axis, exclusive, reverse3) {
        if (axis !== x.rank - 1) {
          throw new Error(`WebGL cumsum shader expects an inner-most axis=${x.rank - 1} but got axis=${axis}`);
        }
        const size = x.shape[axis];
        let result = x;
        for (let i = 0; i <= Math.ceil(Math.log2(size)) - 1; i++) {
          const program = new CumSumProgram(x.shape, false, reverse3);
          const customSetup = program.getCustomSetupFunc(i);
          const prevResult = result;
          result = this.compileAndRun(program, [result], result.dtype, customSetup);
          prevResult.dispose();
        }
        if (exclusive) {
          const program = new CumSumProgram(x.shape, exclusive, reverse3);
          const prevResult = result;
          result = this.compileAndRun(program, [result]);
          prevResult.dispose();
        }
        return result;
      }
      equal(a, b) {
        if (env2().getBool("WEBGL_PACK_BINARY_OPERATIONS")) {
          return this.packedBinaryOp(a, b, EQUAL$1, "bool");
        }
        const program = new BinaryOpProgram(EQUAL, a.shape, b.shape);
        return this.compileAndRun(program, [a, b], "bool");
      }
      less(a, b) {
        const cpuRes = this.tryRunOnCpuOrThrow([a, b], () => this.cpuBackend.less(a, b));
        if (cpuRes) {
          return cpuRes;
        }
        if (env2().getBool("WEBGL_PACK_BINARY_OPERATIONS")) {
          return this.packedBinaryOp(a, b, LESS$1, "bool");
        }
        const program = new BinaryOpProgram(LESS, a.shape, b.shape);
        return this.compileAndRun(program, [a, b], "bool");
      }
      lessEqual(a, b) {
        if (env2().getBool("WEBGL_PACK_BINARY_OPERATIONS")) {
          return this.packedBinaryOp(a, b, LESS_EQUAL$1, "bool");
        }
        const program = new BinaryOpProgram(LESS_EQUAL, a.shape, b.shape);
        return this.compileAndRun(program, [a, b], "bool");
      }
      greater(a, b) {
        const cpuRes = this.tryRunOnCpuOrThrow([a, b], () => this.cpuBackend.greater(a, b));
        if (cpuRes) {
          return cpuRes;
        }
        if (env2().getBool("WEBGL_PACK_BINARY_OPERATIONS")) {
          return this.packedBinaryOp(a, b, GREATER$1, "bool");
        }
        const program = new BinaryOpProgram(GREATER, a.shape, b.shape);
        return this.compileAndRun(program, [a, b], "bool");
      }
      greaterEqual(a, b) {
        if (env2().getBool("WEBGL_PACK_BINARY_OPERATIONS")) {
          return this.packedBinaryOp(a, b, GREATER_EQUAL$1, "bool");
        }
        const program = new BinaryOpProgram(GREATER_EQUAL, a.shape, b.shape);
        return this.compileAndRun(program, [a, b], "bool");
      }
      logicalNot(x) {
        const program = new UnaryOpProgram(x.shape, LOGICAL_NOT);
        return this.compileAndRun(program, [x]);
      }
      logicalAnd(a, b) {
        if (env2().getBool("WEBGL_PACK_BINARY_OPERATIONS")) {
          return this.packedBinaryOp(a, b, LOGICAL_AND$1, "bool");
        }
        const program = new BinaryOpProgram(LOGICAL_AND, a.shape, b.shape);
        return this.compileAndRun(program, [a, b], "bool");
      }
      logicalOr(a, b) {
        if (env2().getBool("WEBGL_PACK_BINARY_OPERATIONS")) {
          return this.packedBinaryOp(a, b, LOGICAL_OR$1, "bool");
        }
        const program = new BinaryOpProgram(LOGICAL_OR, a.shape, b.shape);
        return this.compileAndRun(program, [a, b], "bool");
      }
      select(condition, a, b) {
        const program = new SelectProgram(condition.rank, a.shape, a.rank);
        return this.compileAndRun(program, [condition, a, b], upcastType2(a.dtype, b.dtype));
      }
      where(condition) {
        warn2("tf.where() in webgl locks the UI thread. Call tf.whereAsync() instead");
        const condVals = condition.dataSync();
        return whereImpl$2(condition.shape, condVals);
      }
      topk(x, k, sorted) {
        const xVals = x.dataSync();
        return topkImpl$2(xVals, x.shape, x.dtype, k, sorted);
      }
      min(x, axes) {
        assertAxesAreInnerMostDims2("min", axes, x.rank);
        const [outShape, reduceShape] = computeOutAndReduceShapes2(x.shape, axes);
        const inSize = sizeFromShape2(reduceShape);
        const a2D = x.as2D(-1, inSize);
        return this.reduce(a2D, "min", a2D.dtype).reshape(outShape);
      }
      minimum(a, b) {
        const cpuRes = this.tryRunOnCpuOrThrow([a, b], () => this.cpuBackend.minimum(a, b));
        if (cpuRes) {
          return cpuRes;
        }
        const program = env2().getBool("WEBGL_PACK_BINARY_OPERATIONS") ? new BinaryOpPackedProgram(MIN$1, a.shape, b.shape) : new BinaryOpProgram(MIN, a.shape, b.shape);
        return this.compileAndRun(program, [a, b]);
      }
      mod(a, b) {
        const program = env2().getBool("WEBGL_PACK_BINARY_OPERATIONS") ? new BinaryOpPackedProgram(MOD$1, a.shape, b.shape) : new BinaryOpProgram(MOD, a.shape, b.shape);
        return this.compileAndRun(program, [a, b]);
      }
      maximum(a, b) {
        const cpuRes = this.tryRunOnCpuOrThrow([a, b], () => this.cpuBackend.maximum(a, b));
        if (cpuRes) {
          return cpuRes;
        }
        const program = env2().getBool("WEBGL_PACK_BINARY_OPERATIONS") ? new BinaryOpPackedProgram(MAX$1, a.shape, b.shape) : new BinaryOpProgram(MAX, a.shape, b.shape);
        return this.compileAndRun(program, [a, b]);
      }
      all(x, axes) {
        assertAxesAreInnerMostDims2("all", axes, x.rank);
        const [outShape, reduceShape] = computeOutAndReduceShapes2(x.shape, axes);
        const inSize = sizeFromShape2(reduceShape);
        const a2D = x.as2D(-1, inSize);
        return this.reduce(a2D, "all", a2D.dtype).reshape(outShape);
      }
      any(x, axes) {
        assertAxesAreInnerMostDims2("any", axes, x.rank);
        const [outShape, reduceShape] = computeOutAndReduceShapes2(x.shape, axes);
        const inSize = sizeFromShape2(reduceShape);
        const a2D = x.as2D(-1, inSize);
        return this.reduce(a2D, "any", a2D.dtype).reshape(outShape);
      }
      floorDiv(a, b) {
        const op3 = INT_DIV;
        const outputDtype = "int32";
        if (env2().getBool("WEBGL_PACK_BINARY_OPERATIONS")) {
          return this.packedBinaryOp(a, b, INT_DIV$1, outputDtype);
        }
        const program = new BinaryOpProgram(op3, a.shape, b.shape);
        return this.compileAndRun(program, [a, b], outputDtype);
      }
      packedUnaryOp(x, op3, dtype) {
        const program = new UnaryOpPackedProgram(x.shape, op3);
        return this.compileAndRun(program, [x], dtype);
      }
      packedBinaryOp(a, b, op3, dtype, checkOutOfBounds = false) {
        const program = new BinaryOpPackedProgram(op3, a.shape, b.shape, checkOutOfBounds);
        return this.compileAndRun(program, [a, b], dtype);
      }
      makeComplexComponentTensorInfo(complexTensor, complexPart) {
        return {
          dataId: complexPart.dataId,
          dtype: complexPart.dtype,
          shape: complexTensor.shape
        };
      }
      addN(tensors) {
        if (tensors.length === 1) {
          return tensors[0];
        }
        if (tensors.length > env2().get("WEBGL_MAX_TEXTURES_IN_SHADER")) {
          const midIndex = Math.floor(tensors.length / 2);
          const leftSide = this.addN(tensors.slice(0, midIndex));
          const rightSide = this.addN(tensors.slice(midIndex));
          return this.addN([leftSide, rightSide]);
        }
        const dtype = tensors.map((t) => t.dtype).reduce((d1, d2) => upcastType2(d1, d2));
        const shapes = tensors.map((t) => t.shape);
        const usePackedOp = env2().getBool("WEBGL_PACK");
        const program = usePackedOp ? new AddNPackedProgram(tensors[0].shape, shapes) : new AddNProgram(tensors[0].shape, shapes);
        return this.compileAndRun(program, tensors, dtype);
      }
      pow(a, b) {
        const usePackedOp = env2().getBool("WEBGL_PACK_BINARY_OPERATIONS");
        const program = usePackedOp ? new BinaryOpPackedProgram(POW$1, a.shape, b.shape) : new BinaryOpProgram(POW, a.shape, b.shape);
        const dtype = upcastType2(a.dtype, b.dtype);
        return this.compileAndRun(program, [a, b], dtype);
      }
      ceil(x) {
        if (this.shouldExecuteOnCPU([x])) {
          const outValues = ceilImplCPU(this.texData.get(x.dataId).values, x.dtype);
          return this.makeOutput(x.shape, x.dtype, outValues);
        }
        if (env2().getBool("WEBGL_PACK_UNARY_OPERATIONS")) {
          return this.packedUnaryOp(x, CEIL, x.dtype);
        }
        const program = new UnaryOpProgram(x.shape, CEIL);
        return this.compileAndRun(program, [x]);
      }
      floor(x) {
        if (this.shouldExecuteOnCPU([x])) {
          const outValues = floorImplCPU(this.texData.get(x.dataId).values, x.dtype);
          return this.makeOutput(x.shape, x.dtype, outValues);
        }
        if (env2().getBool("WEBGL_PACK_UNARY_OPERATIONS")) {
          return this.packedUnaryOp(x, FLOOR, x.dtype);
        }
        const program = new UnaryOpProgram(x.shape, FLOOR);
        return this.compileAndRun(program, [x]);
      }
      sign(x) {
        const program = new UnaryOpProgram(x.shape, SIGN);
        return this.compileAndRun(program, [x]);
      }
      isNaN(x) {
        const program = new UnaryOpProgram(x.shape, IS_NAN);
        return this.compileAndRun(program, [x], "bool");
      }
      isInf(x) {
        const program = new UnaryOpProgram(x.shape, IS_INF);
        return this.compileAndRun(program, [x], "bool");
      }
      isFinite(x) {
        const program = new UnaryOpProgram(x.shape, IS_FINITE);
        return this.compileAndRun(program, [x], "bool");
      }
      round(x) {
        const program = new UnaryOpProgram(x.shape, ROUND);
        return this.compileAndRun(program, [x]);
      }
      exp(x) {
        if (this.shouldExecuteOnCPU([x])) {
          const outValues = expImplCPU(this.texData.get(x.dataId).values, x.dtype);
          return this.makeOutput(x.shape, x.dtype, outValues);
        }
        if (env2().getBool("WEBGL_PACK_UNARY_OPERATIONS")) {
          return this.packedUnaryOp(x, EXP, x.dtype);
        }
        const program = new UnaryOpProgram(x.shape, EXP);
        return this.compileAndRun(program, [x]);
      }
      expm1(x) {
        if (this.shouldExecuteOnCPU([x])) {
          const outValues = expm1ImplCPU(this.texData.get(x.dataId).values, x.dtype);
          return this.makeOutput(x.shape, x.dtype, outValues);
        }
        if (env2().getBool("WEBGL_PACK_UNARY_OPERATIONS")) {
          return this.packedUnaryOp(x, EXPM1, x.dtype);
        }
        const program = new UnaryOpProgram(x.shape, EXPM1);
        return this.compileAndRun(program, [x]);
      }
      softmax(logits, dim) {
        const axes = parseAxisParam2([dim], logits.shape);
        const maxLogit = max2(logits, axes);
        const expandedShape = expandShapeToKeepDim2(maxLogit.shape, axes);
        const a = sub(logits, maxLogit.reshape(expandedShape));
        const b = this.exp(a);
        const sumExp = this.sum(b, axes).reshape(expandedShape);
        return div(b, sumExp);
      }
      log(x) {
        if (this.shouldExecuteOnCPU([x])) {
          const outValues = logImplCPU(this.texData.get(x.dataId).values, x.dtype);
          return this.makeOutput(x.shape, x.dtype, outValues);
        }
        if (env2().getBool("WEBGL_PACK_UNARY_OPERATIONS")) {
          return this.packedUnaryOp(x, LOG$1, x.dtype);
        }
        const program = new UnaryOpProgram(x.shape, LOG);
        return this.compileAndRun(program, [x]);
      }
      log1p(x) {
        const program = new UnaryOpProgram(x.shape, LOG1P);
        return this.compileAndRun(program, [x]);
      }
      sqrt(x) {
        const program = new UnaryOpProgram(x.shape, SQRT);
        return this.compileAndRun(program, [x]);
      }
      rsqrt(x) {
        if (this.shouldExecuteOnCPU([x])) {
          const outValues = rsqrtImplCPU(this.texData.get(x.dataId).values, x.dtype);
          return this.makeOutput(x.shape, x.dtype, outValues);
        }
        const program = new UnaryOpProgram(x.shape, RSQRT);
        return this.compileAndRun(program, [x]);
      }
      reciprocal(x) {
        const program = new UnaryOpProgram(x.shape, RECIPROCAL);
        return this.compileAndRun(program, [x]);
      }
      relu(x) {
        let program;
        if (env2().getBool("WEBGL_PACK")) {
          program = new UnaryOpPackedProgram(x.shape, RELU$1);
        } else {
          program = new UnaryOpProgram(x.shape, RELU);
        }
        return this.compileAndRun(program, [x]);
      }
      relu6(x) {
        let program;
        if (env2().getBool("WEBGL_PACK")) {
          program = new UnaryOpPackedProgram(x.shape, RELU6$1);
        } else {
          program = new UnaryOpProgram(x.shape, RELU6);
        }
        return this.compileAndRun(program, [x]);
      }
      prelu(x, alpha) {
        const program = env2().getBool("WEBGL_PACK_BINARY_OPERATIONS") ? new BinaryOpPackedProgram(PRELU$1, x.shape, alpha.shape) : new BinaryOpProgram(PRELU, x.shape, alpha.shape);
        return this.compileAndRun(program, [x, alpha]);
      }
      elu(x) {
        if (env2().getBool("WEBGL_PACK_UNARY_OPERATIONS")) {
          return this.packedUnaryOp(x, ELU$2, x.dtype);
        }
        const program = new UnaryOpProgram(x.shape, ELU$1);
        return this.compileAndRun(program, [x]);
      }
      eluDer(dy, y) {
        const program = env2().getBool("WEBGL_PACK_BINARY_OPERATIONS") ? new BinaryOpPackedProgram(ELU_DER$1, dy.shape, y.shape) : new BinaryOpProgram(ELU_DER, dy.shape, y.shape);
        return this.compileAndRun(program, [dy, y]);
      }
      selu(x) {
        const program = new UnaryOpProgram(x.shape, SELU);
        return this.compileAndRun(program, [x]);
      }
      clip(x, min3, max3) {
        let program;
        if (env2().getBool("WEBGL_PACK_CLIP")) {
          program = new ClipPackedProgram(x.shape);
        } else {
          program = new ClipProgram(x.shape);
        }
        const customSetup = program.getCustomSetupFunc(min3, max3);
        return this.compileAndRun(program, [x], null, customSetup);
      }
      abs(x) {
        if (this.shouldExecuteOnCPU([x]) && x.dtype !== "complex64") {
          const outValues = simpleAbsImplCPU(this.texData.get(x.dataId).values);
          return this.makeOutput(x.shape, x.dtype, outValues);
        }
        if (env2().getBool("WEBGL_PACK_UNARY_OPERATIONS")) {
          return this.packedUnaryOp(x, ABS, x.dtype);
        }
        const program = new UnaryOpProgram(x.shape, ABS);
        return this.compileAndRun(program, [x]);
      }
      complexAbs(x) {
        const xData = this.texData.get(x.dataId);
        const program = new ComplexAbsProgram(x.shape);
        const inputs = [
          this.makeComplexComponentTensorInfo(x, xData.complexTensorInfos.real),
          this.makeComplexComponentTensorInfo(x, xData.complexTensorInfos.imag)
        ];
        return this.compileAndRun(program, inputs);
      }
      sigmoid(x) {
        const program = new UnaryOpProgram(x.shape, SIGMOID);
        return this.compileAndRun(program, [x]);
      }
      softplus(x) {
        const program = new UnaryOpProgram(x.shape, SOFTPLUS);
        return this.compileAndRun(program, [x]);
      }
      asin(x) {
        const program = new UnaryOpProgram(x.shape, ASIN);
        return this.compileAndRun(program, [x]);
      }
      acos(x) {
        const program = new UnaryOpProgram(x.shape, ACOS);
        return this.compileAndRun(program, [x]);
      }
      atan(x) {
        const program = new UnaryOpProgram(x.shape, ATAN);
        return this.compileAndRun(program, [x]);
      }
      sinh(x) {
        const program = new UnaryOpProgram(x.shape, SINH);
        return this.compileAndRun(program, [x]);
      }
      cosh(x) {
        const program = new UnaryOpProgram(x.shape, COSH);
        return this.compileAndRun(program, [x]);
      }
      tanh(x) {
        const program = new UnaryOpProgram(x.shape, TANH);
        return this.compileAndRun(program, [x]);
      }
      asinh(x) {
        const program = new UnaryOpProgram(x.shape, ASINH);
        return this.compileAndRun(program, [x]);
      }
      acosh(x) {
        const program = new UnaryOpProgram(x.shape, ACOSH);
        return this.compileAndRun(program, [x]);
      }
      atanh(x) {
        const program = new UnaryOpProgram(x.shape, ATANH);
        return this.compileAndRun(program, [x]);
      }
      erf(x) {
        const program = new UnaryOpProgram(x.shape, ERF);
        return this.compileAndRun(program, [x]);
      }
      step(x, alpha) {
        const program = new UnaryOpProgram(x.shape, STEP(alpha));
        return this.compileAndRun(program, [x]);
      }
      conv2dByMatMul(x, filter, convInfo, bias, activation2, preluActivationWeights) {
        const xShape = x.shape;
        const xTexData = this.texData.get(x.dataId);
        const sharedMatMulDim = convInfo.inChannels;
        const outerShapeX = xShape[0] * xShape[1] * xShape[2];
        const outerShapeFilter = convInfo.outChannels;
        const isChannelsLast = convInfo.dataFormat === "channelsLast";
        const transposeA = false;
        const transposeB = false;
        const batchMatMulWillBeUnpacked = (outerShapeX === 1 || outerShapeFilter === 1) && sharedMatMulDim > MATMUL_SHARED_DIM_THRESHOLD;
        const reshapeWillBeExpensive = xShape[2] % 2 !== 0 && !!xTexData.isPacked;
        if (batchMatMulWillBeUnpacked || !env2().getBool("WEBGL_LAZILY_UNPACK") || !env2().getBool("WEBGL_PACK_BINARY_OPERATIONS") || !reshapeWillBeExpensive) {
          const targetShape2 = isChannelsLast ? xShape[0] * xShape[1] * xShape[2] : xShape[0] * xShape[2] * xShape[3];
          const xReshaped2 = reshape5(x, [1, targetShape2, convInfo.inChannels]);
          const filterReshaped2 = reshape5(filter, [1, convInfo.inChannels, convInfo.outChannels]);
          const result = this.fusedBatchMatMul({
            a: xReshaped2,
            b: filterReshaped2,
            transposeA,
            transposeB,
            bias,
            activation: activation2,
            preluActivationWeights
          });
          return reshape5(result, convInfo.outShape);
        }
        const targetShape = isChannelsLast ? xShape[0] * xShape[1] * (xShape[2] + 1) : xShape[0] * xShape[2] * (xShape[3] + 1);
        const xReshaped = {
          dataId: x.dataId,
          shape: [1, targetShape, convInfo.inChannels],
          dtype: x.dtype
        };
        const originalXTexDataShape = xTexData.shape;
        xTexData.shape = xTexData.shape.slice();
        xTexData.shape[xTexData.shape.length - 2]++;
        assert2(isReshapeFree(xTexData.shape, xReshaped.shape), () => `packed reshape ${xTexData.shape} to ${xReshaped.shape} isn't free`);
        const filterReshaped = reshape5(filter, [1, convInfo.inChannels, convInfo.outChannels]);
        const pointwiseConv = this.fusedBatchMatMul({
          a: xReshaped,
          b: filterReshaped,
          transposeA,
          transposeB,
          bias,
          activation: activation2,
          preluActivationWeights
        });
        const pointwiseConvTexData = this.texData.get(pointwiseConv.dataId);
        assert2(pointwiseConvTexData.isPacked, () => "batchMatMul result is expected to be packed");
        xTexData.shape = originalXTexDataShape;
        pointwiseConvTexData.shape = convInfo.outShape;
        return engine19().makeTensorFromDataId(pointwiseConv.dataId, convInfo.outShape, pointwiseConv.dtype);
      }
      conv2dWithIm2Row(x, filter, convInfo, bias, activation2, preluActivationWeights) {
        const {filterWidth, filterHeight, inChannels, outWidth, outHeight, dataFormat} = convInfo;
        const isChannelsLast = dataFormat === "channelsLast";
        const sharedDim = filterWidth * filterHeight * inChannels;
        const numCols = outHeight * outWidth;
        const x2ColShape = [sharedDim, numCols];
        const transposeA = true;
        const transposeB = false;
        const xSqueezed = x.squeeze([0]);
        const w2Row = filter.reshape([1, sharedDim, -1]);
        const im2ColProgram = new Im2ColPackedProgram(x2ColShape, xSqueezed.shape, convInfo);
        const im2Col = this.compileAndRun(im2ColProgram, [xSqueezed]).reshape([
          1,
          x2ColShape[0],
          x2ColShape[1]
        ]);
        const hasBias = bias != null;
        const hasPreluActivationWeights = preluActivationWeights != null;
        const fusedActivation = activation2 ? mapActivationToShaderProgram(activation2, true) : null;
        const matmulProgram = new MatMulPackedProgram(im2Col.shape, w2Row.shape, [1, numCols, convInfo.outChannels], transposeA, transposeB, hasBias, fusedActivation, hasPreluActivationWeights);
        const inputs = [im2Col, w2Row];
        if (bias) {
          inputs.push(bias);
        }
        if (hasPreluActivationWeights) {
          inputs.push(preluActivationWeights);
        }
        const product = this.compileAndRun(matmulProgram, inputs);
        if (isChannelsLast) {
          return product.reshape([1, outHeight, outWidth, convInfo.outChannels]);
        } else {
          return product.reshape([1, convInfo.outChannels, outHeight, outWidth]);
        }
      }
      fusedConv2d({input: input2, filter, convInfo, bias, activation: activation2, preluActivationWeights}) {
        if (convInfo.filterHeight === 1 && convInfo.filterWidth === 1 && convInfo.dilationHeight === 1 && convInfo.dilationWidth === 1 && convInfo.strideHeight === 1 && convInfo.strideWidth === 1 && (convInfo.padInfo.type === "SAME" || convInfo.padInfo.type === "VALID")) {
          return this.conv2dByMatMul(input2, filter, convInfo, bias, activation2, preluActivationWeights);
        }
        if (env2().getBool("WEBGL_CONV_IM2COL") && input2.shape[0] === 1) {
          return this.conv2dWithIm2Row(input2, filter, convInfo, bias, activation2, preluActivationWeights);
        }
        const hasBias = bias != null;
        const hasPreluActivationWeights = preluActivationWeights != null;
        const fusedActivation = activation2 ? mapActivationToShaderProgram(activation2, false) : null;
        const program = new Conv2DProgram(convInfo, hasBias, fusedActivation, hasPreluActivationWeights);
        const inputs = [input2, filter];
        if (bias) {
          inputs.push(bias);
        }
        if (preluActivationWeights) {
          inputs.push(preluActivationWeights);
        }
        return this.compileAndRun(program, inputs);
      }
      conv2d(x, filter, convInfo) {
        if (convInfo.filterHeight === 1 && convInfo.filterWidth === 1 && convInfo.dilationHeight === 1 && convInfo.dilationWidth === 1 && convInfo.strideHeight === 1 && convInfo.strideWidth === 1 && (convInfo.padInfo.type === "SAME" || convInfo.padInfo.type === "VALID")) {
          return this.conv2dByMatMul(x, filter, convInfo);
        }
        if (env2().getBool("WEBGL_CONV_IM2COL") && x.shape[0] === 1) {
          return this.conv2dWithIm2Row(x, filter, convInfo);
        }
        const program = new Conv2DProgram(convInfo);
        return this.compileAndRun(program, [x, filter]);
      }
      conv2dDerInput(dy, filter, convInfo) {
        const program = new Conv2DDerInputProgram(convInfo);
        return this.compileAndRun(program, [dy, filter]);
      }
      conv2dDerFilter(x, dy, convInfo) {
        const program = new Conv2DDerFilterProgram(convInfo);
        return this.compileAndRun(program, [x, dy]);
      }
      fusedDepthwiseConv2D({input: input2, filter, convInfo, bias, activation: activation2, preluActivationWeights}) {
        const shouldPackDepthwiseConv = env2().getBool("WEBGL_PACK_DEPTHWISECONV") && convInfo.strideWidth <= 2 && convInfo.outChannels / convInfo.inChannels === 1;
        const fusedActivation = activation2 ? mapActivationToShaderProgram(activation2, shouldPackDepthwiseConv) : null;
        const inputs = [input2, filter];
        const hasBias = bias != null;
        const hasPreluActivationWeights = preluActivationWeights != null;
        if (hasBias) {
          inputs.push(bias);
        }
        if (hasPreluActivationWeights) {
          inputs.push(preluActivationWeights);
        }
        let program;
        if (shouldPackDepthwiseConv) {
          program = new DepthwiseConvPacked2DProgram(convInfo, hasBias, fusedActivation, hasPreluActivationWeights);
          return this.compileAndRun(program, inputs);
        }
        program = new DepthwiseConv2DProgram(convInfo, hasBias, fusedActivation, hasPreluActivationWeights);
        return this.compileAndRun(program, inputs);
      }
      depthwiseConv2D(x, filter, convInfo) {
        let program;
        if (env2().getBool("WEBGL_PACK_DEPTHWISECONV") && convInfo.strideWidth <= 2 && convInfo.outChannels / convInfo.inChannels === 1) {
          program = new DepthwiseConvPacked2DProgram(convInfo);
          return this.compileAndRun(program, [x, filter]);
        }
        program = new DepthwiseConv2DProgram(convInfo);
        return this.compileAndRun(program, [x, filter]);
      }
      depthwiseConv2DDerInput(dy, filter, convInfo) {
        const program = new DepthwiseConv2DDerInputProgram(convInfo);
        return this.compileAndRun(program, [dy, filter]);
      }
      depthwiseConv2DDerFilter(x, dy, convInfo) {
        const program = new DepthwiseConv2DDerFilterProgram(convInfo);
        return this.compileAndRun(program, [x, dy]);
      }
      conv3d(x, filter, convInfo) {
        const program = new Conv3DProgram(convInfo);
        return this.compileAndRun(program, [x, filter]);
      }
      conv3dDerInput(dy, filter, convInfo) {
        const program = new Conv3DDerInputProgram(convInfo);
        return this.compileAndRun(program, [dy, filter]);
      }
      conv3dDerFilter(x, dy, convInfo) {
        const program = new Conv3DDerFilterProgram(convInfo);
        return this.compileAndRun(program, [x, dy]);
      }
      unstack(x, axis) {
        const num = x.shape[axis];
        const outShape = new Array(x.rank - 1);
        let outIndex = 0;
        for (let i = 0; i < x.rank; i++) {
          if (i !== axis) {
            outShape[outIndex++] = x.shape[i];
          }
        }
        const begin = new Array(x.rank).fill(0);
        const size = x.shape.slice();
        size[axis] = 1;
        const res = new Array(num);
        for (let i = 0; i < res.length; i++) {
          begin[axis] = i;
          res[i] = this.slice(x, begin, size).reshape(outShape);
        }
        return res;
      }
      avgPool3d(x, convInfo) {
        const program = new Pool3DProgram(convInfo, "avg", false);
        return this.compileAndRun(program, [x], "float32");
      }
      avgPool3dBackprop(dy, x, convInfo) {
        const avgPool3dBackpropProgram = new AvgPool3DBackpropProgram(convInfo);
        return this.compileAndRun(avgPool3dBackpropProgram, [dy], x.dtype);
      }
      maxPool3d(x, convInfo) {
        const program = new Pool3DProgram(convInfo, "max", false);
        return this.compileAndRun(program, [x], "float32");
      }
      maxPool3dBackprop(dy, x, y, convInfo) {
        const getPositions = true;
        const maxPool3dPositionsProgram = new Pool3DProgram(convInfo, "max", getPositions);
        const maxPool3dPositions = this.compileAndRun(maxPool3dPositionsProgram, [x]);
        const maxPool3dBackPropProgram = new MaxPool3DBackpropProgram(convInfo);
        const result = this.compileAndRun(maxPool3dBackPropProgram, [dy, maxPool3dPositions], x.dtype);
        maxPool3dPositions.dispose();
        return result;
      }
      resizeBilinear(x, newHeight, newWidth, alignCorners) {
        const program = env2().getBool("WEBGL_PACK_IMAGE_OPERATIONS") ? new ResizeBilinearPackedProgram(x.shape, newHeight, newWidth, alignCorners) : new ResizeBilinearProgram(x.shape, newHeight, newWidth, alignCorners);
        return this.compileAndRun(program, [x], "float32");
      }
      resizeBilinearBackprop(dy, x, alignCorners) {
        const program = new ResizeBilinearBackpropProgram(dy, x, alignCorners);
        return this.compileAndRun(program, [dy]);
      }
      resizeNearestNeighbor(x, newHeight, newWidth, alignCorners) {
        const program = new ResizeNearestNeighborProgram(x.shape, newHeight, newWidth, alignCorners);
        return this.compileAndRun(program, [x]);
      }
      resizeNearestNeighborBackprop(dy, x, alignCorners) {
        const program = new ResizeNearestNeigborBackpropProgram(dy, x, alignCorners);
        return this.compileAndRun(program, [dy]);
      }
      multinomial(logits, normalized, numSamples, seed) {
        const probs = normalized ? logits : softmax2(logits);
        const batchSize = probs.shape[0];
        const numOutcomes = probs.shape[1];
        const program = new MultinomialProgram(batchSize, numOutcomes, numSamples);
        const customSetup = program.getCustomSetupFunc(seed);
        return this.compileAndRun(program, [probs], "int32", customSetup);
      }
      oneHot(indices, depth, onValue, offValue) {
        const program = new OneHotProgram(indices.size, depth, onValue, offValue);
        return this.compileAndRun(program, [indices]);
      }
      diag(x) {
        const program = new DiagProgram(x.size);
        return this.compileAndRun(program, [x]);
      }
      cropAndResize(image3, boxes, boxIndex, cropSize, method, extrapolationValue) {
        const program = new CropAndResizeProgram(image3.shape, boxes.shape, cropSize, method, extrapolationValue);
        return this.compileAndRun(program, [image3, boxes, boxIndex], "float32");
      }
      depthToSpace(x, blockSize, dataFormat) {
        assert2(blockSize > 1, () => `blockSize should be > 1 for depthToSpace, but was: ${blockSize}`);
        const batchSize = x.shape[0];
        const inputHeight = dataFormat === "NHWC" ? x.shape[1] : x.shape[2];
        const inputWidth = dataFormat === "NHWC" ? x.shape[2] : x.shape[3];
        const inputDepth = dataFormat === "NHWC" ? x.shape[3] : x.shape[1];
        const outputHeight = inputHeight * blockSize;
        const outputWidth = inputWidth * blockSize;
        const outputDepth = inputDepth / (blockSize * blockSize);
        const outputShape = dataFormat === "NHWC" ? [batchSize, outputHeight, outputWidth, outputDepth] : [batchSize, outputDepth, outputHeight, outputWidth];
        const program = new DepthToSpaceProgram(outputShape, blockSize, dataFormat);
        return this.compileAndRun(program, [x]);
      }
      split(x, sizeSplits, axis) {
        return split$5(x, sizeSplits, axis);
      }
      scatterND(indices, updates, shape) {
        const {sliceRank, numUpdates, sliceSize, strides, outputSize} = calculateShapes2(updates, indices, shape);
        const flattenShape = [outputSize / sliceSize, sliceSize];
        const flattenIndices = indices.reshape([numUpdates, sliceRank]);
        const flattenX = updates.reshape([numUpdates, sliceSize]);
        if (outputSize === 0) {
          return reshapeTensor2(tensor6([]), shape);
        }
        const defaultValue = scalar3(0);
        const program = new ScatterProgram(numUpdates, sliceRank, flattenIndices.rank, flattenX.rank, strides, flattenShape);
        const res = this.compileAndRun(program, [flattenX, flattenIndices, defaultValue]);
        return res.reshape(shape);
      }
      sparseToDense(sparseIndices, sparseValues, outputShape, defaultValue) {
        const {sliceRank, numUpdates, strides, outputSize} = calculateShapes2(sparseValues, sparseIndices, outputShape);
        const sumDupeIndices = false;
        const program = new ScatterProgram(numUpdates, sliceRank, sparseIndices.rank, sparseValues.rank, strides, [outputSize, 1], sumDupeIndices);
        const res = this.compileAndRun(program, [sparseValues, sparseIndices, defaultValue]);
        return res.reshape(outputShape);
      }
      gatherND(x, indices) {
        const indicesShape = indices.shape;
        const sliceRank = indicesShape[indicesShape.length - 1];
        const [resultShape, numSlices, sliceSize, strides] = prepareAndValidate2(x, indices);
        const flattenIndices = indices.reshape([numSlices, sliceRank]);
        const flattenX = x.reshape([x.size / sliceSize, sliceSize]);
        const program = new GatherNDProgram(sliceRank, strides, [numSlices, sliceSize]);
        const res = this.compileAndRun(program, [flattenX, flattenIndices]);
        return res.reshape(resultShape);
      }
      fill(shape, value, dtype) {
        dtype = dtype || inferDtype2(value);
        if (dtype === "string") {
          const values = getArrayFromDType2(dtype, sizeFromShape2(shape));
          values.fill(value);
          return engine19().makeTensor(values, shape, dtype, this);
        } else {
          const program = new FillProgram(shape, value);
          const customSetup = program.getCustomSetupFunc(value);
          return this.compileAndRun(program, [], dtype, customSetup);
        }
      }
      onesLike(x) {
        if (x.dtype === "string") {
          throw new Error("onesLike is not supported under string dtype");
        } else {
          return this.fill(x.shape, 1, x.dtype);
        }
      }
      zerosLike(x) {
        return this.fill(x.shape, x.dtype === "string" ? "" : 0, x.dtype);
      }
      linspace(start, stop, num) {
        return linspaceImpl2(start, stop, num);
      }
      makeTensorInfo(shape, dtype, values) {
        const dataId = this.write(values, shape, dtype);
        this.texData.get(dataId).usage = null;
        return {dataId, shape, dtype};
      }
      makeOutput(shape, dtype, values) {
        const {dataId} = this.makeTensorInfo(shape, dtype, values);
        return engine19().makeTensorFromDataId(dataId, shape, dtype, this);
      }
      unpackTensor(input2) {
        const program = new UnpackProgram(input2.shape);
        return this.runWebGLProgram(program, [input2], input2.dtype);
      }
      packTensor(input2) {
        const program = new PackProgram(input2.shape);
        const preventEagerUnpackingOutput = true;
        return this.runWebGLProgram(program, [input2], input2.dtype, null, preventEagerUnpackingOutput);
      }
      packedReshape(input2, afterShape) {
        const input3DShape = [
          getBatchDim(input2.shape),
          ...getRowsCols(input2.shape)
        ];
        const input3D = {
          dtype: input2.dtype,
          shape: input3DShape,
          dataId: input2.dataId
        };
        const afterShapeAs3D = [
          getBatchDim(afterShape),
          ...getRowsCols(afterShape)
        ];
        const program = new ReshapePackedProgram(afterShapeAs3D, input3DShape);
        const preventEagerUnpackingOfOutput = true;
        const output = this.runWebGLProgram(program, [input3D], input2.dtype, null, preventEagerUnpackingOfOutput);
        return {dataId: output.dataId, shape: afterShape, dtype: output.dtype};
      }
      decode(dataId) {
        const texData = this.texData.get(dataId);
        const {isPacked, shape, dtype} = texData;
        const shapeAs3D = getShapeAs3D(shape);
        let program;
        if (isPacked) {
          program = new DecodeMatrixPackedProgram(shapeAs3D);
        } else {
          program = new DecodeMatrixProgram(shapeAs3D);
        }
        const preventEagerUnpackingOfOutput = true;
        const out = this.runWebGLProgram(program, [{shape: shapeAs3D, dtype, dataId}], dtype, null, preventEagerUnpackingOfOutput);
        return {dtype, shape, dataId: out.dataId};
      }
      runWebGLProgram(program, inputs, outputDtype, customSetup, preventEagerUnpackingOfOutput = false) {
        const output = this.makeTensorInfo(program.outputShape, outputDtype);
        const outData = this.texData.get(output.dataId);
        if (program.packedOutput) {
          outData.isPacked = true;
        }
        if (program.outPackingScheme === PackingScheme.DENSE) {
          const texelShape = getDenseTexShape(program.outputShape);
          outData.texShape = texelShape.map((d) => d * 2);
        }
        if (program.outTexUsage != null) {
          outData.usage = program.outTexUsage;
        }
        if (sizeFromShape2(output.shape) === 0) {
          outData.values = getTypedArrayFromDType2(output.dtype, 0);
          return output;
        }
        const dataToDispose = [];
        const inputsData = inputs.map((input2) => {
          if (input2.dtype === "complex64") {
            throw new Error(`GPGPUProgram does not support complex64 input. For complex64 dtypes, please separate the program into real and imaginary parts.`);
          }
          let texData = this.texData.get(input2.dataId);
          if (texData.texture == null) {
            if (!program.packedInputs && sizeFromShape2(input2.shape) <= env2().getNumber("WEBGL_SIZE_UPLOAD_UNIFORM")) {
              return {
                shape: input2.shape,
                texData: null,
                isUniform: true,
                uniformValues: texData.values
              };
            }
            if (program.packedInputs) {
              texData.isPacked = true;
              texData.shape = input2.shape;
            }
          } else if (!!texData.isPacked !== !!program.packedInputs) {
            input2 = texData.isPacked ? this.unpackTensor(input2) : this.packTensor(input2);
            dataToDispose.push(input2);
            texData = this.texData.get(input2.dataId);
          } else if (texData.isPacked && !isReshapeFree(texData.shape, input2.shape)) {
            const savedInput = input2;
            const targetShape = input2.shape;
            input2.shape = texData.shape;
            input2 = this.packedReshape(input2, targetShape);
            dataToDispose.push(input2);
            texData = this.texData.get(input2.dataId);
            savedInput.shape = targetShape;
          }
          this.uploadToGPU(input2.dataId);
          return {shape: input2.shape, texData, isUniform: false};
        });
        this.uploadToGPU(output.dataId);
        const outputData = {shape: output.shape, texData: outData, isUniform: false};
        const key = makeShaderKey(program, inputsData, outputData);
        const binary = this.getAndSaveBinary(key, () => {
          return compileProgram(this.gpgpu, program, inputsData, outputData);
        });
        const shouldTimeProgram = this.activeTimers != null;
        let query;
        if (shouldTimeProgram) {
          query = this.startTimer();
        }
        runProgram(this.gpgpu, binary, inputsData, outputData, customSetup);
        dataToDispose.forEach((info) => this.disposeIntermediateTensorInfo(info));
        if (shouldTimeProgram) {
          query = this.endTimer(query);
          this.activeTimers.push({name: program.constructor.name, query: this.getQueryTime(query)});
        }
        if (!env2().getBool("WEBGL_LAZILY_UNPACK") && outData.isPacked && preventEagerUnpackingOfOutput === false) {
          const unpacked = this.unpackTensor(output);
          this.disposeIntermediateTensorInfo(output);
          return unpacked;
        }
        return output;
      }
      compileAndRun(program, inputs, outputDtype, customSetup, preventEagerUnpackingOfOutput = false) {
        outputDtype = outputDtype || inputs[0].dtype;
        const outInfo = this.runWebGLProgram(program, inputs, outputDtype, customSetup, preventEagerUnpackingOfOutput);
        return engine19().makeTensorFromDataId(outInfo.dataId, outInfo.shape, outInfo.dtype);
      }
      getAndSaveBinary(key, getBinary) {
        if (!(key in this.binaryCache)) {
          this.binaryCache[key] = getBinary();
        }
        return this.binaryCache[key];
      }
      getTextureManager() {
        return this.textureManager;
      }
      dispose() {
        if (this.disposed) {
          return;
        }
        if (!env2().getBool("IS_TEST")) {
          const allKeys = Object.keys(this.binaryCache);
          allKeys.forEach((key) => {
            this.gpgpu.deleteProgram(this.binaryCache[key].webGLProgram);
            delete this.binaryCache[key];
          });
        }
        this.textureManager.dispose();
        if (this.canvas != null && (typeof HTMLCanvasElement !== "undefined" && this.canvas instanceof HTMLCanvasElement)) {
          this.canvas.remove();
        } else {
          this.canvas = null;
        }
        if (this.gpgpuCreatedLocally) {
          this.gpgpu.program = null;
          this.gpgpu.dispose();
        }
        this.disposed = true;
      }
      floatPrecision() {
        if (this.floatPrecisionValue == null) {
          this.floatPrecisionValue = tidy(() => {
            if (!env2().get("WEBGL_RENDER_FLOAT32_ENABLED")) {
              const debugFlag = env2().getBool("DEBUG");
              env2().set("DEBUG", false);
              const underflowCheckValue = this.abs(scalar3(1e-8)).dataSync()[0];
              env2().set("DEBUG", debugFlag);
              if (underflowCheckValue > 0) {
                return 32;
              }
            }
            return 16;
          });
        }
        return this.floatPrecisionValue;
      }
      epsilon() {
        return this.floatPrecision() === 32 ? EPSILON_FLOAT32$1 : EPSILON_FLOAT16$1;
      }
      uploadToGPU(dataId) {
        const texData = this.texData.get(dataId);
        const {shape, dtype, values, texture, usage, isPacked} = texData;
        if (texture != null) {
          return;
        }
        const shouldTimeProgram = this.activeTimers != null;
        let start;
        if (shouldTimeProgram) {
          start = now3();
        }
        let texShape = texData.texShape;
        if (texShape == null) {
          texShape = getTextureShapeFromLogicalShape(shape, isPacked);
          texData.texShape = texShape;
        }
        if (values != null) {
          const shapeAs3D = getShapeAs3D(shape);
          let program;
          let width = texShape[1], height = texShape[0];
          const isByteArray = values instanceof Uint8Array;
          if (isPacked) {
            [width, height] = getPackedMatrixTextureShapeWidthHeight(texShape[0], texShape[1]);
            program = new EncodeMatrixPackedProgram(shapeAs3D, [height, width], isByteArray);
          } else {
            program = new EncodeMatrixProgram(shapeAs3D, [height, width], isByteArray);
          }
          const tempDenseInputHandle = this.makeTensorInfo([height, width], dtype);
          if (isByteArray) {
            this.texData.get(tempDenseInputHandle.dataId).usage = TextureUsage.PIXELS;
          } else {
            this.texData.get(tempDenseInputHandle.dataId).usage = TextureUsage.UPLOAD;
          }
          this.gpgpu.uploadDenseMatrixToTexture(this.getTexture(tempDenseInputHandle.dataId), width, height, values);
          const preventEagerUnpacking = true;
          const encodedOutputTarget = this.runWebGLProgram(program, [tempDenseInputHandle], dtype, null, preventEagerUnpacking);
          const outputTexData = this.texData.get(encodedOutputTarget.dataId);
          texData.texture = outputTexData.texture;
          texData.texShape = outputTexData.texShape;
          texData.isPacked = outputTexData.isPacked;
          texData.usage = outputTexData.usage;
          this.disposeIntermediateTensorInfo(tempDenseInputHandle);
          this.texData.delete(encodedOutputTarget.dataId);
          texData.values = null;
          if (shouldTimeProgram) {
            this.uploadWaitMs += now3() - start;
          }
        } else {
          const newTexture = this.acquireTexture(texShape, usage, dtype, isPacked);
          texData.texture = newTexture;
        }
      }
      convertAndCacheOnCPU(dataId, float32Values) {
        const texData = this.texData.get(dataId);
        const {dtype} = texData;
        this.releaseGPUData(dataId);
        if (float32Values != null) {
          texData.values = float32ToTypedArray(float32Values, dtype);
        }
        return texData.values;
      }
      acquireTexture(texShape, texType, dtype, isPacked) {
        this.numBytesInGPU += this.computeBytes(texShape, dtype);
        if (!this.warnedAboutMemory && this.numBytesInGPU > this.numMBBeforeWarning * 1024 * 1024) {
          const mb = (this.numBytesInGPU / 1024 / 1024).toFixed(2);
          this.warnedAboutMemory = true;
          console.warn(`High memory usage in GPU: ${mb} MB, most likely due to a memory leak`);
        }
        return this.textureManager.acquireTexture(texShape, texType, isPacked);
      }
      computeBytes(shape, dtype) {
        return shape[0] * shape[1] * bytesPerElement2(dtype);
      }
      tryRunOnCpuOrThrow(inputs, fn) {
        if (this.shouldExecuteOnCPU(inputs)) {
          try {
            return fn();
          } catch (e) {
            if (env2().getBool("IS_TEST")) {
              throw new Error("CPU forwarding failed");
            }
          }
        }
        return null;
      }
    }
    function float32ToTypedArray(a, dtype) {
      if (dtype === "float32" || dtype === "complex64") {
        return a;
      } else if (dtype === "int32" || dtype === "bool") {
        const result = dtype === "int32" ? new Int32Array(a.length) : new Uint8Array(a.length);
        for (let i = 0; i < result.length; ++i) {
          result[i] = Math.round(a[i]);
        }
        return result;
      } else {
        throw new Error(`Unknown dtype ${dtype}`);
      }
    }
    /** @license See the LICENSE file. */
    const version$5 = "2.7.0";
    /**
     * @license
     * Copyright 2019 Google LLC. All Rights Reserved.
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     * http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     * =============================================================================
     */
    function forceHalfFloat() {
      env2().set("WEBGL_FORCE_F16_TEXTURES", true);
    }
    /**
     * @license
     * Copyright 2020 Google Inc. All Rights Reserved.
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     * http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     * =============================================================================
     */
    if (isBrowser()) {
      registerBackend2("webgl", () => new MathBackendWebGL(), 2);
    }
    const webgl = {forceHalfFloat};
    /**
     * @license
     * Copyright 2020 Google LLC. All Rights Reserved.
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     * http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     * =============================================================================
     */
    function identity$2(args) {
      const {inputs, backend: backend3} = args;
      const {x} = inputs;
      backend3.incRef(x.dataId);
      return {dataId: x.dataId, shape: x.shape, dtype: x.dtype};
    }
    const identityConfig$1 = {
      kernelName: Identity5,
      backendName: "webgl",
      kernelFunc: identity$2
    };
    /**
     * @license
     * Copyright 2020 Google LLC. All Rights Reserved.
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     * http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     * =============================================================================
     */
    function complex$2(args) {
      const {inputs, backend: backend3} = args;
      const {real: real2, imag: imag2} = inputs;
      const complexInfo = backend3.makeTensorInfo(real2.shape, "complex64");
      const complex4 = backend3.texData.get(complexInfo.dataId);
      const realTensorInfo = identity$2({inputs: {x: real2}, backend: backend3});
      const realData = backend3.texData.get(realTensorInfo.dataId);
      realData.complexParentRefCount++;
      const imagTensorInfo = identity$2({inputs: {x: imag2}, backend: backend3});
      const imagData = backend3.texData.get(imagTensorInfo.dataId);
      imagData.complexParentRefCount++;
      complex4.complexTensorInfos = {real: realTensorInfo, imag: imagTensorInfo};
      return complexInfo;
    }
    const complexConfig$1 = {
      kernelName: Complex2,
      backendName: "webgl",
      kernelFunc: complex$2
    };
    /**
     * @license
     * Copyright 2020 Google LLC. All Rights Reserved.
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     * http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     * =============================================================================
     */
    const CHECK_NAN_SNIPPET_UNARY = `if (isnan(x)) return x;`;
    const CHECK_NAN_SNIPPET_BINARY = `
  if (isnan(a)) return a;
  if (isnan(b)) return b;
`;
    const CHECK_NAN_SNIPPET_BINARY_PACKED = `
  result.r = isNaN.r > 0. ? NAN : result.r;
  result.g = isNaN.g > 0. ? NAN : result.g;
  result.b = isNaN.b > 0. ? NAN : result.b;
  result.a = isNaN.a > 0. ? NAN : result.a;
`;
    function unaryKernelFunc$1(opSnippet) {
      return ({inputs, backend: backend3}) => {
        const {x} = inputs;
        const webglBackend = backend3;
        const program = new UnaryOpProgram(x.shape, opSnippet);
        return webglBackend.runWebGLProgram(program, [x], x.dtype);
      };
    }
    function binaryKernelFunc$1({opSnippet, packedOpSnippet, checkOutOfBounds = false, supportsComplex = false, cpuKernelImpl, dtype}) {
      return ({inputs, backend: backend3}) => {
        const {a, b} = inputs;
        const webglBackend = backend3;
        if (supportsComplex && a.dtype === "complex64") {
          const aData = webglBackend.texData.get(a.dataId);
          const bData = webglBackend.texData.get(b.dataId);
          const [real2, imag2] = [
            [aData.complexTensorInfos.real, bData.complexTensorInfos.real],
            [aData.complexTensorInfos.imag, bData.complexTensorInfos.imag]
          ].map((complexParts) => {
            const [aPart, bPart] = complexParts;
            const aHandle = {
              dataId: aPart.dataId,
              dtype: aPart.dtype,
              shape: a.shape
            };
            const bHandle = {
              dataId: bPart.dataId,
              dtype: bPart.dtype,
              shape: b.shape
            };
            const program2 = new BinaryOpProgram(opSnippet, a.shape, b.shape);
            return webglBackend.runWebGLProgram(program2, [aHandle, bHandle], upcastType2(aPart.dtype, bPart.dtype));
          });
          const complexOutput = complex$2({inputs: {real: real2, imag: imag2}, backend: webglBackend});
          webglBackend.disposeIntermediateTensorInfo(real2);
          webglBackend.disposeIntermediateTensorInfo(imag2);
          return complexOutput;
        }
        const $dtype = dtype || upcastType2(a.dtype, b.dtype);
        if (webglBackend.shouldExecuteOnCPU([a, b]) && cpuKernelImpl != null) {
          const aData = webglBackend.texData.get(a.dataId);
          const bData = webglBackend.texData.get(b.dataId);
          const [outValues, outShape] = cpuKernelImpl(a.shape, b.shape, aData.values, bData.values, $dtype);
          const out = webglBackend.makeTensorInfo(outShape, $dtype);
          const outData = webglBackend.texData.get(out.dataId);
          outData.values = outValues;
          return out;
        }
        const shouldUsePackedProgram = env2().getBool("WEBGL_PACK_BINARY_OPERATIONS") && packedOpSnippet != null;
        let program;
        if (shouldUsePackedProgram) {
          program = new BinaryOpPackedProgram(packedOpSnippet, a.shape, b.shape, checkOutOfBounds);
        } else {
          program = new BinaryOpProgram(opSnippet, a.shape, b.shape);
        }
        return webglBackend.runWebGLProgram(program, [a, b], $dtype);
      };
    }
    /**
     * @license
     * Copyright 2020 Google LLC. All Rights Reserved.
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     * http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     * =============================================================================
     */
    const ADD = "return a + b;";
    const addKernelFunc = binaryKernelFunc$1({
      opSnippet: ADD,
      packedOpSnippet: ADD,
      supportsComplex: true,
      cpuKernelImpl: addImplCPU
    });
    const addConfig$1 = {
      kernelName: Add3,
      backendName: "webgl",
      kernelFunc: addKernelFunc
    };
    /**
     * @license
     * Copyright 2020 Google LLC. All Rights Reserved.
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     * http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     * =============================================================================
     */
    const ATAN2 = CHECK_NAN_SNIPPET_BINARY + `
  return atan(a, b);
`;
    const ATAN2_PACKED = `
  vec4 result = atan(a, b);
  vec4 isNaN = min(vec4(isnan(a)) + vec4(isnan(b)), vec4(1.0));
  ` + CHECK_NAN_SNIPPET_BINARY_PACKED + `
  return result;
`;
    const atan2$1 = binaryKernelFunc$1({opSnippet: ATAN2, packedOpSnippet: ATAN2_PACKED});
    const atan2Config = {
      kernelName: Atan2,
      backendName: "webgl",
      kernelFunc: atan2$1
    };
    /**
     * @license
     * Copyright 2020 Google LLC. All Rights Reserved.
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     * http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     * =============================================================================
     */
    function avgPool$2(args) {
      const {inputs, backend: backend3, attrs} = args;
      const {x} = inputs;
      assertNotComplex$1(x, "avgPool");
      const {filterSize, strides, pad: pad3, dimRoundingMode} = attrs;
      const dilations = 1;
      assert2(eitherStridesOrDilationsAreOne2(strides, dilations), () => `Error in avgPool: Either strides or dilations must be 1. Got strides ${strides} and dilations '${dilations}'`);
      const convInfo = computePool2DInfo2(x.shape, filterSize, strides, dilations, pad3, dimRoundingMode);
      if (convInfo.filterWidth === 1 && convInfo.filterHeight === 1 && arraysEqual2(convInfo.inShape, convInfo.outShape)) {
        return identity$2({inputs: {x}, backend: backend3});
      }
      const avgPoolProgram = new Pool2DProgram(convInfo, "avg", false);
      return backend3.runWebGLProgram(avgPoolProgram, [x], "float32");
    }
    const avgPoolConfig$1 = {
      kernelName: AvgPool3,
      backendName: "webgl",
      kernelFunc: avgPool$2
    };
    /**
     * @license
     * Copyright 2020 Google LLC. All Rights Reserved.
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     * http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     * =============================================================================
     */
    function avgPoolBackprop$2(args) {
      const {inputs, backend: backend3, attrs} = args;
      const {dy, input: input2} = inputs;
      const x = input2;
      assertNotComplex$1([dy, input2], "avgPoolBackprop");
      const {filterSize, strides, pad: pad3} = attrs;
      const convInfo = computePool2DInfo2(x.shape, filterSize, strides, 1, pad3);
      const avgPoolBackpropProgram = new AvgPool2DBackpropProgram(convInfo);
      return backend3.runWebGLProgram(avgPoolBackpropProgram, [dy], x.dtype);
    }
    const avgPoolBackpropConfig$1 = {
      kernelName: AvgPoolBackprop,
      backendName: "webgl",
      kernelFunc: avgPoolBackprop$2
    };
    /**
     * @license
     * Copyright 2017 Google LLC. All Rights Reserved.
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     * http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     * =============================================================================
     */
    class BatchNormProgram {
      constructor(xShape, meanShape, varianceShape, offsetShape, scaleShape, varianceEpsilon) {
        this.outputShape = [];
        this.variableNames = ["x", "mean", "variance"];
        assertAndGetBroadcastShape2(xShape, meanShape);
        assertAndGetBroadcastShape2(xShape, varianceShape);
        let offsetSnippet = "0.0";
        if (offsetShape != null) {
          assertAndGetBroadcastShape2(xShape, offsetShape);
          this.variableNames.push("offset");
          offsetSnippet = "getOffsetAtOutCoords()";
        }
        let scaleSnippet = "1.0";
        if (scaleShape != null) {
          assertAndGetBroadcastShape2(xShape, scaleShape);
          this.variableNames.push("scale");
          scaleSnippet = "getScaleAtOutCoords()";
        }
        this.outputShape = xShape;
        this.userCode = `
      void main() {
        float x = getXAtOutCoords();
        float mean = getMeanAtOutCoords();
        float variance = getVarianceAtOutCoords();
        float offset = ${offsetSnippet};
        float scale = ${scaleSnippet};
        float inv = scale * inversesqrt(variance + float(${varianceEpsilon}));
        setOutput(dot(vec3(x, -mean, offset), vec3(inv, inv, 1)));
      }
    `;
      }
    }
    /**
     * @license
     * Copyright 2018 Google LLC. All Rights Reserved.
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     * http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     * =============================================================================
     */
    class BatchNormPackedProgram {
      constructor(xShape, meanShape, varianceShape, offsetShape, scaleShape, varianceEpsilon) {
        this.packedInputs = true;
        this.packedOutput = true;
        this.variableNames = ["x", "mean", "variance"];
        assertAndGetBroadcastShape2(xShape, meanShape);
        assertAndGetBroadcastShape2(xShape, varianceShape);
        let offsetSnippet = "vec4(0.0)";
        if (offsetShape != null) {
          assertAndGetBroadcastShape2(xShape, offsetShape);
          this.variableNames.push("offset");
          offsetSnippet = "getOffsetAtOutCoords()";
        }
        let scaleSnippet = "vec4(1.0)";
        if (scaleShape != null) {
          assertAndGetBroadcastShape2(xShape, scaleShape);
          this.variableNames.push("scale");
          scaleSnippet = "getScaleAtOutCoords()";
        }
        this.outputShape = xShape;
        this.userCode = `
      void main() {
        vec4 offset = ${offsetSnippet};
        vec4 scale = ${scaleSnippet};

        vec4 x = getXAtOutCoords();
        vec4 mean = getMeanAtOutCoords();
        vec4 variance = getVarianceAtOutCoords();

        vec4 inv = scale * inversesqrt(variance + vec4(${varianceEpsilon}));

        setOutput((x - mean) * inv + offset);
      }
    `;
      }
    }
    /**
     * @license
     * Copyright 2020 Google LLC. All Rights Reserved.
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     * http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     * =============================================================================
     */
    const batchNorm$2 = ({inputs, backend: backend3, attrs}) => {
      const {x, mean: mean2, variance: variance2, offset, scale: scale2} = inputs;
      assert2(mean2.shape.length === variance2.shape.length, () => "Batch normalization gradient requires mean and variance to have equal ranks.");
      assert2(offset == null || mean2.shape.length === offset.shape.length, () => "Batch normalization gradient requires mean and offset to have equal ranks.");
      assert2(scale2 == null || mean2.shape.length === scale2.shape.length, () => "Batch normalization gradient requires mean and scale to have equal ranks.");
      let {varianceEpsilon} = attrs;
      if (varianceEpsilon == null) {
        varianceEpsilon = 1e-3;
      }
      const finalInputs = [x, mean2, variance2];
      let offsetShape = null;
      if (offset != null) {
        offsetShape = offset.shape;
        finalInputs.push(offset);
      }
      let scaleShape = null;
      if (scale2 != null) {
        scaleShape = scale2.shape;
        finalInputs.push(scale2);
      }
      const program = env2().getBool("WEBGL_PACK_NORMALIZATION") ? new BatchNormPackedProgram(x.shape, mean2.shape, variance2.shape, offsetShape, scaleShape, varianceEpsilon) : new BatchNormProgram(x.shape, mean2.shape, variance2.shape, offsetShape, scaleShape, varianceEpsilon);
      const output = backend3.runWebGLProgram(program, finalInputs, finalInputs[0].dtype);
      return output;
    };
    const batchNormConfig$1 = {
      kernelName: FusedBatchNorm3,
      backendName: "webgl",
      kernelFunc: batchNorm$2
    };
    /**
     * @license
     * Copyright 2020 Google LLC. All Rights Reserved.
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     * http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     * =============================================================================
     */
    const NOT_EQUAL$1 = `return float(a != b);`;
    const notEqual$2 = binaryKernelFunc$1({opSnippet: NOT_EQUAL$1, dtype: "bool"});
    const notEqualConfig$1 = {
      kernelName: NotEqual3,
      backendName: "webgl",
      kernelFunc: notEqual$2
    };
    /**
     * @license
     * Copyright 2020 Google LLC. All Rights Reserved.
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     * http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     * =============================================================================
     */
    function real$2(args) {
      const {inputs, backend: backend3} = args;
      const {input: input2} = inputs;
      const inputData = backend3.texData.get(input2.dataId);
      return identity$2({inputs: {x: inputData.complexTensorInfos.real}, backend: backend3});
    }
    const realConfig$1 = {
      kernelName: Real,
      backendName: "webgl",
      kernelFunc: real$2
    };
    /**
     * @license
     * Copyright 2020 Google LLC. All Rights Reserved.
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     * http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     * =============================================================================
     */
    const TO_INT = `return float(int(x));`;
    function int(input2, backend3) {
      const program = new UnaryOpProgram(input2.shape, TO_INT);
      const output = backend3.runWebGLProgram(program, [input2], "int32");
      return {dataId: output.dataId, shape: output.shape, dtype: output.dtype};
    }
    /**
     * @license
     * Copyright 2020 Google LLC. All Rights Reserved.
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     * http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     * =============================================================================
     */
    function cast$3(args) {
      const {inputs, backend: backend3, attrs} = args;
      const {x} = inputs;
      const {dtype} = attrs;
      if (dtype === "complex64") {
        if (x.dtype === "complex64") {
          return identity$2({inputs: {x}, backend: backend3});
        }
        const zerosTensor = zeros3(x.shape);
        const floatX = cast$3({inputs: {x}, backend: backend3, attrs: {dtype: "float32"}});
        const result = complex$2({inputs: {real: floatX, imag: zerosTensor}, backend: backend3});
        zerosTensor.dispose();
        backend3.disposeIntermediateTensorInfo(floatX);
        return result;
      }
      if (x.dtype === "complex64") {
        const realPart = real$2({inputs: {input: x}, backend: backend3});
        const result = cast$3({inputs: {x: realPart}, backend: backend3, attrs: {dtype}});
        backend3.disposeIntermediateTensorInfo(realPart);
        return result;
      }
      if (!hasEncodingLoss2(x.dtype, dtype)) {
        const result = identity$2({inputs: {x}, backend: backend3});
        return {dataId: result.dataId, shape: result.shape, dtype};
      }
      if (dtype === "int32") {
        return int(x, backend3);
      }
      if (dtype === "bool") {
        const zerosTensorInfo = backend3.makeTensorInfo([], "bool", getTypedArrayFromDType2("bool", 1));
        const binaryInputs = {a: x, b: zerosTensorInfo};
        const result = notEqual$2({inputs: binaryInputs, backend: backend3});
        backend3.disposeIntermediateTensorInfo(zerosTensorInfo);
        return result;
      }
      throw new Error(`Error in Cast: failed to cast ${x.dtype} to ${dtype}`);
    }
    const castConfig$1 = {
      kernelName: Cast5,
      backendName: "webgl",
      kernelFunc: cast$3
    };
    /**
     * @license
     * Copyright 2017 Google LLC. All Rights Reserved.
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     * http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     * =============================================================================
     */
    class ConcatProgram {
      constructor(shapes) {
        this.outputShape = [];
        this.outputShape = computeOutShape$1(shapes, 1);
        this.variableNames = shapes.map((_, i) => `T${i}`);
        const offsets = new Array(shapes.length - 1);
        offsets[0] = shapes[0][1];
        for (let i = 1; i < offsets.length; i++) {
          offsets[i] = offsets[i - 1] + shapes[i][1];
        }
        const snippets = [`if (yC < ${offsets[0]}) setOutput(getT0(yR, yC));`];
        for (let i = 1; i < offsets.length; i++) {
          const shift = offsets[i - 1];
          snippets.push(`else if (yC < ${offsets[i]}) setOutput(getT${i}(yR, yC-${shift}));`);
        }
        const lastIndex = offsets.length;
        const lastShift = offsets[offsets.length - 1];
        snippets.push(`else setOutput(getT${lastIndex}(yR, yC-${lastShift}));`);
        this.userCode = `
      void main() {
        ivec2 coords = getOutputCoords();
        int yR = coords.x;
        int yC = coords.y;

        ${snippets.join("\n        ")}
      }
    `;
      }
    }
    /**
     * @license
     * Copyright 2019 Google LLC. All Rights Reserved.
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     * http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     * =============================================================================
     */
    class ConcatPackedProgram {
      constructor(shapes, axis) {
        this.packedInputs = true;
        this.packedOutput = true;
        this.outputShape = [];
        this.outputShape = computeOutShape$1(shapes, axis);
        const shape = this.outputShape;
        const rank = shape.length;
        const dtype = getCoordsDataType(rank);
        const coords2 = getChannels("coords", rank);
        const channels = ["x", "y", "z", "w", "u", "v"].slice(0, rank);
        this.variableNames = shapes.map((_, i) => `T${i}`);
        const offsets = new Array(shapes.length - 1);
        offsets[0] = shapes[0][axis];
        for (let i = 1; i < offsets.length; i++) {
          offsets[i] = offsets[i - 1] + shapes[i][axis];
        }
        const channel = channels[axis];
        const lastChannels = channels.slice(-2);
        const allChannels = channels.join();
        let getValueSnippet = `if (${channel} < ${offsets[0]}) {
        return getChannel(
            getT0(${allChannels}), vec2(${lastChannels.join()}));
        }`;
        for (let i = 1; i < offsets.length; i++) {
          const shift2 = offsets[i - 1];
          getValueSnippet += `
        if (${channel} < ${offsets[i]}  && ${channel} >= ${offsets[i - 1]}) {
          return getChannel(
            getT${i}(${shiftedChannels(channels, channel, shift2)}),
            vec2(${shiftedChannels(lastChannels, channel, shift2)}));
        }`;
        }
        const lastIndex = offsets.length;
        const shift = offsets[offsets.length - 1];
        getValueSnippet += `
        return getChannel(
          getT${lastIndex}(${shiftedChannels(channels, channel, shift)}),
          vec2(${shiftedChannels(lastChannels, channel, shift)}));`;
        this.userCode = `
      float getValue(${channels.map((x) => "int " + x)}) {
        ${getValueSnippet}
      }

      void main() {
        ${dtype} coords = getOutputCoords();
        vec4 result = vec4(getValue(${coords2}), 0., 0., 0.);

        ${coords2[rank - 1]} = ${coords2[rank - 1]} + 1;
        if (${coords2[rank - 1]} < ${shape[rank - 1]}) {
          result.g = getValue(${coords2});
        }

        ${coords2[rank - 2]} = ${coords2[rank - 2]} + 1;
        if (${coords2[rank - 2]} < ${shape[rank - 2]}) {
          result.a = getValue(${coords2});
        }

        ${coords2[rank - 1]} = ${coords2[rank - 1]} - 1;
        if (${coords2[rank - 2]} < ${shape[rank - 2]} &&
            ${coords2[rank - 1]} < ${shape[rank - 1]}) {
          result.b = getValue(${coords2});
        }
        setOutput(result);
      }
    `;
      }
    }
    function shiftedChannels(channels, channel, shift) {
      const channelIdx = channels.indexOf(channel);
      const res = channels.map((c, idx) => {
        if (idx === channelIdx) {
          return `${c} - ${shift}`;
        } else {
          return c;
        }
      });
      return res.join();
    }
    /**
     * @license
     * Copyright 2020 Google LLC. All Rights Reserved.
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     * http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     * =============================================================================
     */
    function imag$2(args) {
      const {inputs, backend: backend3} = args;
      const {input: input2} = inputs;
      const inputData = backend3.texData.get(input2.dataId);
      return identity$2({inputs: {x: inputData.complexTensorInfos.imag}, backend: backend3});
    }
    const imagConfig$1 = {
      kernelName: Imag,
      backendName: "webgl",
      kernelFunc: imag$2
    };
    /**
     * @license
     * Copyright 2020 Google LLC. All Rights Reserved.
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     * http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     * =============================================================================
     */
    function packedReshape(input2, afterShape, backend3) {
      const input3DShape = [
        getBatchDim(input2.shape),
        ...getRowsCols(input2.shape)
      ];
      const input3D = {
        dtype: input2.dtype,
        shape: input3DShape,
        dataId: input2.dataId
      };
      const afterShapeAs3D = [
        getBatchDim(afterShape),
        ...getRowsCols(afterShape)
      ];
      const program = new ReshapePackedProgram(afterShapeAs3D, input3DShape);
      const preventEagerUnpackingOfOutput = true;
      const output = backend3.runWebGLProgram(program, [input3D], input2.dtype, null, preventEagerUnpackingOfOutput);
      return {dataId: output.dataId, shape: afterShape, dtype: output.dtype};
    }
    /**
     * @license
     * Copyright 2020 Google LLC. All Rights Reserved.
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     * http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     * =============================================================================
     */
    function reshape$3(args) {
      const {inputs, backend: backend3, attrs} = args;
      const {x} = inputs;
      const {shape} = attrs;
      const webglBackend = backend3;
      const xSize = sizeFromShape2(x.shape);
      const $shape = inferFromImplicitShape2(shape, xSize);
      const $xSize = sizeFromShape2($shape);
      assert2(xSize === $xSize, () => `The new shape (${$shape}) has ${$xSize} elements and the old shape (${x.shape}) has ${xSize} elements. The new shape and old shape must have the same number of elements.`);
      const xTexData = webglBackend.texData.get(x.dataId);
      if (xTexData.isPacked && !isReshapeFree(x.shape, $shape) && !(xTexData.texture !== null && isReshapeFree(xTexData.shape, $shape))) {
        return packedReshape(x, $shape, webglBackend);
      }
      webglBackend.incRef(x.dataId);
      return {dataId: x.dataId, shape: $shape, dtype: x.dtype};
    }
    const reshapeConfig$1 = {
      kernelName: Reshape6,
      backendName: "webgl",
      kernelFunc: reshape$3
    };
    /**
     * @license
     * Copyright 2020 Google LLC. All Rights Reserved.
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     * http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     * =============================================================================
     */
    function concatImpl(inputs, axis, backend3) {
      const dtype = inputs[0].dtype;
      if (dtype === "complex64") {
        const reals = inputs.map((t) => real$2({inputs: {input: t}, backend: backend3}));
        const imags = inputs.map((t) => imag$2({inputs: {input: t}, backend: backend3}));
        const realConcated = concatImpl(reals, axis, backend3);
        const imagConcated = concatImpl(imags, axis, backend3);
        const result2 = complex$2({inputs: {real: realConcated, imag: imagConcated}, backend: backend3});
        reals.forEach((r) => backend3.disposeIntermediateTensorInfo(r));
        imags.forEach((i) => backend3.disposeIntermediateTensorInfo(i));
        backend3.disposeIntermediateTensorInfo(realConcated);
        backend3.disposeIntermediateTensorInfo(imagConcated);
        return result2;
      }
      if (inputs.length > env2().getNumber("WEBGL_MAX_TEXTURES_IN_SHADER")) {
        const midIndex = Math.floor(inputs.length / 2);
        const leftSide = concatImpl(inputs.slice(0, midIndex), axis, backend3);
        const rightSide = concatImpl(inputs.slice(midIndex), axis, backend3);
        const result2 = concatImpl([leftSide, rightSide], axis, backend3);
        backend3.disposeIntermediateTensorInfo(leftSide);
        backend3.disposeIntermediateTensorInfo(rightSide);
        return result2;
      }
      if (env2().getBool("WEBGL_PACK_ARRAY_OPERATIONS") && inputs[0].shape.length > 1) {
        const program2 = new ConcatPackedProgram(inputs.map((t) => t.shape), axis);
        return backend3.runWebGLProgram(program2, inputs, dtype);
      }
      const outShape = computeOutShape$1(inputs.map((t) => t.shape), axis);
      const tensors2D = inputs.map((x) => reshape$3({
        inputs: {x},
        attrs: {shape: [-1, sizeFromShape2(x.shape.slice(axis))]},
        backend: backend3
      }));
      const program = new ConcatProgram(tensors2D.map((t) => t.shape));
      const result = backend3.runWebGLProgram(program, tensors2D, dtype);
      tensors2D.forEach((r) => backend3.disposeIntermediateTensorInfo(r));
      const reshapedResult = reshape$3({inputs: {x: result}, attrs: {shape: outShape}, backend: backend3});
      backend3.disposeIntermediateTensorInfo(result);
      return reshapedResult;
    }
    /**
     * @license
     * Copyright 2020 Google LLC. All Rights Reserved.
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     * http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     * =============================================================================
     */
    function concat$2(args) {
      const {inputs, backend: backend3, attrs} = args;
      const {axis} = attrs;
      const $axis = parseAxisParam2(axis, inputs[0].shape)[0];
      const outShape = computeOutShape$1(inputs.map((t) => t.shape), $axis);
      if (sizeFromShape2(outShape) === 0) {
        return backend3.makeTensorInfo(outShape, inputs[0].dtype, []);
      }
      const $inputs = inputs.filter((t) => sizeFromShape2(t.shape) > 0);
      if ($inputs.length === 1) {
        return $inputs[0];
      }
      const shapes = $inputs.map((t) => t.shape);
      assertParamsConsistent2(shapes, $axis);
      return concatImpl($inputs, $axis, backend3);
    }
    const concatConfig$1 = {
      kernelName: Concat3,
      backendName: "webgl",
      kernelFunc: concat$2
    };
    /**
     * @license
     * Copyright 2020 Google LLC. All Rights Reserved.
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     * http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     * =============================================================================
     */
    const COS = CHECK_NAN_SNIPPET_UNARY + `
  return cos(x);
`;
    const cos$2 = unaryKernelFunc$1(COS);
    const cosConfig$1 = {
      kernelName: Cos3,
      backendName: "webgl",
      kernelFunc: cos$2
    };
    /**
     * @license
     * Copyright 2020 Google LLC. All Rights Reserved.
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     * http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     * =============================================================================
     */
    const DIV = `
if (a == b) {
  return 1.0;
};
return a / b;`;
    const DIV_PACKED = `
  // vec4 one = vec4(equal(a, b));
  // return one + (vec4(1.0) - one) * a / b;
  vec4 result = a / b;
  if(a.x == b.x) {
    result.x = 1.;
  }
  if(a.y == b.y) {
    result.y = 1.;
  }
  if(a.z == b.z) {
    result.z = 1.;
  }
  if(a.w == b.w) {
    result.w = 1.;
  }

  return result;
`;
    const div$2 = binaryKernelFunc$1({opSnippet: DIV, packedOpSnippet: DIV_PACKED, checkOutOfBounds: true});
    const divConfig$1 = {
      kernelName: Div3,
      backendName: "webgl",
      kernelFunc: div$2
    };
    /**
     * @license
     * Copyright 2018 Google LLC. All Rights Reserved.
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     * http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     * =============================================================================
     */
    class FFTProgram {
      constructor(component, inputShape, inverse) {
        this.variableNames = ["real", "imag"];
        const innerDim = inputShape[1];
        this.outputShape = inputShape;
        const exponentMultiplierSnippet = inverse ? `2.0 * ${Math.PI}` : `-2.0 * ${Math.PI}`;
        const resultDenominator = inverse ? `${innerDim}.0` : "1.0";
        let opString;
        if (component === "real") {
          opString = "return real * expR - imag * expI;";
        } else if (component === "imag") {
          opString = "return real * expI + imag * expR;";
        } else {
          throw new Error(`FFT component must be either "real" or "imag", got ${component}.`);
        }
        this.userCode = `
      const float exponentMultiplier = ${exponentMultiplierSnippet};

      float unaryOpComplex(float real, float expR, float imag, float expI) {
        ${opString}
      }

      float mulMatDFT(int batch, int index) {
        float indexRatio = float(index) / float(${innerDim});
        float exponentMultiplierTimesIndexRatio =
            exponentMultiplier * indexRatio;

        float result = 0.0;

        for (int i = 0; i < ${innerDim}; i++) {
          // x = (-2|2 * PI / N) * index * i;
          float x = exponentMultiplierTimesIndexRatio * float(i);
          float expR = cos(x);
          float expI = sin(x);
          float real = getReal(batch, i);
          float imag = getImag(batch, i);

          result +=
              unaryOpComplex(real, expR, imag, expI) / ${resultDenominator};
        }

        return result;
      }

      void main() {
        ivec2 coords = getOutputCoords();
        setOutput(mulMatDFT(coords[0], coords[1]));
      }
    `;
      }
    }
    /**
     * @license
     * Copyright 2020 Google LLC. All Rights Reserved.
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     * http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     * =============================================================================
     */
    function fftImpl$1(x, inverse, backend3) {
      const xData = backend3.texData.get(x.dataId);
      const inputSize = sizeFromShape2(x.shape);
      const innerDimensionSize = x.shape[x.shape.length - 1];
      const batch = inputSize / innerDimensionSize;
      const input2D = reshape$3({inputs: {x}, backend: backend3, attrs: {shape: [batch, innerDimensionSize]}});
      const xShape = input2D.shape;
      const realProgram = new FFTProgram("real", xShape, inverse);
      const imagProgram = new FFTProgram("imag", xShape, inverse);
      const inputs = [
        {
          dataId: xData.complexTensorInfos.real.dataId,
          dtype: xData.complexTensorInfos.real.dtype,
          shape: xShape
        },
        {
          dataId: xData.complexTensorInfos.imag.dataId,
          dtype: xData.complexTensorInfos.imag.dtype,
          shape: xShape
        }
      ];
      const realPart = backend3.runWebGLProgram(realProgram, inputs, "float32");
      const imagPart = backend3.runWebGLProgram(imagProgram, inputs, "float32");
      const complexOutput = complex$2({inputs: {real: realPart, imag: imagPart}, backend: backend3});
      backend3.disposeIntermediateTensorInfo(realPart);
      backend3.disposeIntermediateTensorInfo(imagPart);
      const complexOutputReshaped = reshape$3({inputs: {x: complexOutput}, backend: backend3, attrs: {shape: x.shape}});
      backend3.disposeIntermediateTensorInfo(complexOutputReshaped);
      return complexOutputReshaped;
    }
    /**
     * @license
     * Copyright 2020 Google LLC. All Rights Reserved.
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     * http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     * =============================================================================
     */
    function fft$2(args) {
      const {inputs, backend: backend3} = args;
      const {input: input2} = inputs;
      return fftImpl$1(input2, false, backend3);
    }
    const fftConfig$1 = {
      kernelName: FFT,
      backendName: "webgl",
      kernelFunc: fft$2
    };
    /**
     * @license
     * Copyright 2020 Google LLC. All Rights Reserved.
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     * http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     * =============================================================================
     */
    class FlipLeftRightProgram {
      constructor(imageShape) {
        this.variableNames = ["Image"];
        this.outputShape = [];
        const imageWidth = imageShape[2];
        this.outputShape = imageShape;
        this.userCode = `
        void main() {
          ivec4 coords = getOutputCoords();
          int x = coords[2];

          int coordX = ${imageWidth} - x;
          float outputValue;
          if(coordX >= 0 && coordX < ${imageWidth}) {
            outputValue = getImage(coords[0], coords[1], coordX, coords[3]);
          } else {
            outputValue = getImage(coords[0], coords[1], coords[2], coords[3]);
          }
          setOutput(outputValue);
        }
    `;
      }
    }
    /**
     * @license
     * Copyright 2020 Google LLC. All Rights Reserved.
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     * http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     * =============================================================================
     */
    const flipLeftRightConfig$1 = {
      kernelName: FlipLeftRight3,
      backendName: "webgl",
      kernelFunc: ({inputs, backend: backend3}) => {
        const {image: image3} = inputs;
        const webglBackend = backend3;
        const program = new FlipLeftRightProgram(image3.shape);
        const output = webglBackend.runWebGLProgram(program, [image3], image3.dtype);
        return output;
      }
    };
    /**
     * @license
     * Copyright 2018 Google LLC. All Rights Reserved.
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     * http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     * =============================================================================
     */
    class FromPixelsProgram {
      constructor(outputShape) {
        this.variableNames = ["A"];
        const glsl = getGlslDifferences();
        const [height, width] = outputShape;
        this.outputShape = outputShape;
        this.userCode = `
      void main() {
        ivec3 coords = getOutputCoords();
        int texR = coords[0];
        int texC = coords[1];
        int depth = coords[2];
        vec2 uv = (vec2(texC, texR) + halfCR) / vec2(${width}.0, ${height}.0);

        vec4 values = ${glsl.texture2D}(A, uv);
        float value;
        if (depth == 0) {
          value = values.r;
        } else if (depth == 1) {
          value = values.g;
        } else if (depth == 2) {
          value = values.b;
        } else if (depth == 3) {
          value = values.a;
        }

        setOutput(floor(value * 255.0 + 0.5));
      }
    `;
      }
    }
    /**
     * @license
     * Copyright 2018 Google LLC. All Rights Reserved.
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     * http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     * =============================================================================
     */
    class FromPixelsPackedProgram {
      constructor(outputShape) {
        this.variableNames = ["A"];
        this.packedInputs = false;
        this.packedOutput = true;
        const glsl = getGlslDifferences();
        const [height, width] = outputShape;
        this.outputShape = outputShape;
        this.userCode = `
      void main() {
        ivec3 coords = getOutputCoords();
        int texR = coords[0];
        int texC = coords[1];
        int depth = coords[2];

        vec4 result = vec4(0.);

        for(int row=0; row<=1; row++) {
          for(int col=0; col<=1; col++) {
            texC = coords[1] + row;
            depth = coords[2] + col;

            vec2 uv = (vec2(texC, texR) + halfCR) /
                       vec2(${width}.0, ${height}.0);
            vec4 values = ${glsl.texture2D}(A, uv);
            float value;
            if (depth == 0) {
              value = values.r;
            } else if (depth == 1) {
              value = values.g;
            } else if (depth == 2) {
              value = values.b;
            } else if (depth == 3) {
              value = values.a;
            }

            result[row * 2 + col] = floor(value * 255.0 + 0.5);
          }
        }

        ${glsl.output} = result;
      }
    `;
      }
    }
    /**
     * @license
     * Copyright 2019 Google LLC. All Rights Reserved.
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     * http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     * =============================================================================
     */
    const fromPixelsConfig = {
      kernelName: FromPixels,
      backendName: "webgl",
      kernelFunc: fromPixels$1
    };
    let fromPixels2DContext$1;
    function fromPixels$1(args) {
      const {inputs, backend: backend3, attrs} = args;
      let {pixels} = inputs;
      const {numChannels} = attrs;
      const isVideo = typeof HTMLVideoElement !== "undefined" && pixels instanceof HTMLVideoElement;
      const isImage = typeof HTMLImageElement !== "undefined" && pixels instanceof HTMLImageElement;
      const [width, height] = isVideo ? [
        pixels.videoWidth,
        pixels.videoHeight
      ] : [pixels.width, pixels.height];
      const texShape = [height, width];
      const outShape = [height, width, numChannels];
      if (isImage || isVideo) {
        if (fromPixels2DContext$1 == null) {
          fromPixels2DContext$1 = document.createElement("canvas").getContext("2d");
        }
        fromPixels2DContext$1.canvas.width = width;
        fromPixels2DContext$1.canvas.height = height;
        fromPixels2DContext$1.drawImage(pixels, 0, 0, width, height);
        pixels = fromPixels2DContext$1.canvas;
      }
      const tempPixelHandle = backend3.makeTensorInfo(texShape, "int32");
      backend3.texData.get(tempPixelHandle.dataId).usage = TextureUsage.PIXELS;
      backend3.gpgpu.uploadPixelDataToTexture(backend3.getTexture(tempPixelHandle.dataId), pixels);
      const program = env2().getBool("WEBGL_PACK") ? new FromPixelsPackedProgram(outShape) : new FromPixelsProgram(outShape);
      const res = backend3.runWebGLProgram(program, [tempPixelHandle], "int32");
      backend3.disposeData(tempPixelHandle.dataId);
      return res;
    }
    /**
     * @license
     * Copyright 2020 Google LLC. All Rights Reserved.
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     * http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     * =============================================================================
     */
    function ifft$2(args) {
      const {inputs, backend: backend3} = args;
      const {input: input2} = inputs;
      return fftImpl$1(input2, true, backend3);
    }
    const ifftConfig$1 = {
      kernelName: IFFT,
      backendName: "webgl",
      kernelFunc: ifft$2
    };
    /**
     * @license
     * Copyright 2020 Google LLC. All Rights Reserved.
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     * http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     * =============================================================================
     */
    class MeanProgram {
      constructor(reduceInfo, divisor) {
        this.variableNames = ["x"];
        const {windowSize, batchSize, inSize, outSize} = reduceInfo;
        this.outputShape = [batchSize, outSize];
        const windowSizeNearestVec4 = Math.floor(windowSize / 4) * 4;
        const windowSizeVec4Remainder = windowSize % 4;
        let updateSnippet = `sumValue += dot(values, ones);`;
        if (divisor != null) {
          const denominator = 1 / divisor;
          updateSnippet = `sumValue += dot(values * ${isInt2(denominator) ? denominator.toPrecision(2) : denominator}, ones);`;
        }
        let checkOutOfBounds = "";
        if (inSize % windowSize > 0) {
          checkOutOfBounds = `
        if (inIdx < 0 || inIdx >= ${inSize}) {
          return 0.0;
        }
      `;
        }
        this.userCode = `
      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);

      float getValue(int batch, int inIdx) {
        ${checkOutOfBounds}
        return getX(batch, inIdx);
      }

      void main() {
        ivec2 coords = getOutputCoords();
        int batch = coords[0];
        int outIdx = coords[1];
        int inOffset = outIdx * ${windowSize};

        float sumValue = 0.0;

        for (int i = 0; i < ${windowSizeNearestVec4}; i += 4) {
          int inIdx = inOffset + i;
          vec4 values = vec4(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            getValue(batch, inIdx + 2),
            getValue(batch, inIdx + 3)
          );

          ${updateSnippet}
        }

        int inIdx = inOffset + ${windowSizeNearestVec4};
        if (${windowSizeVec4Remainder === 1}) {
          vec4 values = vec4(getValue(batch, inIdx), 0.0, 0.0, 0.0);

          ${updateSnippet}
        } else if (${windowSizeVec4Remainder === 2}) {
          vec4 values = vec4(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1), 0.0, 0.0);

          ${updateSnippet}
        } else if (${windowSizeVec4Remainder === 3}) {
          vec4 values = vec4(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            getValue(batch, inIdx + 2), 0.0);

          ${updateSnippet}
        }
        setOutput(sumValue);
      }
    `;
      }
    }
    /**
     * @license
     * Copyright 2020 Google LLC. All Rights Reserved.
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     * http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     * =============================================================================
     */
    function getReductionStages(inShape) {
      const stages = [];
      while (stages.length === 0 || stages[stages.length - 1].outSize !== 1) {
        const outSize = stages.length ? stages[stages.length - 1].outSize : inShape[1];
        const windowSize = computeOptimalWindowSize2(outSize);
        stages.push({
          inSize: outSize,
          windowSize,
          outSize: Math.ceil(outSize / windowSize)
        });
      }
      return stages;
    }
    function reduce(x, dtype, reductionType, backend3) {
      const reductionStages = getReductionStages(x.shape);
      let result = x;
      for (let i = 0; i < reductionStages.length; i++) {
        const {inSize, windowSize, outSize} = reductionStages[i];
        let program;
        let previousResult;
        if (reductionType === "mean") {
          program = i === 0 ? new MeanProgram({windowSize, inSize, batchSize: x.shape[0], outSize}, inSize) : new MeanProgram({windowSize, inSize, batchSize: x.shape[0], outSize});
        } else {
          program = new ReduceProgram({windowSize, inSize, batchSize: x.shape[0], outSize}, reductionType);
        }
        previousResult = result;
        result = backend3.runWebGLProgram(program, [result], dtype);
        if (previousResult.dataId !== x.dataId) {
          backend3.disposeIntermediateTensorInfo(previousResult);
        }
      }
      return result;
    }
    /**
     * @license
     * Copyright 2020 Google LLC. All Rights Reserved.
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     * http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     * =============================================================================
     */
    function maxImpl$1(x, reduceShape, outShape, backend3) {
      const inSize = sizeFromShape2(reduceShape);
      const xSize = sizeFromShape2(x.shape);
      const batchSize = xSize / inSize;
      const reshapedInput = reshape$3({inputs: {x}, attrs: {shape: [batchSize, inSize]}, backend: backend3});
      const reduced = reduce(reshapedInput, x.dtype, "max", backend3);
      const reshapedOutput = reshape$3({inputs: {x: reduced}, attrs: {shape: outShape}, backend: backend3});
      backend3.disposeIntermediateTensorInfo(reshapedInput);
      backend3.disposeIntermediateTensorInfo(reduced);
      return reshapedOutput;
    }
    /**
     * @license
     * Copyright 2017 Google LLC. All Rights Reserved.
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     * http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     * =============================================================================
     */
    class TransposeProgram {
      constructor(aShape, newDim) {
        this.variableNames = ["A"];
        const outputShape = new Array(aShape.length);
        for (let i = 0; i < outputShape.length; i++) {
          outputShape[i] = aShape[newDim[i]];
        }
        this.outputShape = outputShape;
        this.rank = outputShape.length;
        const dtype = getCoordsDataType(this.rank);
        const switched = getSwitchedCoords(newDim);
        this.userCode = `
    void main() {
      ${dtype} resRC = getOutputCoords();
      setOutput(getA(${switched}));
    }
    `;
      }
    }
    function getSwitchedCoords(newDim) {
      const rank = newDim.length;
      if (rank > 6) {
        throw Error(`Transpose for rank ${rank} is not yet supported`);
      }
      const originalOrder = ["resRC.x", "resRC.y", "resRC.z", "resRC.w", "resRC.u", "resRC.v"];
      const switchedCoords = new Array(rank);
      for (let i = 0; i < newDim.length; i++) {
        switchedCoords[newDim[i]] = originalOrder[i];
      }
      return switchedCoords.join();
    }
    /**
     * @license
     * Copyright 2019 Google LLC. All Rights Reserved.
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     * http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     * =============================================================================
     */
    class TransposePackedProgram {
      constructor(aShape, newDim) {
        this.variableNames = ["A"];
        this.packedInputs = true;
        this.packedOutput = true;
        const outputShape = new Array(aShape.length);
        for (let i = 0; i < outputShape.length; i++) {
          outputShape[i] = aShape[newDim[i]];
        }
        this.outputShape = outputShape;
        this.rank = outputShape.length;
        if (this.rank > 6) {
          throw Error(`Packed transpose for rank ${this.rank} is not yet supported.`);
        }
        const dtype = getCoordsDataType(this.rank);
        const outputOrder = getVecChannels("rc", this.rank);
        const switchedOrder = new Array(this.rank);
        for (let i = 0; i < newDim.length; i++) {
          switchedOrder[newDim[i]] = outputOrder[i];
        }
        const innerDims = `vec2(${switchedOrder.slice(-2).join()})`;
        const nextColumn = `++${outputOrder[this.rank - 1]} < ${outputShape[this.rank - 1]}`;
        const getc = `getChannel(getA(${switchedOrder.join()}), ${innerDims})`;
        this.userCode = `
    void main() {
      ${dtype} rc = getOutputCoords();
      vec4 result = vec4(0.);
      result[0] = ${getc};
      if(${nextColumn}) {
        result[1] = ${getc};
      }
      --${outputOrder[this.rank - 1]};
      if(++${outputOrder[this.rank - 2]} < ${outputShape[this.rank - 2]}) {
        result[2] = ${getc};
        if(${nextColumn}) {
          result[3] = ${getc};
        }
      }
      setOutput(result);
    }
    `;
      }
    }
    /**
     * @license
     * Copyright 2020 Google LLC. All Rights Reserved.
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     * http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     * =============================================================================
     */
    function transposeImpl$1(x, perm, backend3) {
      const program = env2().getBool("WEBGL_PACK_ARRAY_OPERATIONS") ? new TransposePackedProgram(x.shape, perm) : new TransposeProgram(x.shape, perm);
      return backend3.runWebGLProgram(program, [x], x.dtype);
    }
    /**
     * @license
     * Copyright 2020 Google LLC. All Rights Reserved.
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     * http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     * =============================================================================
     */
    const maxConfig$1 = {
      kernelName: Max3,
      backendName: "webgl",
      kernelFunc: ({inputs, attrs, backend: backend3}) => {
        const {x} = inputs;
        const {reductionIndices, keepDims} = attrs;
        const webglBackend = backend3;
        const xRank = x.shape.length;
        const origAxes = parseAxisParam2(reductionIndices, x.shape);
        let axes = origAxes;
        const permutedAxes = getAxesPermutation2(axes, xRank);
        const maxInputIsTransposed = permutedAxes != null;
        const shouldExecuteOnCPU = webglBackend.shouldExecuteOnCPU([x]);
        let maxInput = x;
        if (maxInputIsTransposed) {
          if (shouldExecuteOnCPU) {
            const xTexData = webglBackend.texData.get(maxInput.dataId);
            const values = xTexData.values;
            const newShape = new Array(xRank);
            for (let i = 0; i < newShape.length; i++) {
              newShape[i] = x.shape[permutedAxes[i]];
            }
            const maxInputValues = transposeImplCPU(values, x.shape, x.dtype, permutedAxes, newShape);
            maxInput = webglBackend.makeTensorInfo(newShape, x.dtype);
            const maxInputData = webglBackend.texData.get(maxInput.dataId);
            maxInputData.values = maxInputValues;
          } else {
            maxInput = transposeImpl$1(x, permutedAxes, webglBackend);
          }
          axes = getInnerMostAxes2(axes.length, xRank);
        }
        assertAxesAreInnerMostDims2("max", axes, xRank);
        const [maxOutShape, reduceShape] = computeOutAndReduceShapes2(maxInput.shape, axes);
        let outShape = maxOutShape;
        if (keepDims) {
          outShape = expandShapeToKeepDim2(maxOutShape, origAxes);
        }
        let out;
        if (shouldExecuteOnCPU) {
          const xTexData = webglBackend.texData.get(maxInput.dataId);
          const values = xTexData.values;
          const outValues = maxImplCPU(values, sizeFromShape2(reduceShape), outShape, x.dtype);
          out = webglBackend.makeTensorInfo(outShape, x.dtype);
          const outData = webglBackend.texData.get(out.dataId);
          outData.values = outValues;
        } else {
          out = maxImpl$1(maxInput, reduceShape, outShape, webglBackend);
        }
        if (maxInputIsTransposed) {
          webglBackend.disposeIntermediateTensorInfo(maxInput);
        }
        return out;
      }
    };
    /**
     * @license
     * Copyright 2020 Google LLC. All Rights Reserved.
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     * http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     * =============================================================================
     */
    function maxPool$2(args) {
      const {inputs, backend: backend3, attrs} = args;
      const {x} = inputs;
      assertNotComplex$1(x, "maxPool");
      const {filterSize, strides, pad: pad3, dimRoundingMode} = attrs;
      const dilations = 1;
      assert2(eitherStridesOrDilationsAreOne2(strides, dilations), () => `Error in maxPool: Either strides or dilations must be 1. Got strides ${strides} and dilations '${dilations}'`);
      const convInfo = computePool2DInfo2(x.shape, filterSize, strides, dilations, pad3, dimRoundingMode);
      if (convInfo.filterWidth === 1 && convInfo.filterHeight === 1 && arraysEqual2(convInfo.inShape, convInfo.outShape)) {
        return identity$2({inputs: {x}, backend: backend3});
      }
      const maxPoolProgram = new Pool2DProgram(convInfo, "max", false);
      return backend3.runWebGLProgram(maxPoolProgram, [x], x.dtype);
    }
    const maxPoolConfig$1 = {
      kernelName: MaxPool3,
      backendName: "webgl",
      kernelFunc: maxPool$2
    };
    /**
     * @license
     * Copyright 2020 Google LLC. All Rights Reserved.
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     * http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     * =============================================================================
     */
    function maxPoolBackprop$2(args) {
      const {inputs, backend: backend3, attrs} = args;
      const {dy, input: input2, output} = inputs;
      const x = input2;
      assertNotComplex$1([input2, output], "maxPoolBackprop");
      const {filterSize, strides, pad: pad3, dimRoundingMode} = attrs;
      const convInfo = computePool2DInfo2(x.shape, filterSize, strides, 1, pad3, dimRoundingMode);
      const getPositions = true;
      const maxPoolPositionsProgram = new Pool2DProgram(convInfo, "max", getPositions);
      const maxPoolPositions2 = backend3.runWebGLProgram(maxPoolPositionsProgram, [x], x.dtype);
      const maxPoolBackPropProgram = new MaxPool2DBackpropProgram(convInfo);
      const result = backend3.runWebGLProgram(maxPoolBackPropProgram, [dy, maxPoolPositions2], x.dtype);
      backend3.disposeIntermediateTensorInfo(maxPoolPositions2);
      return result;
    }
    const maxPoolBackpropConfig$1 = {
      kernelName: MaxPoolBackprop,
      backendName: "webgl",
      kernelFunc: maxPoolBackprop$2
    };
    /**
     * @license
     * Copyright 2020 Google LLC. All Rights Reserved.
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     * http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     * =============================================================================
     */
    function maxPoolWithArgmaxImpl$1(x, includeBatchInIndex, convInfo, backend3) {
      let program = new Pool2DProgram(convInfo, "max", false);
      const poolOutput = backend3.runWebGLProgram(program, [x], "float32");
      program = new Pool2DProgram(convInfo, "max", true, true, includeBatchInIndex);
      const indexOutput = backend3.runWebGLProgram(program, [x], "float32");
      return [poolOutput, indexOutput];
    }
    /**
     * @license
     * Copyright 2020 Google LLC. All Rights Reserved.
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     * http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     * =============================================================================
     */
    const maxPoolWithArgmaxConfig$1 = {
      kernelName: MaxPoolWithArgmax,
      backendName: "webgl",
      kernelFunc: ({inputs, attrs, backend: backend3}) => {
        const {x} = inputs;
        const {filterSize, strides, pad: pad3, includeBatchInIndex} = attrs;
        const webglBackend = backend3;
        assert2(x.shape.length === 4, () => `Error in maxPool: input must be rank 4 but got rank ${x.shape.length}.`);
        const dilations = [1, 1];
        assert2(eitherStridesOrDilationsAreOne2(strides, dilations), () => `Error in maxPool: Either strides or dilations must be 1. Got strides ${strides} and dilations '${dilations}'`);
        const convInfo = computePool2DInfo2(x.shape, filterSize, strides, dilations, pad3);
        const [result, indexes] = maxPoolWithArgmaxImpl$1(x, includeBatchInIndex, convInfo, webglBackend);
        return [result, indexes];
      }
    };
    /**
     * @license
     * Copyright 2020 Google LLC. All Rights Reserved.
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     * http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     * =============================================================================
     */
    function meanImpl(x, reduceShape, outShape, backend3) {
      const inSize = sizeFromShape2(reduceShape);
      const xSize = sizeFromShape2(x.shape);
      const batchSize = xSize / inSize;
      const reshapedInput = reshape$3({inputs: {x}, attrs: {shape: [batchSize, inSize]}, backend: backend3});
      const reduced = reduce(reshapedInput, "float32", "mean", backend3);
      const reshapedOutput = reshape$3({inputs: {x: reduced}, attrs: {shape: outShape}, backend: backend3});
      backend3.disposeIntermediateTensorInfo(reshapedInput);
      backend3.disposeIntermediateTensorInfo(reduced);
      return reshapedOutput;
    }
    /**
     * @license
     * Copyright 2020 Google LLC. All Rights Reserved.
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     * http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     * =============================================================================
     */
    const meanConfig = {
      kernelName: Mean,
      backendName: "webgl",
      kernelFunc: ({inputs, attrs, backend: backend3}) => {
        const {x} = inputs;
        const {keepDims, axis} = attrs;
        const webglBackend = backend3;
        const xRank = x.shape.length;
        const origAxes = parseAxisParam2(axis, x.shape);
        let axes = origAxes;
        const permutedAxes = getAxesPermutation2(axes, xRank);
        const meanInputIsTransposed = permutedAxes != null;
        const shouldExecuteOnCPU = webglBackend.shouldExecuteOnCPU([x]);
        const intermediates = [];
        let meanInput = x;
        if (meanInputIsTransposed) {
          if (shouldExecuteOnCPU) {
            const xTexData = webglBackend.texData.get(meanInput.dataId);
            const values = xTexData.values;
            const newShape = new Array(xRank);
            for (let i = 0; i < newShape.length; i++) {
              newShape[i] = x.shape[permutedAxes[i]];
            }
            const meanInputValues = transposeImplCPU(values, x.shape, x.dtype, permutedAxes, newShape);
            meanInput = webglBackend.makeTensorInfo(newShape, x.dtype);
            const meanInputData = webglBackend.texData.get(meanInput.dataId);
            meanInputData.values = meanInputValues;
          } else {
            meanInput = transposeImpl$1(x, permutedAxes, webglBackend);
          }
          intermediates.push(meanInput);
          axes = getInnerMostAxes2(axes.length, xRank);
        }
        assertAxesAreInnerMostDims2("sum", axes, xRank);
        const [meanOutShape, reduceShape] = computeOutAndReduceShapes2(meanInput.shape, axes);
        let outShape = meanOutShape;
        if (keepDims) {
          outShape = expandShapeToKeepDim2(meanOutShape, origAxes);
        }
        const out = meanImpl(meanInput, reduceShape, outShape, webglBackend);
        for (const i of intermediates) {
          webglBackend.disposeIntermediateTensorInfo(i);
        }
        return out;
      }
    };
    /**
     * @license
     * Copyright 2020 Google LLC. All Rights Reserved.
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     * http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     * =============================================================================
     */
    class MirrorPadProgram {
      constructor(xShape, paddings, mode) {
        this.variableNames = ["x"];
        this.outputShape = paddings.map((p2, i) => p2[0] + xShape[i] + p2[1]);
        const rank = xShape.length;
        const dtype = getCoordsDataType(rank);
        const start = paddings.map((p2) => p2[0]).join(",");
        const end = paddings.map((p2, i) => p2[0] + xShape[i]).join(",");
        const unpackedCoords = ["coords[0]", "coords[1]", "coords[2]", "coords[3]"].slice(0, rank);
        const offset = mode === "reflect" ? 0 : 1;
        if (rank === 1) {
          this.userCode = `
        int start = ${start};
        int end = ${end};

        void main() {
          int outC = getOutputCoords();
          if (outC < start) {
            outC = start * 2 - outC - ${offset};
          } else if(outC >= end) {
            outC = (end - 1) * 2 - outC + ${offset};
          }
          setOutput(getX(outC - start));
        }
      `;
          return;
        }
        this.userCode = `
      ${dtype} start = ${dtype}(${start});
      ${dtype} end = ${dtype}(${end});

      void main() {
        ${dtype} outC = getOutputCoords();
        for (int i = 0; i < ${rank}; i++) {
          if (outC[i] < start[i]) {
            outC[i] = start[i] * 2 - outC[i] - ${offset};
          } else if(outC[i] >= end[i]) {
            outC[i] = (end[i] - 1) * 2 - outC[i] + ${offset};
          }
        }
        ${dtype} coords = outC - start;
        setOutput(getX(${unpackedCoords}));
      }
    `;
      }
    }
    /**
     * @license
     * Copyright 2020 Google LLC. All Rights Reserved.
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     * http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     * =============================================================================
     */
    class MirrorPadPackedProgram {
      constructor(xShape, paddings, mode) {
        this.variableNames = ["x"];
        this.packedInputs = true;
        this.packedOutput = true;
        this.outputShape = paddings.map((p2, i) => p2[0] + xShape[i] + p2[1]);
        const rank = xShape.length;
        const dtype = getCoordsDataType(rank);
        const start = paddings.map((p2) => p2[0]).join(",");
        const end = paddings.map((p2, i) => p2[0] + xShape[i]).join(",");
        const coords2 = getChannels("rc", rank);
        const source = getChannels("source", rank);
        const cLimit = `${coords2[rank - 1]} < ${this.outputShape[rank - 1]}`;
        const innerDims = rank === 1 ? "source" : `vec2(${source.slice(-2).join()})`;
        const offset = mode === "reflect" ? 0 : 1;
        let mainLoop = "";
        if (rank === 1) {
          const padSetup = `
        ${dtype} source = rc;
        if (source < start) {
          source = start * 2 - source - ${offset};
        } else if (source >= end) {
          source = (end - 1) * 2 - source + ${offset};
        }
        source -= start;
      `;
          mainLoop = `
        ${dtype} rc = outputLoc;
        ${padSetup}
        result[0] = getChannel(getX(${source.join()}), ${innerDims});
        ${coords2[rank - 1]} += 1;
        if(${cLimit}) {
          ${padSetup}
          result[1] = getChannel(getX(${source.join()}), ${innerDims});
        }
      `;
        } else {
          const padSetup = `
        ${dtype} source = rc;
        ${dtype} lt = ${dtype}(lessThan(source, start));
        ${dtype} gte = ${dtype}(greaterThanEqual(source, end));
        ${dtype} orig = 1 - (lt + gte);
        source = orig * source +
                lt * (start * 2 - source - ${offset}) +
                gte * ((end - 1) * 2 - source + ${offset});
        source -= start;
      `;
          mainLoop = `
        ${dtype} rc = outputLoc;
        ${padSetup}
        result[0] = getChannel(getX(${source.join()}), ${innerDims});
        ${coords2[rank - 1]} += 1;
        if(${cLimit}) {
          ${padSetup}
          result[1] = getChannel(getX(${source.join()}), ${innerDims});
        }
        rc = outputLoc;
        ${coords2[rank - 2]} += 1;
        if(${coords2[rank - 2]} < ${this.outputShape[rank - 2]}) {
          ${padSetup}
          result[2] = getChannel(getX(${source.join()}), ${innerDims});
          ${coords2[rank - 1]} += 1;
          if(${cLimit}) {
            ${padSetup}
            result[3] = getChannel(getX(${source.join()}), ${innerDims});
          }
        }
      `;
        }
        this.userCode = `
      const ${dtype} start = ${dtype}(${start});
      const ${dtype} end = ${dtype}(${end});

      void main() {
        ${dtype} outputLoc = getOutputCoords();
        vec4 result = vec4(0.);
        ${mainLoop}
        setOutput(result);
      }
    `;
      }
    }
    /**
     * @license
     * Copyright 2020 Google LLC. All Rights Reserved.
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     * http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     * =============================================================================
     */
    const mirrorPadKernelFunc = ({inputs, backend: backend3, attrs}) => {
      const {x} = inputs;
      const {paddings, mode} = attrs;
      const program = env2().getBool("WEBGL_PACK_ARRAY_OPERATIONS") ? new MirrorPadPackedProgram(x.shape, paddings, mode) : new MirrorPadProgram(x.shape, paddings, mode);
      const output = backend3.runWebGLProgram(program, [x], x.dtype);
      return output;
    };
    const mirrorPadConfig$1 = {
      kernelName: MirrorPad,
      backendName: "webgl",
      kernelFunc: mirrorPadKernelFunc
    };
    /**
     * @license
     * Copyright 2018 Google LLC. All Rights Reserved.
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     * http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     * =============================================================================
     */
    const COMPLEX_MULTIPLY = {
      REAL: "return areal * breal - aimag * bimag;",
      IMAG: "return areal * bimag + aimag * breal;"
    };
    class BinaryOpComplexProgram {
      constructor(op3, aShape, bShape) {
        this.variableNames = ["AReal", "AImag", "BReal", "BImag"];
        this.outputShape = assertAndGetBroadcastShape2(aShape, bShape);
        this.userCode = `
      float binaryOpComplex(
          float areal, float aimag, float breal, float bimag) {
        ${op3}
      }

      void main() {
        float areal = getARealAtOutCoords();
        float aimag = getAImagAtOutCoords();
        float breal = getBRealAtOutCoords();
        float bimag = getBImagAtOutCoords();
        setOutput(binaryOpComplex(areal, aimag, breal, bimag));
      }
    `;
      }
    }
    /**
     * @license
     * Copyright 2020 Google LLC. All Rights Reserved.
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     * http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     * =============================================================================
     */
    const MUL = "return a * b;";
    function multiply$3(args) {
      const {inputs, backend: backend3} = args;
      const {a, b} = inputs;
      const dtype = upcastType2(a.dtype, b.dtype);
      if (a.dtype === "complex64") {
        const aData = backend3.texData.get(a.dataId);
        const bData = backend3.texData.get(b.dataId);
        const realProgram = new BinaryOpComplexProgram(COMPLEX_MULTIPLY.REAL, a.shape, b.shape);
        const imagProgram = new BinaryOpComplexProgram(COMPLEX_MULTIPLY.IMAG, a.shape, b.shape);
        const inputs2 = [
          {
            dataId: aData.complexTensorInfos.real.dataId,
            dtype: aData.complexTensorInfos.real.dtype,
            shape: a.shape
          },
          {
            dataId: aData.complexTensorInfos.imag.dataId,
            dtype: aData.complexTensorInfos.imag.dtype,
            shape: a.shape
          },
          {
            dataId: bData.complexTensorInfos.real.dataId,
            dtype: bData.complexTensorInfos.real.dtype,
            shape: b.shape
          },
          {
            dataId: bData.complexTensorInfos.imag.dataId,
            dtype: bData.complexTensorInfos.imag.dtype,
            shape: b.shape
          }
        ];
        const realPart = backend3.runWebGLProgram(realProgram, inputs2, "float32");
        const imagPart = backend3.runWebGLProgram(imagProgram, inputs2, "float32");
        const complexOutput = complex$2({inputs: {real: realPart, imag: imagPart}, backend: backend3});
        backend3.disposeIntermediateTensorInfo(realPart);
        backend3.disposeIntermediateTensorInfo(imagPart);
        return complexOutput;
      }
      if (backend3.shouldExecuteOnCPU([a, b])) {
        const aData = backend3.texData.get(a.dataId);
        const bData = backend3.texData.get(b.dataId);
        const [outValues, outShape] = multiplyImplCPU(a.shape, b.shape, aData.values, bData.values, dtype);
        const out = backend3.makeTensorInfo(outShape, dtype);
        const outData = backend3.texData.get(out.dataId);
        outData.values = outValues;
        return out;
      }
      let program;
      if (env2().getBool("WEBGL_PACK_BINARY_OPERATIONS")) {
        program = new BinaryOpPackedProgram(MUL, a.shape, b.shape);
      } else {
        program = new BinaryOpProgram(MUL, a.shape, b.shape);
      }
      return backend3.runWebGLProgram(program, [a, b], dtype);
    }
    const multiplyConfig$1 = {
      kernelName: Multiply3,
      backendName: "webgl",
      kernelFunc: multiply$3
    };
    /**
     * @license
     * Copyright 2020 Google LLC. All Rights Reserved.
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     * http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     * =============================================================================
     */
    const nonMaxSuppressionV3Config2 = {
      kernelName: NonMaxSuppressionV33,
      backendName: "webgl",
      kernelFunc: ({inputs, backend: backend3, attrs}) => {
        warn2("tf.nonMaxSuppression() in webgl locks the UI thread. Call tf.nonMaxSuppressionAsync() instead");
        const {boxes, scores} = inputs;
        const {maxOutputSize, iouThreshold, scoreThreshold} = attrs;
        const gpuBackend = backend3;
        const boxesVals = gpuBackend.readSync(boxes.dataId);
        const scoresVals = gpuBackend.readSync(scores.dataId);
        const maxOutputSizeVal = maxOutputSize;
        const iouThresholdVal = iouThreshold;
        const scoreThresholdVal = scoreThreshold;
        return nonMaxSuppressionV3Impl(boxesVals, scoresVals, maxOutputSizeVal, iouThresholdVal, scoreThresholdVal);
      }
    };
    /**
     * @license
     * Copyright 2020 Google LLC. All Rights Reserved.
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     * http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     * =============================================================================
     */
    const nonMaxSuppressionV4Impl$2 = nonMaxSuppressionV4Impl;
    const nonMaxSuppressionV4Config$1 = {
      kernelName: NonMaxSuppressionV43,
      backendName: "webgl",
      kernelFunc: ({inputs, backend: backend3, attrs}) => {
        warn2("tf.nonMaxSuppression() in webgl locks the UI thread. Call tf.nonMaxSuppressionAsync() instead");
        const {boxes, scores} = inputs;
        const {maxOutputSize, iouThreshold, scoreThreshold, padToMaxOutputSize} = attrs;
        const gpuBackend = backend3;
        const boxesVals = gpuBackend.readSync(boxes.dataId);
        const scoresVals = gpuBackend.readSync(scores.dataId);
        const {selectedIndices, validOutputs} = nonMaxSuppressionV4Impl$2(boxesVals, scoresVals, maxOutputSize, iouThreshold, scoreThreshold, padToMaxOutputSize);
        return [selectedIndices, validOutputs];
      }
    };
    /**
     * @license
     * Copyright 2020 Google LLC. All Rights Reserved.
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     * http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     * =============================================================================
     */
    const nonMaxSuppressionV5Impl$2 = nonMaxSuppressionV5Impl;
    const nonMaxSuppressionV5Config$1 = {
      kernelName: NonMaxSuppressionV53,
      backendName: "webgl",
      kernelFunc: ({inputs, backend: backend3, attrs}) => {
        warn2("tf.nonMaxSuppression() in webgl locks the UI thread. Call tf.nonMaxSuppressionAsync() instead");
        const {boxes, scores} = inputs;
        const {maxOutputSize, iouThreshold, scoreThreshold, softNmsSigma} = attrs;
        const gpuBackend = backend3;
        const boxesVals = gpuBackend.readSync(boxes.dataId);
        const scoresVals = gpuBackend.readSync(scores.dataId);
        const maxOutputSizeVal = maxOutputSize;
        const iouThresholdVal = iouThreshold;
        const scoreThresholdVal = scoreThreshold;
        const softNmsSigmaVal = softNmsSigma;
        const {selectedIndices, selectedScores} = nonMaxSuppressionV5Impl$2(boxesVals, scoresVals, maxOutputSizeVal, iouThresholdVal, scoreThresholdVal, softNmsSigmaVal);
        return [selectedIndices, selectedScores];
      }
    };
    /**
     * @license
     * Copyright 2020 Google LLC. All Rights Reserved.
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     * http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     * =============================================================================
     */
    class RotateProgram {
      constructor(imageShape, radians, fillValue, center) {
        this.variableNames = ["Image"];
        this.outputShape = [];
        const imageHeight = imageShape[1];
        const imageWidth = imageShape[2];
        const sinFactor = Math.sin(radians).toFixed(3);
        const cosFactor = Math.cos(radians).toFixed(3);
        this.outputShape = imageShape;
        const [centerX, centerY] = getImageCenter2(center, imageHeight, imageWidth);
        const centerXString = centerX.toFixed(3);
        const centerYString = centerY.toFixed(3);
        let fillSnippet = "";
        if (typeof fillValue === "number") {
          fillSnippet = `float outputValue = ${fillValue.toFixed(2)};`;
        } else {
          fillSnippet = `
        vec3 fill = vec3(${fillValue.join(",")});
        float outputValue = fill[coords[3]];`;
        }
        this.userCode = `
        void main() {
          ivec4 coords = getOutputCoords();
          int x = coords[2];
          int y = coords[1];
          float coordXFloat = (float(x) - ${centerXString}) * ${cosFactor} - (float(y) - ${centerYString}) * ${sinFactor};
          float coordYFloat = (float(x) - ${centerXString}) * ${sinFactor} + (float(y) - ${centerYString}) * ${cosFactor};
          int coordX = int(round(coordXFloat + ${centerXString}));
          int coordY = int(round(coordYFloat + ${centerYString}));
          ${fillSnippet}
          if(coordX >= 0 && coordX < ${imageWidth} && coordY >= 0 && coordY < ${imageHeight}) {
            outputValue = getImage(coords[0], coordY, coordX, coords[3]);
          }
          setOutput(outputValue);
        }
    `;
      }
    }
    /**
     * @license
     * Copyright 2020 Google LLC. All Rights Reserved.
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     * http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     * =============================================================================
     */
    const rotateWithOffsetConfig$1 = {
      kernelName: RotateWithOffset3,
      backendName: "webgl",
      kernelFunc: ({inputs, attrs, backend: backend3}) => {
        const {image: image3} = inputs;
        const {radians, fillValue, center} = attrs;
        const webglBackend = backend3;
        const program = new RotateProgram(image3.shape, radians, fillValue, center);
        const output = webglBackend.runWebGLProgram(program, [image3], image3.dtype);
        return output;
      }
    };
    /**
     * @license
     * Copyright 2020 Google LLC. All Rights Reserved.
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     * http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     * =============================================================================
     */
    const SIN = CHECK_NAN_SNIPPET_UNARY + `
  return sin(x);
`;
    const sin$2 = unaryKernelFunc$1(SIN);
    const sinConfig$1 = {
      kernelName: Sin3,
      backendName: "webgl",
      kernelFunc: sin$2
    };
    /**
     * @license
     * Copyright 2019 Google LLC. All Rights Reserved.
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     * http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     * =============================================================================
     */
    const SQUARE = `return x * x;`;
    const square$2 = unaryKernelFunc$1(SQUARE);
    const squareConfig$1 = {
      kernelName: Square3,
      backendName: "webgl",
      kernelFunc: square$2
    };
    /**
     * @license
     * Copyright 2020 Google LLC. All Rights Reserved.
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     * http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     * =============================================================================
     */
    const SQUARED_DIFFERENCE$1 = "return (a - b) * (a - b);";
    const squaredDifference$2 = binaryKernelFunc$1({opSnippet: SQUARED_DIFFERENCE$1, packedOpSnippet: SQUARED_DIFFERENCE$1});
    const squaredDifferenceConfig$1 = {
      kernelName: SquaredDifference3,
      backendName: "webgl",
      kernelFunc: squaredDifference$2
    };
    /**
     * @license
     * Copyright 2020 Google LLC. All Rights Reserved.
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     * http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     * =============================================================================
     */
    const SUB = "return a - b;";
    const subKernelFunc = binaryKernelFunc$1({
      opSnippet: SUB,
      packedOpSnippet: SUB,
      supportsComplex: true,
      cpuKernelImpl: subImplCPU
    });
    const subConfig$1 = {
      kernelName: Sub3,
      backendName: "webgl",
      kernelFunc: subKernelFunc
    };
    /**
     * @license
     * Copyright 2020 Google LLC. All Rights Reserved.
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     * http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     * =============================================================================
     */
    const TAN = `return tan(x);`;
    const tan$2 = unaryKernelFunc$1(TAN);
    const tanConfig$1 = {
      kernelName: Tan,
      backendName: "webgl",
      kernelFunc: tan$2
    };
    /**
     * @license
     * Copyright 2020 Google LLC. All Rights Reserved.
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     * http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     * =============================================================================
     */
    const transposeConfig$1 = {
      kernelName: Transpose5,
      backendName: "webgl",
      kernelFunc: ({inputs, attrs, backend: backend3}) => {
        const {x} = inputs;
        const {perm} = attrs;
        const webglBackend = backend3;
        const xRank = x.shape.length;
        const newShape = new Array(xRank);
        for (let i = 0; i < newShape.length; i++) {
          newShape[i] = x.shape[perm[i]];
        }
        let out;
        if (webglBackend.shouldExecuteOnCPU([x])) {
          const xTexData = webglBackend.texData.get(x.dataId);
          const values = xTexData.values;
          const outValues = transposeImplCPU(values, x.shape, x.dtype, perm, newShape);
          out = webglBackend.makeTensorInfo(newShape, x.dtype);
          const outData = webglBackend.texData.get(out.dataId);
          outData.values = outValues;
        } else {
          out = transposeImpl$1(x, perm, webglBackend);
        }
        return out;
      }
    };
    /**
     * @license
     * Copyright 2020 Google LLC. All Rights Reserved.
     * Licensed under the Apache License, Version 2.0 (the License);
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     * http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an AS IS BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     * =============================================================================
     */
    function unique$3(args) {
      const {inputs, attrs, backend: backend3} = args;
      const {axis} = attrs;
      const {x} = inputs;
      assertNotComplex$1(x, "unique");
      console.warn("WARNING: ", "UI might be locked temporarily as data is being downloaded");
      const values = backend3.readSync(x.dataId);
      const {outputValues, outputShape, indices} = uniqueImplCPU(values, axis, x.shape, x.dtype);
      return [
        backend3.makeTensorInfo(outputShape, x.dtype, outputValues),
        backend3.makeTensorInfo([indices.length], "int32", indices)
      ];
    }
    const uniqueConfig$1 = {
      kernelName: Unique,
      backendName: "webgl",
      kernelFunc: unique$3
    };
    /**
     * @license
     * Copyright 2020 Google LLC. All Rights Reserved.
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     * http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     * =============================================================================
     */
    const kernelConfigs$1 = [
      addConfig$1,
      atan2Config,
      avgPoolConfig$1,
      avgPoolBackpropConfig$1,
      batchNormConfig$1,
      castConfig$1,
      complexConfig$1,
      concatConfig$1,
      cosConfig$1,
      divConfig$1,
      fftConfig$1,
      flipLeftRightConfig$1,
      fromPixelsConfig,
      identityConfig$1,
      ifftConfig$1,
      imagConfig$1,
      maxConfig$1,
      maxPoolConfig$1,
      maxPoolBackpropConfig$1,
      maxPoolWithArgmaxConfig$1,
      meanConfig,
      mirrorPadConfig$1,
      multiplyConfig$1,
      nonMaxSuppressionV3Config2,
      nonMaxSuppressionV4Config$1,
      nonMaxSuppressionV5Config$1,
      notEqualConfig$1,
      realConfig$1,
      reshapeConfig$1,
      rotateWithOffsetConfig$1,
      sinConfig$1,
      squareConfig$1,
      subConfig$1,
      squaredDifferenceConfig$1,
      tanConfig$1,
      transposeConfig$1,
      uniqueConfig$1
    ];
    for (const kernelConfig of kernelConfigs$1) {
      registerKernel2(kernelConfig);
    }
    /**
     * @license
     * Copyright 2020 Google LLC. All Rights Reserved.
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     * http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     * =============================================================================
     */
    /** @license See the LICENSE file. */
    const version$6 = "2.7.0";
    /**
     * @license
     * Copyright 2018 Google LLC. All Rights Reserved.
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     * http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     * =============================================================================
     */
    const version$7 = {
      "tfjs-core": version4,
      "tfjs-backend-cpu": version$4,
      "tfjs-backend-webgl": version$5,
      "tfjs-data": version$3,
      "tfjs-layers": version$1,
      "tfjs-converter": version$2,
      tfjs: version$6
    };
    exports2.Abs = Abs3;
    exports2.Acos = Acos;
    exports2.Acosh = Acosh;
    exports2.AdadeltaOptimizer = AdadeltaOptimizer;
    exports2.AdagradOptimizer = AdagradOptimizer;
    exports2.AdamOptimizer = AdamOptimizer;
    exports2.AdamaxOptimizer = AdamaxOptimizer;
    exports2.Add = Add3;
    exports2.AddN = AddN3;
    exports2.All = All;
    exports2.Any = Any;
    exports2.ArgMax = ArgMax3;
    exports2.ArgMin = ArgMin;
    exports2.Asin = Asin;
    exports2.Asinh = Asinh;
    exports2.Atan = Atan;
    exports2.Atan2 = Atan2;
    exports2.Atanh = Atanh;
    exports2.AvgPool = AvgPool3;
    exports2.AvgPool3D = AvgPool3D;
    exports2.AvgPool3DBackprop = AvgPool3DBackprop;
    exports2.AvgPoolBackprop = AvgPoolBackprop;
    exports2.BatchMatMul = BatchMatMul3;
    exports2.BatchToSpaceND = BatchToSpaceND;
    exports2.BroadcastTo = BroadcastTo;
    exports2.Callback = Callback;
    exports2.CallbackList = CallbackList;
    exports2.Cast = Cast5;
    exports2.Ceil = Ceil;
    exports2.ClipByValue = ClipByValue3;
    exports2.Complex = Complex2;
    exports2.Concat = Concat3;
    exports2.Conv2D = Conv2D3;
    exports2.Conv2DBackpropFilter = Conv2DBackpropFilter;
    exports2.Conv2DBackpropInput = Conv2DBackpropInput3;
    exports2.Conv3D = Conv3D;
    exports2.Conv3DBackpropFilterV2 = Conv3DBackpropFilterV2;
    exports2.Conv3DBackpropInputV2 = Conv3DBackpropInputV2;
    exports2.Cos = Cos3;
    exports2.Cosh = Cosh;
    exports2.CropAndResize = CropAndResize3;
    exports2.Cumsum = Cumsum3;
    exports2.CustomCallback = CustomCallback;
    exports2.DataStorage = DataStorage2;
    exports2.DepthToSpace = DepthToSpace3;
    exports2.DepthwiseConv2dNative = DepthwiseConv2dNative3;
    exports2.DepthwiseConv2dNativeBackpropFilter = DepthwiseConv2dNativeBackpropFilter;
    exports2.DepthwiseConv2dNativeBackpropInput = DepthwiseConv2dNativeBackpropInput;
    exports2.Diag = Diag;
    exports2.Dilation2D = Dilation2D;
    exports2.Dilation2DBackpropFilter = Dilation2DBackpropFilter;
    exports2.Dilation2DBackpropInput = Dilation2DBackpropInput;
    exports2.Div = Div3;
    exports2.EarlyStopping = EarlyStopping;
    exports2.Elu = Elu2;
    exports2.EluGrad = EluGrad;
    exports2.Environment = Environment2;
    exports2.Equal = Equal3;
    exports2.Erf = Erf;
    exports2.Exp = Exp3;
    exports2.Expm1 = Expm1;
    exports2.FFT = FFT;
    exports2.Fill = Fill3;
    exports2.FlipLeftRight = FlipLeftRight3;
    exports2.Floor = Floor;
    exports2.FloorDiv = FloorDiv3;
    exports2.FromPixels = FromPixels;
    exports2.FusedBatchNorm = FusedBatchNorm3;
    exports2.FusedConv2D = FusedConv2D3;
    exports2.FusedDepthwiseConv2D = FusedDepthwiseConv2D3;
    exports2.GatherNd = GatherNd3;
    exports2.GatherV2 = GatherV23;
    exports2.GraphModel = GraphModel;
    exports2.Greater = Greater3;
    exports2.GreaterEqual = GreaterEqual3;
    exports2.History = History;
    exports2.IFFT = IFFT;
    exports2.Identity = Identity5;
    exports2.Imag = Imag;
    exports2.InputSpec = InputSpec;
    exports2.IsFinite = IsFinite;
    exports2.IsInf = IsInf;
    exports2.IsNan = IsNan;
    exports2.KernelBackend = KernelBackend2;
    exports2.LRN = LRN;
    exports2.LRNBackprop = LRNBackprop;
    exports2.LayerVariable = LayerVariable;
    exports2.LayersModel = LayersModel;
    exports2.Less = Less3;
    exports2.LessEqual = LessEqual3;
    exports2.LinSpace = LinSpace;
    exports2.Log = Log3;
    exports2.Log1p = Log1p;
    exports2.LogSoftmax = LogSoftmax;
    exports2.LogicalAnd = LogicalAnd3;
    exports2.LogicalNot = LogicalNot;
    exports2.LogicalOr = LogicalOr;
    exports2.Max = Max3;
    exports2.MaxPool = MaxPool3;
    exports2.MaxPool3D = MaxPool3D;
    exports2.MaxPool3DBackprop = MaxPool3DBackprop;
    exports2.MaxPoolBackprop = MaxPoolBackprop;
    exports2.MaxPoolWithArgmax = MaxPoolWithArgmax;
    exports2.Maximum = Maximum3;
    exports2.Mean = Mean;
    exports2.Min = Min3;
    exports2.Minimum = Minimum3;
    exports2.MirrorPad = MirrorPad;
    exports2.Mod = Mod;
    exports2.MomentumOptimizer = MomentumOptimizer;
    exports2.Multiply = Multiply3;
    exports2.Negate = Negate3;
    exports2.NonMaxSuppressionV3 = NonMaxSuppressionV33;
    exports2.NonMaxSuppressionV4 = NonMaxSuppressionV43;
    exports2.NonMaxSuppressionV5 = NonMaxSuppressionV53;
    exports2.NotEqual = NotEqual3;
    exports2.OP_SCOPE_SUFFIX = OP_SCOPE_SUFFIX2;
    exports2.OneHot = OneHot3;
    exports2.OnesLike = OnesLike3;
    exports2.Optimizer = Optimizer;
    exports2.PadV2 = PadV23;
    exports2.Pool = Pool;
    exports2.Pow = Pow3;
    exports2.Prelu = Prelu3;
    exports2.Prod = Prod;
    exports2.RMSPropOptimizer = RMSPropOptimizer;
    exports2.RNN = RNN;
    exports2.Range = Range;
    exports2.Real = Real;
    exports2.Reciprocal = Reciprocal;
    exports2.Relu = Relu3;
    exports2.Relu6 = Relu63;
    exports2.Reshape = Reshape6;
    exports2.ResizeBilinear = ResizeBilinear3;
    exports2.ResizeBilinearGrad = ResizeBilinearGrad;
    exports2.ResizeNearestNeighbor = ResizeNearestNeighbor;
    exports2.ResizeNearestNeighborGrad = ResizeNearestNeighborGrad;
    exports2.Reverse = Reverse3;
    exports2.RotateWithOffset = RotateWithOffset3;
    exports2.Round = Round;
    exports2.Rsqrt = Rsqrt3;
    exports2.SGDOptimizer = SGDOptimizer;
    exports2.ScatterNd = ScatterNd3;
    exports2.SelectV2 = SelectV23;
    exports2.Selu = Selu;
    exports2.Sequential = Sequential;
    exports2.Sigmoid = Sigmoid3;
    exports2.Sign = Sign;
    exports2.Sin = Sin3;
    exports2.Sinh = Sinh;
    exports2.Slice = Slice6;
    exports2.Softmax = Softmax3;
    exports2.Softplus = Softplus;
    exports2.SpaceToBatchND = SpaceToBatchND;
    exports2.SparseToDense = SparseToDense;
    exports2.SplitV = SplitV2;
    exports2.Sqrt = Sqrt3;
    exports2.Square = Square3;
    exports2.SquaredDifference = SquaredDifference3;
    exports2.Step = Step2;
    exports2.StridedSlice = StridedSlice3;
    exports2.Sub = Sub3;
    exports2.Sum = Sum3;
    exports2.SymbolicTensor = SymbolicTensor;
    exports2.Tan = Tan;
    exports2.Tanh = Tanh3;
    exports2.Tensor = Tensor2;
    exports2.TensorBuffer = TensorBuffer2;
    exports2.Tile = Tile3;
    exports2.TopK = TopK;
    exports2.Transpose = Transpose5;
    exports2.Unique = Unique;
    exports2.Unpack = Unpack3;
    exports2.UnsortedSegmentSum = UnsortedSegmentSum;
    exports2.Variable = Variable2;
    exports2.ZerosLike = ZerosLike3;
    exports2._FusedMatMul = _FusedMatMul2;
    exports2.abs = abs;
    exports2.acos = acos;
    exports2.acosh = acosh;
    exports2.add = add$1;
    exports2.addN = addN;
    exports2.addStrict = addStrict;
    exports2.all = all;
    exports2.any = any;
    exports2.argMax = argMax;
    exports2.argMin = argMin;
    exports2.asin = asin;
    exports2.asinh = asinh;
    exports2.atan = atan;
    exports2.atan2 = atan2;
    exports2.atanh = atanh;
    exports2.avgPool = avgPool2;
    exports2.avgPool3d = avgPool3d;
    exports2.backend = backend2;
    exports2.backend_util = backend_util;
    exports2.basicLSTMCell = basicLSTMCell;
    exports2.batchNorm = batchNorm;
    exports2.batchNorm2d = batchNorm2d;
    exports2.batchNorm3d = batchNorm3d;
    exports2.batchNorm4d = batchNorm4d;
    exports2.batchToSpaceND = batchToSpaceND;
    exports2.booleanMaskAsync = booleanMaskAsync;
    exports2.broadcastTo = broadcastTo;
    exports2.browser = browser;
    exports2.buffer = buffer2;
    exports2.callbacks = callbacks;
    exports2.cast = cast7;
    exports2.ceil = ceil;
    exports2.clipByValue = clipByValue;
    exports2.clone = clone;
    exports2.complex = complex3;
    exports2.concat = concat2;
    exports2.concat1d = concat1d;
    exports2.concat2d = concat2d;
    exports2.concat3d = concat3d;
    exports2.concat4d = concat4d;
    exports2.constraints = exports_constraints;
    exports2.conv1d = conv1d;
    exports2.conv2d = conv2d2;
    exports2.conv2dTranspose = conv2dTranspose;
    exports2.conv3d = conv3d;
    exports2.conv3dTranspose = conv3dTranspose;
    exports2.copyRegisteredKernels = copyRegisteredKernels;
    exports2.cos = cos;
    exports2.cosh = cosh;
    exports2.cosineWindow = cosineWindow;
    exports2.cumsum = cumsum2;
    exports2.customGrad = customGrad;
    exports2.data = index;
    exports2.deprecationWarn = deprecationWarn2;
    exports2.depthToSpace = depthToSpace2;
    exports2.depthwiseConv2d = depthwiseConv2d2;
    exports2.deregisterOp = deregisterOp;
    exports2.device_util = device_util;
    exports2.diag = diag;
    exports2.dilation2d = dilation2d;
    exports2.disableDeprecationWarnings = disableDeprecationWarnings;
    exports2.dispose = dispose;
    exports2.disposeVariables = disposeVariables;
    exports2.div = div;
    exports2.divNoNan = divNoNan;
    exports2.divStrict = divStrict;
    exports2.dot = dot2;
    exports2.dropout = dropout;
    exports2.elu = elu3;
    exports2.enableDebugMode = enableDebugMode;
    exports2.enableProdMode = enableProdMode;
    exports2.enclosingPowerOfTwo = enclosingPowerOfTwo;
    exports2.engine = engine19;
    exports2.env = env2;
    exports2.equal = equal;
    exports2.equalStrict = equalStrict;
    exports2.erf = erf;
    exports2.exp = exp;
    exports2.expandDims = expandDims;
    exports2.expm1 = expm1;
    exports2.eye = eye;
    exports2.fft = fft;
    exports2.fill = fill2;
    exports2.findBackend = findBackend;
    exports2.findBackendFactory = findBackendFactory;
    exports2.floor = floor;
    exports2.floorDiv = floorDiv;
    exports2.fused = fused_ops;
    exports2.gather = gather;
    exports2.gatherND = gatherND;
    exports2.gather_util = gather_nd_util;
    exports2.getBackend = getBackend;
    exports2.getGradient = getGradient2;
    exports2.getKernel = getKernel2;
    exports2.getKernelsForBackend = getKernelsForBackend2;
    exports2.grad = grad;
    exports2.grads = grads;
    exports2.greater = greater;
    exports2.greaterEqual = greaterEqual;
    exports2.greaterEqualStrict = greaterEqualStrict;
    exports2.greaterStrict = greaterStrict;
    exports2.ifft = ifft;
    exports2.imag = imag;
    exports2.image = image2;
    exports2.inTopKAsync = inTopKAsync;
    exports2.initializers = exports_initializers;
    exports2.input = input;
    exports2.io = io;
    exports2.irfft = irfft;
    exports2.isFinite = isFinite$1;
    exports2.isInf = isInf;
    exports2.isNaN = isNaN$1;
    exports2.keep = keep;
    exports2.kernel_impls = kernel_impls;
    exports2.layers = exports_layers;
    exports2.leakyRelu = leakyRelu;
    exports2.less = less;
    exports2.lessEqual = lessEqual;
    exports2.lessEqualStrict = lessEqualStrict;
    exports2.lessStrict = lessStrict;
    exports2.linalg = linalg;
    exports2.linspace = linspace;
    exports2.loadGraphModel = loadGraphModel2;
    exports2.loadLayersModel = loadLayersModel;
    exports2.localResponseNormalization = localResponseNormalization;
    exports2.log = log22;
    exports2.log1p = log1p;
    exports2.logSigmoid = logSigmoid;
    exports2.logSoftmax = logSoftmax;
    exports2.logSumExp = logSumExp;
    exports2.logicalAnd = logicalAnd;
    exports2.logicalNot = logicalNot;
    exports2.logicalOr = logicalOr;
    exports2.logicalXor = logicalXor;
    exports2.losses = losses;
    exports2.matMul = matMul;
    exports2.math = math;
    exports2.max = max2;
    exports2.maxPool = maxPool2;
    exports2.maxPool3d = maxPool3d;
    exports2.maxPoolWithArgmax = maxPoolWithArgmax;
    exports2.maximum = maximum;
    exports2.maximumStrict = maximumStrict;
    exports2.mean = mean;
    exports2.memory = memory;
    exports2.metrics = exports_metrics;
    exports2.min = min2;
    exports2.minimum = minimum;
    exports2.minimumStrict = minimumStrict;
    exports2.mirrorPad = mirrorPad;
    exports2.mod = mod;
    exports2.modStrict = modStrict;
    exports2.model = model;
    exports2.models = exports_models;
    exports2.moments = moments;
    exports2.movingAverage = movingAverage;
    exports2.mul = mul3;
    exports2.mulStrict = mulStrict;
    exports2.multiRNNCell = multiRNNCell;
    exports2.multinomial = multinomial;
    exports2.neg = neg;
    exports2.nextFrame = nextFrame;
    exports2.norm = norm;
    exports2.notEqual = notEqual;
    exports2.notEqualStrict = notEqualStrict;
    exports2.oneHot = oneHot2;
    exports2.ones = ones$1;
    exports2.onesLike = onesLike2;
    exports2.op = op2;
    exports2.outerProduct = outerProduct;
    exports2.pad = pad2;
    exports2.pad1d = pad1d;
    exports2.pad2d = pad2d;
    exports2.pad3d = pad3d;
    exports2.pad4d = pad4d;
    exports2.pool = pool;
    exports2.pow = pow;
    exports2.powStrict = powStrict;
    exports2.prelu = prelu4;
    exports2.print = print2;
    exports2.prod = prod;
    exports2.profile = profile2;
    exports2.rand = rand;
    exports2.randomGamma = randomGamma;
    exports2.randomNormal = randomNormal;
    exports2.randomUniform = randomUniform;
    exports2.range = range;
    exports2.ready = ready;
    exports2.real = real;
    exports2.reciprocal = reciprocal;
    exports2.registerBackend = registerBackend2;
    exports2.registerCallbackConstructor = registerCallbackConstructor;
    exports2.registerGradient = registerGradient;
    exports2.registerKernel = registerKernel2;
    exports2.registerOp = registerOp;
    exports2.regularizers = exports_regularizers;
    exports2.relu = relu3;
    exports2.relu6 = relu63;
    exports2.removeBackend = removeBackend;
    exports2.reshape = reshape5;
    exports2.reverse = reverse2;
    exports2.reverse1d = reverse1d;
    exports2.reverse2d = reverse2d;
    exports2.reverse3d = reverse3d;
    exports2.reverse4d = reverse4d;
    exports2.rfft = rfft;
    exports2.round = round;
    exports2.rsqrt = rsqrt;
    exports2.scalar = scalar3;
    exports2.scatterND = scatterND;
    exports2.scatter_util = scatter_nd_util;
    exports2.selu = selu;
    exports2.separableConv2d = separableConv2d;
    exports2.sequential = sequential;
    exports2.serialization = serialization;
    exports2.setBackend = setBackend;
    exports2.setPlatform = setPlatform;
    exports2.setdiff1dAsync = setdiff1dAsync;
    exports2.sigmoid = sigmoid2;
    exports2.sign = sign;
    exports2.signal = signal;
    exports2.sin = sin;
    exports2.sinh = sinh;
    exports2.slice = slice2;
    exports2.slice1d = slice1d;
    exports2.slice2d = slice2d2;
    exports2.slice3d = slice3d2;
    exports2.slice4d = slice4d2;
    exports2.slice_util = slice_util;
    exports2.softmax = softmax2;
    exports2.softplus = softplus;
    exports2.spaceToBatchND = spaceToBatchND;
    exports2.sparseToDense = sparseToDense;
    exports2.spectral = spectral;
    exports2.split = split2;
    exports2.sqrt = sqrt;
    exports2.square = square;
    exports2.squaredDifference = squaredDifference;
    exports2.squaredDifferenceStrict = squaredDifferenceStrict;
    exports2.squeeze = squeeze;
    exports2.stack = stack;
    exports2.step = step3;
    exports2.stridedSlice = stridedSlice2;
    exports2.sub = sub;
    exports2.subStrict = subStrict;
    exports2.sum = sum$1;
    exports2.sumOutType = sumOutType;
    exports2.tan = tan;
    exports2.tanh = tanh$1;
    exports2.tensor = tensor6;
    exports2.tensor1d = tensor1d3;
    exports2.tensor2d = tensor2d;
    exports2.tensor3d = tensor3d;
    exports2.tensor4d = tensor4d;
    exports2.tensor5d = tensor5d;
    exports2.tensor6d = tensor6d;
    exports2.tensor_util = tensor_util3;
    exports2.test_util = test_util;
    exports2.tidy = tidy;
    exports2.tile = tile2;
    exports2.time = time;
    exports2.topk = topk;
    exports2.train = train;
    exports2.transpose = transpose4;
    exports2.truncatedNormal = truncatedNormal;
    exports2.unique = unique;
    exports2.unregisterGradient = unregisterGradient;
    exports2.unregisterKernel = unregisterKernel;
    exports2.unsortedSegmentSum = unsortedSegmentSum;
    exports2.unstack = unstack;
    exports2.upcastType = upcastType2;
    exports2.util = util30;
    exports2.valueAndGrad = valueAndGrad;
    exports2.valueAndGrads = valueAndGrads;
    exports2.variable = variable;
    exports2.variableGrads = variableGrads;
    exports2.version = version$7;
    exports2.version_converter = version$2;
    exports2.version_core = version4;
    exports2.version_layers = version$1;
    exports2.where = where;
    exports2.whereAsync = whereAsync;
    exports2.zeros = zeros3;
    exports2.zerosLike = zerosLike2;
    Object.defineProperty(exports2, "__esModule", {value: true});
  });
});
var require_path = __commonJS(() => {
});
var require_worker_threads = __commonJS(() => {
});
var require_perf_hooks = __commonJS(() => {
});
var require_tfjs_backend_wasm_threaded_simd = __commonJS((exports, module) => {
  var WasmBackendModuleThreadedSimd = function() {
    var _scriptDir = typeof document !== "undefined" && document.currentScript ? document.currentScript.src : void 0;
    if (typeof __filename !== "undefined")
      _scriptDir = _scriptDir || __filename;
    return function(WasmBackendModuleThreadedSimd2) {
      WasmBackendModuleThreadedSimd2 = WasmBackendModuleThreadedSimd2 || {};
      function GROWABLE_HEAP_I8() {
        if (wasmMemory.buffer != buffer2) {
          updateGlobalBufferAndViews(wasmMemory.buffer);
        }
        return HEAP8;
      }
      function GROWABLE_HEAP_U8() {
        if (wasmMemory.buffer != buffer2) {
          updateGlobalBufferAndViews(wasmMemory.buffer);
        }
        return HEAPU8;
      }
      function GROWABLE_HEAP_I32() {
        if (wasmMemory.buffer != buffer2) {
          updateGlobalBufferAndViews(wasmMemory.buffer);
        }
        return HEAP32;
      }
      function GROWABLE_HEAP_U32() {
        if (wasmMemory.buffer != buffer2) {
          updateGlobalBufferAndViews(wasmMemory.buffer);
        }
        return HEAPU32;
      }
      function GROWABLE_HEAP_F64() {
        if (wasmMemory.buffer != buffer2) {
          updateGlobalBufferAndViews(wasmMemory.buffer);
        }
        return HEAPF64;
      }
      var Module = typeof WasmBackendModuleThreadedSimd2 !== "undefined" ? WasmBackendModuleThreadedSimd2 : {};
      var moduleOverrides = {};
      var key;
      for (key in Module) {
        if (Module.hasOwnProperty(key)) {
          moduleOverrides[key] = Module[key];
        }
      }
      var arguments_ = [];
      var thisProgram = "./this.program";
      var quit_ = function(status2, toThrow) {
        throw toThrow;
      };
      var ENVIRONMENT_IS_WEB = false;
      var ENVIRONMENT_IS_WORKER = false;
      var ENVIRONMENT_IS_NODE = false;
      var ENVIRONMENT_IS_SHELL = false;
      ENVIRONMENT_IS_WEB = typeof window === "object";
      ENVIRONMENT_IS_WORKER = typeof importScripts === "function";
      ENVIRONMENT_IS_NODE = typeof process === "object" && typeof process.versions === "object" && typeof process.versions.node === "string";
      ENVIRONMENT_IS_SHELL = !ENVIRONMENT_IS_WEB && !ENVIRONMENT_IS_NODE && !ENVIRONMENT_IS_WORKER;
      var ENVIRONMENT_IS_PTHREAD = Module["ENVIRONMENT_IS_PTHREAD"] || false;
      if (ENVIRONMENT_IS_PTHREAD) {
        buffer2 = Module["buffer"];
        DYNAMIC_BASE = Module["DYNAMIC_BASE"];
        DYNAMICTOP_PTR = Module["DYNAMICTOP_PTR"];
      }
      var scriptDirectory = "";
      function locateFile(path) {
        if (Module["locateFile"]) {
          return Module["locateFile"](path, scriptDirectory);
        }
        return scriptDirectory + path;
      }
      var read_, readAsync, readBinary, setWindowTitle;
      var nodeFS;
      var nodePath;
      if (ENVIRONMENT_IS_NODE) {
        if (ENVIRONMENT_IS_WORKER) {
          scriptDirectory = require_path().dirname(scriptDirectory) + "/";
        } else {
          scriptDirectory = __dirname + "/";
        }
        read_ = function shell_read(filename, binary) {
          if (!nodeFS)
            nodeFS = require("fs");
          if (!nodePath)
            nodePath = require_path();
          filename = nodePath["normalize"](filename);
          return nodeFS["readFileSync"](filename, binary ? null : "utf8");
        };
        readBinary = function readBinary2(filename) {
          var ret = read_(filename, true);
          if (!ret.buffer) {
            ret = new Uint8Array(ret);
          }
          assert2(ret.buffer);
          return ret;
        };
        if (process["argv"].length > 1) {
          thisProgram = process["argv"][1].replace(/\\/g, "/");
        }
        arguments_ = process["argv"].slice(2);
        process["on"]("uncaughtException", function(ex) {
          if (!(ex instanceof ExitStatus)) {
            throw ex;
          }
        });
        process["on"]("unhandledRejection", abort);
        quit_ = function(status2) {
          process["exit"](status2);
        };
        Module["inspect"] = function() {
          return "[Emscripten Module object]";
        };
        var nodeWorkerThreads;
        try {
          nodeWorkerThreads = require_worker_threads();
        } catch (e) {
          console.error('The "worker_threads" module is not supported in this node.js build - perhaps a newer version is needed?');
          throw e;
        }
        Worker = nodeWorkerThreads.Worker;
      } else if (ENVIRONMENT_IS_SHELL) {
        if (typeof read != "undefined") {
          read_ = function shell_read(f) {
            return read(f);
          };
        }
        readBinary = function readBinary2(f) {
          var data2;
          if (typeof readbuffer === "function") {
            return new Uint8Array(readbuffer(f));
          }
          data2 = read(f, "binary");
          assert2(typeof data2 === "object");
          return data2;
        };
        if (typeof scriptArgs != "undefined") {
          arguments_ = scriptArgs;
        } else if (typeof arguments != "undefined") {
          arguments_ = arguments;
        }
        if (typeof quit === "function") {
          quit_ = function(status2) {
            quit(status2);
          };
        }
        if (typeof print !== "undefined") {
          if (typeof console === "undefined")
            console = {};
          console.log = print;
          console.warn = console.error = typeof printErr !== "undefined" ? printErr : print;
        }
      } else if (ENVIRONMENT_IS_WEB || ENVIRONMENT_IS_WORKER) {
        if (ENVIRONMENT_IS_WORKER) {
          scriptDirectory = self.location.href;
        } else if (document.currentScript) {
          scriptDirectory = document.currentScript.src;
        }
        if (_scriptDir) {
          scriptDirectory = _scriptDir;
        }
        if (scriptDirectory.indexOf("blob:") !== 0) {
          scriptDirectory = scriptDirectory.substr(0, scriptDirectory.lastIndexOf("/") + 1);
        } else {
          scriptDirectory = "";
        }
        if (ENVIRONMENT_IS_NODE) {
          read_ = function shell_read(filename, binary) {
            if (!nodeFS)
              nodeFS = require("fs");
            if (!nodePath)
              nodePath = require_path();
            filename = nodePath["normalize"](filename);
            return nodeFS["readFileSync"](filename, binary ? null : "utf8");
          };
          readBinary = function readBinary2(filename) {
            var ret = read_(filename, true);
            if (!ret.buffer) {
              ret = new Uint8Array(ret);
            }
            assert2(ret.buffer);
            return ret;
          };
        } else {
          read_ = function shell_read(url) {
            var xhr = new XMLHttpRequest();
            xhr.open("GET", url, false);
            xhr.send(null);
            return xhr.responseText;
          };
          if (ENVIRONMENT_IS_WORKER) {
            readBinary = function readBinary2(url) {
              var xhr = new XMLHttpRequest();
              xhr.open("GET", url, false);
              xhr.responseType = "arraybuffer";
              xhr.send(null);
              return new Uint8Array(xhr.response);
            };
          }
          readAsync = function readAsync2(url, onload, onerror) {
            var xhr = new XMLHttpRequest();
            xhr.open("GET", url, true);
            xhr.responseType = "arraybuffer";
            xhr.onload = function xhr_onload() {
              if (xhr.status == 200 || xhr.status == 0 && xhr.response) {
                onload(xhr.response);
                return;
              }
              onerror();
            };
            xhr.onerror = onerror;
            xhr.send(null);
          };
        }
        setWindowTitle = function(title) {
          document.title = title;
        };
      } else {
      }
      if (ENVIRONMENT_IS_NODE) {
        if (typeof performance === "undefined") {
          performance = require_perf_hooks().performance;
        }
      }
      var out = Module["print"] || console.log.bind(console);
      var err = Module["printErr"] || console.warn.bind(console);
      for (key in moduleOverrides) {
        if (moduleOverrides.hasOwnProperty(key)) {
          Module[key] = moduleOverrides[key];
        }
      }
      moduleOverrides = null;
      if (Module["arguments"])
        arguments_ = Module["arguments"];
      if (Module["thisProgram"])
        thisProgram = Module["thisProgram"];
      if (Module["quit"])
        quit_ = Module["quit"];
      var Atomics_load = Atomics.load;
      var Atomics_store = Atomics.store;
      var Atomics_compareExchange = Atomics.compareExchange;
      var wasmBinary;
      if (Module["wasmBinary"])
        wasmBinary = Module["wasmBinary"];
      var noExitRuntime;
      if (Module["noExitRuntime"])
        noExitRuntime = Module["noExitRuntime"];
      if (typeof WebAssembly !== "object") {
        err("no native wasm support detected");
      }
      var wasmMemory;
      var wasmTable = new WebAssembly.Table({initial: 165, maximum: 165 + 0, element: "anyfunc"});
      var wasmModule;
      var threadInfoStruct = 0;
      var selfThreadId = 0;
      var ABORT = false;
      var EXITSTATUS = 0;
      function assert2(condition, text) {
        if (!condition) {
          abort("Assertion failed: " + text);
        }
      }
      function getCFunc(ident) {
        var func = Module["_" + ident];
        assert2(func, "Cannot call unknown function " + ident + ", make sure it is exported");
        return func;
      }
      function ccall(ident, returnType, argTypes, args, opts) {
        var toC = {string: function(str2) {
          var ret2 = 0;
          if (str2 !== null && str2 !== void 0 && str2 !== 0) {
            var len = (str2.length << 2) + 1;
            ret2 = stackAlloc(len);
            stringToUTF8(str2, ret2, len);
          }
          return ret2;
        }, array: function(arr) {
          var ret2 = stackAlloc(arr.length);
          writeArrayToMemory(arr, ret2);
          return ret2;
        }};
        function convertReturnValue(ret2) {
          if (returnType === "string")
            return UTF8ToString(ret2);
          if (returnType === "boolean")
            return Boolean(ret2);
          return ret2;
        }
        var func = getCFunc(ident);
        var cArgs = [];
        var stack = 0;
        if (args) {
          for (var i = 0; i < args.length; i++) {
            var converter = toC[argTypes[i]];
            if (converter) {
              if (stack === 0)
                stack = stackSave();
              cArgs[i] = converter(args[i]);
            } else {
              cArgs[i] = args[i];
            }
          }
        }
        var ret = func.apply(null, cArgs);
        ret = convertReturnValue(ret);
        if (stack !== 0)
          stackRestore(stack);
        return ret;
      }
      function cwrap(ident, returnType, argTypes, opts) {
        argTypes = argTypes || [];
        var numericArgs = argTypes.every(function(type) {
          return type === "number";
        });
        var numericRet = returnType !== "string";
        if (numericRet && numericArgs && !opts) {
          return getCFunc(ident);
        }
        return function() {
          return ccall(ident, returnType, argTypes, arguments, opts);
        };
      }
      function UTF8ArrayToString(heap, idx, maxBytesToRead) {
        var endIdx = idx + maxBytesToRead;
        var str2 = "";
        while (!(idx >= endIdx)) {
          var u0 = heap[idx++];
          if (!u0)
            return str2;
          if (!(u0 & 128)) {
            str2 += String.fromCharCode(u0);
            continue;
          }
          var u1 = heap[idx++] & 63;
          if ((u0 & 224) == 192) {
            str2 += String.fromCharCode((u0 & 31) << 6 | u1);
            continue;
          }
          var u2 = heap[idx++] & 63;
          if ((u0 & 240) == 224) {
            u0 = (u0 & 15) << 12 | u1 << 6 | u2;
          } else {
            u0 = (u0 & 7) << 18 | u1 << 12 | u2 << 6 | heap[idx++] & 63;
          }
          if (u0 < 65536) {
            str2 += String.fromCharCode(u0);
          } else {
            var ch = u0 - 65536;
            str2 += String.fromCharCode(55296 | ch >> 10, 56320 | ch & 1023);
          }
        }
        return str2;
      }
      function UTF8ToString(ptr, maxBytesToRead) {
        return ptr ? UTF8ArrayToString(GROWABLE_HEAP_U8(), ptr, maxBytesToRead) : "";
      }
      function stringToUTF8Array(str2, heap, outIdx, maxBytesToWrite) {
        if (!(maxBytesToWrite > 0))
          return 0;
        var startIdx = outIdx;
        var endIdx = outIdx + maxBytesToWrite - 1;
        for (var i = 0; i < str2.length; ++i) {
          var u = str2.charCodeAt(i);
          if (u >= 55296 && u <= 57343) {
            var u1 = str2.charCodeAt(++i);
            u = 65536 + ((u & 1023) << 10) | u1 & 1023;
          }
          if (u <= 127) {
            if (outIdx >= endIdx)
              break;
            heap[outIdx++] = u;
          } else if (u <= 2047) {
            if (outIdx + 1 >= endIdx)
              break;
            heap[outIdx++] = 192 | u >> 6;
            heap[outIdx++] = 128 | u & 63;
          } else if (u <= 65535) {
            if (outIdx + 2 >= endIdx)
              break;
            heap[outIdx++] = 224 | u >> 12;
            heap[outIdx++] = 128 | u >> 6 & 63;
            heap[outIdx++] = 128 | u & 63;
          } else {
            if (outIdx + 3 >= endIdx)
              break;
            heap[outIdx++] = 240 | u >> 18;
            heap[outIdx++] = 128 | u >> 12 & 63;
            heap[outIdx++] = 128 | u >> 6 & 63;
            heap[outIdx++] = 128 | u & 63;
          }
        }
        heap[outIdx] = 0;
        return outIdx - startIdx;
      }
      function stringToUTF8(str2, outPtr, maxBytesToWrite) {
        return stringToUTF8Array(str2, GROWABLE_HEAP_U8(), outPtr, maxBytesToWrite);
      }
      function lengthBytesUTF8(str2) {
        var len = 0;
        for (var i = 0; i < str2.length; ++i) {
          var u = str2.charCodeAt(i);
          if (u >= 55296 && u <= 57343)
            u = 65536 + ((u & 1023) << 10) | str2.charCodeAt(++i) & 1023;
          if (u <= 127)
            ++len;
          else if (u <= 2047)
            len += 2;
          else if (u <= 65535)
            len += 3;
          else
            len += 4;
        }
        return len;
      }
      function writeArrayToMemory(array, buffer3) {
        GROWABLE_HEAP_I8().set(array, buffer3);
      }
      var WASM_PAGE_SIZE = 65536;
      function alignUp(x, multiple) {
        if (x % multiple > 0) {
          x += multiple - x % multiple;
        }
        return x;
      }
      var buffer2, HEAP8, HEAPU8, HEAP16, HEAPU16, HEAP32, HEAPU32, HEAPF32, HEAPF64;
      function updateGlobalBufferAndViews(buf) {
        buffer2 = buf;
        Module["HEAP8"] = HEAP8 = new Int8Array(buf);
        Module["HEAP16"] = HEAP16 = new Int16Array(buf);
        Module["HEAP32"] = HEAP32 = new Int32Array(buf);
        Module["HEAPU8"] = HEAPU8 = new Uint8Array(buf);
        Module["HEAPU16"] = HEAPU16 = new Uint16Array(buf);
        Module["HEAPU32"] = HEAPU32 = new Uint32Array(buf);
        Module["HEAPF32"] = HEAPF32 = new Float32Array(buf);
        Module["HEAPF64"] = HEAPF64 = new Float64Array(buf);
      }
      var STACK_BASE = 5256384, STACKTOP = STACK_BASE, STACK_MAX = 13504, DYNAMIC_BASE = 5256384, DYNAMICTOP_PTR = 12576;
      if (ENVIRONMENT_IS_PTHREAD) {
      }
      var INITIAL_INITIAL_MEMORY = Module["INITIAL_MEMORY"] || 16777216;
      if (ENVIRONMENT_IS_PTHREAD) {
        wasmMemory = Module["wasmMemory"];
        buffer2 = Module["buffer"];
      } else {
        if (Module["wasmMemory"]) {
          wasmMemory = Module["wasmMemory"];
        } else {
          wasmMemory = new WebAssembly.Memory({initial: INITIAL_INITIAL_MEMORY / WASM_PAGE_SIZE, maximum: 2147483648 / WASM_PAGE_SIZE, shared: true});
          if (!(wasmMemory.buffer instanceof SharedArrayBuffer)) {
            err("requested a shared WebAssembly.Memory but the returned buffer is not a SharedArrayBuffer, indicating that while the browser has SharedArrayBuffer it does not have WebAssembly threads support - you may need to set a flag");
            if (ENVIRONMENT_IS_NODE) {
              console.log("(on node you may need: --experimental-wasm-threads --experimental-wasm-bulk-memory and also use a recent version)");
            }
            throw Error("bad memory");
          }
        }
      }
      if (wasmMemory) {
        buffer2 = wasmMemory.buffer;
      }
      INITIAL_INITIAL_MEMORY = buffer2.byteLength;
      updateGlobalBufferAndViews(buffer2);
      if (!ENVIRONMENT_IS_PTHREAD) {
        GROWABLE_HEAP_I32()[DYNAMICTOP_PTR >> 2] = DYNAMIC_BASE;
      }
      function callRuntimeCallbacks(callbacks) {
        while (callbacks.length > 0) {
          var callback = callbacks.shift();
          if (typeof callback == "function") {
            callback(Module);
            continue;
          }
          var func = callback.func;
          if (typeof func === "number") {
            if (callback.arg === void 0) {
              Module["dynCall_v"](func);
            } else {
              Module["dynCall_vi"](func, callback.arg);
            }
          } else {
            func(callback.arg === void 0 ? null : callback.arg);
          }
        }
      }
      var __ATPRERUN__ = [];
      var __ATINIT__ = [];
      var __ATMAIN__ = [];
      var __ATEXIT__ = [];
      var __ATPOSTRUN__ = [];
      var runtimeInitialized = false;
      if (ENVIRONMENT_IS_PTHREAD)
        runtimeInitialized = true;
      function preRun() {
        if (ENVIRONMENT_IS_PTHREAD)
          return;
        if (Module["preRun"]) {
          if (typeof Module["preRun"] == "function")
            Module["preRun"] = [Module["preRun"]];
          while (Module["preRun"].length) {
            addOnPreRun(Module["preRun"].shift());
          }
        }
        callRuntimeCallbacks(__ATPRERUN__);
      }
      function initRuntime() {
        runtimeInitialized = true;
        callRuntimeCallbacks(__ATINIT__);
      }
      function preMain() {
        if (ENVIRONMENT_IS_PTHREAD)
          return;
        callRuntimeCallbacks(__ATMAIN__);
      }
      function postRun() {
        if (ENVIRONMENT_IS_PTHREAD)
          return;
        if (Module["postRun"]) {
          if (typeof Module["postRun"] == "function")
            Module["postRun"] = [Module["postRun"]];
          while (Module["postRun"].length) {
            addOnPostRun(Module["postRun"].shift());
          }
        }
        callRuntimeCallbacks(__ATPOSTRUN__);
      }
      function addOnPreRun(cb) {
        __ATPRERUN__.unshift(cb);
      }
      function addOnPostRun(cb) {
        __ATPOSTRUN__.unshift(cb);
      }
      var Math_ceil = Math.ceil;
      var Math_floor = Math.floor;
      var runDependencies = 0;
      var runDependencyWatcher = null;
      var dependenciesFulfilled = null;
      function addRunDependency(id) {
        assert2(!ENVIRONMENT_IS_PTHREAD, "addRunDependency cannot be used in a pthread worker");
        runDependencies++;
        if (Module["monitorRunDependencies"]) {
          Module["monitorRunDependencies"](runDependencies);
        }
      }
      function removeRunDependency(id) {
        runDependencies--;
        if (Module["monitorRunDependencies"]) {
          Module["monitorRunDependencies"](runDependencies);
        }
        if (runDependencies == 0) {
          if (runDependencyWatcher !== null) {
            clearInterval(runDependencyWatcher);
            runDependencyWatcher = null;
          }
          if (dependenciesFulfilled) {
            var callback = dependenciesFulfilled;
            dependenciesFulfilled = null;
            callback();
          }
        }
      }
      Module["preloadedImages"] = {};
      Module["preloadedAudios"] = {};
      function abort(what) {
        if (Module["onAbort"]) {
          Module["onAbort"](what);
        }
        if (ENVIRONMENT_IS_PTHREAD)
          console.error("Pthread aborting at " + new Error().stack);
        what += "";
        out(what);
        err(what);
        ABORT = true;
        EXITSTATUS = 1;
        what = "abort(" + what + "). Build with -s ASSERTIONS=1 for more info.";
        throw new WebAssembly.RuntimeError(what);
      }
      function hasPrefix(str2, prefix) {
        return String.prototype.startsWith ? str2.startsWith(prefix) : str2.indexOf(prefix) === 0;
      }
      var dataURIPrefix = "data:application/octet-stream;base64,";
      function isDataURI(filename) {
        return hasPrefix(filename, dataURIPrefix);
      }
      var fileURIPrefix = "file://";
      function isFileURI(filename) {
        return hasPrefix(filename, fileURIPrefix);
      }
      var wasmBinaryFile = "tfjs-backend-wasm-threaded-simd.wasm";
      if (!isDataURI(wasmBinaryFile)) {
        wasmBinaryFile = locateFile(wasmBinaryFile);
      }
      function getBinary() {
        try {
          if (wasmBinary) {
            return new Uint8Array(wasmBinary);
          }
          if (readBinary) {
            return readBinary(wasmBinaryFile);
          } else {
            throw "both async and sync fetching of the wasm failed";
          }
        } catch (err2) {
          abort(err2);
        }
      }
      function getBinaryPromise() {
        if (!wasmBinary && (ENVIRONMENT_IS_WEB || ENVIRONMENT_IS_WORKER) && typeof fetch === "function" && !isFileURI(wasmBinaryFile)) {
          return fetch(wasmBinaryFile, {credentials: "same-origin"}).then(function(response) {
            if (!response["ok"]) {
              throw "failed to load wasm binary file at '" + wasmBinaryFile + "'";
            }
            return response["arrayBuffer"]();
          }).catch(function() {
            return getBinary();
          });
        }
        return new Promise(function(resolve, reject) {
          resolve(getBinary());
        });
      }
      function createWasm() {
        var info = {a: asmLibraryArg};
        function receiveInstance(instance2, module2) {
          var exports3 = instance2.exports;
          Module["asm"] = exports3;
          wasmModule = module2;
          if (!ENVIRONMENT_IS_PTHREAD) {
            var numWorkersToLoad = PThread.unusedWorkers.length;
            PThread.unusedWorkers.forEach(function(w) {
              PThread.loadWasmModuleToWorker(w, function() {
                if (!--numWorkersToLoad)
                  removeRunDependency("wasm-instantiate");
              });
            });
          }
        }
        if (!ENVIRONMENT_IS_PTHREAD) {
          addRunDependency("wasm-instantiate");
        }
        function receiveInstantiatedSource(output) {
          receiveInstance(output["instance"], output["module"]);
        }
        function instantiateArrayBuffer(receiver) {
          return getBinaryPromise().then(function(binary) {
            return WebAssembly.instantiate(binary, info);
          }).then(receiver, function(reason) {
            err("failed to asynchronously prepare wasm: " + reason);
            abort(reason);
          });
        }
        function instantiateAsync() {
          if (!wasmBinary && typeof WebAssembly.instantiateStreaming === "function" && !isDataURI(wasmBinaryFile) && !isFileURI(wasmBinaryFile) && typeof fetch === "function") {
            fetch(wasmBinaryFile, {credentials: "same-origin"}).then(function(response) {
              var result = WebAssembly.instantiateStreaming(response, info);
              return result.then(receiveInstantiatedSource, function(reason) {
                err("wasm streaming compile failed: " + reason);
                err("falling back to ArrayBuffer instantiation");
                instantiateArrayBuffer(receiveInstantiatedSource);
              });
            });
          } else {
            return instantiateArrayBuffer(receiveInstantiatedSource);
          }
        }
        if (Module["instantiateWasm"]) {
          try {
            var exports2 = Module["instantiateWasm"](info, receiveInstance);
            return exports2;
          } catch (e) {
            err("Module.instantiateWasm callback failed with error: " + e);
            return false;
          }
        }
        instantiateAsync();
        return {};
      }
      var ASM_CONSTS = {};
      function initPthreadsJS() {
        PThread.initRuntime();
      }
      if (!ENVIRONMENT_IS_PTHREAD)
        __ATINIT__.push({func: function() {
          ___wasm_call_ctors();
        }});
      var __pthread_ptr = 0;
      var __pthread_is_main_runtime_thread = 0;
      var __pthread_is_main_browser_thread = 0;
      function __register_pthread_ptr(pthreadPtr, isMainBrowserThread, isMainRuntimeThread) {
        pthreadPtr = pthreadPtr | 0;
        isMainBrowserThread = isMainBrowserThread | 0;
        isMainRuntimeThread = isMainRuntimeThread | 0;
        __pthread_ptr = pthreadPtr;
        __pthread_is_main_browser_thread = isMainBrowserThread;
        __pthread_is_main_runtime_thread = isMainRuntimeThread;
      }
      Module["__register_pthread_ptr"] = __register_pthread_ptr;
      var ERRNO_CODES = {EPERM: 63, ENOENT: 44, ESRCH: 71, EINTR: 27, EIO: 29, ENXIO: 60, E2BIG: 1, ENOEXEC: 45, EBADF: 8, ECHILD: 12, EAGAIN: 6, EWOULDBLOCK: 6, ENOMEM: 48, EACCES: 2, EFAULT: 21, ENOTBLK: 105, EBUSY: 10, EEXIST: 20, EXDEV: 75, ENODEV: 43, ENOTDIR: 54, EISDIR: 31, EINVAL: 28, ENFILE: 41, EMFILE: 33, ENOTTY: 59, ETXTBSY: 74, EFBIG: 22, ENOSPC: 51, ESPIPE: 70, EROFS: 69, EMLINK: 34, EPIPE: 64, EDOM: 18, ERANGE: 68, ENOMSG: 49, EIDRM: 24, ECHRNG: 106, EL2NSYNC: 156, EL3HLT: 107, EL3RST: 108, ELNRNG: 109, EUNATCH: 110, ENOCSI: 111, EL2HLT: 112, EDEADLK: 16, ENOLCK: 46, EBADE: 113, EBADR: 114, EXFULL: 115, ENOANO: 104, EBADRQC: 103, EBADSLT: 102, EDEADLOCK: 16, EBFONT: 101, ENOSTR: 100, ENODATA: 116, ETIME: 117, ENOSR: 118, ENONET: 119, ENOPKG: 120, EREMOTE: 121, ENOLINK: 47, EADV: 122, ESRMNT: 123, ECOMM: 124, EPROTO: 65, EMULTIHOP: 36, EDOTDOT: 125, EBADMSG: 9, ENOTUNIQ: 126, EBADFD: 127, EREMCHG: 128, ELIBACC: 129, ELIBBAD: 130, ELIBSCN: 131, ELIBMAX: 132, ELIBEXEC: 133, ENOSYS: 52, ENOTEMPTY: 55, ENAMETOOLONG: 37, ELOOP: 32, EOPNOTSUPP: 138, EPFNOSUPPORT: 139, ECONNRESET: 15, ENOBUFS: 42, EAFNOSUPPORT: 5, EPROTOTYPE: 67, ENOTSOCK: 57, ENOPROTOOPT: 50, ESHUTDOWN: 140, ECONNREFUSED: 14, EADDRINUSE: 3, ECONNABORTED: 13, ENETUNREACH: 40, ENETDOWN: 38, ETIMEDOUT: 73, EHOSTDOWN: 142, EHOSTUNREACH: 23, EINPROGRESS: 26, EALREADY: 7, EDESTADDRREQ: 17, EMSGSIZE: 35, EPROTONOSUPPORT: 66, ESOCKTNOSUPPORT: 137, EADDRNOTAVAIL: 4, ENETRESET: 39, EISCONN: 30, ENOTCONN: 53, ETOOMANYREFS: 141, EUSERS: 136, EDQUOT: 19, ESTALE: 72, ENOTSUP: 138, ENOMEDIUM: 148, EILSEQ: 25, EOVERFLOW: 61, ECANCELED: 11, ENOTRECOVERABLE: 56, EOWNERDEAD: 62, ESTRPIPE: 135};
      var __main_thread_futex_wait_address = 13488;
      function _emscripten_futex_wake(addr, count) {
        if (addr <= 0 || addr > GROWABLE_HEAP_I8().length || addr & true || count < 0)
          return -28;
        if (count == 0)
          return 0;
        if (count >= 2147483647)
          count = Infinity;
        var mainThreadWaitAddress = Atomics.load(GROWABLE_HEAP_I32(), __main_thread_futex_wait_address >> 2);
        var mainThreadWoken = 0;
        if (mainThreadWaitAddress == addr) {
          var loadedAddr = Atomics.compareExchange(GROWABLE_HEAP_I32(), __main_thread_futex_wait_address >> 2, mainThreadWaitAddress, 0);
          if (loadedAddr == mainThreadWaitAddress) {
            --count;
            mainThreadWoken = 1;
            if (count <= 0)
              return 1;
          }
        }
        var ret = Atomics.notify(GROWABLE_HEAP_I32(), addr >> 2, count);
        if (ret >= 0)
          return ret + mainThreadWoken;
        throw "Atomics.notify returned an unexpected value " + ret;
      }
      Module["_emscripten_futex_wake"] = _emscripten_futex_wake;
      function __kill_thread(pthread_ptr) {
        if (ENVIRONMENT_IS_PTHREAD)
          throw "Internal Error! _kill_thread() can only ever be called from main application thread!";
        if (!pthread_ptr)
          throw "Internal Error! Null pthread_ptr in _kill_thread!";
        GROWABLE_HEAP_I32()[pthread_ptr + 12 >> 2] = 0;
        var pthread = PThread.pthreads[pthread_ptr];
        pthread.worker.terminate();
        PThread.freeThreadData(pthread);
        PThread.runningWorkers.splice(PThread.runningWorkers.indexOf(pthread.worker), 1);
        pthread.worker.pthread = void 0;
      }
      function __cancel_thread(pthread_ptr) {
        if (ENVIRONMENT_IS_PTHREAD)
          throw "Internal Error! _cancel_thread() can only ever be called from main application thread!";
        if (!pthread_ptr)
          throw "Internal Error! Null pthread_ptr in _cancel_thread!";
        var pthread = PThread.pthreads[pthread_ptr];
        pthread.worker.postMessage({cmd: "cancel"});
      }
      function __cleanup_thread(pthread_ptr) {
        if (ENVIRONMENT_IS_PTHREAD)
          throw "Internal Error! _cleanup_thread() can only ever be called from main application thread!";
        if (!pthread_ptr)
          throw "Internal Error! Null pthread_ptr in _cleanup_thread!";
        GROWABLE_HEAP_I32()[pthread_ptr + 12 >> 2] = 0;
        var pthread = PThread.pthreads[pthread_ptr];
        if (pthread) {
          var worker2 = pthread.worker;
          PThread.returnWorkerToPool(worker2);
        }
      }
      var PThread = {MAIN_THREAD_ID: 1, mainThreadInfo: {schedPolicy: 0, schedPrio: 0}, unusedWorkers: [], runningWorkers: [], initRuntime: function() {
        __register_pthread_ptr(PThread.mainThreadBlock, !ENVIRONMENT_IS_WORKER, 1);
        _emscripten_register_main_browser_thread_id(PThread.mainThreadBlock);
      }, initMainThreadBlock: function() {
        var pthreadPoolSize = 8;
        for (var i = 0; i < pthreadPoolSize; ++i) {
          PThread.allocateUnusedWorker();
        }
        PThread.mainThreadBlock = 12736;
        for (var i = 0; i < 232 / 4; ++i)
          GROWABLE_HEAP_U32()[PThread.mainThreadBlock / 4 + i] = 0;
        GROWABLE_HEAP_I32()[PThread.mainThreadBlock + 12 >> 2] = PThread.mainThreadBlock;
        var headPtr = PThread.mainThreadBlock + 156;
        GROWABLE_HEAP_I32()[headPtr >> 2] = headPtr;
        var tlsMemory = 12976;
        for (var i = 0; i < 128; ++i)
          GROWABLE_HEAP_U32()[tlsMemory / 4 + i] = 0;
        Atomics.store(GROWABLE_HEAP_U32(), PThread.mainThreadBlock + 104 >> 2, tlsMemory);
        Atomics.store(GROWABLE_HEAP_U32(), PThread.mainThreadBlock + 40 >> 2, PThread.mainThreadBlock);
        Atomics.store(GROWABLE_HEAP_U32(), PThread.mainThreadBlock + 44 >> 2, 42);
      }, initWorker: function() {
      }, pthreads: {}, exitHandlers: null, setThreadStatus: function() {
      }, runExitHandlers: function() {
        if (PThread.exitHandlers !== null) {
          while (PThread.exitHandlers.length > 0) {
            PThread.exitHandlers.pop()();
          }
          PThread.exitHandlers = null;
        }
        if (ENVIRONMENT_IS_PTHREAD && threadInfoStruct)
          ___pthread_tsd_run_dtors();
      }, threadExit: function(exitCode) {
        var tb = _pthread_self();
        if (tb) {
          Atomics.store(GROWABLE_HEAP_U32(), tb + 4 >> 2, exitCode);
          Atomics.store(GROWABLE_HEAP_U32(), tb + 0 >> 2, 1);
          Atomics.store(GROWABLE_HEAP_U32(), tb + 60 >> 2, 1);
          Atomics.store(GROWABLE_HEAP_U32(), tb + 64 >> 2, 0);
          PThread.runExitHandlers();
          _emscripten_futex_wake(tb + 0, 2147483647);
          __register_pthread_ptr(0, 0, 0);
          threadInfoStruct = 0;
          if (ENVIRONMENT_IS_PTHREAD) {
            postMessage({cmd: "exit"});
          }
        }
      }, threadCancel: function() {
        PThread.runExitHandlers();
        Atomics.store(GROWABLE_HEAP_U32(), threadInfoStruct + 4 >> 2, -1);
        Atomics.store(GROWABLE_HEAP_U32(), threadInfoStruct + 0 >> 2, 1);
        _emscripten_futex_wake(threadInfoStruct + 0, 2147483647);
        threadInfoStruct = selfThreadId = 0;
        __register_pthread_ptr(0, 0, 0);
        postMessage({cmd: "cancelDone"});
      }, terminateAllThreads: function() {
        for (var t in PThread.pthreads) {
          var pthread = PThread.pthreads[t];
          if (pthread && pthread.worker) {
            PThread.returnWorkerToPool(pthread.worker);
          }
        }
        PThread.pthreads = {};
        for (var i = 0; i < PThread.unusedWorkers.length; ++i) {
          var worker2 = PThread.unusedWorkers[i];
          worker2.terminate();
        }
        PThread.unusedWorkers = [];
        for (var i = 0; i < PThread.runningWorkers.length; ++i) {
          var worker2 = PThread.runningWorkers[i];
          var pthread = worker2.pthread;
          PThread.freeThreadData(pthread);
          worker2.terminate();
        }
        PThread.runningWorkers = [];
      }, freeThreadData: function(pthread) {
        if (!pthread)
          return;
        if (pthread.threadInfoStruct) {
          var tlsMemory = GROWABLE_HEAP_I32()[pthread.threadInfoStruct + 104 >> 2];
          GROWABLE_HEAP_I32()[pthread.threadInfoStruct + 104 >> 2] = 0;
          _free(tlsMemory);
          _free(pthread.threadInfoStruct);
        }
        pthread.threadInfoStruct = 0;
        if (pthread.allocatedOwnStack && pthread.stackBase)
          _free(pthread.stackBase);
        pthread.stackBase = 0;
        if (pthread.worker)
          pthread.worker.pthread = null;
      }, returnWorkerToPool: function(worker2) {
        delete PThread.pthreads[worker2.pthread.thread];
        PThread.unusedWorkers.push(worker2);
        PThread.runningWorkers.splice(PThread.runningWorkers.indexOf(worker2), 1);
        PThread.freeThreadData(worker2.pthread);
        worker2.pthread = void 0;
      }, receiveObjectTransfer: function(data2) {
      }, loadWasmModuleToWorker: function(worker2, onFinishedLoading) {
        worker2.onmessage = function(e) {
          var d = e["data"];
          var cmd = d["cmd"];
          if (worker2.pthread)
            PThread.currentProxiedOperationCallerThread = worker2.pthread.threadInfoStruct;
          if (d["targetThread"] && d["targetThread"] != _pthread_self()) {
            var thread = PThread.pthreads[d.targetThread];
            if (thread) {
              thread.worker.postMessage(e.data, d["transferList"]);
            } else {
              console.error('Internal error! Worker sent a message "' + cmd + '" to target pthread ' + d["targetThread"] + ", but that thread no longer exists!");
            }
            PThread.currentProxiedOperationCallerThread = void 0;
            return;
          }
          if (cmd === "processQueuedMainThreadWork") {
            _emscripten_main_thread_process_queued_calls();
          } else if (cmd === "spawnThread") {
            __spawn_thread(e.data);
          } else if (cmd === "cleanupThread") {
            __cleanup_thread(d["thread"]);
          } else if (cmd === "killThread") {
            __kill_thread(d["thread"]);
          } else if (cmd === "cancelThread") {
            __cancel_thread(d["thread"]);
          } else if (cmd === "loaded") {
            worker2.loaded = true;
            if (onFinishedLoading)
              onFinishedLoading(worker2);
            if (worker2.runPthread) {
              worker2.runPthread();
              delete worker2.runPthread;
            }
          } else if (cmd === "print") {
            out("Thread " + d["threadId"] + ": " + d["text"]);
          } else if (cmd === "printErr") {
            err("Thread " + d["threadId"] + ": " + d["text"]);
          } else if (cmd === "alert") {
            alert("Thread " + d["threadId"] + ": " + d["text"]);
          } else if (cmd === "exit") {
            var detached = worker2.pthread && Atomics.load(GROWABLE_HEAP_U32(), worker2.pthread.thread + 68 >> 2);
            if (detached) {
              PThread.returnWorkerToPool(worker2);
            }
          } else if (cmd === "cancelDone") {
            PThread.returnWorkerToPool(worker2);
          } else if (cmd === "objectTransfer") {
            PThread.receiveObjectTransfer(e.data);
          } else if (e.data.target === "setimmediate") {
            worker2.postMessage(e.data);
          } else {
            err("worker sent an unknown command " + cmd);
          }
          PThread.currentProxiedOperationCallerThread = void 0;
        };
        worker2.onerror = function(e) {
          err("pthread sent an error! " + e.filename + ":" + e.lineno + ": " + e.message);
        };
        if (ENVIRONMENT_IS_NODE) {
          worker2.on("message", function(data2) {
            worker2.onmessage({data: data2});
          });
          worker2.on("error", function(data2) {
            worker2.onerror(data2);
          });
          worker2.on("exit", function(data2) {
            console.log("worker exited - TODO: update the worker queue?");
          });
        }
        worker2.postMessage({cmd: "load", urlOrBlob: Module["mainScriptUrlOrBlob"] || _scriptDir, wasmMemory, wasmModule, DYNAMIC_BASE, DYNAMICTOP_PTR});
      }, allocateUnusedWorker: function() {
        var pthreadMainJs = locateFile("tfjs-backend-wasm-threaded-simd.worker.js");
        PThread.unusedWorkers.push(new Worker(pthreadMainJs));
      }, getNewWorker: function() {
        if (PThread.unusedWorkers.length == 0) {
          PThread.allocateUnusedWorker();
          PThread.loadWasmModuleToWorker(PThread.unusedWorkers[0]);
        }
        if (PThread.unusedWorkers.length > 0)
          return PThread.unusedWorkers.pop();
        else
          return null;
      }, busySpinWait: function(msecs) {
        var t = performance.now() + msecs;
        while (performance.now() < t) {
        }
      }};
      function establishStackSpace(stackTop, stackMax) {
        STACK_BASE = STACKTOP = stackTop;
        STACK_MAX = stackMax;
        stackRestore(stackTop);
      }
      Module["establishStackSpace"] = establishStackSpace;
      function getNoExitRuntime() {
        return noExitRuntime;
      }
      Module["getNoExitRuntime"] = getNoExitRuntime;
      function ___assert_fail(condition, filename, line, func) {
        abort("Assertion failed: " + UTF8ToString(condition) + ", at: " + [filename ? UTF8ToString(filename) : "unknown filename", line, func ? UTF8ToString(func) : "unknown function"]);
      }
      function ___call_main(argc, argv) {
        var returnCode = _main(argc, argv);
      }
      var _emscripten_get_now;
      if (ENVIRONMENT_IS_NODE) {
        _emscripten_get_now = function() {
          var t = process["hrtime"]();
          return t[0] * 1e3 + t[1] / 1e6;
        };
      } else if (ENVIRONMENT_IS_PTHREAD) {
        _emscripten_get_now = function() {
          return performance.now() - Module["__performance_now_clock_drift"];
        };
      } else if (typeof dateNow !== "undefined") {
        _emscripten_get_now = dateNow;
      } else
        _emscripten_get_now = function() {
          return performance.now();
        };
      function setErrNo(value) {
        GROWABLE_HEAP_I32()[___errno_location() >> 2] = value;
        return value;
      }
      function _atexit(func, arg) {
        if (ENVIRONMENT_IS_PTHREAD)
          return _emscripten_proxy_to_main_thread_js(1, 1, func, arg);
        __ATEXIT__.unshift({func, arg});
      }
      function __emscripten_notify_thread_queue(targetThreadId, mainThreadId) {
        if (targetThreadId == mainThreadId) {
          postMessage({cmd: "processQueuedMainThreadWork"});
        } else if (ENVIRONMENT_IS_PTHREAD) {
          postMessage({targetThread: targetThreadId, cmd: "processThreadQueue"});
        } else {
          var pthread = PThread.pthreads[targetThreadId];
          var worker2 = pthread && pthread.worker;
          if (!worker2) {
            return;
          }
          worker2.postMessage({cmd: "processThreadQueue"});
        }
        return 1;
      }
      function _abort() {
        abort();
      }
      function _emscripten_conditional_set_current_thread_status(expectedStatus, newStatus) {
        expectedStatus = expectedStatus | 0;
        newStatus = newStatus | 0;
      }
      function _emscripten_futex_wait(addr, val, timeout) {
        if (addr <= 0 || addr > GROWABLE_HEAP_I8().length || addr & true)
          return -28;
        if (ENVIRONMENT_IS_WORKER) {
          var ret = Atomics.wait(GROWABLE_HEAP_I32(), addr >> 2, val, timeout);
          if (ret === "timed-out")
            return -73;
          if (ret === "not-equal")
            return -6;
          if (ret === "ok")
            return 0;
          throw "Atomics.wait returned an unexpected value " + ret;
        } else {
          var loadedVal = Atomics.load(GROWABLE_HEAP_I32(), addr >> 2);
          if (val != loadedVal)
            return -6;
          var tNow = performance.now();
          var tEnd = tNow + timeout;
          Atomics.store(GROWABLE_HEAP_I32(), __main_thread_futex_wait_address >> 2, addr);
          var ourWaitAddress = addr;
          while (addr == ourWaitAddress) {
            tNow = performance.now();
            if (tNow > tEnd) {
              return -73;
            }
            _emscripten_main_thread_process_queued_calls();
            addr = Atomics.load(GROWABLE_HEAP_I32(), __main_thread_futex_wait_address >> 2);
          }
          return 0;
        }
      }
      function _emscripten_is_main_browser_thread() {
        return __pthread_is_main_browser_thread | 0;
      }
      function _emscripten_is_main_runtime_thread() {
        return __pthread_is_main_runtime_thread | 0;
      }
      function _emscripten_memcpy_big(dest, src, num) {
        GROWABLE_HEAP_U8().copyWithin(dest, src, src + num);
      }
      function _emscripten_num_logical_cores() {
        return navigator["hardwareConcurrency"];
      }
      function _emscripten_proxy_to_main_thread_js(index, sync) {
        var numCallArgs = arguments.length - 2;
        var stack = stackSave();
        var args = stackAlloc(numCallArgs * 8);
        var b = args >> 3;
        for (var i = 0; i < numCallArgs; i++) {
          GROWABLE_HEAP_F64()[b + i] = arguments[2 + i];
        }
        var ret = _emscripten_run_in_main_runtime_thread_js(index, numCallArgs, args, sync);
        stackRestore(stack);
        return ret;
      }
      var _emscripten_receive_on_main_thread_js_callArgs = [];
      function readAsmConstArgs(sigPtr, buf) {
        if (!readAsmConstArgs.array) {
          readAsmConstArgs.array = [];
        }
        var args = readAsmConstArgs.array;
        args.length = 0;
        var ch;
        while (ch = GROWABLE_HEAP_U8()[sigPtr++]) {
          if (ch === 100 || ch === 102) {
            buf = buf + 7 & ~7;
            args.push(GROWABLE_HEAP_F64()[buf >> 3]);
            buf += 8;
          } else {
            buf = buf + 3 & ~3;
            args.push(GROWABLE_HEAP_I32()[buf >> 2]);
            buf += 4;
          }
        }
        return args;
      }
      function _emscripten_receive_on_main_thread_js(index, numCallArgs, args) {
        _emscripten_receive_on_main_thread_js_callArgs.length = numCallArgs;
        var b = args >> 3;
        for (var i = 0; i < numCallArgs; i++) {
          _emscripten_receive_on_main_thread_js_callArgs[i] = GROWABLE_HEAP_F64()[b + i];
        }
        var isEmAsmConst = index < 0;
        var func = !isEmAsmConst ? proxiedFunctionTable[index] : ASM_CONSTS[-index - 1];
        if (isEmAsmConst) {
          var sigPtr = _emscripten_receive_on_main_thread_js_callArgs[1];
          var varargPtr = _emscripten_receive_on_main_thread_js_callArgs[2];
          var constArgs = readAsmConstArgs(sigPtr, varargPtr);
          return func.apply(null, constArgs);
        }
        return func.apply(null, _emscripten_receive_on_main_thread_js_callArgs);
      }
      function _emscripten_get_heap_size() {
        return GROWABLE_HEAP_U8().length;
      }
      function emscripten_realloc_buffer(size) {
        try {
          wasmMemory.grow(size - buffer2.byteLength + 65535 >>> 16);
          updateGlobalBufferAndViews(wasmMemory.buffer);
          return 1;
        } catch (e) {
        }
      }
      function _emscripten_resize_heap(requestedSize) {
        requestedSize = requestedSize >>> 0;
        var oldSize = _emscripten_get_heap_size();
        if (requestedSize <= oldSize) {
          return false;
        }
        var PAGE_MULTIPLE = 65536;
        var maxHeapSize = 2147483648;
        if (requestedSize > maxHeapSize) {
          return false;
        }
        var minHeapSize = 16777216;
        for (var cutDown = 1; cutDown <= 4; cutDown *= 2) {
          var overGrownHeapSize = oldSize * (1 + 0.2 / cutDown);
          overGrownHeapSize = Math.min(overGrownHeapSize, requestedSize + 100663296);
          var newSize = Math.min(maxHeapSize, alignUp(Math.max(minHeapSize, requestedSize, overGrownHeapSize), PAGE_MULTIPLE));
          var replacement = emscripten_realloc_buffer(newSize);
          if (replacement) {
            return true;
          }
        }
        return false;
      }
      var JSEvents = {keyEvent: 0, mouseEvent: 0, wheelEvent: 0, uiEvent: 0, focusEvent: 0, deviceOrientationEvent: 0, deviceMotionEvent: 0, fullscreenChangeEvent: 0, pointerlockChangeEvent: 0, visibilityChangeEvent: 0, touchEvent: 0, previousFullscreenElement: null, previousScreenX: null, previousScreenY: null, removeEventListenersRegistered: false, removeAllEventListeners: function() {
        for (var i = JSEvents.eventHandlers.length - 1; i >= 0; --i) {
          JSEvents._removeHandler(i);
        }
        JSEvents.eventHandlers = [];
        JSEvents.deferredCalls = [];
      }, registerRemoveEventListeners: function() {
        if (!JSEvents.removeEventListenersRegistered) {
          __ATEXIT__.push(JSEvents.removeAllEventListeners);
          JSEvents.removeEventListenersRegistered = true;
        }
      }, deferredCalls: [], deferCall: function(targetFunction, precedence, argsList) {
        function arraysHaveEqualContent(arrA, arrB) {
          if (arrA.length != arrB.length)
            return false;
          for (var i2 in arrA) {
            if (arrA[i2] != arrB[i2])
              return false;
          }
          return true;
        }
        for (var i in JSEvents.deferredCalls) {
          var call = JSEvents.deferredCalls[i];
          if (call.targetFunction == targetFunction && arraysHaveEqualContent(call.argsList, argsList)) {
            return;
          }
        }
        JSEvents.deferredCalls.push({targetFunction, precedence, argsList});
        JSEvents.deferredCalls.sort(function(x, y) {
          return x.precedence < y.precedence;
        });
      }, removeDeferredCalls: function(targetFunction) {
        for (var i = 0; i < JSEvents.deferredCalls.length; ++i) {
          if (JSEvents.deferredCalls[i].targetFunction == targetFunction) {
            JSEvents.deferredCalls.splice(i, 1);
            --i;
          }
        }
      }, canPerformEventHandlerRequests: function() {
        return JSEvents.inEventHandler && JSEvents.currentEventHandler.allowsDeferredCalls;
      }, runDeferredCalls: function() {
        if (!JSEvents.canPerformEventHandlerRequests()) {
          return;
        }
        for (var i = 0; i < JSEvents.deferredCalls.length; ++i) {
          var call = JSEvents.deferredCalls[i];
          JSEvents.deferredCalls.splice(i, 1);
          --i;
          call.targetFunction.apply(null, call.argsList);
        }
      }, inEventHandler: 0, currentEventHandler: null, eventHandlers: [], removeAllHandlersOnTarget: function(target, eventTypeString) {
        for (var i = 0; i < JSEvents.eventHandlers.length; ++i) {
          if (JSEvents.eventHandlers[i].target == target && (!eventTypeString || eventTypeString == JSEvents.eventHandlers[i].eventTypeString)) {
            JSEvents._removeHandler(i--);
          }
        }
      }, _removeHandler: function(i) {
        var h = JSEvents.eventHandlers[i];
        h.target.removeEventListener(h.eventTypeString, h.eventListenerFunc, h.useCapture);
        JSEvents.eventHandlers.splice(i, 1);
      }, registerOrRemoveHandler: function(eventHandler) {
        var jsEventHandler = function jsEventHandler2(event) {
          ++JSEvents.inEventHandler;
          JSEvents.currentEventHandler = eventHandler;
          JSEvents.runDeferredCalls();
          eventHandler.handlerFunc(event);
          JSEvents.runDeferredCalls();
          --JSEvents.inEventHandler;
        };
        if (eventHandler.callbackfunc) {
          eventHandler.eventListenerFunc = jsEventHandler;
          eventHandler.target.addEventListener(eventHandler.eventTypeString, jsEventHandler, eventHandler.useCapture);
          JSEvents.eventHandlers.push(eventHandler);
          JSEvents.registerRemoveEventListeners();
        } else {
          for (var i = 0; i < JSEvents.eventHandlers.length; ++i) {
            if (JSEvents.eventHandlers[i].target == eventHandler.target && JSEvents.eventHandlers[i].eventTypeString == eventHandler.eventTypeString) {
              JSEvents._removeHandler(i--);
            }
          }
        }
      }, queueEventHandlerOnThread_iiii: function(targetThread, eventHandlerFunc, eventTypeId, eventData, userData) {
        var stackTop = stackSave();
        var varargs = stackAlloc(12);
        GROWABLE_HEAP_I32()[varargs >> 2] = eventTypeId;
        GROWABLE_HEAP_I32()[varargs + 4 >> 2] = eventData;
        GROWABLE_HEAP_I32()[varargs + 8 >> 2] = userData;
        _emscripten_async_queue_on_thread_(targetThread, 637534208, eventHandlerFunc, eventData, varargs);
        stackRestore(stackTop);
      }, getTargetThreadForEventCallback: function(targetThread) {
        switch (targetThread) {
          case 1:
            return 0;
          case 2:
            return PThread.currentProxiedOperationCallerThread;
          default:
            return targetThread;
        }
      }, getNodeNameForTarget: function(target) {
        if (!target)
          return "";
        if (target == window)
          return "#window";
        if (target == screen)
          return "#screen";
        return target && target.nodeName ? target.nodeName : "";
      }, fullscreenEnabled: function() {
        return document.fullscreenEnabled || document.webkitFullscreenEnabled;
      }};
      function stringToNewUTF8(jsString) {
        var length = lengthBytesUTF8(jsString) + 1;
        var cString = _malloc(length);
        stringToUTF8(jsString, cString, length);
        return cString;
      }
      function _emscripten_set_offscreencanvas_size_on_target_thread_js(targetThread, targetCanvas, width, height) {
        var stackTop = stackSave();
        var varargs = stackAlloc(12);
        var targetCanvasPtr = 0;
        if (targetCanvas) {
          targetCanvasPtr = stringToNewUTF8(targetCanvas);
        }
        GROWABLE_HEAP_I32()[varargs >> 2] = targetCanvasPtr;
        GROWABLE_HEAP_I32()[varargs + 4 >> 2] = width;
        GROWABLE_HEAP_I32()[varargs + 8 >> 2] = height;
        _emscripten_async_queue_on_thread_(targetThread, 657457152, 0, targetCanvasPtr, varargs);
        stackRestore(stackTop);
      }
      function _emscripten_set_offscreencanvas_size_on_target_thread(targetThread, targetCanvas, width, height) {
        targetCanvas = targetCanvas ? UTF8ToString(targetCanvas) : "";
        _emscripten_set_offscreencanvas_size_on_target_thread_js(targetThread, targetCanvas, width, height);
      }
      function __maybeCStringToJsString(cString) {
        return cString > 2 ? UTF8ToString(cString) : cString;
      }
      var specialHTMLTargets = [0, typeof document !== "undefined" ? document : 0, typeof window !== "undefined" ? window : 0];
      function __findEventTarget(target) {
        target = __maybeCStringToJsString(target);
        var domElement = specialHTMLTargets[target] || (typeof document !== "undefined" ? document.querySelector(target) : void 0);
        return domElement;
      }
      function __findCanvasEventTarget(target) {
        return __findEventTarget(target);
      }
      function _emscripten_set_canvas_element_size_calling_thread(target, width, height) {
        var canvas = __findCanvasEventTarget(target);
        if (!canvas)
          return -4;
        if (canvas.canvasSharedPtr) {
          GROWABLE_HEAP_I32()[canvas.canvasSharedPtr >> 2] = width;
          GROWABLE_HEAP_I32()[canvas.canvasSharedPtr + 4 >> 2] = height;
        }
        if (canvas.offscreenCanvas || !canvas.controlTransferredOffscreen) {
          if (canvas.offscreenCanvas)
            canvas = canvas.offscreenCanvas;
          var autoResizeViewport = false;
          if (canvas.GLctxObject && canvas.GLctxObject.GLctx) {
            var prevViewport = canvas.GLctxObject.GLctx.getParameter(2978);
            autoResizeViewport = prevViewport[0] === 0 && prevViewport[1] === 0 && prevViewport[2] === canvas.width && prevViewport[3] === canvas.height;
          }
          canvas.width = width;
          canvas.height = height;
          if (autoResizeViewport) {
            canvas.GLctxObject.GLctx.viewport(0, 0, width, height);
          }
        } else if (canvas.canvasSharedPtr) {
          var targetThread = GROWABLE_HEAP_I32()[canvas.canvasSharedPtr + 8 >> 2];
          _emscripten_set_offscreencanvas_size_on_target_thread(targetThread, target, width, height);
          return 1;
        } else {
          return -4;
        }
        return 0;
      }
      function _emscripten_set_canvas_element_size_main_thread(target, width, height) {
        if (ENVIRONMENT_IS_PTHREAD)
          return _emscripten_proxy_to_main_thread_js(2, 1, target, width, height);
        return _emscripten_set_canvas_element_size_calling_thread(target, width, height);
      }
      function _emscripten_set_canvas_element_size(target, width, height) {
        var canvas = __findCanvasEventTarget(target);
        if (canvas) {
          return _emscripten_set_canvas_element_size_calling_thread(target, width, height);
        } else {
          return _emscripten_set_canvas_element_size_main_thread(target, width, height);
        }
      }
      function _emscripten_set_current_thread_status(newStatus) {
        newStatus = newStatus | 0;
      }
      function _emscripten_set_thread_name(threadId, name) {
        threadId = threadId | 0;
        name = name | 0;
      }
      function __webgl_enable_ANGLE_instanced_arrays(ctx) {
        var ext = ctx.getExtension("ANGLE_instanced_arrays");
        if (ext) {
          ctx["vertexAttribDivisor"] = function(index, divisor) {
            ext["vertexAttribDivisorANGLE"](index, divisor);
          };
          ctx["drawArraysInstanced"] = function(mode, first, count, primcount) {
            ext["drawArraysInstancedANGLE"](mode, first, count, primcount);
          };
          ctx["drawElementsInstanced"] = function(mode, count, type, indices, primcount) {
            ext["drawElementsInstancedANGLE"](mode, count, type, indices, primcount);
          };
          return 1;
        }
      }
      function __webgl_enable_OES_vertex_array_object(ctx) {
        var ext = ctx.getExtension("OES_vertex_array_object");
        if (ext) {
          ctx["createVertexArray"] = function() {
            return ext["createVertexArrayOES"]();
          };
          ctx["deleteVertexArray"] = function(vao) {
            ext["deleteVertexArrayOES"](vao);
          };
          ctx["bindVertexArray"] = function(vao) {
            ext["bindVertexArrayOES"](vao);
          };
          ctx["isVertexArray"] = function(vao) {
            return ext["isVertexArrayOES"](vao);
          };
          return 1;
        }
      }
      function __webgl_enable_WEBGL_draw_buffers(ctx) {
        var ext = ctx.getExtension("WEBGL_draw_buffers");
        if (ext) {
          ctx["drawBuffers"] = function(n, bufs) {
            ext["drawBuffersWEBGL"](n, bufs);
          };
          return 1;
        }
      }
      var GL = {counter: 1, lastError: 0, buffers: [], mappedBuffers: {}, programs: [], framebuffers: [], renderbuffers: [], textures: [], uniforms: [], shaders: [], vaos: [], contexts: {}, currentContext: null, offscreenCanvases: {}, timerQueriesEXT: [], programInfos: {}, stringCache: {}, unpackAlignment: 4, init: function() {
        var miniTempFloatBuffer = new Float32Array(GL.MINI_TEMP_BUFFER_SIZE);
        for (var i = 0; i < GL.MINI_TEMP_BUFFER_SIZE; i++) {
          GL.miniTempBufferFloatViews[i] = miniTempFloatBuffer.subarray(0, i + 1);
        }
        var miniTempIntBuffer = new Int32Array(GL.MINI_TEMP_BUFFER_SIZE);
        for (var i = 0; i < GL.MINI_TEMP_BUFFER_SIZE; i++) {
          GL.miniTempBufferIntViews[i] = miniTempIntBuffer.subarray(0, i + 1);
        }
      }, recordError: function recordError(errorCode) {
        if (!GL.lastError) {
          GL.lastError = errorCode;
        }
      }, getNewId: function(table) {
        var ret = GL.counter++;
        for (var i = table.length; i < ret; i++) {
          table[i] = null;
        }
        return ret;
      }, MINI_TEMP_BUFFER_SIZE: 256, miniTempBufferFloatViews: [0], miniTempBufferIntViews: [0], getSource: function(shader, count, string, length) {
        var source = "";
        for (var i = 0; i < count; ++i) {
          var len = length ? GROWABLE_HEAP_I32()[length + i * 4 >> 2] : -1;
          source += UTF8ToString(GROWABLE_HEAP_I32()[string + i * 4 >> 2], len < 0 ? void 0 : len);
        }
        return source;
      }, createContext: function(canvas, webGLContextAttributes) {
        var ctx = canvas.getContext("webgl", webGLContextAttributes);
        if (!ctx)
          return 0;
        var handle = GL.registerContext(ctx, webGLContextAttributes);
        return handle;
      }, registerContext: function(ctx, webGLContextAttributes) {
        var handle = _malloc(8);
        GROWABLE_HEAP_I32()[handle + 4 >> 2] = _pthread_self();
        var context = {handle, attributes: webGLContextAttributes, version: webGLContextAttributes.majorVersion, GLctx: ctx};
        if (ctx.canvas)
          ctx.canvas.GLctxObject = context;
        GL.contexts[handle] = context;
        if (typeof webGLContextAttributes.enableExtensionsByDefault === "undefined" || webGLContextAttributes.enableExtensionsByDefault) {
          GL.initExtensions(context);
        }
        return handle;
      }, makeContextCurrent: function(contextHandle) {
        GL.currentContext = GL.contexts[contextHandle];
        Module.ctx = GLctx = GL.currentContext && GL.currentContext.GLctx;
        return !(contextHandle && !GLctx);
      }, getContext: function(contextHandle) {
        return GL.contexts[contextHandle];
      }, deleteContext: function(contextHandle) {
        if (GL.currentContext === GL.contexts[contextHandle])
          GL.currentContext = null;
        if (typeof JSEvents === "object")
          JSEvents.removeAllHandlersOnTarget(GL.contexts[contextHandle].GLctx.canvas);
        if (GL.contexts[contextHandle] && GL.contexts[contextHandle].GLctx.canvas)
          GL.contexts[contextHandle].GLctx.canvas.GLctxObject = void 0;
        _free(GL.contexts[contextHandle].handle);
        GL.contexts[contextHandle] = null;
      }, initExtensions: function(context) {
        if (!context)
          context = GL.currentContext;
        if (context.initExtensionsDone)
          return;
        context.initExtensionsDone = true;
        var GLctx2 = context.GLctx;
        __webgl_enable_ANGLE_instanced_arrays(GLctx2);
        __webgl_enable_OES_vertex_array_object(GLctx2);
        __webgl_enable_WEBGL_draw_buffers(GLctx2);
        GLctx2.disjointTimerQueryExt = GLctx2.getExtension("EXT_disjoint_timer_query");
        var automaticallyEnabledExtensions = ["OES_texture_float", "OES_texture_half_float", "OES_standard_derivatives", "OES_vertex_array_object", "WEBGL_compressed_texture_s3tc", "WEBGL_depth_texture", "OES_element_index_uint", "EXT_texture_filter_anisotropic", "EXT_frag_depth", "WEBGL_draw_buffers", "ANGLE_instanced_arrays", "OES_texture_float_linear", "OES_texture_half_float_linear", "EXT_blend_minmax", "EXT_shader_texture_lod", "EXT_texture_norm16", "WEBGL_compressed_texture_pvrtc", "EXT_color_buffer_half_float", "WEBGL_color_buffer_float", "EXT_sRGB", "WEBGL_compressed_texture_etc1", "EXT_disjoint_timer_query", "WEBGL_compressed_texture_etc", "WEBGL_compressed_texture_astc", "EXT_color_buffer_float", "WEBGL_compressed_texture_s3tc_srgb", "EXT_disjoint_timer_query_webgl2", "WEBKIT_WEBGL_compressed_texture_pvrtc"];
        var exts = GLctx2.getSupportedExtensions() || [];
        exts.forEach(function(ext) {
          if (automaticallyEnabledExtensions.indexOf(ext) != -1) {
            GLctx2.getExtension(ext);
          }
        });
      }, populateUniformTable: function(program) {
        var p = GL.programs[program];
        var ptable = GL.programInfos[program] = {uniforms: {}, maxUniformLength: 0, maxAttributeLength: -1, maxUniformBlockNameLength: -1};
        var utable = ptable.uniforms;
        var numUniforms = GLctx.getProgramParameter(p, 35718);
        for (var i = 0; i < numUniforms; ++i) {
          var u = GLctx.getActiveUniform(p, i);
          var name = u.name;
          ptable.maxUniformLength = Math.max(ptable.maxUniformLength, name.length + 1);
          if (name.slice(-1) == "]") {
            name = name.slice(0, name.lastIndexOf("["));
          }
          var loc = GLctx.getUniformLocation(p, name);
          if (loc) {
            var id = GL.getNewId(GL.uniforms);
            utable[name] = [u.size, id];
            GL.uniforms[id] = loc;
            for (var j = 1; j < u.size; ++j) {
              var n = name + "[" + j + "]";
              loc = GLctx.getUniformLocation(p, n);
              id = GL.getNewId(GL.uniforms);
              GL.uniforms[id] = loc;
            }
          }
        }
      }};
      var __emscripten_webgl_power_preferences = ["default", "low-power", "high-performance"];
      function _emscripten_webgl_do_create_context(target, attributes) {
        var contextAttributes = {};
        var a = attributes >> 2;
        contextAttributes["alpha"] = !!GROWABLE_HEAP_I32()[a + (0 >> 2)];
        contextAttributes["depth"] = !!GROWABLE_HEAP_I32()[a + (4 >> 2)];
        contextAttributes["stencil"] = !!GROWABLE_HEAP_I32()[a + (8 >> 2)];
        contextAttributes["antialias"] = !!GROWABLE_HEAP_I32()[a + (12 >> 2)];
        contextAttributes["premultipliedAlpha"] = !!GROWABLE_HEAP_I32()[a + (16 >> 2)];
        contextAttributes["preserveDrawingBuffer"] = !!GROWABLE_HEAP_I32()[a + (20 >> 2)];
        var powerPreference = GROWABLE_HEAP_I32()[a + (24 >> 2)];
        contextAttributes["powerPreference"] = __emscripten_webgl_power_preferences[powerPreference];
        contextAttributes["failIfMajorPerformanceCaveat"] = !!GROWABLE_HEAP_I32()[a + (28 >> 2)];
        contextAttributes.majorVersion = GROWABLE_HEAP_I32()[a + (32 >> 2)];
        contextAttributes.minorVersion = GROWABLE_HEAP_I32()[a + (36 >> 2)];
        contextAttributes.enableExtensionsByDefault = GROWABLE_HEAP_I32()[a + (40 >> 2)];
        contextAttributes.explicitSwapControl = GROWABLE_HEAP_I32()[a + (44 >> 2)];
        contextAttributes.proxyContextToMainThread = GROWABLE_HEAP_I32()[a + (48 >> 2)];
        contextAttributes.renderViaOffscreenBackBuffer = GROWABLE_HEAP_I32()[a + (52 >> 2)];
        var canvas = __findCanvasEventTarget(target);
        if (!canvas) {
          return -4;
        }
        if (contextAttributes.explicitSwapControl) {
          return -1;
        }
        var contextHandle = GL.createContext(canvas, contextAttributes);
        return contextHandle;
      }
      function _emscripten_webgl_create_context(a0, a1) {
        return _emscripten_webgl_do_create_context(a0, a1);
      }
      var PATH = {splitPath: function(filename) {
        var splitPathRe = /^(\/?|)([\s\S]*?)((?:\.{1,2}|[^\/]+?|)(\.[^.\/]*|))(?:[\/]*)$/;
        return splitPathRe.exec(filename).slice(1);
      }, normalizeArray: function(parts, allowAboveRoot) {
        var up = 0;
        for (var i = parts.length - 1; i >= 0; i--) {
          var last = parts[i];
          if (last === ".") {
            parts.splice(i, 1);
          } else if (last === "..") {
            parts.splice(i, 1);
            up++;
          } else if (up) {
            parts.splice(i, 1);
            up--;
          }
        }
        if (allowAboveRoot) {
          for (; up; up--) {
            parts.unshift("..");
          }
        }
        return parts;
      }, normalize: function(path) {
        var isAbsolute = path.charAt(0) === "/", trailingSlash = path.substr(-1) === "/";
        path = PATH.normalizeArray(path.split("/").filter(function(p) {
          return !!p;
        }), !isAbsolute).join("/");
        if (!path && !isAbsolute) {
          path = ".";
        }
        if (path && trailingSlash) {
          path += "/";
        }
        return (isAbsolute ? "/" : "") + path;
      }, dirname: function(path) {
        var result = PATH.splitPath(path), root = result[0], dir = result[1];
        if (!root && !dir) {
          return ".";
        }
        if (dir) {
          dir = dir.substr(0, dir.length - 1);
        }
        return root + dir;
      }, basename: function(path) {
        if (path === "/")
          return "/";
        var lastSlash = path.lastIndexOf("/");
        if (lastSlash === -1)
          return path;
        return path.substr(lastSlash + 1);
      }, extname: function(path) {
        return PATH.splitPath(path)[3];
      }, join: function() {
        var paths = Array.prototype.slice.call(arguments, 0);
        return PATH.normalize(paths.join("/"));
      }, join2: function(l, r) {
        return PATH.normalize(l + "/" + r);
      }};
      var SYSCALLS = {mappings: {}, buffers: [null, [], []], printChar: function(stream, curr) {
        var buffer3 = SYSCALLS.buffers[stream];
        if (curr === 0 || curr === 10) {
          (stream === 1 ? out : err)(UTF8ArrayToString(buffer3, 0));
          buffer3.length = 0;
        } else {
          buffer3.push(curr);
        }
      }, varargs: void 0, get: function() {
        SYSCALLS.varargs += 4;
        var ret = GROWABLE_HEAP_I32()[SYSCALLS.varargs - 4 >> 2];
        return ret;
      }, getStr: function(ptr) {
        var ret = UTF8ToString(ptr);
        return ret;
      }, get64: function(low, high) {
        return low;
      }};
      function _fd_close(fd) {
        if (ENVIRONMENT_IS_PTHREAD)
          return _emscripten_proxy_to_main_thread_js(3, 1, fd);
        return 0;
      }
      function _fd_seek(fd, offset_low, offset_high, whence, newOffset) {
        if (ENVIRONMENT_IS_PTHREAD)
          return _emscripten_proxy_to_main_thread_js(4, 1, fd, offset_low, offset_high, whence, newOffset);
      }
      function _fd_write(fd, iov, iovcnt, pnum) {
        if (ENVIRONMENT_IS_PTHREAD)
          return _emscripten_proxy_to_main_thread_js(5, 1, fd, iov, iovcnt, pnum);
        var num = 0;
        for (var i = 0; i < iovcnt; i++) {
          var ptr = GROWABLE_HEAP_I32()[iov + i * 8 >> 2];
          var len = GROWABLE_HEAP_I32()[iov + (i * 8 + 4) >> 2];
          for (var j = 0; j < len; j++) {
            SYSCALLS.printChar(fd, GROWABLE_HEAP_U8()[ptr + j]);
          }
          num += len;
        }
        GROWABLE_HEAP_I32()[pnum >> 2] = num;
        return 0;
      }
      function _pthread_cleanup_pop(execute) {
        var routine = PThread.exitHandlers.pop();
        if (execute)
          routine();
      }
      function _pthread_cleanup_push(routine, arg) {
        if (PThread.exitHandlers === null) {
          PThread.exitHandlers = [];
        }
        PThread.exitHandlers.push(function() {
          dynCall_vi(routine, arg);
        });
      }
      function __spawn_thread(threadParams) {
        if (ENVIRONMENT_IS_PTHREAD)
          throw "Internal Error! _spawn_thread() can only ever be called from main application thread!";
        var worker2 = PThread.getNewWorker();
        if (worker2.pthread !== void 0)
          throw "Internal error!";
        if (!threadParams.pthread_ptr)
          throw "Internal error, no pthread ptr!";
        PThread.runningWorkers.push(worker2);
        var tlsMemory = _malloc(128 * 4);
        for (var i = 0; i < 128; ++i) {
          GROWABLE_HEAP_I32()[tlsMemory + i * 4 >> 2] = 0;
        }
        var stackHigh = threadParams.stackBase + threadParams.stackSize;
        var pthread = PThread.pthreads[threadParams.pthread_ptr] = {worker: worker2, stackBase: threadParams.stackBase, stackSize: threadParams.stackSize, allocatedOwnStack: threadParams.allocatedOwnStack, thread: threadParams.pthread_ptr, threadInfoStruct: threadParams.pthread_ptr};
        var tis = pthread.threadInfoStruct >> 2;
        Atomics.store(GROWABLE_HEAP_U32(), tis + (0 >> 2), 0);
        Atomics.store(GROWABLE_HEAP_U32(), tis + (4 >> 2), 0);
        Atomics.store(GROWABLE_HEAP_U32(), tis + (8 >> 2), 0);
        Atomics.store(GROWABLE_HEAP_U32(), tis + (68 >> 2), threadParams.detached);
        Atomics.store(GROWABLE_HEAP_U32(), tis + (104 >> 2), tlsMemory);
        Atomics.store(GROWABLE_HEAP_U32(), tis + (48 >> 2), 0);
        Atomics.store(GROWABLE_HEAP_U32(), tis + (40 >> 2), pthread.threadInfoStruct);
        Atomics.store(GROWABLE_HEAP_U32(), tis + (44 >> 2), 42);
        Atomics.store(GROWABLE_HEAP_U32(), tis + (108 >> 2), threadParams.stackSize);
        Atomics.store(GROWABLE_HEAP_U32(), tis + (84 >> 2), threadParams.stackSize);
        Atomics.store(GROWABLE_HEAP_U32(), tis + (80 >> 2), stackHigh);
        Atomics.store(GROWABLE_HEAP_U32(), tis + (108 + 8 >> 2), stackHigh);
        Atomics.store(GROWABLE_HEAP_U32(), tis + (108 + 12 >> 2), threadParams.detached);
        Atomics.store(GROWABLE_HEAP_U32(), tis + (108 + 20 >> 2), threadParams.schedPolicy);
        Atomics.store(GROWABLE_HEAP_U32(), tis + (108 + 24 >> 2), threadParams.schedPrio);
        var global_libc = _emscripten_get_global_libc();
        var global_locale = global_libc + 40;
        Atomics.store(GROWABLE_HEAP_U32(), tis + (176 >> 2), global_locale);
        worker2.pthread = pthread;
        var msg = {cmd: "run", start_routine: threadParams.startRoutine, arg: threadParams.arg, threadInfoStruct: threadParams.pthread_ptr, selfThreadId: threadParams.pthread_ptr, parentThreadId: threadParams.parent_pthread_ptr, stackBase: threadParams.stackBase, stackSize: threadParams.stackSize};
        worker2.runPthread = function() {
          msg.time = performance.now();
          worker2.postMessage(msg, threadParams.transferList);
        };
        if (worker2.loaded) {
          worker2.runPthread();
          delete worker2.runPthread;
        }
      }
      function _pthread_getschedparam(thread, policy, schedparam) {
        if (!policy && !schedparam)
          return ERRNO_CODES.EINVAL;
        if (!thread) {
          err("pthread_getschedparam called with a null thread pointer!");
          return ERRNO_CODES.ESRCH;
        }
        var self2 = GROWABLE_HEAP_I32()[thread + 12 >> 2];
        if (self2 !== thread) {
          err("pthread_getschedparam attempted on thread " + thread + ", which does not point to a valid thread, or does not exist anymore!");
          return ERRNO_CODES.ESRCH;
        }
        var schedPolicy = Atomics.load(GROWABLE_HEAP_U32(), thread + 108 + 20 >> 2);
        var schedPrio = Atomics.load(GROWABLE_HEAP_U32(), thread + 108 + 24 >> 2);
        if (policy)
          GROWABLE_HEAP_I32()[policy >> 2] = schedPolicy;
        if (schedparam)
          GROWABLE_HEAP_I32()[schedparam >> 2] = schedPrio;
        return 0;
      }
      function _pthread_self() {
        return __pthread_ptr | 0;
      }
      Module["_pthread_self"] = _pthread_self;
      function _pthread_create(pthread_ptr, attr, start_routine, arg) {
        if (typeof SharedArrayBuffer === "undefined") {
          err("Current environment does not support SharedArrayBuffer, pthreads are not available!");
          return 6;
        }
        if (!pthread_ptr) {
          err("pthread_create called with a null thread pointer!");
          return 28;
        }
        var transferList = [];
        var error = 0;
        if (ENVIRONMENT_IS_PTHREAD && (transferList.length === 0 || error)) {
          return _emscripten_sync_run_in_main_thread_4(687865856, pthread_ptr, attr, start_routine, arg);
        }
        if (error)
          return error;
        var stackSize = 0;
        var stackBase = 0;
        var detached = 0;
        var schedPolicy = 0;
        var schedPrio = 0;
        if (attr) {
          stackSize = GROWABLE_HEAP_I32()[attr >> 2];
          stackSize += 81920;
          stackBase = GROWABLE_HEAP_I32()[attr + 8 >> 2];
          detached = GROWABLE_HEAP_I32()[attr + 12 >> 2] !== 0;
          var inheritSched = GROWABLE_HEAP_I32()[attr + 16 >> 2] === 0;
          if (inheritSched) {
            var prevSchedPolicy = GROWABLE_HEAP_I32()[attr + 20 >> 2];
            var prevSchedPrio = GROWABLE_HEAP_I32()[attr + 24 >> 2];
            var parentThreadPtr = PThread.currentProxiedOperationCallerThread ? PThread.currentProxiedOperationCallerThread : _pthread_self();
            _pthread_getschedparam(parentThreadPtr, attr + 20, attr + 24);
            schedPolicy = GROWABLE_HEAP_I32()[attr + 20 >> 2];
            schedPrio = GROWABLE_HEAP_I32()[attr + 24 >> 2];
            GROWABLE_HEAP_I32()[attr + 20 >> 2] = prevSchedPolicy;
            GROWABLE_HEAP_I32()[attr + 24 >> 2] = prevSchedPrio;
          } else {
            schedPolicy = GROWABLE_HEAP_I32()[attr + 20 >> 2];
            schedPrio = GROWABLE_HEAP_I32()[attr + 24 >> 2];
          }
        } else {
          stackSize = 2097152;
        }
        var allocatedOwnStack = stackBase == 0;
        if (allocatedOwnStack) {
          stackBase = _memalign(16, stackSize);
        } else {
          stackBase -= stackSize;
          assert2(stackBase > 0);
        }
        var threadInfoStruct2 = _malloc(232);
        for (var i = 0; i < 232 >> 2; ++i)
          GROWABLE_HEAP_U32()[(threadInfoStruct2 >> 2) + i] = 0;
        GROWABLE_HEAP_I32()[pthread_ptr >> 2] = threadInfoStruct2;
        GROWABLE_HEAP_I32()[threadInfoStruct2 + 12 >> 2] = threadInfoStruct2;
        var headPtr = threadInfoStruct2 + 156;
        GROWABLE_HEAP_I32()[headPtr >> 2] = headPtr;
        var threadParams = {stackBase, stackSize, allocatedOwnStack, schedPolicy, schedPrio, detached, startRoutine: start_routine, pthread_ptr: threadInfoStruct2, parent_pthread_ptr: _pthread_self(), arg, transferList};
        if (ENVIRONMENT_IS_PTHREAD) {
          threadParams.cmd = "spawnThread";
          postMessage(threadParams, transferList);
        } else {
          __spawn_thread(threadParams);
        }
        return 0;
      }
      function _roundf(d) {
        d = +d;
        return d >= 0 ? +Math_floor(d + 0.5) : +Math_ceil(d - 0.5);
      }
      function _sysconf(name) {
        if (ENVIRONMENT_IS_PTHREAD)
          return _emscripten_proxy_to_main_thread_js(6, 1, name);
        switch (name) {
          case 30:
            return 16384;
          case 85:
            var maxHeapSize = 2147483648;
            return maxHeapSize / 16384;
          case 132:
          case 133:
          case 12:
          case 137:
          case 138:
          case 15:
          case 235:
          case 16:
          case 17:
          case 18:
          case 19:
          case 20:
          case 149:
          case 13:
          case 10:
          case 236:
          case 153:
          case 9:
          case 21:
          case 22:
          case 159:
          case 154:
          case 14:
          case 77:
          case 78:
          case 139:
          case 80:
          case 81:
          case 82:
          case 68:
          case 67:
          case 164:
          case 11:
          case 29:
          case 47:
          case 48:
          case 95:
          case 52:
          case 51:
          case 46:
          case 79:
            return 200809;
          case 27:
          case 246:
          case 127:
          case 128:
          case 23:
          case 24:
          case 160:
          case 161:
          case 181:
          case 182:
          case 242:
          case 183:
          case 184:
          case 243:
          case 244:
          case 245:
          case 165:
          case 178:
          case 179:
          case 49:
          case 50:
          case 168:
          case 169:
          case 175:
          case 170:
          case 171:
          case 172:
          case 97:
          case 76:
          case 32:
          case 173:
          case 35:
            return -1;
          case 176:
          case 177:
          case 7:
          case 155:
          case 8:
          case 157:
          case 125:
          case 126:
          case 92:
          case 93:
          case 129:
          case 130:
          case 131:
          case 94:
          case 91:
            return 1;
          case 74:
          case 60:
          case 69:
          case 70:
          case 4:
            return 1024;
          case 31:
          case 42:
          case 72:
            return 32;
          case 87:
          case 26:
          case 33:
            return 2147483647;
          case 34:
          case 1:
            return 47839;
          case 38:
          case 36:
            return 99;
          case 43:
          case 37:
            return 2048;
          case 0:
            return 2097152;
          case 3:
            return 65536;
          case 28:
            return 32768;
          case 44:
            return 32767;
          case 75:
            return 16384;
          case 39:
            return 1e3;
          case 89:
            return 700;
          case 71:
            return 256;
          case 40:
            return 255;
          case 2:
            return 100;
          case 180:
            return 64;
          case 25:
            return 20;
          case 5:
            return 16;
          case 6:
            return 6;
          case 73:
            return 4;
          case 84: {
            if (typeof navigator === "object")
              return navigator["hardwareConcurrency"] || 1;
            return 1;
          }
        }
        setErrNo(28);
        return -1;
      }
      if (!ENVIRONMENT_IS_PTHREAD)
        PThread.initMainThreadBlock();
      else
        PThread.initWorker();
      var GLctx;
      GL.init();
      var proxiedFunctionTable = [null, _atexit, _emscripten_set_canvas_element_size_main_thread, _fd_close, _fd_seek, _fd_write, _sysconf];
      var asmLibraryArg = {e: ___assert_fail, r: ___call_main, w: __emscripten_notify_thread_queue, a: _abort, l: _emscripten_conditional_set_current_thread_status, d: _emscripten_futex_wait, c: _emscripten_futex_wake, h: _emscripten_get_now, g: _emscripten_is_main_browser_thread, x: _emscripten_is_main_runtime_thread, q: _emscripten_memcpy_big, B: _emscripten_num_logical_cores, t: _emscripten_receive_on_main_thread_js, A: _emscripten_resize_heap, u: _emscripten_set_canvas_element_size, k: _emscripten_set_current_thread_status, s: _emscripten_set_thread_name, v: _emscripten_webgl_create_context, m: _fd_close, o: _fd_seek, i: _fd_write, p: initPthreadsJS, memory: wasmMemory || Module["wasmMemory"], y: _pthread_cleanup_pop, z: _pthread_cleanup_push, j: _pthread_create, b: _pthread_self, f: _roundf, n: _sysconf, table: wasmTable};
      var asm = createWasm();
      Module["asm"] = asm;
      var ___wasm_call_ctors = Module["___wasm_call_ctors"] = function() {
        return (___wasm_call_ctors = Module["___wasm_call_ctors"] = Module["asm"]["C"]).apply(null, arguments);
      };
      var _init = Module["_init"] = function() {
        return (_init = Module["_init"] = Module["asm"]["D"]).apply(null, arguments);
      };
      var _register_tensor = Module["_register_tensor"] = function() {
        return (_register_tensor = Module["_register_tensor"] = Module["asm"]["E"]).apply(null, arguments);
      };
      var _dispose_data = Module["_dispose_data"] = function() {
        return (_dispose_data = Module["_dispose_data"] = Module["asm"]["F"]).apply(null, arguments);
      };
      var _dispose = Module["_dispose"] = function() {
        return (_dispose = Module["_dispose"] = Module["asm"]["G"]).apply(null, arguments);
      };
      var _Abs = Module["_Abs"] = function() {
        return (_Abs = Module["_Abs"] = Module["asm"]["H"]).apply(null, arguments);
      };
      var _Add = Module["_Add"] = function() {
        return (_Add = Module["_Add"] = Module["asm"]["I"]).apply(null, arguments);
      };
      var _AddN = Module["_AddN"] = function() {
        return (_AddN = Module["_AddN"] = Module["asm"]["J"]).apply(null, arguments);
      };
      var _ArgMax = Module["_ArgMax"] = function() {
        return (_ArgMax = Module["_ArgMax"] = Module["asm"]["K"]).apply(null, arguments);
      };
      var _AvgPool = Module["_AvgPool"] = function() {
        return (_AvgPool = Module["_AvgPool"] = Module["asm"]["L"]).apply(null, arguments);
      };
      var _BatchMatMul = Module["_BatchMatMul"] = function() {
        return (_BatchMatMul = Module["_BatchMatMul"] = Module["asm"]["M"]).apply(null, arguments);
      };
      var _ClipByValue = Module["_ClipByValue"] = function() {
        return (_ClipByValue = Module["_ClipByValue"] = Module["asm"]["N"]).apply(null, arguments);
      };
      var _Conv2D = Module["_Conv2D"] = function() {
        return (_Conv2D = Module["_Conv2D"] = Module["asm"]["O"]).apply(null, arguments);
      };
      var _Conv2DBackpropInput = Module["_Conv2DBackpropInput"] = function() {
        return (_Conv2DBackpropInput = Module["_Conv2DBackpropInput"] = Module["asm"]["P"]).apply(null, arguments);
      };
      var _Cos = Module["_Cos"] = function() {
        return (_Cos = Module["_Cos"] = Module["asm"]["Q"]).apply(null, arguments);
      };
      var _CropAndResize = Module["_CropAndResize"] = function() {
        return (_CropAndResize = Module["_CropAndResize"] = Module["asm"]["R"]).apply(null, arguments);
      };
      var _Cumsum = Module["_Cumsum"] = function() {
        return (_Cumsum = Module["_Cumsum"] = Module["asm"]["S"]).apply(null, arguments);
      };
      var _DepthToSpace = Module["_DepthToSpace"] = function() {
        return (_DepthToSpace = Module["_DepthToSpace"] = Module["asm"]["T"]).apply(null, arguments);
      };
      var _DepthwiseConv2dNative = Module["_DepthwiseConv2dNative"] = function() {
        return (_DepthwiseConv2dNative = Module["_DepthwiseConv2dNative"] = Module["asm"]["U"]).apply(null, arguments);
      };
      var _Div = Module["_Div"] = function() {
        return (_Div = Module["_Div"] = Module["asm"]["V"]).apply(null, arguments);
      };
      var _Equal = Module["_Equal"] = function() {
        return (_Equal = Module["_Equal"] = Module["asm"]["W"]).apply(null, arguments);
      };
      var _Exp = Module["_Exp"] = function() {
        return (_Exp = Module["_Exp"] = Module["asm"]["X"]).apply(null, arguments);
      };
      var _FlipLeftRight = Module["_FlipLeftRight"] = function() {
        return (_FlipLeftRight = Module["_FlipLeftRight"] = Module["asm"]["Y"]).apply(null, arguments);
      };
      var _FloorDiv = Module["_FloorDiv"] = function() {
        return (_FloorDiv = Module["_FloorDiv"] = Module["asm"]["Z"]).apply(null, arguments);
      };
      var _FusedBatchNorm = Module["_FusedBatchNorm"] = function() {
        return (_FusedBatchNorm = Module["_FusedBatchNorm"] = Module["asm"]["_"]).apply(null, arguments);
      };
      var _FusedConv2D = Module["_FusedConv2D"] = function() {
        return (_FusedConv2D = Module["_FusedConv2D"] = Module["asm"]["$"]).apply(null, arguments);
      };
      var _FusedDepthwiseConv2D = Module["_FusedDepthwiseConv2D"] = function() {
        return (_FusedDepthwiseConv2D = Module["_FusedDepthwiseConv2D"] = Module["asm"]["aa"]).apply(null, arguments);
      };
      var _Gather = Module["_Gather"] = function() {
        return (_Gather = Module["_Gather"] = Module["asm"]["ba"]).apply(null, arguments);
      };
      var _GatherNd = Module["_GatherNd"] = function() {
        return (_GatherNd = Module["_GatherNd"] = Module["asm"]["ca"]).apply(null, arguments);
      };
      var _Greater = Module["_Greater"] = function() {
        return (_Greater = Module["_Greater"] = Module["asm"]["da"]).apply(null, arguments);
      };
      var _GreaterEqual = Module["_GreaterEqual"] = function() {
        return (_GreaterEqual = Module["_GreaterEqual"] = Module["asm"]["ea"]).apply(null, arguments);
      };
      var _Less = Module["_Less"] = function() {
        return (_Less = Module["_Less"] = Module["asm"]["fa"]).apply(null, arguments);
      };
      var _LessEqual = Module["_LessEqual"] = function() {
        return (_LessEqual = Module["_LessEqual"] = Module["asm"]["ga"]).apply(null, arguments);
      };
      var _Log = Module["_Log"] = function() {
        return (_Log = Module["_Log"] = Module["asm"]["ha"]).apply(null, arguments);
      };
      var _LogicalAnd = Module["_LogicalAnd"] = function() {
        return (_LogicalAnd = Module["_LogicalAnd"] = Module["asm"]["ia"]).apply(null, arguments);
      };
      var _Max = Module["_Max"] = function() {
        return (_Max = Module["_Max"] = Module["asm"]["ja"]).apply(null, arguments);
      };
      var _MaxPool = Module["_MaxPool"] = function() {
        return (_MaxPool = Module["_MaxPool"] = Module["asm"]["ka"]).apply(null, arguments);
      };
      var _Maximum = Module["_Maximum"] = function() {
        return (_Maximum = Module["_Maximum"] = Module["asm"]["la"]).apply(null, arguments);
      };
      var _Min = Module["_Min"] = function() {
        return (_Min = Module["_Min"] = Module["asm"]["ma"]).apply(null, arguments);
      };
      var _Minimum = Module["_Minimum"] = function() {
        return (_Minimum = Module["_Minimum"] = Module["asm"]["na"]).apply(null, arguments);
      };
      var _Multiply = Module["_Multiply"] = function() {
        return (_Multiply = Module["_Multiply"] = Module["asm"]["oa"]).apply(null, arguments);
      };
      var _Negate = Module["_Negate"] = function() {
        return (_Negate = Module["_Negate"] = Module["asm"]["pa"]).apply(null, arguments);
      };
      var _NonMaxSuppressionV3 = Module["_NonMaxSuppressionV3"] = function() {
        return (_NonMaxSuppressionV3 = Module["_NonMaxSuppressionV3"] = Module["asm"]["qa"]).apply(null, arguments);
      };
      var _NonMaxSuppressionV4 = Module["_NonMaxSuppressionV4"] = function() {
        return (_NonMaxSuppressionV4 = Module["_NonMaxSuppressionV4"] = Module["asm"]["ra"]).apply(null, arguments);
      };
      var _NonMaxSuppressionV5 = Module["_NonMaxSuppressionV5"] = function() {
        return (_NonMaxSuppressionV5 = Module["_NonMaxSuppressionV5"] = Module["asm"]["sa"]).apply(null, arguments);
      };
      var _NotEqual = Module["_NotEqual"] = function() {
        return (_NotEqual = Module["_NotEqual"] = Module["asm"]["ta"]).apply(null, arguments);
      };
      var _OneHot = Module["_OneHot"] = function() {
        return (_OneHot = Module["_OneHot"] = Module["asm"]["ua"]).apply(null, arguments);
      };
      var _PadV2 = Module["_PadV2"] = function() {
        return (_PadV2 = Module["_PadV2"] = Module["asm"]["va"]).apply(null, arguments);
      };
      var _Pow = Module["_Pow"] = function() {
        return (_Pow = Module["_Pow"] = Module["asm"]["wa"]).apply(null, arguments);
      };
      var _Prelu = Module["_Prelu"] = function() {
        return (_Prelu = Module["_Prelu"] = Module["asm"]["xa"]).apply(null, arguments);
      };
      var _Relu = Module["_Relu"] = function() {
        return (_Relu = Module["_Relu"] = Module["asm"]["ya"]).apply(null, arguments);
      };
      var _Relu6 = Module["_Relu6"] = function() {
        return (_Relu6 = Module["_Relu6"] = Module["asm"]["za"]).apply(null, arguments);
      };
      var _ResizeBilinear = Module["_ResizeBilinear"] = function() {
        return (_ResizeBilinear = Module["_ResizeBilinear"] = Module["asm"]["Aa"]).apply(null, arguments);
      };
      var _Reverse = Module["_Reverse"] = function() {
        return (_Reverse = Module["_Reverse"] = Module["asm"]["Ba"]).apply(null, arguments);
      };
      var _RotateWithOffset = Module["_RotateWithOffset"] = function() {
        return (_RotateWithOffset = Module["_RotateWithOffset"] = Module["asm"]["Ca"]).apply(null, arguments);
      };
      var _Rsqrt = Module["_Rsqrt"] = function() {
        return (_Rsqrt = Module["_Rsqrt"] = Module["asm"]["Da"]).apply(null, arguments);
      };
      var _ScatterNd = Module["_ScatterNd"] = function() {
        return (_ScatterNd = Module["_ScatterNd"] = Module["asm"]["Ea"]).apply(null, arguments);
      };
      var _SelectV2 = Module["_SelectV2"] = function() {
        return (_SelectV2 = Module["_SelectV2"] = Module["asm"]["Fa"]).apply(null, arguments);
      };
      var _Sigmoid = Module["_Sigmoid"] = function() {
        return (_Sigmoid = Module["_Sigmoid"] = Module["asm"]["Ga"]).apply(null, arguments);
      };
      var _Sin = Module["_Sin"] = function() {
        return (_Sin = Module["_Sin"] = Module["asm"]["Ha"]).apply(null, arguments);
      };
      var _Softmax = Module["_Softmax"] = function() {
        return (_Softmax = Module["_Softmax"] = Module["asm"]["Ia"]).apply(null, arguments);
      };
      var _Sqrt = Module["_Sqrt"] = function() {
        return (_Sqrt = Module["_Sqrt"] = Module["asm"]["Ja"]).apply(null, arguments);
      };
      var _Square = Module["_Square"] = function() {
        return (_Square = Module["_Square"] = Module["asm"]["Ka"]).apply(null, arguments);
      };
      var _SquaredDifference = Module["_SquaredDifference"] = function() {
        return (_SquaredDifference = Module["_SquaredDifference"] = Module["asm"]["La"]).apply(null, arguments);
      };
      var _StridedSlice = Module["_StridedSlice"] = function() {
        return (_StridedSlice = Module["_StridedSlice"] = Module["asm"]["Ma"]).apply(null, arguments);
      };
      var _Sub = Module["_Sub"] = function() {
        return (_Sub = Module["_Sub"] = Module["asm"]["Na"]).apply(null, arguments);
      };
      var _Sum = Module["_Sum"] = function() {
        return (_Sum = Module["_Sum"] = Module["asm"]["Oa"]).apply(null, arguments);
      };
      var _Tanh = Module["_Tanh"] = function() {
        return (_Tanh = Module["_Tanh"] = Module["asm"]["Pa"]).apply(null, arguments);
      };
      var _Tile = Module["_Tile"] = function() {
        return (_Tile = Module["_Tile"] = Module["asm"]["Qa"]).apply(null, arguments);
      };
      var _Transpose = Module["_Transpose"] = function() {
        return (_Transpose = Module["_Transpose"] = Module["asm"]["Ra"]).apply(null, arguments);
      };
      var __FusedMatMul = Module["__FusedMatMul"] = function() {
        return (__FusedMatMul = Module["__FusedMatMul"] = Module["asm"]["Sa"]).apply(null, arguments);
      };
      var _malloc = Module["_malloc"] = function() {
        return (_malloc = Module["_malloc"] = Module["asm"]["Ta"]).apply(null, arguments);
      };
      var _free = Module["_free"] = function() {
        return (_free = Module["_free"] = Module["asm"]["Ua"]).apply(null, arguments);
      };
      var _emscripten_get_global_libc = Module["_emscripten_get_global_libc"] = function() {
        return (_emscripten_get_global_libc = Module["_emscripten_get_global_libc"] = Module["asm"]["Va"]).apply(null, arguments);
      };
      var ___errno_location = Module["___errno_location"] = function() {
        return (___errno_location = Module["___errno_location"] = Module["asm"]["Wa"]).apply(null, arguments);
      };
      var ___em_js__initPthreadsJS = Module["___em_js__initPthreadsJS"] = function() {
        return (___em_js__initPthreadsJS = Module["___em_js__initPthreadsJS"] = Module["asm"]["Xa"]).apply(null, arguments);
      };
      var _memalign = Module["_memalign"] = function() {
        return (_memalign = Module["_memalign"] = Module["asm"]["Ya"]).apply(null, arguments);
      };
      var ___pthread_tsd_run_dtors = Module["___pthread_tsd_run_dtors"] = function() {
        return (___pthread_tsd_run_dtors = Module["___pthread_tsd_run_dtors"] = Module["asm"]["Za"]).apply(null, arguments);
      };
      var _emscripten_main_thread_process_queued_calls = Module["_emscripten_main_thread_process_queued_calls"] = function() {
        return (_emscripten_main_thread_process_queued_calls = Module["_emscripten_main_thread_process_queued_calls"] = Module["asm"]["_a"]).apply(null, arguments);
      };
      var _emscripten_current_thread_process_queued_calls = Module["_emscripten_current_thread_process_queued_calls"] = function() {
        return (_emscripten_current_thread_process_queued_calls = Module["_emscripten_current_thread_process_queued_calls"] = Module["asm"]["$a"]).apply(null, arguments);
      };
      var _emscripten_register_main_browser_thread_id = Module["_emscripten_register_main_browser_thread_id"] = function() {
        return (_emscripten_register_main_browser_thread_id = Module["_emscripten_register_main_browser_thread_id"] = Module["asm"]["ab"]).apply(null, arguments);
      };
      var _emscripten_main_browser_thread_id = Module["_emscripten_main_browser_thread_id"] = function() {
        return (_emscripten_main_browser_thread_id = Module["_emscripten_main_browser_thread_id"] = Module["asm"]["bb"]).apply(null, arguments);
      };
      var _emscripten_async_run_in_main_thread = Module["_emscripten_async_run_in_main_thread"] = function() {
        return (_emscripten_async_run_in_main_thread = Module["_emscripten_async_run_in_main_thread"] = Module["asm"]["cb"]).apply(null, arguments);
      };
      var _emscripten_sync_run_in_main_thread = Module["_emscripten_sync_run_in_main_thread"] = function() {
        return (_emscripten_sync_run_in_main_thread = Module["_emscripten_sync_run_in_main_thread"] = Module["asm"]["db"]).apply(null, arguments);
      };
      var _emscripten_sync_run_in_main_thread_0 = Module["_emscripten_sync_run_in_main_thread_0"] = function() {
        return (_emscripten_sync_run_in_main_thread_0 = Module["_emscripten_sync_run_in_main_thread_0"] = Module["asm"]["eb"]).apply(null, arguments);
      };
      var _emscripten_sync_run_in_main_thread_1 = Module["_emscripten_sync_run_in_main_thread_1"] = function() {
        return (_emscripten_sync_run_in_main_thread_1 = Module["_emscripten_sync_run_in_main_thread_1"] = Module["asm"]["fb"]).apply(null, arguments);
      };
      var _emscripten_sync_run_in_main_thread_2 = Module["_emscripten_sync_run_in_main_thread_2"] = function() {
        return (_emscripten_sync_run_in_main_thread_2 = Module["_emscripten_sync_run_in_main_thread_2"] = Module["asm"]["gb"]).apply(null, arguments);
      };
      var _emscripten_sync_run_in_main_thread_xprintf_varargs = Module["_emscripten_sync_run_in_main_thread_xprintf_varargs"] = function() {
        return (_emscripten_sync_run_in_main_thread_xprintf_varargs = Module["_emscripten_sync_run_in_main_thread_xprintf_varargs"] = Module["asm"]["hb"]).apply(null, arguments);
      };
      var _emscripten_sync_run_in_main_thread_3 = Module["_emscripten_sync_run_in_main_thread_3"] = function() {
        return (_emscripten_sync_run_in_main_thread_3 = Module["_emscripten_sync_run_in_main_thread_3"] = Module["asm"]["ib"]).apply(null, arguments);
      };
      var _emscripten_sync_run_in_main_thread_4 = Module["_emscripten_sync_run_in_main_thread_4"] = function() {
        return (_emscripten_sync_run_in_main_thread_4 = Module["_emscripten_sync_run_in_main_thread_4"] = Module["asm"]["jb"]).apply(null, arguments);
      };
      var _emscripten_sync_run_in_main_thread_5 = Module["_emscripten_sync_run_in_main_thread_5"] = function() {
        return (_emscripten_sync_run_in_main_thread_5 = Module["_emscripten_sync_run_in_main_thread_5"] = Module["asm"]["kb"]).apply(null, arguments);
      };
      var _emscripten_sync_run_in_main_thread_6 = Module["_emscripten_sync_run_in_main_thread_6"] = function() {
        return (_emscripten_sync_run_in_main_thread_6 = Module["_emscripten_sync_run_in_main_thread_6"] = Module["asm"]["lb"]).apply(null, arguments);
      };
      var _emscripten_sync_run_in_main_thread_7 = Module["_emscripten_sync_run_in_main_thread_7"] = function() {
        return (_emscripten_sync_run_in_main_thread_7 = Module["_emscripten_sync_run_in_main_thread_7"] = Module["asm"]["mb"]).apply(null, arguments);
      };
      var _emscripten_run_in_main_runtime_thread_js = Module["_emscripten_run_in_main_runtime_thread_js"] = function() {
        return (_emscripten_run_in_main_runtime_thread_js = Module["_emscripten_run_in_main_runtime_thread_js"] = Module["asm"]["nb"]).apply(null, arguments);
      };
      var _emscripten_async_queue_on_thread_ = Module["_emscripten_async_queue_on_thread_"] = function() {
        return (_emscripten_async_queue_on_thread_ = Module["_emscripten_async_queue_on_thread_"] = Module["asm"]["ob"]).apply(null, arguments);
      };
      var _emscripten_tls_init = Module["_emscripten_tls_init"] = function() {
        return (_emscripten_tls_init = Module["_emscripten_tls_init"] = Module["asm"]["pb"]).apply(null, arguments);
      };
      var stackSave = Module["stackSave"] = function() {
        return (stackSave = Module["stackSave"] = Module["asm"]["qb"]).apply(null, arguments);
      };
      var stackAlloc = Module["stackAlloc"] = function() {
        return (stackAlloc = Module["stackAlloc"] = Module["asm"]["rb"]).apply(null, arguments);
      };
      var stackRestore = Module["stackRestore"] = function() {
        return (stackRestore = Module["stackRestore"] = Module["asm"]["sb"]).apply(null, arguments);
      };
      var dynCall_vi = Module["dynCall_vi"] = function() {
        return (dynCall_vi = Module["dynCall_vi"] = Module["asm"]["tb"]).apply(null, arguments);
      };
      var dynCall_v = Module["dynCall_v"] = function() {
        return (dynCall_v = Module["dynCall_v"] = Module["asm"]["ub"]).apply(null, arguments);
      };
      var dynCall_ii = Module["dynCall_ii"] = function() {
        return (dynCall_ii = Module["dynCall_ii"] = Module["asm"]["vb"]).apply(null, arguments);
      };
      Module["asm"] = asm;
      Module["cwrap"] = cwrap;
      Module["PThread"] = PThread;
      Module["PThread"] = PThread;
      Module["_pthread_self"] = _pthread_self;
      Module["wasmMemory"] = wasmMemory;
      Module["ExitStatus"] = ExitStatus;
      var calledRun;
      Module["then"] = function(func) {
        if (calledRun) {
          func(Module);
        } else {
          var old = Module["onRuntimeInitialized"];
          Module["onRuntimeInitialized"] = function() {
            if (old)
              old();
            func(Module);
          };
        }
        return Module;
      };
      function ExitStatus(status2) {
        this.name = "ExitStatus";
        this.message = "Program terminated with exit(" + status2 + ")";
        this.status = status2;
      }
      dependenciesFulfilled = function runCaller() {
        if (!calledRun)
          run();
        if (!calledRun)
          dependenciesFulfilled = runCaller;
      };
      function run(args) {
        args = args || arguments_;
        if (runDependencies > 0) {
          return;
        }
        preRun();
        if (runDependencies > 0)
          return;
        function doRun() {
          if (calledRun)
            return;
          calledRun = true;
          Module["calledRun"] = true;
          if (ABORT)
            return;
          initRuntime();
          preMain();
          if (Module["onRuntimeInitialized"])
            Module["onRuntimeInitialized"]();
          postRun();
        }
        if (Module["setStatus"]) {
          Module["setStatus"]("Running...");
          setTimeout(function() {
            setTimeout(function() {
              Module["setStatus"]("");
            }, 1);
            doRun();
          }, 1);
        } else {
          doRun();
        }
      }
      Module["run"] = run;
      if (Module["preInit"]) {
        if (typeof Module["preInit"] == "function")
          Module["preInit"] = [Module["preInit"]];
        while (Module["preInit"].length > 0) {
          Module["preInit"].pop()();
        }
      }
      if (!ENVIRONMENT_IS_PTHREAD)
        noExitRuntime = true;
      if (!ENVIRONMENT_IS_PTHREAD)
        run();
      return WasmBackendModuleThreadedSimd2;
    };
  }();
  if (typeof exports === "object" && typeof module === "object")
    module.exports = WasmBackendModuleThreadedSimd;
  else if (typeof define === "function" && define["amd"])
    define([], function() {
      return WasmBackendModuleThreadedSimd;
    });
  else if (typeof exports === "object")
    exports["WasmBackendModuleThreadedSimd"] = WasmBackendModuleThreadedSimd;
});
var require_tfjs_backend_wasm = __commonJS((exports, module) => {
  var WasmBackendModule = function() {
    var _scriptDir = typeof document !== "undefined" && document.currentScript ? document.currentScript.src : void 0;
    if (typeof __filename !== "undefined")
      _scriptDir = _scriptDir || __filename;
    return function(WasmBackendModule2) {
      WasmBackendModule2 = WasmBackendModule2 || {};
      var Module = typeof WasmBackendModule2 !== "undefined" ? WasmBackendModule2 : {};
      var moduleOverrides = {};
      var key;
      for (key in Module) {
        if (Module.hasOwnProperty(key)) {
          moduleOverrides[key] = Module[key];
        }
      }
      var arguments_ = [];
      var thisProgram = "./this.program";
      var quit_ = function(status2, toThrow) {
        throw toThrow;
      };
      var ENVIRONMENT_IS_WEB = false;
      var ENVIRONMENT_IS_WORKER = false;
      var ENVIRONMENT_IS_NODE = false;
      var ENVIRONMENT_IS_SHELL = false;
      ENVIRONMENT_IS_WEB = typeof window === "object";
      ENVIRONMENT_IS_WORKER = typeof importScripts === "function";
      ENVIRONMENT_IS_NODE = typeof process === "object" && typeof process.versions === "object" && typeof process.versions.node === "string";
      ENVIRONMENT_IS_SHELL = !ENVIRONMENT_IS_WEB && !ENVIRONMENT_IS_NODE && !ENVIRONMENT_IS_WORKER;
      var scriptDirectory = "";
      function locateFile(path) {
        if (Module["locateFile"]) {
          return Module["locateFile"](path, scriptDirectory);
        }
        return scriptDirectory + path;
      }
      var read_, readAsync, readBinary, setWindowTitle;
      var nodeFS;
      var nodePath;
      if (ENVIRONMENT_IS_NODE) {
        if (ENVIRONMENT_IS_WORKER) {
          scriptDirectory = require_path().dirname(scriptDirectory) + "/";
        } else {
          scriptDirectory = __dirname + "/";
        }
        read_ = function shell_read(filename, binary) {
          if (!nodeFS)
            nodeFS = require("fs");
          if (!nodePath)
            nodePath = require_path();
          filename = nodePath["normalize"](filename);
          return nodeFS["readFileSync"](filename, binary ? null : "utf8");
        };
        readBinary = function readBinary2(filename) {
          var ret = read_(filename, true);
          if (!ret.buffer) {
            ret = new Uint8Array(ret);
          }
          assert2(ret.buffer);
          return ret;
        };
        if (process["argv"].length > 1) {
          thisProgram = process["argv"][1].replace(/\\/g, "/");
        }
        arguments_ = process["argv"].slice(2);
        process["on"]("uncaughtException", function(ex) {
          if (!(ex instanceof ExitStatus)) {
            throw ex;
          }
        });
        process["on"]("unhandledRejection", abort);
        quit_ = function(status2) {
          process["exit"](status2);
        };
        Module["inspect"] = function() {
          return "[Emscripten Module object]";
        };
      } else if (ENVIRONMENT_IS_SHELL) {
        if (typeof read != "undefined") {
          read_ = function shell_read(f) {
            return read(f);
          };
        }
        readBinary = function readBinary2(f) {
          var data2;
          if (typeof readbuffer === "function") {
            return new Uint8Array(readbuffer(f));
          }
          data2 = read(f, "binary");
          assert2(typeof data2 === "object");
          return data2;
        };
        if (typeof scriptArgs != "undefined") {
          arguments_ = scriptArgs;
        } else if (typeof arguments != "undefined") {
          arguments_ = arguments;
        }
        if (typeof quit === "function") {
          quit_ = function(status2) {
            quit(status2);
          };
        }
        if (typeof print !== "undefined") {
          if (typeof console === "undefined")
            console = {};
          console.log = print;
          console.warn = console.error = typeof printErr !== "undefined" ? printErr : print;
        }
      } else if (ENVIRONMENT_IS_WEB || ENVIRONMENT_IS_WORKER) {
        if (ENVIRONMENT_IS_WORKER) {
          scriptDirectory = self.location.href;
        } else if (document.currentScript) {
          scriptDirectory = document.currentScript.src;
        }
        if (_scriptDir) {
          scriptDirectory = _scriptDir;
        }
        if (scriptDirectory.indexOf("blob:") !== 0) {
          scriptDirectory = scriptDirectory.substr(0, scriptDirectory.lastIndexOf("/") + 1);
        } else {
          scriptDirectory = "";
        }
        {
          read_ = function shell_read(url) {
            var xhr = new XMLHttpRequest();
            xhr.open("GET", url, false);
            xhr.send(null);
            return xhr.responseText;
          };
          if (ENVIRONMENT_IS_WORKER) {
            readBinary = function readBinary2(url) {
              var xhr = new XMLHttpRequest();
              xhr.open("GET", url, false);
              xhr.responseType = "arraybuffer";
              xhr.send(null);
              return new Uint8Array(xhr.response);
            };
          }
          readAsync = function readAsync2(url, onload, onerror) {
            var xhr = new XMLHttpRequest();
            xhr.open("GET", url, true);
            xhr.responseType = "arraybuffer";
            xhr.onload = function xhr_onload() {
              if (xhr.status == 200 || xhr.status == 0 && xhr.response) {
                onload(xhr.response);
                return;
              }
              onerror();
            };
            xhr.onerror = onerror;
            xhr.send(null);
          };
        }
        setWindowTitle = function(title) {
          document.title = title;
        };
      } else {
      }
      var out = Module["print"] || console.log.bind(console);
      var err = Module["printErr"] || console.warn.bind(console);
      for (key in moduleOverrides) {
        if (moduleOverrides.hasOwnProperty(key)) {
          Module[key] = moduleOverrides[key];
        }
      }
      moduleOverrides = null;
      if (Module["arguments"])
        arguments_ = Module["arguments"];
      if (Module["thisProgram"])
        thisProgram = Module["thisProgram"];
      if (Module["quit"])
        quit_ = Module["quit"];
      var wasmBinary;
      if (Module["wasmBinary"])
        wasmBinary = Module["wasmBinary"];
      var noExitRuntime;
      if (Module["noExitRuntime"])
        noExitRuntime = Module["noExitRuntime"];
      if (typeof WebAssembly !== "object") {
        err("no native wasm support detected");
      }
      var wasmMemory;
      var wasmTable = new WebAssembly.Table({initial: 147, maximum: 147 + 0, element: "anyfunc"});
      var ABORT = false;
      var EXITSTATUS = 0;
      function assert2(condition, text) {
        if (!condition) {
          abort("Assertion failed: " + text);
        }
      }
      function getCFunc(ident) {
        var func = Module["_" + ident];
        assert2(func, "Cannot call unknown function " + ident + ", make sure it is exported");
        return func;
      }
      function ccall(ident, returnType, argTypes, args, opts) {
        var toC = {string: function(str2) {
          var ret2 = 0;
          if (str2 !== null && str2 !== void 0 && str2 !== 0) {
            var len = (str2.length << 2) + 1;
            ret2 = stackAlloc(len);
            stringToUTF8(str2, ret2, len);
          }
          return ret2;
        }, array: function(arr) {
          var ret2 = stackAlloc(arr.length);
          writeArrayToMemory(arr, ret2);
          return ret2;
        }};
        function convertReturnValue(ret2) {
          if (returnType === "string")
            return UTF8ToString(ret2);
          if (returnType === "boolean")
            return Boolean(ret2);
          return ret2;
        }
        var func = getCFunc(ident);
        var cArgs = [];
        var stack = 0;
        if (args) {
          for (var i = 0; i < args.length; i++) {
            var converter = toC[argTypes[i]];
            if (converter) {
              if (stack === 0)
                stack = stackSave();
              cArgs[i] = converter(args[i]);
            } else {
              cArgs[i] = args[i];
            }
          }
        }
        var ret = func.apply(null, cArgs);
        ret = convertReturnValue(ret);
        if (stack !== 0)
          stackRestore(stack);
        return ret;
      }
      function cwrap(ident, returnType, argTypes, opts) {
        argTypes = argTypes || [];
        var numericArgs = argTypes.every(function(type) {
          return type === "number";
        });
        var numericRet = returnType !== "string";
        if (numericRet && numericArgs && !opts) {
          return getCFunc(ident);
        }
        return function() {
          return ccall(ident, returnType, argTypes, arguments, opts);
        };
      }
      var UTF8Decoder = typeof TextDecoder !== "undefined" ? new TextDecoder("utf8") : void 0;
      function UTF8ArrayToString(heap, idx, maxBytesToRead) {
        var endIdx = idx + maxBytesToRead;
        var endPtr = idx;
        while (heap[endPtr] && !(endPtr >= endIdx))
          ++endPtr;
        if (endPtr - idx > 16 && heap.subarray && UTF8Decoder) {
          return UTF8Decoder.decode(heap.subarray(idx, endPtr));
        } else {
          var str2 = "";
          while (idx < endPtr) {
            var u0 = heap[idx++];
            if (!(u0 & 128)) {
              str2 += String.fromCharCode(u0);
              continue;
            }
            var u1 = heap[idx++] & 63;
            if ((u0 & 224) == 192) {
              str2 += String.fromCharCode((u0 & 31) << 6 | u1);
              continue;
            }
            var u2 = heap[idx++] & 63;
            if ((u0 & 240) == 224) {
              u0 = (u0 & 15) << 12 | u1 << 6 | u2;
            } else {
              u0 = (u0 & 7) << 18 | u1 << 12 | u2 << 6 | heap[idx++] & 63;
            }
            if (u0 < 65536) {
              str2 += String.fromCharCode(u0);
            } else {
              var ch = u0 - 65536;
              str2 += String.fromCharCode(55296 | ch >> 10, 56320 | ch & 1023);
            }
          }
        }
        return str2;
      }
      function UTF8ToString(ptr, maxBytesToRead) {
        return ptr ? UTF8ArrayToString(HEAPU8, ptr, maxBytesToRead) : "";
      }
      function stringToUTF8Array(str2, heap, outIdx, maxBytesToWrite) {
        if (!(maxBytesToWrite > 0))
          return 0;
        var startIdx = outIdx;
        var endIdx = outIdx + maxBytesToWrite - 1;
        for (var i = 0; i < str2.length; ++i) {
          var u = str2.charCodeAt(i);
          if (u >= 55296 && u <= 57343) {
            var u1 = str2.charCodeAt(++i);
            u = 65536 + ((u & 1023) << 10) | u1 & 1023;
          }
          if (u <= 127) {
            if (outIdx >= endIdx)
              break;
            heap[outIdx++] = u;
          } else if (u <= 2047) {
            if (outIdx + 1 >= endIdx)
              break;
            heap[outIdx++] = 192 | u >> 6;
            heap[outIdx++] = 128 | u & 63;
          } else if (u <= 65535) {
            if (outIdx + 2 >= endIdx)
              break;
            heap[outIdx++] = 224 | u >> 12;
            heap[outIdx++] = 128 | u >> 6 & 63;
            heap[outIdx++] = 128 | u & 63;
          } else {
            if (outIdx + 3 >= endIdx)
              break;
            heap[outIdx++] = 240 | u >> 18;
            heap[outIdx++] = 128 | u >> 12 & 63;
            heap[outIdx++] = 128 | u >> 6 & 63;
            heap[outIdx++] = 128 | u & 63;
          }
        }
        heap[outIdx] = 0;
        return outIdx - startIdx;
      }
      function stringToUTF8(str2, outPtr, maxBytesToWrite) {
        return stringToUTF8Array(str2, HEAPU8, outPtr, maxBytesToWrite);
      }
      function writeArrayToMemory(array, buffer3) {
        HEAP8.set(array, buffer3);
      }
      var buffer2, HEAP8, HEAPU8, HEAP16, HEAPU16, HEAP32, HEAPU32, HEAPF32, HEAPF64;
      function updateGlobalBufferAndViews(buf) {
        buffer2 = buf;
        Module["HEAP8"] = HEAP8 = new Int8Array(buf);
        Module["HEAP16"] = HEAP16 = new Int16Array(buf);
        Module["HEAP32"] = HEAP32 = new Int32Array(buf);
        Module["HEAPU8"] = HEAPU8 = new Uint8Array(buf);
        Module["HEAPU16"] = HEAPU16 = new Uint16Array(buf);
        Module["HEAPU32"] = HEAPU32 = new Uint32Array(buf);
        Module["HEAPF32"] = HEAPF32 = new Float32Array(buf);
        Module["HEAPF64"] = HEAPF64 = new Float64Array(buf);
      }
      var INITIAL_INITIAL_MEMORY = Module["INITIAL_MEMORY"] || 16777216;
      function callRuntimeCallbacks(callbacks) {
        while (callbacks.length > 0) {
          var callback = callbacks.shift();
          if (typeof callback == "function") {
            callback(Module);
            continue;
          }
          var func = callback.func;
          if (typeof func === "number") {
            if (callback.arg === void 0) {
              Module["dynCall_v"](func);
            } else {
              Module["dynCall_vi"](func, callback.arg);
            }
          } else {
            func(callback.arg === void 0 ? null : callback.arg);
          }
        }
      }
      var __ATPRERUN__ = [];
      var __ATINIT__ = [];
      var __ATMAIN__ = [];
      var __ATPOSTRUN__ = [];
      var runtimeInitialized = false;
      var runtimeExited = false;
      function preRun() {
        if (Module["preRun"]) {
          if (typeof Module["preRun"] == "function")
            Module["preRun"] = [Module["preRun"]];
          while (Module["preRun"].length) {
            addOnPreRun(Module["preRun"].shift());
          }
        }
        callRuntimeCallbacks(__ATPRERUN__);
      }
      function initRuntime() {
        runtimeInitialized = true;
        callRuntimeCallbacks(__ATINIT__);
      }
      function preMain() {
        callRuntimeCallbacks(__ATMAIN__);
      }
      function exitRuntime() {
        runtimeExited = true;
      }
      function postRun() {
        if (Module["postRun"]) {
          if (typeof Module["postRun"] == "function")
            Module["postRun"] = [Module["postRun"]];
          while (Module["postRun"].length) {
            addOnPostRun(Module["postRun"].shift());
          }
        }
        callRuntimeCallbacks(__ATPOSTRUN__);
      }
      function addOnPreRun(cb) {
        __ATPRERUN__.unshift(cb);
      }
      function addOnPostRun(cb) {
        __ATPOSTRUN__.unshift(cb);
      }
      var Math_ceil = Math.ceil;
      var Math_floor = Math.floor;
      var runDependencies = 0;
      var runDependencyWatcher = null;
      var dependenciesFulfilled = null;
      function addRunDependency(id) {
        runDependencies++;
        if (Module["monitorRunDependencies"]) {
          Module["monitorRunDependencies"](runDependencies);
        }
      }
      function removeRunDependency(id) {
        runDependencies--;
        if (Module["monitorRunDependencies"]) {
          Module["monitorRunDependencies"](runDependencies);
        }
        if (runDependencies == 0) {
          if (runDependencyWatcher !== null) {
            clearInterval(runDependencyWatcher);
            runDependencyWatcher = null;
          }
          if (dependenciesFulfilled) {
            var callback = dependenciesFulfilled;
            dependenciesFulfilled = null;
            callback();
          }
        }
      }
      Module["preloadedImages"] = {};
      Module["preloadedAudios"] = {};
      function abort(what) {
        if (Module["onAbort"]) {
          Module["onAbort"](what);
        }
        what += "";
        out(what);
        err(what);
        ABORT = true;
        EXITSTATUS = 1;
        what = "abort(" + what + "). Build with -s ASSERTIONS=1 for more info.";
        throw new WebAssembly.RuntimeError(what);
      }
      function hasPrefix(str2, prefix) {
        return String.prototype.startsWith ? str2.startsWith(prefix) : str2.indexOf(prefix) === 0;
      }
      var dataURIPrefix = "data:application/octet-stream;base64,";
      function isDataURI(filename) {
        return hasPrefix(filename, dataURIPrefix);
      }
      var fileURIPrefix = "file://";
      function isFileURI(filename) {
        return hasPrefix(filename, fileURIPrefix);
      }
      var wasmBinaryFile = "tfjs-backend-wasm.wasm";
      if (!isDataURI(wasmBinaryFile)) {
        wasmBinaryFile = locateFile(wasmBinaryFile);
      }
      function getBinary() {
        try {
          if (wasmBinary) {
            return new Uint8Array(wasmBinary);
          }
          if (readBinary) {
            return readBinary(wasmBinaryFile);
          } else {
            throw "both async and sync fetching of the wasm failed";
          }
        } catch (err2) {
          abort(err2);
        }
      }
      function getBinaryPromise() {
        if (!wasmBinary && (ENVIRONMENT_IS_WEB || ENVIRONMENT_IS_WORKER) && typeof fetch === "function" && !isFileURI(wasmBinaryFile)) {
          return fetch(wasmBinaryFile, {credentials: "same-origin"}).then(function(response) {
            if (!response["ok"]) {
              throw "failed to load wasm binary file at '" + wasmBinaryFile + "'";
            }
            return response["arrayBuffer"]();
          }).catch(function() {
            return getBinary();
          });
        }
        return new Promise(function(resolve, reject) {
          resolve(getBinary());
        });
      }
      function createWasm() {
        var info = {env: asmLibraryArg, wasi_snapshot_preview1: asmLibraryArg};
        function receiveInstance(instance2, module2) {
          var exports3 = instance2.exports;
          Module["asm"] = exports3;
          wasmMemory = exports3["memory"];
          updateGlobalBufferAndViews(wasmMemory.buffer);
          removeRunDependency("wasm-instantiate");
        }
        addRunDependency("wasm-instantiate");
        function receiveInstantiatedSource(output) {
          receiveInstance(output["instance"]);
        }
        function instantiateArrayBuffer(receiver) {
          return getBinaryPromise().then(function(binary) {
            return WebAssembly.instantiate(binary, info);
          }).then(receiver, function(reason) {
            err("failed to asynchronously prepare wasm: " + reason);
            abort(reason);
          });
        }
        function instantiateAsync() {
          if (!wasmBinary && typeof WebAssembly.instantiateStreaming === "function" && !isDataURI(wasmBinaryFile) && !isFileURI(wasmBinaryFile) && typeof fetch === "function") {
            fetch(wasmBinaryFile, {credentials: "same-origin"}).then(function(response) {
              var result = WebAssembly.instantiateStreaming(response, info);
              return result.then(receiveInstantiatedSource, function(reason) {
                err("wasm streaming compile failed: " + reason);
                err("falling back to ArrayBuffer instantiation");
                instantiateArrayBuffer(receiveInstantiatedSource);
              });
            });
          } else {
            return instantiateArrayBuffer(receiveInstantiatedSource);
          }
        }
        if (Module["instantiateWasm"]) {
          try {
            var exports2 = Module["instantiateWasm"](info, receiveInstance);
            return exports2;
          } catch (e) {
            err("Module.instantiateWasm callback failed with error: " + e);
            return false;
          }
        }
        instantiateAsync();
        return {};
      }
      __ATINIT__.push();
      function _emscripten_notify_memory_growth(memoryIndex) {
        updateGlobalBufferAndViews(wasmMemory.buffer);
      }
      var PATH = {splitPath: function(filename) {
        var splitPathRe = /^(\/?|)([\s\S]*?)((?:\.{1,2}|[^\/]+?|)(\.[^.\/]*|))(?:[\/]*)$/;
        return splitPathRe.exec(filename).slice(1);
      }, normalizeArray: function(parts, allowAboveRoot) {
        var up = 0;
        for (var i = parts.length - 1; i >= 0; i--) {
          var last = parts[i];
          if (last === ".") {
            parts.splice(i, 1);
          } else if (last === "..") {
            parts.splice(i, 1);
            up++;
          } else if (up) {
            parts.splice(i, 1);
            up--;
          }
        }
        if (allowAboveRoot) {
          for (; up; up--) {
            parts.unshift("..");
          }
        }
        return parts;
      }, normalize: function(path) {
        var isAbsolute = path.charAt(0) === "/", trailingSlash = path.substr(-1) === "/";
        path = PATH.normalizeArray(path.split("/").filter(function(p) {
          return !!p;
        }), !isAbsolute).join("/");
        if (!path && !isAbsolute) {
          path = ".";
        }
        if (path && trailingSlash) {
          path += "/";
        }
        return (isAbsolute ? "/" : "") + path;
      }, dirname: function(path) {
        var result = PATH.splitPath(path), root = result[0], dir = result[1];
        if (!root && !dir) {
          return ".";
        }
        if (dir) {
          dir = dir.substr(0, dir.length - 1);
        }
        return root + dir;
      }, basename: function(path) {
        if (path === "/")
          return "/";
        var lastSlash = path.lastIndexOf("/");
        if (lastSlash === -1)
          return path;
        return path.substr(lastSlash + 1);
      }, extname: function(path) {
        return PATH.splitPath(path)[3];
      }, join: function() {
        var paths = Array.prototype.slice.call(arguments, 0);
        return PATH.normalize(paths.join("/"));
      }, join2: function(l, r) {
        return PATH.normalize(l + "/" + r);
      }};
      var SYSCALLS = {mappings: {}, buffers: [null, [], []], printChar: function(stream, curr) {
        var buffer3 = SYSCALLS.buffers[stream];
        if (curr === 0 || curr === 10) {
          (stream === 1 ? out : err)(UTF8ArrayToString(buffer3, 0));
          buffer3.length = 0;
        } else {
          buffer3.push(curr);
        }
      }, varargs: void 0, get: function() {
        SYSCALLS.varargs += 4;
        var ret = HEAP32[SYSCALLS.varargs - 4 >> 2];
        return ret;
      }, getStr: function(ptr) {
        var ret = UTF8ToString(ptr);
        return ret;
      }, get64: function(low, high) {
        return low;
      }};
      function _fd_close(fd) {
        return 0;
      }
      function _fd_seek(fd, offset_low, offset_high, whence, newOffset) {
      }
      function _fd_write(fd, iov, iovcnt, pnum) {
        var num = 0;
        for (var i = 0; i < iovcnt; i++) {
          var ptr = HEAP32[iov + i * 8 >> 2];
          var len = HEAP32[iov + (i * 8 + 4) >> 2];
          for (var j = 0; j < len; j++) {
            SYSCALLS.printChar(fd, HEAPU8[ptr + j]);
          }
          num += len;
        }
        HEAP32[pnum >> 2] = num;
        return 0;
      }
      function _exit(status2) {
        exit(status2);
      }
      function _proc_exit(code) {
        _exit(code);
      }
      function _roundf(d) {
        d = +d;
        return d >= 0 ? +Math_floor(d + 0.5) : +Math_ceil(d - 0.5);
      }
      var asmLibraryArg = {emscripten_notify_memory_growth: _emscripten_notify_memory_growth, fd_close: _fd_close, fd_seek: _fd_seek, fd_write: _fd_write, proc_exit: _proc_exit, roundf: _roundf};
      var asm = createWasm();
      Module["asm"] = asm;
      var _init = Module["_init"] = function() {
        return (_init = Module["_init"] = Module["asm"]["init"]).apply(null, arguments);
      };
      var _register_tensor = Module["_register_tensor"] = function() {
        return (_register_tensor = Module["_register_tensor"] = Module["asm"]["register_tensor"]).apply(null, arguments);
      };
      var _dispose_data = Module["_dispose_data"] = function() {
        return (_dispose_data = Module["_dispose_data"] = Module["asm"]["dispose_data"]).apply(null, arguments);
      };
      var _dispose = Module["_dispose"] = function() {
        return (_dispose = Module["_dispose"] = Module["asm"]["dispose"]).apply(null, arguments);
      };
      var _Abs = Module["_Abs"] = function() {
        return (_Abs = Module["_Abs"] = Module["asm"]["Abs"]).apply(null, arguments);
      };
      var _Add = Module["_Add"] = function() {
        return (_Add = Module["_Add"] = Module["asm"]["Add"]).apply(null, arguments);
      };
      var _AddN = Module["_AddN"] = function() {
        return (_AddN = Module["_AddN"] = Module["asm"]["AddN"]).apply(null, arguments);
      };
      var _ArgMax = Module["_ArgMax"] = function() {
        return (_ArgMax = Module["_ArgMax"] = Module["asm"]["ArgMax"]).apply(null, arguments);
      };
      var _AvgPool = Module["_AvgPool"] = function() {
        return (_AvgPool = Module["_AvgPool"] = Module["asm"]["AvgPool"]).apply(null, arguments);
      };
      var _BatchMatMul = Module["_BatchMatMul"] = function() {
        return (_BatchMatMul = Module["_BatchMatMul"] = Module["asm"]["BatchMatMul"]).apply(null, arguments);
      };
      var _ClipByValue = Module["_ClipByValue"] = function() {
        return (_ClipByValue = Module["_ClipByValue"] = Module["asm"]["ClipByValue"]).apply(null, arguments);
      };
      var _Conv2D = Module["_Conv2D"] = function() {
        return (_Conv2D = Module["_Conv2D"] = Module["asm"]["Conv2D"]).apply(null, arguments);
      };
      var _Conv2DBackpropInput = Module["_Conv2DBackpropInput"] = function() {
        return (_Conv2DBackpropInput = Module["_Conv2DBackpropInput"] = Module["asm"]["Conv2DBackpropInput"]).apply(null, arguments);
      };
      var _Cos = Module["_Cos"] = function() {
        return (_Cos = Module["_Cos"] = Module["asm"]["Cos"]).apply(null, arguments);
      };
      var _CropAndResize = Module["_CropAndResize"] = function() {
        return (_CropAndResize = Module["_CropAndResize"] = Module["asm"]["CropAndResize"]).apply(null, arguments);
      };
      var _Cumsum = Module["_Cumsum"] = function() {
        return (_Cumsum = Module["_Cumsum"] = Module["asm"]["Cumsum"]).apply(null, arguments);
      };
      var _DepthToSpace = Module["_DepthToSpace"] = function() {
        return (_DepthToSpace = Module["_DepthToSpace"] = Module["asm"]["DepthToSpace"]).apply(null, arguments);
      };
      var _DepthwiseConv2dNative = Module["_DepthwiseConv2dNative"] = function() {
        return (_DepthwiseConv2dNative = Module["_DepthwiseConv2dNative"] = Module["asm"]["DepthwiseConv2dNative"]).apply(null, arguments);
      };
      var _Div = Module["_Div"] = function() {
        return (_Div = Module["_Div"] = Module["asm"]["Div"]).apply(null, arguments);
      };
      var _Equal = Module["_Equal"] = function() {
        return (_Equal = Module["_Equal"] = Module["asm"]["Equal"]).apply(null, arguments);
      };
      var _Exp = Module["_Exp"] = function() {
        return (_Exp = Module["_Exp"] = Module["asm"]["Exp"]).apply(null, arguments);
      };
      var _FlipLeftRight = Module["_FlipLeftRight"] = function() {
        return (_FlipLeftRight = Module["_FlipLeftRight"] = Module["asm"]["FlipLeftRight"]).apply(null, arguments);
      };
      var _FloorDiv = Module["_FloorDiv"] = function() {
        return (_FloorDiv = Module["_FloorDiv"] = Module["asm"]["FloorDiv"]).apply(null, arguments);
      };
      var _FusedBatchNorm = Module["_FusedBatchNorm"] = function() {
        return (_FusedBatchNorm = Module["_FusedBatchNorm"] = Module["asm"]["FusedBatchNorm"]).apply(null, arguments);
      };
      var _FusedConv2D = Module["_FusedConv2D"] = function() {
        return (_FusedConv2D = Module["_FusedConv2D"] = Module["asm"]["FusedConv2D"]).apply(null, arguments);
      };
      var _FusedDepthwiseConv2D = Module["_FusedDepthwiseConv2D"] = function() {
        return (_FusedDepthwiseConv2D = Module["_FusedDepthwiseConv2D"] = Module["asm"]["FusedDepthwiseConv2D"]).apply(null, arguments);
      };
      var _Gather = Module["_Gather"] = function() {
        return (_Gather = Module["_Gather"] = Module["asm"]["Gather"]).apply(null, arguments);
      };
      var _GatherNd = Module["_GatherNd"] = function() {
        return (_GatherNd = Module["_GatherNd"] = Module["asm"]["GatherNd"]).apply(null, arguments);
      };
      var _Greater = Module["_Greater"] = function() {
        return (_Greater = Module["_Greater"] = Module["asm"]["Greater"]).apply(null, arguments);
      };
      var _GreaterEqual = Module["_GreaterEqual"] = function() {
        return (_GreaterEqual = Module["_GreaterEqual"] = Module["asm"]["GreaterEqual"]).apply(null, arguments);
      };
      var _Less = Module["_Less"] = function() {
        return (_Less = Module["_Less"] = Module["asm"]["Less"]).apply(null, arguments);
      };
      var _LessEqual = Module["_LessEqual"] = function() {
        return (_LessEqual = Module["_LessEqual"] = Module["asm"]["LessEqual"]).apply(null, arguments);
      };
      var _Log = Module["_Log"] = function() {
        return (_Log = Module["_Log"] = Module["asm"]["Log"]).apply(null, arguments);
      };
      var _LogicalAnd = Module["_LogicalAnd"] = function() {
        return (_LogicalAnd = Module["_LogicalAnd"] = Module["asm"]["LogicalAnd"]).apply(null, arguments);
      };
      var _Max = Module["_Max"] = function() {
        return (_Max = Module["_Max"] = Module["asm"]["Max"]).apply(null, arguments);
      };
      var _MaxPool = Module["_MaxPool"] = function() {
        return (_MaxPool = Module["_MaxPool"] = Module["asm"]["MaxPool"]).apply(null, arguments);
      };
      var _Maximum = Module["_Maximum"] = function() {
        return (_Maximum = Module["_Maximum"] = Module["asm"]["Maximum"]).apply(null, arguments);
      };
      var _Min = Module["_Min"] = function() {
        return (_Min = Module["_Min"] = Module["asm"]["Min"]).apply(null, arguments);
      };
      var _Minimum = Module["_Minimum"] = function() {
        return (_Minimum = Module["_Minimum"] = Module["asm"]["Minimum"]).apply(null, arguments);
      };
      var _Multiply = Module["_Multiply"] = function() {
        return (_Multiply = Module["_Multiply"] = Module["asm"]["Multiply"]).apply(null, arguments);
      };
      var _Negate = Module["_Negate"] = function() {
        return (_Negate = Module["_Negate"] = Module["asm"]["Negate"]).apply(null, arguments);
      };
      var _NonMaxSuppressionV3 = Module["_NonMaxSuppressionV3"] = function() {
        return (_NonMaxSuppressionV3 = Module["_NonMaxSuppressionV3"] = Module["asm"]["NonMaxSuppressionV3"]).apply(null, arguments);
      };
      var _NonMaxSuppressionV4 = Module["_NonMaxSuppressionV4"] = function() {
        return (_NonMaxSuppressionV4 = Module["_NonMaxSuppressionV4"] = Module["asm"]["NonMaxSuppressionV4"]).apply(null, arguments);
      };
      var _NonMaxSuppressionV5 = Module["_NonMaxSuppressionV5"] = function() {
        return (_NonMaxSuppressionV5 = Module["_NonMaxSuppressionV5"] = Module["asm"]["NonMaxSuppressionV5"]).apply(null, arguments);
      };
      var _NotEqual = Module["_NotEqual"] = function() {
        return (_NotEqual = Module["_NotEqual"] = Module["asm"]["NotEqual"]).apply(null, arguments);
      };
      var _OneHot = Module["_OneHot"] = function() {
        return (_OneHot = Module["_OneHot"] = Module["asm"]["OneHot"]).apply(null, arguments);
      };
      var _PadV2 = Module["_PadV2"] = function() {
        return (_PadV2 = Module["_PadV2"] = Module["asm"]["PadV2"]).apply(null, arguments);
      };
      var _Pow = Module["_Pow"] = function() {
        return (_Pow = Module["_Pow"] = Module["asm"]["Pow"]).apply(null, arguments);
      };
      var _Prelu = Module["_Prelu"] = function() {
        return (_Prelu = Module["_Prelu"] = Module["asm"]["Prelu"]).apply(null, arguments);
      };
      var _Relu = Module["_Relu"] = function() {
        return (_Relu = Module["_Relu"] = Module["asm"]["Relu"]).apply(null, arguments);
      };
      var _Relu6 = Module["_Relu6"] = function() {
        return (_Relu6 = Module["_Relu6"] = Module["asm"]["Relu6"]).apply(null, arguments);
      };
      var _ResizeBilinear = Module["_ResizeBilinear"] = function() {
        return (_ResizeBilinear = Module["_ResizeBilinear"] = Module["asm"]["ResizeBilinear"]).apply(null, arguments);
      };
      var _Reverse = Module["_Reverse"] = function() {
        return (_Reverse = Module["_Reverse"] = Module["asm"]["Reverse"]).apply(null, arguments);
      };
      var _RotateWithOffset = Module["_RotateWithOffset"] = function() {
        return (_RotateWithOffset = Module["_RotateWithOffset"] = Module["asm"]["RotateWithOffset"]).apply(null, arguments);
      };
      var _Rsqrt = Module["_Rsqrt"] = function() {
        return (_Rsqrt = Module["_Rsqrt"] = Module["asm"]["Rsqrt"]).apply(null, arguments);
      };
      var _ScatterNd = Module["_ScatterNd"] = function() {
        return (_ScatterNd = Module["_ScatterNd"] = Module["asm"]["ScatterNd"]).apply(null, arguments);
      };
      var _SelectV2 = Module["_SelectV2"] = function() {
        return (_SelectV2 = Module["_SelectV2"] = Module["asm"]["SelectV2"]).apply(null, arguments);
      };
      var _Sigmoid = Module["_Sigmoid"] = function() {
        return (_Sigmoid = Module["_Sigmoid"] = Module["asm"]["Sigmoid"]).apply(null, arguments);
      };
      var _Sin = Module["_Sin"] = function() {
        return (_Sin = Module["_Sin"] = Module["asm"]["Sin"]).apply(null, arguments);
      };
      var _Softmax = Module["_Softmax"] = function() {
        return (_Softmax = Module["_Softmax"] = Module["asm"]["Softmax"]).apply(null, arguments);
      };
      var _Sqrt = Module["_Sqrt"] = function() {
        return (_Sqrt = Module["_Sqrt"] = Module["asm"]["Sqrt"]).apply(null, arguments);
      };
      var _Square = Module["_Square"] = function() {
        return (_Square = Module["_Square"] = Module["asm"]["Square"]).apply(null, arguments);
      };
      var _SquaredDifference = Module["_SquaredDifference"] = function() {
        return (_SquaredDifference = Module["_SquaredDifference"] = Module["asm"]["SquaredDifference"]).apply(null, arguments);
      };
      var _StridedSlice = Module["_StridedSlice"] = function() {
        return (_StridedSlice = Module["_StridedSlice"] = Module["asm"]["StridedSlice"]).apply(null, arguments);
      };
      var _Sub = Module["_Sub"] = function() {
        return (_Sub = Module["_Sub"] = Module["asm"]["Sub"]).apply(null, arguments);
      };
      var _Sum = Module["_Sum"] = function() {
        return (_Sum = Module["_Sum"] = Module["asm"]["Sum"]).apply(null, arguments);
      };
      var _Tanh = Module["_Tanh"] = function() {
        return (_Tanh = Module["_Tanh"] = Module["asm"]["Tanh"]).apply(null, arguments);
      };
      var _Tile = Module["_Tile"] = function() {
        return (_Tile = Module["_Tile"] = Module["asm"]["Tile"]).apply(null, arguments);
      };
      var _Transpose = Module["_Transpose"] = function() {
        return (_Transpose = Module["_Transpose"] = Module["asm"]["Transpose"]).apply(null, arguments);
      };
      var __FusedMatMul = Module["__FusedMatMul"] = function() {
        return (__FusedMatMul = Module["__FusedMatMul"] = Module["asm"]["_FusedMatMul"]).apply(null, arguments);
      };
      var _malloc = Module["_malloc"] = function() {
        return (_malloc = Module["_malloc"] = Module["asm"]["malloc"]).apply(null, arguments);
      };
      var _free = Module["_free"] = function() {
        return (_free = Module["_free"] = Module["asm"]["free"]).apply(null, arguments);
      };
      var __start = Module["__start"] = function() {
        return (__start = Module["__start"] = Module["asm"]["_start"]).apply(null, arguments);
      };
      var stackSave = Module["stackSave"] = function() {
        return (stackSave = Module["stackSave"] = Module["asm"]["stackSave"]).apply(null, arguments);
      };
      var stackAlloc = Module["stackAlloc"] = function() {
        return (stackAlloc = Module["stackAlloc"] = Module["asm"]["stackAlloc"]).apply(null, arguments);
      };
      var stackRestore = Module["stackRestore"] = function() {
        return (stackRestore = Module["stackRestore"] = Module["asm"]["stackRestore"]).apply(null, arguments);
      };
      Module["asm"] = asm;
      Module["cwrap"] = cwrap;
      var calledRun;
      Module["then"] = function(func) {
        if (calledRun) {
          func(Module);
        } else {
          var old = Module["onRuntimeInitialized"];
          Module["onRuntimeInitialized"] = function() {
            if (old)
              old();
            func(Module);
          };
        }
        return Module;
      };
      function ExitStatus(status2) {
        this.name = "ExitStatus";
        this.message = "Program terminated with exit(" + status2 + ")";
        this.status = status2;
      }
      var calledMain = false;
      dependenciesFulfilled = function runCaller() {
        if (!calledRun)
          run();
        if (!calledRun)
          dependenciesFulfilled = runCaller;
      };
      function callMain(args) {
        var entryFunction = Module["__start"];
        try {
          entryFunction();
          var ret = 0;
          exit(ret, true);
        } catch (e) {
          if (e instanceof ExitStatus) {
            return;
          } else if (e == "unwind") {
            noExitRuntime = true;
            return;
          } else {
            var toLog = e;
            if (e && typeof e === "object" && e.stack) {
              toLog = [e, e.stack];
            }
            err("exception thrown: " + toLog);
            quit_(1, e);
          }
        } finally {
          calledMain = true;
        }
      }
      function run(args) {
        args = args || arguments_;
        if (runDependencies > 0) {
          return;
        }
        preRun();
        if (runDependencies > 0)
          return;
        function doRun() {
          if (calledRun)
            return;
          calledRun = true;
          Module["calledRun"] = true;
          if (ABORT)
            return;
          initRuntime();
          preMain();
          if (Module["onRuntimeInitialized"])
            Module["onRuntimeInitialized"]();
          if (shouldRunNow)
            callMain(args);
          postRun();
        }
        if (Module["setStatus"]) {
          Module["setStatus"]("Running...");
          setTimeout(function() {
            setTimeout(function() {
              Module["setStatus"]("");
            }, 1);
            doRun();
          }, 1);
        } else {
          doRun();
        }
      }
      Module["run"] = run;
      function exit(status2, implicit) {
        if (implicit && noExitRuntime && status2 === 0) {
          return;
        }
        if (noExitRuntime) {
        } else {
          ABORT = true;
          EXITSTATUS = status2;
          exitRuntime();
          if (Module["onExit"])
            Module["onExit"](status2);
        }
        quit_(status2, new ExitStatus(status2));
      }
      if (Module["preInit"]) {
        if (typeof Module["preInit"] == "function")
          Module["preInit"] = [Module["preInit"]];
        while (Module["preInit"].length > 0) {
          Module["preInit"].pop()();
        }
      }
      var shouldRunNow = true;
      if (Module["noInitialRun"])
        shouldRunNow = false;
      noExitRuntime = true;
      run();
      return WasmBackendModule2;
    };
  }();
  if (typeof exports === "object" && typeof module === "object")
    module.exports = WasmBackendModule;
  else if (typeof define === "function" && define["amd"])
    define([], function() {
      return WasmBackendModule;
    });
  else if (typeof exports === "object")
    exports["WasmBackendModule"] = WasmBackendModule;
});
var require_blazeface = __commonJS((exports) => {
  const NUM_LANDMARKS = 6;
  function generateAnchors(inputSize) {
    const spec = {strides: [inputSize / 16, inputSize / 8], anchors: [2, 6]};
    const anchors = [];
    for (let i = 0; i < spec.strides.length; i++) {
      const stride = spec.strides[i];
      const gridRows = Math.floor((inputSize + stride - 1) / stride);
      const gridCols = Math.floor((inputSize + stride - 1) / stride);
      const anchorsNum = spec.anchors[i];
      for (let gridY = 0; gridY < gridRows; gridY++) {
        const anchorY = stride * (gridY + 0.5);
        for (let gridX = 0; gridX < gridCols; gridX++) {
          const anchorX = stride * (gridX + 0.5);
          for (let n = 0; n < anchorsNum; n++) {
            anchors.push([anchorX, anchorY]);
          }
        }
      }
    }
    return anchors;
  }
  const disposeBox = (box) => {
    box.startEndTensor.dispose();
    box.startPoint.dispose();
    box.endPoint.dispose();
  };
  const createBox = (startEndTensor) => ({
    startEndTensor,
    startPoint: tf.slice(startEndTensor, [0, 0], [-1, 2]),
    endPoint: tf.slice(startEndTensor, [0, 2], [-1, 2])
  });
  const scaleBox = (box, factors) => {
    const starts = tf.mul(box.startPoint, factors);
    const ends = tf.mul(box.endPoint, factors);
    const newCoordinates = tf.concat2d([starts, ends], 1);
    return createBox(newCoordinates);
  };
  function decodeBounds(boxOutputs, anchors, inputSize) {
    const boxStarts = tf.slice(boxOutputs, [0, 1], [-1, 2]);
    const centers = tf.add(boxStarts, anchors);
    const boxSizes = tf.slice(boxOutputs, [0, 3], [-1, 2]);
    const boxSizesNormalized = tf.div(boxSizes, inputSize);
    const centersNormalized = tf.div(centers, inputSize);
    const halfBoxSize = tf.div(boxSizesNormalized, 2);
    const starts = tf.sub(centersNormalized, halfBoxSize);
    const ends = tf.add(centersNormalized, halfBoxSize);
    const startNormalized = tf.mul(starts, inputSize);
    const endNormalized = tf.mul(ends, inputSize);
    const concatAxis = 1;
    return tf.concat2d([startNormalized, endNormalized], concatAxis);
  }
  function scaleBoxFromPrediction(face2, scaleFactor) {
    return tf.tidy(() => {
      const box = face2["box"] ? face2["box"] : face2;
      return scaleBox(box, scaleFactor).startEndTensor.squeeze();
    });
  }
  class BlazeFaceModel {
    constructor(model, config2) {
      this.blazeFaceModel = model;
      this.width = config2.detector.inputSize;
      this.height = config2.detector.inputSize;
      this.anchorsData = generateAnchors(config2.detector.inputSize);
      this.anchors = tf.tensor2d(this.anchorsData);
      this.inputSize = tf.tensor1d([this.width, this.height]);
      this.config = config2;
      this.scaleFaces = 0.8;
    }
    async getBoundingBoxes(inputImage) {
      if (!inputImage || inputImage.isDisposedInternal || inputImage.shape.length !== 4 || inputImage.shape[1] < 1 || inputImage.shape[2] < 1)
        return null;
      const [detectedOutputs, boxes, scores] = tf.tidy(() => {
        const resizedImage = inputImage.resizeBilinear([this.width, this.height]);
        const normalizedImage = tf.sub(resizedImage.div(127.5), 1);
        const batchedPrediction = this.blazeFaceModel.predict(normalizedImage);
        let prediction;
        if (Array.isArray(batchedPrediction)) {
          const sorted = batchedPrediction.sort((a, b) => a.size - b.size);
          const concat384 = tf.concat([sorted[0], sorted[2]], 2);
          const concat512 = tf.concat([sorted[1], sorted[3]], 2);
          const concat2 = tf.concat([concat512, concat384], 1);
          prediction = concat2.squeeze(0);
        } else {
          prediction = batchedPrediction.squeeze();
        }
        const decodedBounds = decodeBounds(prediction, this.anchors, this.inputSize);
        const logits = tf.slice(prediction, [0, 0], [-1, 1]);
        const scoresOut = tf.sigmoid(logits).squeeze();
        return [prediction, decodedBounds, scoresOut];
      });
      const boxIndicesTensor = await tf.image.nonMaxSuppressionAsync(boxes, scores, this.config.detector.maxFaces, this.config.detector.iouThreshold, this.config.detector.scoreThreshold);
      const boxIndices = boxIndicesTensor.arraySync();
      boxIndicesTensor.dispose();
      const boundingBoxesMap = boxIndices.map((boxIndex) => tf.slice(boxes, [boxIndex, 0], [1, -1]));
      const boundingBoxes = boundingBoxesMap.map((boundingBox) => {
        const vals = boundingBox.arraySync();
        boundingBox.dispose();
        return vals;
      });
      const scoresVal = scores.dataSync();
      const annotatedBoxes = [];
      for (const i in boundingBoxes) {
        const boxIndex = boxIndices[i];
        const confidence = scoresVal[boxIndex];
        if (confidence > this.config.detector.minConfidence) {
          const box = createBox(boundingBoxes[i]);
          const anchor = this.anchorsData[boxIndex];
          const landmarks = tf.tidy(() => tf.slice(detectedOutputs, [boxIndex, NUM_LANDMARKS - 1], [1, -1]).squeeze().reshape([NUM_LANDMARKS, -1]));
          annotatedBoxes.push({box, landmarks, anchor, confidence});
        }
      }
      detectedOutputs.dispose();
      boxes.dispose();
      scores.dispose();
      detectedOutputs.dispose();
      return {
        boxes: annotatedBoxes,
        scaleFactor: [inputImage.shape[2] / this.width, inputImage.shape[1] / this.height]
      };
    }
    async estimateFaces(input) {
      const {boxes, scaleFactor} = await this.getBoundingBoxes(input);
      const faces = [];
      for (const face2 of boxes) {
        const landmarkData = face2.landmarks.arraySync();
        const scaledBox = scaleBoxFromPrediction(face2, scaleFactor);
        const boxData = scaleBox.arraySync();
        const probabilityData = face2.probability.arraySync();
        const anchor = face2.anchor;
        const [scaleFactorX, scaleFactorY] = scaleFactor;
        const scaledLandmarks = landmarkData.map((landmark) => [
          (landmark[0] + anchor[0]) * scaleFactorX,
          (landmark[1] + anchor[1]) * scaleFactorY
        ]);
        const normalizedFace = {
          topLeft: boxData.slice(0, 2),
          bottomRight: boxData.slice(2),
          landmarks: scaledLandmarks,
          probability: probabilityData
        };
        disposeBox(face2.box);
        face2.landmarks.dispose();
        face2.probability.dispose();
        scaledBox.dispose();
        faces.push(normalizedFace);
      }
      return faces;
    }
  }
  async function load2(config2) {
    const blazeface = await loadGraphModel(config2.detector.modelPath, {fromTFHub: config2.detector.modelPath.includes("tfhub.dev")});
    const model = new BlazeFaceModel(blazeface, config2);
    console.log(`Human: load model: ${config2.detector.modelPath.match(/\/(.*)\./)[1]}`);
    return model;
  }
  exports.load = load2;
  exports.BlazeFaceModel = BlazeFaceModel;
  exports.disposeBox = disposeBox;
});
var require_box = __commonJS((exports) => {
  function scaleBoxCoordinates2(box, factor) {
    const startPoint = [box.startPoint[0] * factor[0], box.startPoint[1] * factor[1]];
    const endPoint = [box.endPoint[0] * factor[0], box.endPoint[1] * factor[1]];
    return {startPoint, endPoint};
  }
  exports.scaleBoxCoordinates = scaleBoxCoordinates2;
  function getBoxSize2(box) {
    return [
      Math.abs(box.endPoint[0] - box.startPoint[0]),
      Math.abs(box.endPoint[1] - box.startPoint[1])
    ];
  }
  exports.getBoxSize = getBoxSize2;
  function getBoxCenter2(box) {
    return [
      box.startPoint[0] + (box.endPoint[0] - box.startPoint[0]) / 2,
      box.startPoint[1] + (box.endPoint[1] - box.startPoint[1]) / 2
    ];
  }
  exports.getBoxCenter = getBoxCenter2;
  function cutBoxFromImageAndResize2(box, image2, cropSize) {
    const h = image2.shape[1];
    const w = image2.shape[2];
    const boxes = [[
      box.startPoint[1] / h,
      box.startPoint[0] / w,
      box.endPoint[1] / h,
      box.endPoint[0] / w
    ]];
    return tf.image.cropAndResize(image2, boxes, [0], cropSize);
  }
  exports.cutBoxFromImageAndResize = cutBoxFromImageAndResize2;
  function enlargeBox2(box, factor = 1.5) {
    const center = getBoxCenter2(box);
    const size = getBoxSize2(box);
    const newHalfSize = [factor * size[0] / 2, factor * size[1] / 2];
    const startPoint = [center[0] - newHalfSize[0], center[1] - newHalfSize[1]];
    const endPoint = [center[0] + newHalfSize[0], center[1] + newHalfSize[1]];
    return {startPoint, endPoint, landmarks: box.landmarks};
  }
  exports.enlargeBox = enlargeBox2;
  function squarifyBox2(box) {
    const centers = getBoxCenter2(box);
    const size = getBoxSize2(box);
    const maxEdge = Math.max(...size);
    const halfSize = maxEdge / 2;
    const startPoint = [centers[0] - halfSize, centers[1] - halfSize];
    const endPoint = [centers[0] + halfSize, centers[1] + halfSize];
    return {startPoint, endPoint, landmarks: box.landmarks};
  }
  exports.squarifyBox = squarifyBox2;
});
var require_util = __commonJS((exports) => {
  exports.IDENTITY_MATRIX = [[1, 0, 0], [0, 1, 0], [0, 0, 1]];
  function normalizeRadians2(angle) {
    return angle - 2 * Math.PI * Math.floor((angle + Math.PI) / (2 * Math.PI));
  }
  exports.normalizeRadians = normalizeRadians2;
  function computeRotation2(point1, point2) {
    const radians = Math.PI / 2 - Math.atan2(-(point2[1] - point1[1]), point2[0] - point1[0]);
    return normalizeRadians2(radians);
  }
  exports.computeRotation = computeRotation2;
  function radToDegrees(rad) {
    return rad * 180 / Math.PI;
  }
  exports.radToDegrees = radToDegrees;
  function buildTranslationMatrix2(x, y) {
    return [[1, 0, x], [0, 1, y], [0, 0, 1]];
  }
  function dot2(v1, v2) {
    let product = 0;
    for (let i = 0; i < v1.length; i++) {
      product += v1[i] * v2[i];
    }
    return product;
  }
  exports.dot = dot2;
  function getColumnFrom2DArr2(arr, columnIndex) {
    const column = [];
    for (let i = 0; i < arr.length; i++) {
      column.push(arr[i][columnIndex]);
    }
    return column;
  }
  exports.getColumnFrom2DArr = getColumnFrom2DArr2;
  function multiplyTransformMatrices2(mat1, mat2) {
    const product = [];
    const size = mat1.length;
    for (let row = 0; row < size; row++) {
      product.push([]);
      for (let col = 0; col < size; col++) {
        product[row].push(dot2(mat1[row], getColumnFrom2DArr2(mat2, col)));
      }
    }
    return product;
  }
  function buildRotationMatrix2(rotation, center) {
    const cosA = Math.cos(rotation);
    const sinA = Math.sin(rotation);
    const rotationMatrix = [[cosA, -sinA, 0], [sinA, cosA, 0], [0, 0, 1]];
    const translationMatrix = buildTranslationMatrix2(center[0], center[1]);
    const translationTimesRotation = multiplyTransformMatrices2(translationMatrix, rotationMatrix);
    const negativeTranslationMatrix = buildTranslationMatrix2(-center[0], -center[1]);
    return multiplyTransformMatrices2(translationTimesRotation, negativeTranslationMatrix);
  }
  exports.buildRotationMatrix = buildRotationMatrix2;
  function invertTransformMatrix2(matrix) {
    const rotationComponent = [[matrix[0][0], matrix[1][0]], [matrix[0][1], matrix[1][1]]];
    const translationComponent = [matrix[0][2], matrix[1][2]];
    const invertedTranslation = [
      -dot2(rotationComponent[0], translationComponent),
      -dot2(rotationComponent[1], translationComponent)
    ];
    return [
      rotationComponent[0].concat(invertedTranslation[0]),
      rotationComponent[1].concat(invertedTranslation[1]),
      [0, 0, 1]
    ];
  }
  exports.invertTransformMatrix = invertTransformMatrix2;
  function rotatePoint2(homogeneousCoordinate, rotationMatrix) {
    return [
      dot2(homogeneousCoordinate, rotationMatrix[0]),
      dot2(homogeneousCoordinate, rotationMatrix[1])
    ];
  }
  exports.rotatePoint = rotatePoint2;
  function xyDistanceBetweenPoints(a, b) {
    return Math.sqrt((a[0] - b[0]) ** 2 + (a[1] - b[1]) ** 2);
  }
  exports.xyDistanceBetweenPoints = xyDistanceBetweenPoints;
});
var require_coords = __commonJS((exports) => {
  const MESH_ANNOTATIONS = {
    silhouette: [
      10,
      338,
      297,
      332,
      284,
      251,
      389,
      356,
      454,
      323,
      361,
      288,
      397,
      365,
      379,
      378,
      400,
      377,
      152,
      148,
      176,
      149,
      150,
      136,
      172,
      58,
      132,
      93,
      234,
      127,
      162,
      21,
      54,
      103,
      67,
      109
    ],
    lipsUpperOuter: [61, 185, 40, 39, 37, 0, 267, 269, 270, 409, 291],
    lipsLowerOuter: [146, 91, 181, 84, 17, 314, 405, 321, 375, 291],
    lipsUpperInner: [78, 191, 80, 81, 82, 13, 312, 311, 310, 415, 308],
    lipsLowerInner: [78, 95, 88, 178, 87, 14, 317, 402, 318, 324, 308],
    rightEyeUpper0: [246, 161, 160, 159, 158, 157, 173],
    rightEyeLower0: [33, 7, 163, 144, 145, 153, 154, 155, 133],
    rightEyeUpper1: [247, 30, 29, 27, 28, 56, 190],
    rightEyeLower1: [130, 25, 110, 24, 23, 22, 26, 112, 243],
    rightEyeUpper2: [113, 225, 224, 223, 222, 221, 189],
    rightEyeLower2: [226, 31, 228, 229, 230, 231, 232, 233, 244],
    rightEyeLower3: [143, 111, 117, 118, 119, 120, 121, 128, 245],
    rightEyebrowUpper: [156, 70, 63, 105, 66, 107, 55, 193],
    rightEyebrowLower: [35, 124, 46, 53, 52, 65],
    rightEyeIris: [473, 474, 475, 476, 477],
    leftEyeUpper0: [466, 388, 387, 386, 385, 384, 398],
    leftEyeLower0: [263, 249, 390, 373, 374, 380, 381, 382, 362],
    leftEyeUpper1: [467, 260, 259, 257, 258, 286, 414],
    leftEyeLower1: [359, 255, 339, 254, 253, 252, 256, 341, 463],
    leftEyeUpper2: [342, 445, 444, 443, 442, 441, 413],
    leftEyeLower2: [446, 261, 448, 449, 450, 451, 452, 453, 464],
    leftEyeLower3: [372, 340, 346, 347, 348, 349, 350, 357, 465],
    leftEyebrowUpper: [383, 300, 293, 334, 296, 336, 285, 417],
    leftEyebrowLower: [265, 353, 276, 283, 282, 295],
    leftEyeIris: [468, 469, 470, 471, 472],
    midwayBetweenEyes: [168],
    noseTip: [1],
    noseBottom: [2],
    noseRightCorner: [98],
    noseLeftCorner: [327],
    rightCheek: [205],
    leftCheek: [425]
  };
  const MESH_TO_IRIS_INDICES_MAP = [
    {key: "EyeUpper0", indices: [9, 10, 11, 12, 13, 14, 15]},
    {key: "EyeUpper1", indices: [25, 26, 27, 28, 29, 30, 31]},
    {key: "EyeUpper2", indices: [41, 42, 43, 44, 45, 46, 47]},
    {key: "EyeLower0", indices: [0, 1, 2, 3, 4, 5, 6, 7, 8]},
    {key: "EyeLower1", indices: [16, 17, 18, 19, 20, 21, 22, 23, 24]},
    {key: "EyeLower2", indices: [32, 33, 34, 35, 36, 37, 38, 39, 40]},
    {key: "EyeLower3", indices: [54, 55, 56, 57, 58, 59, 60, 61, 62]},
    {key: "EyebrowUpper", indices: [63, 64, 65, 66, 67, 68, 69, 70]},
    {key: "EyebrowLower", indices: [48, 49, 50, 51, 52, 53]}
  ];
  const UV468 = [
    [0.499976992607117, 0.652534008026123],
    [0.500025987625122, 0.547487020492554],
    [0.499974012374878, 0.602371990680695],
    [0.482113003730774, 0.471979022026062],
    [0.500150978565216, 0.527155995368958],
    [0.499909996986389, 0.498252987861633],
    [0.499523013830185, 0.40106201171875],
    [0.289712011814117, 0.380764007568359],
    [0.499954998493195, 0.312398016452789],
    [0.499987006187439, 0.269918978214264],
    [0.500023007392883, 0.107050001621246],
    [0.500023007392883, 0.666234016418457],
    [0.5000159740448, 0.679224014282227],
    [0.500023007392883, 0.692348003387451],
    [0.499976992607117, 0.695277988910675],
    [0.499976992607117, 0.70593398809433],
    [0.499976992607117, 0.719385027885437],
    [0.499976992607117, 0.737019002437592],
    [0.499967992305756, 0.781370997428894],
    [0.499816000461578, 0.562981009483337],
    [0.473773002624512, 0.573909997940063],
    [0.104906998574734, 0.254140973091125],
    [0.365929991006851, 0.409575998783112],
    [0.338757991790771, 0.41302502155304],
    [0.311120003461838, 0.409460008144379],
    [0.274657994508743, 0.389131009578705],
    [0.393361985683441, 0.403706014156342],
    [0.345234006643295, 0.344011008739471],
    [0.370094001293182, 0.346076011657715],
    [0.319321990013123, 0.347265005111694],
    [0.297903001308441, 0.353591024875641],
    [0.24779200553894, 0.410809993743896],
    [0.396889001131058, 0.842755019664764],
    [0.280097991228104, 0.375599980354309],
    [0.106310002505779, 0.399955987930298],
    [0.2099249958992, 0.391353011131287],
    [0.355807989835739, 0.534406006336212],
    [0.471751004457474, 0.65040397644043],
    [0.474155008792877, 0.680191993713379],
    [0.439785003662109, 0.657229006290436],
    [0.414617002010345, 0.66654098033905],
    [0.450374007225037, 0.680860996246338],
    [0.428770989179611, 0.682690978050232],
    [0.374971002340317, 0.727805018424988],
    [0.486716985702515, 0.547628998756409],
    [0.485300987958908, 0.527395009994507],
    [0.257764995098114, 0.314490020275116],
    [0.401223003864288, 0.455172002315521],
    [0.429818987846375, 0.548614978790283],
    [0.421351999044418, 0.533740997314453],
    [0.276895999908447, 0.532056987285614],
    [0.483370006084442, 0.499586999416351],
    [0.33721199631691, 0.282882988452911],
    [0.296391993761063, 0.293242990970612],
    [0.169294998049736, 0.193813979625702],
    [0.447580009698868, 0.302609980106354],
    [0.392390012741089, 0.353887975215912],
    [0.354490011930466, 0.696784019470215],
    [0.067304998636246, 0.730105042457581],
    [0.442739009857178, 0.572826027870178],
    [0.457098007202148, 0.584792017936707],
    [0.381974011659622, 0.694710969924927],
    [0.392388999462128, 0.694203019142151],
    [0.277076005935669, 0.271932005882263],
    [0.422551989555359, 0.563233017921448],
    [0.385919004678726, 0.281364023685455],
    [0.383103013038635, 0.255840003490448],
    [0.331431001424789, 0.119714021682739],
    [0.229923993349075, 0.232002973556519],
    [0.364500999450684, 0.189113974571228],
    [0.229622006416321, 0.299540996551514],
    [0.173287004232407, 0.278747975826263],
    [0.472878992557526, 0.666198015213013],
    [0.446828007698059, 0.668527007102966],
    [0.422762006521225, 0.673889994621277],
    [0.445307999849319, 0.580065965652466],
    [0.388103008270264, 0.693961024284363],
    [0.403039008378983, 0.706539988517761],
    [0.403629004955292, 0.693953037261963],
    [0.460041999816895, 0.557139039039612],
    [0.431158006191254, 0.692366003990173],
    [0.452181994915009, 0.692366003990173],
    [0.475387006998062, 0.692366003990173],
    [0.465828001499176, 0.779190003871918],
    [0.472328990697861, 0.736225962638855],
    [0.473087012767792, 0.717857003211975],
    [0.473122000694275, 0.704625964164734],
    [0.473033010959625, 0.695277988910675],
    [0.427942007780075, 0.695277988910675],
    [0.426479011774063, 0.703539967536926],
    [0.423162013292313, 0.711845993995667],
    [0.4183090031147, 0.720062971115112],
    [0.390094995498657, 0.639572978019714],
    [0.013953999616206, 0.560034036636353],
    [0.499913990497589, 0.58014702796936],
    [0.413199990987778, 0.69539999961853],
    [0.409626007080078, 0.701822996139526],
    [0.468080013990402, 0.601534962654114],
    [0.422728985548019, 0.585985004901886],
    [0.463079988956451, 0.593783974647522],
    [0.37211999297142, 0.47341400384903],
    [0.334562003612518, 0.496073007583618],
    [0.411671012639999, 0.546965003013611],
    [0.242175996303558, 0.14767599105835],
    [0.290776997804642, 0.201445996761322],
    [0.327338010072708, 0.256527006626129],
    [0.399509996175766, 0.748921036720276],
    [0.441727995872498, 0.261676013469696],
    [0.429764986038208, 0.187834024429321],
    [0.412198007106781, 0.108901023864746],
    [0.288955003023148, 0.398952007293701],
    [0.218936994671822, 0.435410976409912],
    [0.41278201341629, 0.398970007896423],
    [0.257135003805161, 0.355440020561218],
    [0.427684992551804, 0.437960982322693],
    [0.448339998722076, 0.536936044692993],
    [0.178560003638268, 0.45755398273468],
    [0.247308000922203, 0.457193970680237],
    [0.286267012357712, 0.467674970626831],
    [0.332827985286713, 0.460712015628815],
    [0.368755996227264, 0.447206974029541],
    [0.398963987827301, 0.432654976844788],
    [0.476410001516342, 0.405806005001068],
    [0.189241006970406, 0.523923993110657],
    [0.228962004184723, 0.348950982093811],
    [0.490725994110107, 0.562400996685028],
    [0.404670000076294, 0.485132992267609],
    [0.019469000399113, 0.401564002037048],
    [0.426243007183075, 0.420431017875671],
    [0.396993011236191, 0.548797011375427],
    [0.266469985246658, 0.376977026462555],
    [0.439121007919312, 0.51895797252655],
    [0.032313998788595, 0.644356966018677],
    [0.419054001569748, 0.387154996395111],
    [0.462783008813858, 0.505746960639954],
    [0.238978996872902, 0.779744982719421],
    [0.198220998048782, 0.831938028335571],
    [0.107550002634525, 0.540755033493042],
    [0.183610007166862, 0.740257024765015],
    [0.134409993886948, 0.333683013916016],
    [0.385764002799988, 0.883153975009918],
    [0.490967005491257, 0.579378008842468],
    [0.382384985685349, 0.508572995662689],
    [0.174399003386497, 0.397670984268188],
    [0.318785011768341, 0.39623498916626],
    [0.343364000320435, 0.400596976280212],
    [0.396100014448166, 0.710216999053955],
    [0.187885001301765, 0.588537991046906],
    [0.430987000465393, 0.944064974784851],
    [0.318993002176285, 0.898285031318665],
    [0.266247987747192, 0.869701027870178],
    [0.500023007392883, 0.190576016902924],
    [0.499976992607117, 0.954452991485596],
    [0.366169989109039, 0.398822009563446],
    [0.393207013607025, 0.39553701877594],
    [0.410373002290726, 0.391080021858215],
    [0.194993004202843, 0.342101991176605],
    [0.388664990663528, 0.362284004688263],
    [0.365961998701096, 0.355970978736877],
    [0.343364000320435, 0.355356991291046],
    [0.318785011768341, 0.35834002494812],
    [0.301414996385574, 0.363156020641327],
    [0.058132998645306, 0.319076001644135],
    [0.301414996385574, 0.387449026107788],
    [0.499987989664078, 0.618434011936188],
    [0.415838003158569, 0.624195992946625],
    [0.445681989192963, 0.566076993942261],
    [0.465844005346298, 0.620640993118286],
    [0.49992299079895, 0.351523995399475],
    [0.288718998432159, 0.819945991039276],
    [0.335278987884521, 0.852819979190826],
    [0.440512001514435, 0.902418971061707],
    [0.128294005990028, 0.791940987110138],
    [0.408771991729736, 0.373893976211548],
    [0.455606997013092, 0.451801002025604],
    [0.499877005815506, 0.908990025520325],
    [0.375436991453171, 0.924192011356354],
    [0.11421000212431, 0.615022003650665],
    [0.448662012815475, 0.695277988910675],
    [0.4480200111866, 0.704632043838501],
    [0.447111994028091, 0.715808033943176],
    [0.444831997156143, 0.730794012546539],
    [0.430011987686157, 0.766808986663818],
    [0.406787008047104, 0.685672998428345],
    [0.400738000869751, 0.681069016456604],
    [0.392399996519089, 0.677703022956848],
    [0.367855995893478, 0.663918972015381],
    [0.247923001646996, 0.601333022117615],
    [0.452769994735718, 0.420849978923798],
    [0.43639200925827, 0.359887003898621],
    [0.416164010763168, 0.368713974952698],
    [0.413385987281799, 0.692366003990173],
    [0.228018000721931, 0.683571994304657],
    [0.468268007040024, 0.352671027183533],
    [0.411361992359161, 0.804327011108398],
    [0.499989002943039, 0.469825029373169],
    [0.479153990745544, 0.442654013633728],
    [0.499974012374878, 0.439637005329132],
    [0.432112008333206, 0.493588984012604],
    [0.499886006116867, 0.866917014122009],
    [0.49991300702095, 0.821729004383087],
    [0.456548988819122, 0.819200992584229],
    [0.344549000263214, 0.745438992977142],
    [0.37890899181366, 0.574010014533997],
    [0.374292999505997, 0.780184984207153],
    [0.319687992334366, 0.570737957954407],
    [0.357154995203018, 0.604269981384277],
    [0.295284003019333, 0.621580958366394],
    [0.447750002145767, 0.862477004528046],
    [0.410986006259918, 0.508723020553589],
    [0.31395098567009, 0.775308012962341],
    [0.354128003120422, 0.812552988529205],
    [0.324548006057739, 0.703992962837219],
    [0.189096003770828, 0.646299958229065],
    [0.279776990413666, 0.71465802192688],
    [0.1338230073452, 0.682700991630554],
    [0.336768001317978, 0.644733011722565],
    [0.429883986711502, 0.466521978378296],
    [0.455527991056442, 0.548622965812683],
    [0.437114000320435, 0.558896005153656],
    [0.467287987470627, 0.529924988746643],
    [0.414712011814117, 0.335219979286194],
    [0.37704598903656, 0.322777986526489],
    [0.344107985496521, 0.320150971412659],
    [0.312875986099243, 0.32233202457428],
    [0.283526003360748, 0.333190023899078],
    [0.241245999932289, 0.382785975933075],
    [0.102986000478268, 0.468762993812561],
    [0.267612010240555, 0.424560010433197],
    [0.297879010438919, 0.433175981044769],
    [0.333433985710144, 0.433878004550934],
    [0.366427004337311, 0.426115989685059],
    [0.396012008190155, 0.416696012020111],
    [0.420121014118195, 0.41022801399231],
    [0.007561000064015, 0.480777025222778],
    [0.432949006557465, 0.569517970085144],
    [0.458638995885849, 0.479089021682739],
    [0.473466008901596, 0.545744001865387],
    [0.476087987422943, 0.563830018043518],
    [0.468472003936768, 0.555056989192963],
    [0.433990985155106, 0.582361996173859],
    [0.483518004417419, 0.562983989715576],
    [0.482482999563217, 0.57784903049469],
    [0.42645001411438, 0.389798998832703],
    [0.438998997211456, 0.39649498462677],
    [0.450067013502121, 0.400434017181396],
    [0.289712011814117, 0.368252992630005],
    [0.276670008897781, 0.363372981548309],
    [0.517862021923065, 0.471948027610779],
    [0.710287988185883, 0.380764007568359],
    [0.526226997375488, 0.573909997940063],
    [0.895093023777008, 0.254140973091125],
    [0.634069979190826, 0.409575998783112],
    [0.661242008209229, 0.41302502155304],
    [0.688880026340485, 0.409460008144379],
    [0.725341975688934, 0.389131009578705],
    [0.606630027294159, 0.40370500087738],
    [0.654766023159027, 0.344011008739471],
    [0.629905998706818, 0.346076011657715],
    [0.680678009986877, 0.347265005111694],
    [0.702096998691559, 0.353591024875641],
    [0.75221198797226, 0.410804986953735],
    [0.602918028831482, 0.842862963676453],
    [0.719901978969574, 0.375599980354309],
    [0.893692970275879, 0.399959981441498],
    [0.790081977844238, 0.391354024410248],
    [0.643998026847839, 0.534487962722778],
    [0.528249025344849, 0.65040397644043],
    [0.525849997997284, 0.680191040039062],
    [0.560214996337891, 0.657229006290436],
    [0.585384011268616, 0.66654098033905],
    [0.549625992774963, 0.680860996246338],
    [0.57122802734375, 0.682691991329193],
    [0.624852001667023, 0.72809898853302],
    [0.513050019741058, 0.547281980514526],
    [0.51509702205658, 0.527251958847046],
    [0.742246985435486, 0.314507007598877],
    [0.598631024360657, 0.454979002475739],
    [0.570338010787964, 0.548575043678284],
    [0.578631997108459, 0.533622980117798],
    [0.723087012767792, 0.532054007053375],
    [0.516445994377136, 0.499638974666595],
    [0.662801027297974, 0.282917976379395],
    [0.70362401008606, 0.293271005153656],
    [0.830704987049103, 0.193813979625702],
    [0.552385985851288, 0.302568018436432],
    [0.607609987258911, 0.353887975215912],
    [0.645429015159607, 0.696707010269165],
    [0.932694971561432, 0.730105042457581],
    [0.557260990142822, 0.572826027870178],
    [0.542901992797852, 0.584792017936707],
    [0.6180260181427, 0.694710969924927],
    [0.607590973377228, 0.694203019142151],
    [0.722943007946014, 0.271963000297546],
    [0.577413976192474, 0.563166975975037],
    [0.614082992076874, 0.281386971473694],
    [0.616907000541687, 0.255886018276215],
    [0.668509006500244, 0.119913995265961],
    [0.770092010498047, 0.232020974159241],
    [0.635536015033722, 0.189248979091644],
    [0.77039098739624, 0.299556016921997],
    [0.826722025871277, 0.278755009174347],
    [0.527121007442474, 0.666198015213013],
    [0.553171992301941, 0.668527007102966],
    [0.577238023281097, 0.673889994621277],
    [0.554691970348358, 0.580065965652466],
    [0.611896991729736, 0.693961024284363],
    [0.59696102142334, 0.706539988517761],
    [0.596370995044708, 0.693953037261963],
    [0.539958000183105, 0.557139039039612],
    [0.568841993808746, 0.692366003990173],
    [0.547818005084991, 0.692366003990173],
    [0.52461302280426, 0.692366003990173],
    [0.534089982509613, 0.779141008853912],
    [0.527670979499817, 0.736225962638855],
    [0.526912987232208, 0.717857003211975],
    [0.526877999305725, 0.704625964164734],
    [0.526966989040375, 0.695277988910675],
    [0.572058022022247, 0.695277988910675],
    [0.573521018028259, 0.703539967536926],
    [0.57683801651001, 0.711845993995667],
    [0.581691026687622, 0.720062971115112],
    [0.609944999217987, 0.639909982681274],
    [0.986046016216278, 0.560034036636353],
    [0.5867999792099, 0.69539999961853],
    [0.590372025966644, 0.701822996139526],
    [0.531915009021759, 0.601536989212036],
    [0.577268004417419, 0.585934996604919],
    [0.536915004253387, 0.593786001205444],
    [0.627542972564697, 0.473352015018463],
    [0.665585994720459, 0.495950996875763],
    [0.588353991508484, 0.546862006187439],
    [0.757824003696442, 0.14767599105835],
    [0.709249973297119, 0.201507985591888],
    [0.672684013843536, 0.256581008434296],
    [0.600408971309662, 0.74900496006012],
    [0.55826598405838, 0.261672019958496],
    [0.570303976535797, 0.187870979309082],
    [0.588165998458862, 0.109044015407562],
    [0.711045026779175, 0.398952007293701],
    [0.781069993972778, 0.435405015945435],
    [0.587247014045715, 0.398931980133057],
    [0.742869973182678, 0.355445981025696],
    [0.572156012058258, 0.437651991844177],
    [0.55186802148819, 0.536570012569427],
    [0.821442008018494, 0.457556009292603],
    [0.752701997756958, 0.457181990146637],
    [0.71375697851181, 0.467626988887787],
    [0.66711300611496, 0.460672974586487],
    [0.631101012229919, 0.447153985500336],
    [0.6008620262146, 0.432473003864288],
    [0.523481011390686, 0.405627012252808],
    [0.810747981071472, 0.523926019668579],
    [0.771045982837677, 0.348959028720856],
    [0.509127020835876, 0.562718033790588],
    [0.595292985439301, 0.485023975372314],
    [0.980530977249146, 0.401564002037048],
    [0.573499977588654, 0.420000016689301],
    [0.602994978427887, 0.548687994480133],
    [0.733529984951019, 0.376977026462555],
    [0.560611009597778, 0.519016981124878],
    [0.967685997486115, 0.644356966018677],
    [0.580985009670258, 0.387160003185272],
    [0.537728011608124, 0.505385041236877],
    [0.760966002941132, 0.779752969741821],
    [0.801778972148895, 0.831938028335571],
    [0.892440974712372, 0.54076099395752],
    [0.816350996494293, 0.740260004997253],
    [0.865594983100891, 0.333687007427216],
    [0.614073991775513, 0.883246004581451],
    [0.508952975273132, 0.579437971115112],
    [0.617941975593567, 0.508316040039062],
    [0.825608015060425, 0.397674977779388],
    [0.681214988231659, 0.39623498916626],
    [0.656635999679565, 0.400596976280212],
    [0.603900015354156, 0.710216999053955],
    [0.81208598613739, 0.588539004325867],
    [0.56801301240921, 0.944564998149872],
    [0.681007981300354, 0.898285031318665],
    [0.733752012252808, 0.869701027870178],
    [0.633830010890961, 0.398822009563446],
    [0.606792986392975, 0.39553701877594],
    [0.589659988880157, 0.391062021255493],
    [0.805015981197357, 0.342108011245728],
    [0.611334979534149, 0.362284004688263],
    [0.634037971496582, 0.355970978736877],
    [0.656635999679565, 0.355356991291046],
    [0.681214988231659, 0.35834002494812],
    [0.698584973812103, 0.363156020641327],
    [0.941866993904114, 0.319076001644135],
    [0.698584973812103, 0.387449026107788],
    [0.584177017211914, 0.624107003211975],
    [0.554318010807037, 0.566076993942261],
    [0.534153997898102, 0.62064003944397],
    [0.711217999458313, 0.819975018501282],
    [0.664629995822906, 0.852871000766754],
    [0.559099972248077, 0.902631998062134],
    [0.871706008911133, 0.791940987110138],
    [0.591234028339386, 0.373893976211548],
    [0.544341027736664, 0.451583981513977],
    [0.624562978744507, 0.924192011356354],
    [0.88577002286911, 0.615028977394104],
    [0.551338016986847, 0.695277988910675],
    [0.551980018615723, 0.704632043838501],
    [0.552887976169586, 0.715808033943176],
    [0.555167973041534, 0.730794012546539],
    [0.569944024085999, 0.767035007476807],
    [0.593203008174896, 0.685675978660583],
    [0.599261999130249, 0.681069016456604],
    [0.607599973678589, 0.677703022956848],
    [0.631937980651855, 0.663500010967255],
    [0.752032995223999, 0.601315021514893],
    [0.547226011753082, 0.420395016670227],
    [0.563543975353241, 0.359827995300293],
    [0.583841025829315, 0.368713974952698],
    [0.586614012718201, 0.692366003990173],
    [0.771915018558502, 0.683578014373779],
    [0.531597018241882, 0.352482974529266],
    [0.588370978832245, 0.804440975189209],
    [0.52079701423645, 0.442565023899078],
    [0.567984998226166, 0.493479013442993],
    [0.543282985687256, 0.819254994392395],
    [0.655317008495331, 0.745514988899231],
    [0.621008992195129, 0.574018001556396],
    [0.625559985637665, 0.78031200170517],
    [0.680198013782501, 0.570719003677368],
    [0.64276397228241, 0.604337990283966],
    [0.704662978649139, 0.621529996395111],
    [0.552012026309967, 0.862591981887817],
    [0.589071989059448, 0.508637011051178],
    [0.685944974422455, 0.775357007980347],
    [0.645735025405884, 0.812640011310577],
    [0.675342977046967, 0.703978002071381],
    [0.810858011245728, 0.646304965019226],
    [0.72012197971344, 0.714666962623596],
    [0.866151988506317, 0.682704985141754],
    [0.663187026977539, 0.644596993923187],
    [0.570082008838654, 0.466325998306274],
    [0.544561982154846, 0.548375964164734],
    [0.562758982181549, 0.558784961700439],
    [0.531987011432648, 0.530140042304993],
    [0.585271000862122, 0.335177004337311],
    [0.622952997684479, 0.32277899980545],
    [0.655896008014679, 0.320163011550903],
    [0.687132000923157, 0.322345972061157],
    [0.716481983661652, 0.333200991153717],
    [0.758756995201111, 0.382786989212036],
    [0.897013008594513, 0.468769013881683],
    [0.732392013072968, 0.424547016620636],
    [0.70211398601532, 0.433162987232208],
    [0.66652500629425, 0.433866024017334],
    [0.633504986763, 0.426087975502014],
    [0.603875994682312, 0.416586995124817],
    [0.579657971858978, 0.409945011138916],
    [0.992439985275269, 0.480777025222778],
    [0.567192018032074, 0.569419980049133],
    [0.54136598110199, 0.478899002075195],
    [0.526564002037048, 0.546118021011353],
    [0.523913025856018, 0.563830018043518],
    [0.531529009342194, 0.555056989192963],
    [0.566035985946655, 0.582329034805298],
    [0.51631098985672, 0.563053965568542],
    [0.5174720287323, 0.577877044677734],
    [0.573594987392426, 0.389806985855103],
    [0.560697972774506, 0.395331978797913],
    [0.549755990505219, 0.399751007556915],
    [0.710287988185883, 0.368252992630005],
    [0.723330020904541, 0.363372981548309]
  ];
  const TRI468 = [
    127,
    34,
    139,
    11,
    0,
    37,
    232,
    231,
    120,
    72,
    37,
    39,
    128,
    121,
    47,
    232,
    121,
    128,
    104,
    69,
    67,
    175,
    171,
    148,
    157,
    154,
    155,
    118,
    50,
    101,
    73,
    39,
    40,
    9,
    151,
    108,
    48,
    115,
    131,
    194,
    204,
    211,
    74,
    40,
    185,
    80,
    42,
    183,
    40,
    92,
    186,
    230,
    229,
    118,
    202,
    212,
    214,
    83,
    18,
    17,
    76,
    61,
    146,
    160,
    29,
    30,
    56,
    157,
    173,
    106,
    204,
    194,
    135,
    214,
    192,
    203,
    165,
    98,
    21,
    71,
    68,
    51,
    45,
    4,
    144,
    24,
    23,
    77,
    146,
    91,
    205,
    50,
    187,
    201,
    200,
    18,
    91,
    106,
    182,
    90,
    91,
    181,
    85,
    84,
    17,
    206,
    203,
    36,
    148,
    171,
    140,
    92,
    40,
    39,
    193,
    189,
    244,
    159,
    158,
    28,
    247,
    246,
    161,
    236,
    3,
    196,
    54,
    68,
    104,
    193,
    168,
    8,
    117,
    228,
    31,
    189,
    193,
    55,
    98,
    97,
    99,
    126,
    47,
    100,
    166,
    79,
    218,
    155,
    154,
    26,
    209,
    49,
    131,
    135,
    136,
    150,
    47,
    126,
    217,
    223,
    52,
    53,
    45,
    51,
    134,
    211,
    170,
    140,
    67,
    69,
    108,
    43,
    106,
    91,
    230,
    119,
    120,
    226,
    130,
    247,
    63,
    53,
    52,
    238,
    20,
    242,
    46,
    70,
    156,
    78,
    62,
    96,
    46,
    53,
    63,
    143,
    34,
    227,
    173,
    155,
    133,
    123,
    117,
    111,
    44,
    125,
    19,
    236,
    134,
    51,
    216,
    206,
    205,
    154,
    153,
    22,
    39,
    37,
    167,
    200,
    201,
    208,
    36,
    142,
    100,
    57,
    212,
    202,
    20,
    60,
    99,
    28,
    158,
    157,
    35,
    226,
    113,
    160,
    159,
    27,
    204,
    202,
    210,
    113,
    225,
    46,
    43,
    202,
    204,
    62,
    76,
    77,
    137,
    123,
    116,
    41,
    38,
    72,
    203,
    129,
    142,
    64,
    98,
    240,
    49,
    102,
    64,
    41,
    73,
    74,
    212,
    216,
    207,
    42,
    74,
    184,
    169,
    170,
    211,
    170,
    149,
    176,
    105,
    66,
    69,
    122,
    6,
    168,
    123,
    147,
    187,
    96,
    77,
    90,
    65,
    55,
    107,
    89,
    90,
    180,
    101,
    100,
    120,
    63,
    105,
    104,
    93,
    137,
    227,
    15,
    86,
    85,
    129,
    102,
    49,
    14,
    87,
    86,
    55,
    8,
    9,
    100,
    47,
    121,
    145,
    23,
    22,
    88,
    89,
    179,
    6,
    122,
    196,
    88,
    95,
    96,
    138,
    172,
    136,
    215,
    58,
    172,
    115,
    48,
    219,
    42,
    80,
    81,
    195,
    3,
    51,
    43,
    146,
    61,
    171,
    175,
    199,
    81,
    82,
    38,
    53,
    46,
    225,
    144,
    163,
    110,
    246,
    33,
    7,
    52,
    65,
    66,
    229,
    228,
    117,
    34,
    127,
    234,
    107,
    108,
    69,
    109,
    108,
    151,
    48,
    64,
    235,
    62,
    78,
    191,
    129,
    209,
    126,
    111,
    35,
    143,
    163,
    161,
    246,
    117,
    123,
    50,
    222,
    65,
    52,
    19,
    125,
    141,
    221,
    55,
    65,
    3,
    195,
    197,
    25,
    7,
    33,
    220,
    237,
    44,
    70,
    71,
    139,
    122,
    193,
    245,
    247,
    130,
    33,
    71,
    21,
    162,
    153,
    158,
    159,
    170,
    169,
    150,
    188,
    174,
    196,
    216,
    186,
    92,
    144,
    160,
    161,
    2,
    97,
    167,
    141,
    125,
    241,
    164,
    167,
    37,
    72,
    38,
    12,
    145,
    159,
    160,
    38,
    82,
    13,
    63,
    68,
    71,
    226,
    35,
    111,
    158,
    153,
    154,
    101,
    50,
    205,
    206,
    92,
    165,
    209,
    198,
    217,
    165,
    167,
    97,
    220,
    115,
    218,
    133,
    112,
    243,
    239,
    238,
    241,
    214,
    135,
    169,
    190,
    173,
    133,
    171,
    208,
    32,
    125,
    44,
    237,
    86,
    87,
    178,
    85,
    86,
    179,
    84,
    85,
    180,
    83,
    84,
    181,
    201,
    83,
    182,
    137,
    93,
    132,
    76,
    62,
    183,
    61,
    76,
    184,
    57,
    61,
    185,
    212,
    57,
    186,
    214,
    207,
    187,
    34,
    143,
    156,
    79,
    239,
    237,
    123,
    137,
    177,
    44,
    1,
    4,
    201,
    194,
    32,
    64,
    102,
    129,
    213,
    215,
    138,
    59,
    166,
    219,
    242,
    99,
    97,
    2,
    94,
    141,
    75,
    59,
    235,
    24,
    110,
    228,
    25,
    130,
    226,
    23,
    24,
    229,
    22,
    23,
    230,
    26,
    22,
    231,
    112,
    26,
    232,
    189,
    190,
    243,
    221,
    56,
    190,
    28,
    56,
    221,
    27,
    28,
    222,
    29,
    27,
    223,
    30,
    29,
    224,
    247,
    30,
    225,
    238,
    79,
    20,
    166,
    59,
    75,
    60,
    75,
    240,
    147,
    177,
    215,
    20,
    79,
    166,
    187,
    147,
    213,
    112,
    233,
    244,
    233,
    128,
    245,
    128,
    114,
    188,
    114,
    217,
    174,
    131,
    115,
    220,
    217,
    198,
    236,
    198,
    131,
    134,
    177,
    132,
    58,
    143,
    35,
    124,
    110,
    163,
    7,
    228,
    110,
    25,
    356,
    389,
    368,
    11,
    302,
    267,
    452,
    350,
    349,
    302,
    303,
    269,
    357,
    343,
    277,
    452,
    453,
    357,
    333,
    332,
    297,
    175,
    152,
    377,
    384,
    398,
    382,
    347,
    348,
    330,
    303,
    304,
    270,
    9,
    336,
    337,
    278,
    279,
    360,
    418,
    262,
    431,
    304,
    408,
    409,
    310,
    415,
    407,
    270,
    409,
    410,
    450,
    348,
    347,
    422,
    430,
    434,
    313,
    314,
    17,
    306,
    307,
    375,
    387,
    388,
    260,
    286,
    414,
    398,
    335,
    406,
    418,
    364,
    367,
    416,
    423,
    358,
    327,
    251,
    284,
    298,
    281,
    5,
    4,
    373,
    374,
    253,
    307,
    320,
    321,
    425,
    427,
    411,
    421,
    313,
    18,
    321,
    405,
    406,
    320,
    404,
    405,
    315,
    16,
    17,
    426,
    425,
    266,
    377,
    400,
    369,
    322,
    391,
    269,
    417,
    465,
    464,
    386,
    257,
    258,
    466,
    260,
    388,
    456,
    399,
    419,
    284,
    332,
    333,
    417,
    285,
    8,
    346,
    340,
    261,
    413,
    441,
    285,
    327,
    460,
    328,
    355,
    371,
    329,
    392,
    439,
    438,
    382,
    341,
    256,
    429,
    420,
    360,
    364,
    394,
    379,
    277,
    343,
    437,
    443,
    444,
    283,
    275,
    440,
    363,
    431,
    262,
    369,
    297,
    338,
    337,
    273,
    375,
    321,
    450,
    451,
    349,
    446,
    342,
    467,
    293,
    334,
    282,
    458,
    461,
    462,
    276,
    353,
    383,
    308,
    324,
    325,
    276,
    300,
    293,
    372,
    345,
    447,
    382,
    398,
    362,
    352,
    345,
    340,
    274,
    1,
    19,
    456,
    248,
    281,
    436,
    427,
    425,
    381,
    256,
    252,
    269,
    391,
    393,
    200,
    199,
    428,
    266,
    330,
    329,
    287,
    273,
    422,
    250,
    462,
    328,
    258,
    286,
    384,
    265,
    353,
    342,
    387,
    259,
    257,
    424,
    431,
    430,
    342,
    353,
    276,
    273,
    335,
    424,
    292,
    325,
    307,
    366,
    447,
    345,
    271,
    303,
    302,
    423,
    266,
    371,
    294,
    455,
    460,
    279,
    278,
    294,
    271,
    272,
    304,
    432,
    434,
    427,
    272,
    407,
    408,
    394,
    430,
    431,
    395,
    369,
    400,
    334,
    333,
    299,
    351,
    417,
    168,
    352,
    280,
    411,
    325,
    319,
    320,
    295,
    296,
    336,
    319,
    403,
    404,
    330,
    348,
    349,
    293,
    298,
    333,
    323,
    454,
    447,
    15,
    16,
    315,
    358,
    429,
    279,
    14,
    15,
    316,
    285,
    336,
    9,
    329,
    349,
    350,
    374,
    380,
    252,
    318,
    402,
    403,
    6,
    197,
    419,
    318,
    319,
    325,
    367,
    364,
    365,
    435,
    367,
    397,
    344,
    438,
    439,
    272,
    271,
    311,
    195,
    5,
    281,
    273,
    287,
    291,
    396,
    428,
    199,
    311,
    271,
    268,
    283,
    444,
    445,
    373,
    254,
    339,
    263,
    466,
    249,
    282,
    334,
    296,
    449,
    347,
    346,
    264,
    447,
    454,
    336,
    296,
    299,
    338,
    10,
    151,
    278,
    439,
    455,
    292,
    407,
    415,
    358,
    371,
    355,
    340,
    345,
    372,
    390,
    249,
    466,
    346,
    347,
    280,
    442,
    443,
    282,
    19,
    94,
    370,
    441,
    442,
    295,
    248,
    419,
    197,
    263,
    255,
    359,
    440,
    275,
    274,
    300,
    383,
    368,
    351,
    412,
    465,
    263,
    467,
    466,
    301,
    368,
    389,
    380,
    374,
    386,
    395,
    378,
    379,
    412,
    351,
    419,
    436,
    426,
    322,
    373,
    390,
    388,
    2,
    164,
    393,
    370,
    462,
    461,
    164,
    0,
    267,
    302,
    11,
    12,
    374,
    373,
    387,
    268,
    12,
    13,
    293,
    300,
    301,
    446,
    261,
    340,
    385,
    384,
    381,
    330,
    266,
    425,
    426,
    423,
    391,
    429,
    355,
    437,
    391,
    327,
    326,
    440,
    457,
    438,
    341,
    382,
    362,
    459,
    457,
    461,
    434,
    430,
    394,
    414,
    463,
    362,
    396,
    369,
    262,
    354,
    461,
    457,
    316,
    403,
    402,
    315,
    404,
    403,
    314,
    405,
    404,
    313,
    406,
    405,
    421,
    418,
    406,
    366,
    401,
    361,
    306,
    408,
    407,
    291,
    409,
    408,
    287,
    410,
    409,
    432,
    436,
    410,
    434,
    416,
    411,
    264,
    368,
    383,
    309,
    438,
    457,
    352,
    376,
    401,
    274,
    275,
    4,
    421,
    428,
    262,
    294,
    327,
    358,
    433,
    416,
    367,
    289,
    455,
    439,
    462,
    370,
    326,
    2,
    326,
    370,
    305,
    460,
    455,
    254,
    449,
    448,
    255,
    261,
    446,
    253,
    450,
    449,
    252,
    451,
    450,
    256,
    452,
    451,
    341,
    453,
    452,
    413,
    464,
    463,
    441,
    413,
    414,
    258,
    442,
    441,
    257,
    443,
    442,
    259,
    444,
    443,
    260,
    445,
    444,
    467,
    342,
    445,
    459,
    458,
    250,
    289,
    392,
    290,
    290,
    328,
    460,
    376,
    433,
    435,
    250,
    290,
    392,
    411,
    416,
    433,
    341,
    463,
    464,
    453,
    464,
    465,
    357,
    465,
    412,
    343,
    412,
    399,
    360,
    363,
    440,
    437,
    399,
    456,
    420,
    456,
    363,
    401,
    435,
    288,
    372,
    383,
    353,
    339,
    255,
    249,
    448,
    261,
    255,
    133,
    243,
    190,
    133,
    155,
    112,
    33,
    246,
    247,
    33,
    130,
    25,
    398,
    384,
    286,
    362,
    398,
    414,
    362,
    463,
    341,
    263,
    359,
    467,
    263,
    249,
    255,
    466,
    467,
    260,
    75,
    60,
    166,
    238,
    239,
    79,
    162,
    127,
    139,
    72,
    11,
    37,
    121,
    232,
    120,
    73,
    72,
    39,
    114,
    128,
    47,
    233,
    232,
    128,
    103,
    104,
    67,
    152,
    175,
    148,
    173,
    157,
    155,
    119,
    118,
    101,
    74,
    73,
    40,
    107,
    9,
    108,
    49,
    48,
    131,
    32,
    194,
    211,
    184,
    74,
    185,
    191,
    80,
    183,
    185,
    40,
    186,
    119,
    230,
    118,
    210,
    202,
    214,
    84,
    83,
    17,
    77,
    76,
    146,
    161,
    160,
    30,
    190,
    56,
    173,
    182,
    106,
    194,
    138,
    135,
    192,
    129,
    203,
    98,
    54,
    21,
    68,
    5,
    51,
    4,
    145,
    144,
    23,
    90,
    77,
    91,
    207,
    205,
    187,
    83,
    201,
    18,
    181,
    91,
    182,
    180,
    90,
    181,
    16,
    85,
    17,
    205,
    206,
    36,
    176,
    148,
    140,
    165,
    92,
    39,
    245,
    193,
    244,
    27,
    159,
    28,
    30,
    247,
    161,
    174,
    236,
    196,
    103,
    54,
    104,
    55,
    193,
    8,
    111,
    117,
    31,
    221,
    189,
    55,
    240,
    98,
    99,
    142,
    126,
    100,
    219,
    166,
    218,
    112,
    155,
    26,
    198,
    209,
    131,
    169,
    135,
    150,
    114,
    47,
    217,
    224,
    223,
    53,
    220,
    45,
    134,
    32,
    211,
    140,
    109,
    67,
    108,
    146,
    43,
    91,
    231,
    230,
    120,
    113,
    226,
    247,
    105,
    63,
    52,
    241,
    238,
    242,
    124,
    46,
    156,
    95,
    78,
    96,
    70,
    46,
    63,
    116,
    143,
    227,
    116,
    123,
    111,
    1,
    44,
    19,
    3,
    236,
    51,
    207,
    216,
    205,
    26,
    154,
    22,
    165,
    39,
    167,
    199,
    200,
    208,
    101,
    36,
    100,
    43,
    57,
    202,
    242,
    20,
    99,
    56,
    28,
    157,
    124,
    35,
    113,
    29,
    160,
    27,
    211,
    204,
    210,
    124,
    113,
    46,
    106,
    43,
    204,
    96,
    62,
    77,
    227,
    137,
    116,
    73,
    41,
    72,
    36,
    203,
    142,
    235,
    64,
    240,
    48,
    49,
    64,
    42,
    41,
    74,
    214,
    212,
    207,
    183,
    42,
    184,
    210,
    169,
    211,
    140,
    170,
    176,
    104,
    105,
    69,
    193,
    122,
    168,
    50,
    123,
    187,
    89,
    96,
    90,
    66,
    65,
    107,
    179,
    89,
    180,
    119,
    101,
    120,
    68,
    63,
    104,
    234,
    93,
    227,
    16,
    15,
    85,
    209,
    129,
    49,
    15,
    14,
    86,
    107,
    55,
    9,
    120,
    100,
    121,
    153,
    145,
    22,
    178,
    88,
    179,
    197,
    6,
    196,
    89,
    88,
    96,
    135,
    138,
    136,
    138,
    215,
    172,
    218,
    115,
    219,
    41,
    42,
    81,
    5,
    195,
    51,
    57,
    43,
    61,
    208,
    171,
    199,
    41,
    81,
    38,
    224,
    53,
    225,
    24,
    144,
    110,
    105,
    52,
    66,
    118,
    229,
    117,
    227,
    34,
    234,
    66,
    107,
    69,
    10,
    109,
    151,
    219,
    48,
    235,
    183,
    62,
    191,
    142,
    129,
    126,
    116,
    111,
    143,
    7,
    163,
    246,
    118,
    117,
    50,
    223,
    222,
    52,
    94,
    19,
    141,
    222,
    221,
    65,
    196,
    3,
    197,
    45,
    220,
    44,
    156,
    70,
    139,
    188,
    122,
    245,
    139,
    71,
    162,
    145,
    153,
    159,
    149,
    170,
    150,
    122,
    188,
    196,
    206,
    216,
    92,
    163,
    144,
    161,
    164,
    2,
    167,
    242,
    141,
    241,
    0,
    164,
    37,
    11,
    72,
    12,
    144,
    145,
    160,
    12,
    38,
    13,
    70,
    63,
    71,
    31,
    226,
    111,
    157,
    158,
    154,
    36,
    101,
    205,
    203,
    206,
    165,
    126,
    209,
    217,
    98,
    165,
    97,
    237,
    220,
    218,
    237,
    239,
    241,
    210,
    214,
    169,
    140,
    171,
    32,
    241,
    125,
    237,
    179,
    86,
    178,
    180,
    85,
    179,
    181,
    84,
    180,
    182,
    83,
    181,
    194,
    201,
    182,
    177,
    137,
    132,
    184,
    76,
    183,
    185,
    61,
    184,
    186,
    57,
    185,
    216,
    212,
    186,
    192,
    214,
    187,
    139,
    34,
    156,
    218,
    79,
    237,
    147,
    123,
    177,
    45,
    44,
    4,
    208,
    201,
    32,
    98,
    64,
    129,
    192,
    213,
    138,
    235,
    59,
    219,
    141,
    242,
    97,
    97,
    2,
    141,
    240,
    75,
    235,
    229,
    24,
    228,
    31,
    25,
    226,
    230,
    23,
    229,
    231,
    22,
    230,
    232,
    26,
    231,
    233,
    112,
    232,
    244,
    189,
    243,
    189,
    221,
    190,
    222,
    28,
    221,
    223,
    27,
    222,
    224,
    29,
    223,
    225,
    30,
    224,
    113,
    247,
    225,
    99,
    60,
    240,
    213,
    147,
    215,
    60,
    20,
    166,
    192,
    187,
    213,
    243,
    112,
    244,
    244,
    233,
    245,
    245,
    128,
    188,
    188,
    114,
    174,
    134,
    131,
    220,
    174,
    217,
    236,
    236,
    198,
    134,
    215,
    177,
    58,
    156,
    143,
    124,
    25,
    110,
    7,
    31,
    228,
    25,
    264,
    356,
    368,
    0,
    11,
    267,
    451,
    452,
    349,
    267,
    302,
    269,
    350,
    357,
    277,
    350,
    452,
    357,
    299,
    333,
    297,
    396,
    175,
    377,
    381,
    384,
    382,
    280,
    347,
    330,
    269,
    303,
    270,
    151,
    9,
    337,
    344,
    278,
    360,
    424,
    418,
    431,
    270,
    304,
    409,
    272,
    310,
    407,
    322,
    270,
    410,
    449,
    450,
    347,
    432,
    422,
    434,
    18,
    313,
    17,
    291,
    306,
    375,
    259,
    387,
    260,
    424,
    335,
    418,
    434,
    364,
    416,
    391,
    423,
    327,
    301,
    251,
    298,
    275,
    281,
    4,
    254,
    373,
    253,
    375,
    307,
    321,
    280,
    425,
    411,
    200,
    421,
    18,
    335,
    321,
    406,
    321,
    320,
    405,
    314,
    315,
    17,
    423,
    426,
    266,
    396,
    377,
    369,
    270,
    322,
    269,
    413,
    417,
    464,
    385,
    386,
    258,
    248,
    456,
    419,
    298,
    284,
    333,
    168,
    417,
    8,
    448,
    346,
    261,
    417,
    413,
    285,
    326,
    327,
    328,
    277,
    355,
    329,
    309,
    392,
    438,
    381,
    382,
    256,
    279,
    429,
    360,
    365,
    364,
    379,
    355,
    277,
    437,
    282,
    443,
    283,
    281,
    275,
    363,
    395,
    431,
    369,
    299,
    297,
    337,
    335,
    273,
    321,
    348,
    450,
    349,
    359,
    446,
    467,
    283,
    293,
    282,
    250,
    458,
    462,
    300,
    276,
    383,
    292,
    308,
    325,
    283,
    276,
    293,
    264,
    372,
    447,
    346,
    352,
    340,
    354,
    274,
    19,
    363,
    456,
    281,
    426,
    436,
    425,
    380,
    381,
    252,
    267,
    269,
    393,
    421,
    200,
    428,
    371,
    266,
    329,
    432,
    287,
    422,
    290,
    250,
    328,
    385,
    258,
    384,
    446,
    265,
    342,
    386,
    387,
    257,
    422,
    424,
    430,
    445,
    342,
    276,
    422,
    273,
    424,
    306,
    292,
    307,
    352,
    366,
    345,
    268,
    271,
    302,
    358,
    423,
    371,
    327,
    294,
    460,
    331,
    279,
    294,
    303,
    271,
    304,
    436,
    432,
    427,
    304,
    272,
    408,
    395,
    394,
    431,
    378,
    395,
    400,
    296,
    334,
    299,
    6,
    351,
    168,
    376,
    352,
    411,
    307,
    325,
    320,
    285,
    295,
    336,
    320,
    319,
    404,
    329,
    330,
    349,
    334,
    293,
    333,
    366,
    323,
    447,
    316,
    15,
    315,
    331,
    358,
    279,
    317,
    14,
    316,
    8,
    285,
    9,
    277,
    329,
    350,
    253,
    374,
    252,
    319,
    318,
    403,
    351,
    6,
    419,
    324,
    318,
    325,
    397,
    367,
    365,
    288,
    435,
    397,
    278,
    344,
    439,
    310,
    272,
    311,
    248,
    195,
    281,
    375,
    273,
    291,
    175,
    396,
    199,
    312,
    311,
    268,
    276,
    283,
    445,
    390,
    373,
    339,
    295,
    282,
    296,
    448,
    449,
    346,
    356,
    264,
    454,
    337,
    336,
    299,
    337,
    338,
    151,
    294,
    278,
    455,
    308,
    292,
    415,
    429,
    358,
    355,
    265,
    340,
    372,
    388,
    390,
    466,
    352,
    346,
    280,
    295,
    442,
    282,
    354,
    19,
    370,
    285,
    441,
    295,
    195,
    248,
    197,
    457,
    440,
    274,
    301,
    300,
    368,
    417,
    351,
    465,
    251,
    301,
    389,
    385,
    380,
    386,
    394,
    395,
    379,
    399,
    412,
    419,
    410,
    436,
    322,
    387,
    373,
    388,
    326,
    2,
    393,
    354,
    370,
    461,
    393,
    164,
    267,
    268,
    302,
    12,
    386,
    374,
    387,
    312,
    268,
    13,
    298,
    293,
    301,
    265,
    446,
    340,
    380,
    385,
    381,
    280,
    330,
    425,
    322,
    426,
    391,
    420,
    429,
    437,
    393,
    391,
    326,
    344,
    440,
    438,
    458,
    459,
    461,
    364,
    434,
    394,
    428,
    396,
    262,
    274,
    354,
    457,
    317,
    316,
    402,
    316,
    315,
    403,
    315,
    314,
    404,
    314,
    313,
    405,
    313,
    421,
    406,
    323,
    366,
    361,
    292,
    306,
    407,
    306,
    291,
    408,
    291,
    287,
    409,
    287,
    432,
    410,
    427,
    434,
    411,
    372,
    264,
    383,
    459,
    309,
    457,
    366,
    352,
    401,
    1,
    274,
    4,
    418,
    421,
    262,
    331,
    294,
    358,
    435,
    433,
    367,
    392,
    289,
    439,
    328,
    462,
    326,
    94,
    2,
    370,
    289,
    305,
    455,
    339,
    254,
    448,
    359,
    255,
    446,
    254,
    253,
    449,
    253,
    252,
    450,
    252,
    256,
    451,
    256,
    341,
    452,
    414,
    413,
    463,
    286,
    441,
    414,
    286,
    258,
    441,
    258,
    257,
    442,
    257,
    259,
    443,
    259,
    260,
    444,
    260,
    467,
    445,
    309,
    459,
    250,
    305,
    289,
    290,
    305,
    290,
    460,
    401,
    376,
    435,
    309,
    250,
    392,
    376,
    411,
    433,
    453,
    341,
    464,
    357,
    453,
    465,
    343,
    357,
    412,
    437,
    343,
    399,
    344,
    360,
    440,
    420,
    437,
    456,
    360,
    420,
    363,
    361,
    401,
    288,
    265,
    372,
    353,
    390,
    339,
    249,
    339,
    448,
    255
  ];
  const TRI68 = [
    0,
    1,
    36,
    0,
    36,
    17,
    1,
    2,
    41,
    1,
    41,
    36,
    2,
    3,
    31,
    2,
    31,
    41,
    3,
    4,
    48,
    3,
    48,
    31,
    4,
    5,
    48,
    5,
    6,
    48,
    6,
    7,
    59,
    6,
    59,
    48,
    7,
    8,
    58,
    7,
    58,
    59,
    8,
    9,
    56,
    8,
    56,
    57,
    8,
    57,
    58,
    9,
    10,
    55,
    9,
    55,
    56,
    10,
    11,
    54,
    10,
    54,
    55,
    11,
    12,
    54,
    12,
    13,
    54,
    13,
    14,
    35,
    13,
    35,
    54,
    14,
    15,
    46,
    14,
    46,
    35,
    15,
    16,
    45,
    15,
    45,
    46,
    16,
    26,
    45,
    17,
    36,
    18,
    18,
    37,
    19,
    18,
    36,
    37,
    19,
    38,
    20,
    19,
    37,
    38,
    20,
    39,
    21,
    20,
    38,
    39,
    21,
    39,
    27,
    22,
    42,
    23,
    22,
    27,
    42,
    23,
    43,
    24,
    23,
    42,
    43,
    24,
    44,
    25,
    24,
    43,
    44,
    25,
    45,
    26,
    25,
    44,
    45,
    27,
    39,
    28,
    27,
    28,
    42,
    28,
    39,
    29,
    28,
    29,
    42,
    29,
    31,
    30,
    29,
    30,
    35,
    29,
    40,
    31,
    29,
    35,
    47,
    29,
    39,
    40,
    29,
    47,
    42,
    30,
    31,
    32,
    30,
    32,
    33,
    30,
    33,
    34,
    30,
    34,
    35,
    31,
    50,
    32,
    31,
    40,
    41,
    31,
    48,
    49,
    31,
    49,
    50,
    32,
    51,
    33,
    32,
    50,
    51,
    33,
    51,
    34,
    34,
    52,
    35,
    34,
    51,
    52,
    35,
    46,
    47,
    35,
    52,
    53,
    35,
    53,
    54,
    36,
    41,
    37,
    37,
    40,
    38,
    37,
    41,
    40,
    38,
    40,
    39,
    42,
    47,
    43,
    43,
    47,
    44,
    44,
    46,
    45,
    44,
    47,
    46,
    48,
    60,
    49,
    48,
    59,
    60,
    49,
    61,
    50,
    49,
    60,
    61,
    50,
    62,
    51,
    50,
    61,
    62,
    51,
    62,
    52,
    52,
    63,
    53,
    52,
    62,
    63,
    53,
    64,
    54,
    53,
    63,
    64,
    54,
    64,
    55,
    55,
    65,
    56,
    55,
    64,
    65,
    56,
    66,
    57,
    56,
    65,
    66,
    57,
    66,
    58,
    58,
    67,
    59,
    58,
    66,
    67,
    59,
    67,
    60,
    60,
    67,
    61,
    61,
    66,
    62,
    61,
    67,
    66,
    62,
    66,
    63,
    63,
    65,
    64,
    63,
    66,
    65,
    21,
    27,
    22
  ];
  const TRI33 = [
    0,
    8,
    7,
    7,
    8,
    1,
    2,
    10,
    9,
    9,
    10,
    3,
    17,
    0,
    18,
    18,
    0,
    7,
    18,
    7,
    19,
    19,
    7,
    1,
    19,
    1,
    11,
    19,
    11,
    20,
    21,
    3,
    22,
    21,
    9,
    3,
    20,
    9,
    21,
    20,
    2,
    9,
    20,
    11,
    2,
    23,
    17,
    18,
    25,
    21,
    22,
    24,
    19,
    20,
    24,
    18,
    19,
    24,
    20,
    21,
    24,
    23,
    18,
    24,
    21,
    25,
    11,
    12,
    4,
    11,
    4,
    13,
    1,
    12,
    11,
    11,
    13,
    2,
    12,
    14,
    4,
    4,
    14,
    13,
    14,
    5,
    15,
    14,
    15,
    6,
    12,
    5,
    14,
    14,
    6,
    13,
    8,
    12,
    1,
    2,
    13,
    10,
    8,
    26,
    12,
    10,
    13,
    27,
    26,
    5,
    12,
    13,
    6,
    27,
    0,
    26,
    8,
    10,
    27,
    3,
    5,
    32,
    16,
    16,
    32,
    6,
    5,
    30,
    32,
    6,
    32,
    31,
    26,
    30,
    5,
    27,
    6,
    31,
    0,
    28,
    26,
    3,
    27,
    29,
    17,
    28,
    0,
    3,
    29,
    22,
    23,
    28,
    17,
    22,
    29,
    25,
    28,
    30,
    26,
    27,
    31,
    29
  ];
  const TRI7 = [0, 4, 1, 2, 4, 3, 4, 5, 6];
  const VTX68 = [
    127,
    234,
    132,
    58,
    172,
    150,
    149,
    148,
    152,
    377,
    378,
    379,
    397,
    288,
    361,
    454,
    356,
    70,
    63,
    105,
    66,
    107,
    336,
    296,
    334,
    293,
    300,
    168,
    6,
    195,
    4,
    98,
    97,
    2,
    326,
    327,
    33,
    160,
    158,
    133,
    153,
    144,
    362,
    385,
    387,
    263,
    373,
    380,
    57,
    40,
    37,
    0,
    267,
    270,
    287,
    321,
    314,
    17,
    84,
    91,
    78,
    81,
    13,
    311,
    308,
    402,
    14,
    178
  ];
  const VTX33 = [33, 133, 362, 263, 1, 62, 308, 159, 145, 386, 374, 6, 102, 331, 2, 13, 14, 70, 105, 107, 336, 334, 300, 54, 10, 284, 50, 280, 234, 454, 58, 288, 152];
  const VTX7 = [33, 133, 362, 263, 1, 78, 308];
  exports.MESH_ANNOTATIONS = MESH_ANNOTATIONS;
  exports.MESH_TO_IRIS_INDICES_MAP = MESH_TO_IRIS_INDICES_MAP;
  exports.TRI468 = TRI468;
  exports.TRI68 = TRI68;
  exports.TRI33 = TRI33;
  exports.TRI7 = TRI7;
  exports.UV468 = UV468;
  exports.UV68 = VTX68.map((x) => UV468[x]);
  exports.UV33 = VTX33.map((x) => UV468[x]);
  exports.UV7 = VTX7.map((x) => UV468[x]);
});
var require_facepipeline = __commonJS((exports) => {
  const bounding = __toModule(require_box());
  const util30 = __toModule(require_util());
  const coords = __toModule(require_coords());
  const LANDMARKS_COUNT = 468;
  const MESH_MOUTH_INDEX = 13;
  const MESH_KEYPOINTS_LINE_OF_SYMMETRY_INDICES = [MESH_MOUTH_INDEX, coords.MESH_ANNOTATIONS["midwayBetweenEyes"][0]];
  const BLAZEFACE_MOUTH_INDEX = 3;
  const BLAZEFACE_NOSE_INDEX = 2;
  const BLAZEFACE_KEYPOINTS_LINE_OF_SYMMETRY_INDICES = [BLAZEFACE_MOUTH_INDEX, BLAZEFACE_NOSE_INDEX];
  const LEFT_EYE_OUTLINE = coords.MESH_ANNOTATIONS["leftEyeLower0"];
  const LEFT_EYE_BOUNDS = [LEFT_EYE_OUTLINE[0], LEFT_EYE_OUTLINE[LEFT_EYE_OUTLINE.length - 1]];
  const RIGHT_EYE_OUTLINE = coords.MESH_ANNOTATIONS["rightEyeLower0"];
  const RIGHT_EYE_BOUNDS = [RIGHT_EYE_OUTLINE[0], RIGHT_EYE_OUTLINE[RIGHT_EYE_OUTLINE.length - 1]];
  const IRIS_UPPER_CENTER_INDEX = 3;
  const IRIS_LOWER_CENTER_INDEX = 4;
  const IRIS_IRIS_INDEX = 71;
  const IRIS_NUM_COORDINATES = 76;
  function replaceRawCoordinates(rawCoords, newCoords, prefix, keys) {
    for (let i = 0; i < coords.MESH_TO_IRIS_INDICES_MAP.length; i++) {
      const {key, indices} = coords.MESH_TO_IRIS_INDICES_MAP[i];
      const originalIndices = coords.MESH_ANNOTATIONS[`${prefix}${key}`];
      const shouldReplaceAllKeys = keys == null;
      if (shouldReplaceAllKeys || keys.includes(key)) {
        for (let j = 0; j < indices.length; j++) {
          const index = indices[j];
          rawCoords[originalIndices[j]] = [
            newCoords[index][0],
            newCoords[index][1],
            (newCoords[index][2] + rawCoords[originalIndices[j]][2]) / 2
          ];
        }
      }
    }
  }
  class Pipeline {
    constructor(boundingBoxDetector, meshDetector, irisModel, config2) {
      this.storedBoxes = [];
      this.runsWithoutFaceDetector = 0;
      this.boundingBoxDetector = boundingBoxDetector;
      this.meshDetector = meshDetector;
      this.irisModel = irisModel;
      this.meshWidth = config2.mesh.inputSize;
      this.meshHeight = config2.mesh.inputSize;
      this.irisSize = config2.iris.inputSize;
      this.irisEnlarge = 2.3;
      this.skipped = 1e3;
      this.detectedFaces = 0;
    }
    transformRawCoords(rawCoords, box, angle, rotationMatrix) {
      const boxSize = bounding.getBoxSize({startPoint: box.startPoint, endPoint: box.endPoint});
      const scaleFactor = [boxSize[0] / this.meshWidth, boxSize[1] / this.meshHeight];
      const coordsScaled = rawCoords.map((coord) => [
        scaleFactor[0] * (coord[0] - this.meshWidth / 2),
        scaleFactor[1] * (coord[1] - this.meshHeight / 2),
        coord[2]
      ]);
      const coordsRotationMatrix = util30.buildRotationMatrix(angle, [0, 0]);
      const coordsRotated = coordsScaled.map((coord) => [...util30.rotatePoint(coord, coordsRotationMatrix), coord[2]]);
      const inverseRotationMatrix = util30.invertTransformMatrix(rotationMatrix);
      const boxCenter = [...bounding.getBoxCenter({startPoint: box.startPoint, endPoint: box.endPoint}), 1];
      const originalBoxCenter = [
        util30.dot(boxCenter, inverseRotationMatrix[0]),
        util30.dot(boxCenter, inverseRotationMatrix[1])
      ];
      return coordsRotated.map((coord) => [
        coord[0] + originalBoxCenter[0],
        coord[1] + originalBoxCenter[1],
        coord[2]
      ]);
    }
    getLeftToRightEyeDepthDifference(rawCoords) {
      const leftEyeZ = rawCoords[LEFT_EYE_BOUNDS[0]][2];
      const rightEyeZ = rawCoords[RIGHT_EYE_BOUNDS[0]][2];
      return leftEyeZ - rightEyeZ;
    }
    getEyeBox(rawCoords, face2, eyeInnerCornerIndex, eyeOuterCornerIndex, flip = false) {
      const box = bounding.squarifyBox(bounding.enlargeBox(this.calculateLandmarksBoundingBox([rawCoords[eyeInnerCornerIndex], rawCoords[eyeOuterCornerIndex]]), this.irisEnlarge));
      const boxSize = bounding.getBoxSize(box);
      let crop = tf.image.cropAndResize(face2, [[
        box.startPoint[1] / this.meshHeight,
        box.startPoint[0] / this.meshWidth,
        box.endPoint[1] / this.meshHeight,
        box.endPoint[0] / this.meshWidth
      ]], [0], [this.irisSize, this.irisSize]);
      if (flip) {
        crop = tf.image.flipLeftRight(crop);
      }
      return {box, boxSize, crop};
    }
    getEyeCoords(eyeData, eyeBox, eyeBoxSize, flip = false) {
      const eyeRawCoords = [];
      for (let i = 0; i < IRIS_NUM_COORDINATES; i++) {
        const x = eyeData[i * 3];
        const y = eyeData[i * 3 + 1];
        const z = eyeData[i * 3 + 2];
        eyeRawCoords.push([
          (flip ? 1 - x / this.irisSize : x / this.irisSize) * eyeBoxSize[0] + eyeBox.startPoint[0],
          y / this.irisSize * eyeBoxSize[1] + eyeBox.startPoint[1],
          z
        ]);
      }
      return {rawCoords: eyeRawCoords, iris: eyeRawCoords.slice(IRIS_IRIS_INDEX)};
    }
    getAdjustedIrisCoords(rawCoords, irisCoords, direction) {
      const upperCenterZ = rawCoords[coords.MESH_ANNOTATIONS[`${direction}EyeUpper0`][IRIS_UPPER_CENTER_INDEX]][2];
      const lowerCenterZ = rawCoords[coords.MESH_ANNOTATIONS[`${direction}EyeLower0`][IRIS_LOWER_CENTER_INDEX]][2];
      const averageZ = (upperCenterZ + lowerCenterZ) / 2;
      return irisCoords.map((coord, i) => {
        let z = averageZ;
        if (i === 2) {
          z = upperCenterZ;
        } else if (i === 4) {
          z = lowerCenterZ;
        }
        return [coord[0], coord[1], z];
      });
    }
    async predict(input, config2) {
      this.skipped++;
      let useFreshBox = false;
      let detector;
      if (this.skipped > config2.detector.skipFrames || !config2.mesh.enabled || !config2.videoOptimized) {
        detector = await this.boundingBoxDetector.getBoundingBoxes(input);
        if (input.shape[1] !== 255 && input.shape[2] !== 255)
          this.skipped = 0;
      }
      if (detector && detector.boxes && detector.boxes.length > 0 && (!config2.mesh.enabled || detector.boxes.length !== this.detectedFaces && this.detectedFaces !== config2.detector.maxFaces)) {
        this.storedBoxes = [];
        this.detectedFaces = 0;
        for (const possible of detector.boxes) {
          this.storedBoxes.push({startPoint: possible.box.startPoint.dataSync(), endPoint: possible.box.endPoint.dataSync(), landmarks: possible.landmarks, confidence: possible.confidence});
        }
        if (this.storedBoxes.length > 0)
          useFreshBox = true;
      }
      if (useFreshBox) {
        if (!detector || !detector.boxes || detector.boxes.length === 0) {
          this.storedBoxes = [];
          this.detectedFaces = 0;
          return null;
        }
        for (const i in this.storedBoxes) {
          const scaledBox = bounding.scaleBoxCoordinates({startPoint: this.storedBoxes[i].startPoint, endPoint: this.storedBoxes[i].endPoint}, detector.scaleFactor);
          const enlargedBox = bounding.enlargeBox(scaledBox);
          const landmarks = this.storedBoxes[i].landmarks.arraySync();
          const confidence = this.storedBoxes[i].confidence;
          this.storedBoxes[i] = {...enlargedBox, confidence, landmarks};
        }
        this.runsWithoutFaceDetector = 0;
      }
      if (detector && detector.boxes) {
        detector.boxes.forEach((prediction) => {
          prediction.box.startPoint.dispose();
          prediction.box.endPoint.dispose();
          prediction.landmarks.dispose();
        });
      }
      let results = tf.tidy(() => this.storedBoxes.map((box, i) => {
        let angle = 0;
        const boxLandmarksFromMeshModel = box.landmarks.length >= LANDMARKS_COUNT;
        let [indexOfMouth, indexOfForehead] = MESH_KEYPOINTS_LINE_OF_SYMMETRY_INDICES;
        if (boxLandmarksFromMeshModel === false) {
          [indexOfMouth, indexOfForehead] = BLAZEFACE_KEYPOINTS_LINE_OF_SYMMETRY_INDICES;
        }
        angle = util30.computeRotation(box.landmarks[indexOfMouth], box.landmarks[indexOfForehead]);
        const faceCenter = bounding.getBoxCenter({startPoint: box.startPoint, endPoint: box.endPoint});
        const faceCenterNormalized = [faceCenter[0] / input.shape[2], faceCenter[1] / input.shape[1]];
        let rotatedImage = input;
        let rotationMatrix = util30.IDENTITY_MATRIX;
        if (angle !== 0) {
          rotatedImage = tf.image.rotateWithOffset(input, angle, 0, faceCenterNormalized);
          rotationMatrix = util30.buildRotationMatrix(-angle, faceCenter);
        }
        const face2 = bounding.cutBoxFromImageAndResize({startPoint: box.startPoint, endPoint: box.endPoint}, rotatedImage, [this.meshHeight, this.meshWidth]).div(255);
        const outputFace = config2.detector.rotation ? tf.image.rotateWithOffset(face2, angle) : face2;
        if (!config2.mesh.enabled) {
          const prediction2 = {
            coords: null,
            box,
            faceConfidence: null,
            confidence: box.confidence,
            image: outputFace
          };
          return prediction2;
        }
        const [, confidence, contourCoords] = this.meshDetector.predict(face2);
        const confidenceVal = confidence.dataSync()[0];
        confidence.dispose();
        if (confidenceVal < config2.detector.minConfidence) {
          contourCoords.dispose();
          return null;
        }
        const coordsReshaped = tf.reshape(contourCoords, [-1, 3]);
        let rawCoords = coordsReshaped.arraySync();
        if (config2.iris.enabled) {
          const {box: leftEyeBox, boxSize: leftEyeBoxSize, crop: leftEyeCrop} = this.getEyeBox(rawCoords, face2, LEFT_EYE_BOUNDS[0], LEFT_EYE_BOUNDS[1], true);
          const {box: rightEyeBox, boxSize: rightEyeBoxSize, crop: rightEyeCrop} = this.getEyeBox(rawCoords, face2, RIGHT_EYE_BOUNDS[0], RIGHT_EYE_BOUNDS[1]);
          const eyePredictions = this.irisModel.predict(tf.concat([leftEyeCrop, rightEyeCrop]));
          const eyePredictionsData = eyePredictions.dataSync();
          eyePredictions.dispose();
          const leftEyeData = eyePredictionsData.slice(0, IRIS_NUM_COORDINATES * 3);
          const {rawCoords: leftEyeRawCoords, iris: leftIrisRawCoords} = this.getEyeCoords(leftEyeData, leftEyeBox, leftEyeBoxSize, true);
          const rightEyeData = eyePredictionsData.slice(IRIS_NUM_COORDINATES * 3);
          const {rawCoords: rightEyeRawCoords, iris: rightIrisRawCoords} = this.getEyeCoords(rightEyeData, rightEyeBox, rightEyeBoxSize);
          const leftToRightEyeDepthDifference = this.getLeftToRightEyeDepthDifference(rawCoords);
          if (Math.abs(leftToRightEyeDepthDifference) < 30) {
            replaceRawCoordinates(rawCoords, leftEyeRawCoords, "left");
            replaceRawCoordinates(rawCoords, rightEyeRawCoords, "right");
          } else if (leftToRightEyeDepthDifference < 1) {
            replaceRawCoordinates(rawCoords, leftEyeRawCoords, "left", ["EyeUpper0", "EyeLower0"]);
          } else {
            replaceRawCoordinates(rawCoords, rightEyeRawCoords, "right", ["EyeUpper0", "EyeLower0"]);
          }
          const adjustedLeftIrisCoords = this.getAdjustedIrisCoords(rawCoords, leftIrisRawCoords, "left");
          const adjustedRightIrisCoords = this.getAdjustedIrisCoords(rawCoords, rightIrisRawCoords, "right");
          rawCoords = rawCoords.concat(adjustedLeftIrisCoords).concat(adjustedRightIrisCoords);
        }
        const transformedCoordsData = this.transformRawCoords(rawCoords, box, angle, rotationMatrix);
        tf.dispose(rawCoords);
        const landmarksBox = bounding.enlargeBox(this.calculateLandmarksBoundingBox(transformedCoordsData));
        const transformedCoords = tf.tensor2d(transformedCoordsData);
        const prediction = {
          coords: transformedCoords,
          box: landmarksBox,
          faceConfidence: confidenceVal,
          confidence: box.confidence,
          image: outputFace
        };
        this.storedBoxes[i] = {...landmarksBox, landmarks: transformedCoords.arraySync(), confidence: box.confidence, faceConfidence: confidenceVal};
        return prediction;
      }));
      results = results.filter((a) => a !== null);
      this.detectedFaces = results.length;
      return results;
    }
    calculateLandmarksBoundingBox(landmarks) {
      const xs = landmarks.map((d) => d[0]);
      const ys = landmarks.map((d) => d[1]);
      const startPoint = [Math.min(...xs), Math.min(...ys)];
      const endPoint = [Math.max(...xs), Math.max(...ys)];
      return {startPoint, endPoint, landmarks};
    }
  }
  exports.Pipeline = Pipeline;
});
var require_facemesh = __commonJS((exports) => {
  const blazeface = __toModule(require_blazeface());
  const pipe = __toModule(require_facepipeline());
  const coords = __toModule(require_coords());
  class MediaPipeFaceMesh {
    constructor(blazeFace, blazeMeshModel, irisModel, config2) {
      this.pipeline = new pipe.Pipeline(blazeFace, blazeMeshModel, irisModel, config2);
      if (config2)
        this.config = config2;
    }
    async estimateFaces(input, config2) {
      if (config2)
        this.config = config2;
      const predictions = await this.pipeline.predict(input, config2);
      const results = [];
      for (const prediction of predictions || []) {
        if (prediction.isDisposedInternal)
          continue;
        const mesh = prediction.coords ? prediction.coords.arraySync() : null;
        const annotations = {};
        if (mesh && mesh.length > 0) {
          for (const key in coords.MESH_ANNOTATIONS) {
            if (this.config.iris.enabled || key.includes("Iris") === false) {
              annotations[key] = coords.MESH_ANNOTATIONS[key].map((index) => mesh[index]);
            }
          }
        }
        results.push({
          confidence: prediction.confidence || 0,
          box: prediction.box ? [prediction.box.startPoint[0], prediction.box.startPoint[1], prediction.box.endPoint[0] - prediction.box.startPoint[0], prediction.box.endPoint[1] - prediction.box.startPoint[1]] : 0,
          mesh,
          annotations,
          image: prediction.image ? tf.clone(prediction.image) : null
        });
        if (prediction.coords)
          prediction.coords.dispose();
        if (prediction.image)
          prediction.image.dispose();
      }
      return results;
    }
  }
  async function load2(config2) {
    const models = await Promise.all([
      blazeface.load(config2),
      loadGraphModel(config2.mesh.modelPath, {fromTFHub: config2.mesh.modelPath.includes("tfhub.dev")}),
      loadGraphModel(config2.iris.modelPath, {fromTFHub: config2.iris.modelPath.includes("tfhub.dev")})
    ]);
    const faceMesh = new MediaPipeFaceMesh(models[0], models[1], models[2], config2);
    console.log(`Human: load model: ${config2.mesh.modelPath.match(/\/(.*)\./)[1]}`);
    console.log(`Human: load model: ${config2.iris.modelPath.match(/\/(.*)\./)[1]}`);
    return faceMesh;
  }
  exports.load = load2;
  exports.MediaPipeFaceMesh = MediaPipeFaceMesh;
  exports.triangulation = coords.TRI468;
});
var require_profile = __commonJS((exports) => {
  const profileData = {};
  function profile2(name, data2) {
    if (!data2 || !data2.kernels)
      return;
    const maxResults = 5;
    const time = data2.kernels.filter((a) => a.kernelTimeMs > 0).reduce((a, b) => a += b.kernelTimeMs, 0);
    const slowest = data2.kernels.map((a, i) => {
      a.id = i;
      return a;
    }).filter((a) => a.kernelTimeMs > 0).sort((a, b) => b.kernelTimeMs - a.kernelTimeMs);
    const largest = data2.kernels.map((a, i) => {
      a.id = i;
      return a;
    }).filter((a) => a.totalBytesSnapshot > 0).sort((a, b) => b.totalBytesSnapshot - a.totalBytesSnapshot);
    if (slowest.length > maxResults)
      slowest.length = maxResults;
    if (largest.length > maxResults)
      largest.length = maxResults;
    const res = {newBytes: data2.newBytes, newTensors: data2.newTensors, peakBytes: data2.peakBytes, numKernelOps: data2.kernels.length, timeKernelOps: time, slowestKernelOps: slowest, largestKernelOps: largest};
    profileData[name] = res;
    console.log("Human profiler", name, res);
  }
  exports.run = profile2;
});
var require_age = __commonJS((exports) => {
  const profile2 = __toModule(require_profile());
  const models = {};
  let last = {age: 0};
  let frame = Number.MAX_SAFE_INTEGER;
  async function load2(config2) {
    if (!models.age) {
      models.age = await loadGraphModel(config2.face.age.modelPath);
      console.log(`Human: load model: ${config2.face.age.modelPath.match(/\/(.*)\./)[1]}`);
    }
    return models.age;
  }
  async function predict2(image2, config2) {
    if (!models.age)
      return null;
    if (frame < config2.face.age.skipFrames && config2.videoOptimized && last.age && last.age > 0) {
      frame += 1;
      return last;
    }
    frame = 0;
    return new Promise(async (resolve) => {
      const resize = tf.image.resizeBilinear(image2, [config2.face.age.inputSize, config2.face.age.inputSize], false);
      const enhance = tf.mul(resize, [255]);
      tf.dispose(resize);
      let ageT;
      const obj = {};
      if (!config2.profile) {
        if (config2.face.age.enabled)
          ageT = await models.age.predict(enhance);
      } else {
        const profileAge = config2.face.age.enabled ? await tf.profile(() => models.age.predict(enhance)) : {};
        ageT = profileAge.result.clone();
        profileAge.result.dispose();
        profile2.run("age", profileAge);
      }
      enhance.dispose();
      if (ageT) {
        const data2 = ageT.dataSync();
        obj.age = Math.trunc(10 * data2[0]) / 10;
      }
      ageT.dispose();
      last = obj;
      resolve(obj);
    });
  }
  exports.predict = predict2;
  exports.load = load2;
});
var require_gender = __commonJS((exports) => {
  const profile2 = __toModule(require_profile());
  const models = {};
  let last = {gender: ""};
  let frame = Number.MAX_SAFE_INTEGER;
  let alternative = false;
  const rgb = [0.2989, 0.587, 0.114];
  async function load2(config2) {
    if (!models.gender) {
      models.gender = await loadGraphModel(config2.face.gender.modelPath);
      alternative = models.gender.inputs[0].shape[3] === 1;
      console.log(`Human: load model: ${config2.face.gender.modelPath.match(/\/(.*)\./)[1]}`);
    }
    return models.gender;
  }
  async function predict2(image2, config2) {
    if (!models.gender)
      return null;
    if (frame < config2.face.gender.skipFrames && config2.videoOptimized && last.gender !== "") {
      frame += 1;
      return last;
    }
    frame = 0;
    return new Promise(async (resolve) => {
      const resize = tf.image.resizeBilinear(image2, [config2.face.gender.inputSize, config2.face.gender.inputSize], false);
      let enhance;
      if (alternative) {
        enhance = tf.tidy(() => {
          const [red, green, blue] = tf.split(resize, 3, 3);
          const redNorm = tf.mul(red, rgb[0]);
          const greenNorm = tf.mul(green, rgb[1]);
          const blueNorm = tf.mul(blue, rgb[2]);
          const grayscale = tf.addN([redNorm, greenNorm, blueNorm]);
          return grayscale.sub(0.5).mul(2);
        });
      } else {
        enhance = tf.mul(resize, [255]);
      }
      tf.dispose(resize);
      let genderT;
      const obj = {};
      if (!config2.profile) {
        if (config2.face.gender.enabled)
          genderT = await models.gender.predict(enhance);
      } else {
        const profileGender = config2.face.gender.enabled ? await tf.profile(() => models.gender.predict(enhance)) : {};
        genderT = profileGender.result.clone();
        profileGender.result.dispose();
        profile2.run("gender", profileGender);
      }
      enhance.dispose();
      if (genderT) {
        const data2 = genderT.dataSync();
        if (alternative) {
          const confidence = Math.trunc(100 * Math.abs(data2[0] - data2[1])) / 100;
          if (confidence > config2.face.gender.minConfidence) {
            obj.gender = data2[0] > data2[1] ? "female" : "male";
            obj.confidence = confidence;
          }
        } else {
          const confidence = Math.trunc(200 * Math.abs(data2[0] - 0.5)) / 100;
          if (confidence > config2.face.gender.minConfidence) {
            obj.gender = data2[0] <= 0.5 ? "female" : "male";
            obj.confidence = Math.min(0.99, confidence);
          }
        }
      }
      genderT.dispose();
      last = obj;
      resolve(obj);
    });
  }
  exports.predict = predict2;
  exports.load = load2;
});
var require_emotion = __commonJS((exports) => {
  const profile2 = __toModule(require_profile());
  const annotations = ["angry", "disgust", "fear", "happy", "sad", "surpise", "neutral"];
  const models = {};
  let last = [];
  let frame = Number.MAX_SAFE_INTEGER;
  const rgb = [0.2989, 0.587, 0.114];
  const scale = 1;
  async function load2(config2) {
    if (!models.emotion) {
      models.emotion = await loadGraphModel(config2.face.emotion.modelPath);
      console.log(`Human: load model: ${config2.face.emotion.modelPath.match(/\/(.*)\./)[1]}`);
    }
    return models.emotion;
  }
  async function predict2(image2, config2) {
    if (!models.emotion)
      return null;
    if (frame < config2.face.emotion.skipFrames && config2.videoOptimized && last.length > 0) {
      frame += 1;
      return last;
    }
    frame = 0;
    return new Promise(async (resolve) => {
      const resize = tf.image.resizeBilinear(image2, [config2.face.emotion.inputSize, config2.face.emotion.inputSize], false);
      const [red, green, blue] = tf.split(resize, 3, 3);
      resize.dispose();
      const redNorm = tf.mul(red, rgb[0]);
      const greenNorm = tf.mul(green, rgb[1]);
      const blueNorm = tf.mul(blue, rgb[2]);
      red.dispose();
      green.dispose();
      blue.dispose();
      const grayscale = tf.addN([redNorm, greenNorm, blueNorm]);
      redNorm.dispose();
      greenNorm.dispose();
      blueNorm.dispose();
      const normalize = tf.tidy(() => grayscale.sub(0.5).mul(2));
      grayscale.dispose();
      const obj = [];
      if (config2.face.emotion.enabled) {
        let data2;
        if (!config2.profile) {
          const emotionT = await models.emotion.predict(normalize);
          data2 = emotionT.dataSync();
          tf.dispose(emotionT);
        } else {
          const profileData = await tf.profile(() => models.emotion.predict(normalize));
          data2 = profileData.result.dataSync();
          profileData.result.dispose();
          profile2.run("emotion", profileData);
        }
        for (let i = 0; i < data2.length; i++) {
          if (scale * data2[i] > config2.face.emotion.minConfidence)
            obj.push({score: Math.min(0.99, Math.trunc(100 * scale * data2[i]) / 100), emotion: annotations[i]});
        }
        obj.sort((a, b) => b.score - a.score);
      }
      normalize.dispose();
      last = obj;
      resolve(obj);
    });
  }
  exports.predict = predict2;
  exports.load = load2;
});
var require_embedding = __commonJS((exports) => {
  const profile2 = __toModule(require_profile());
  const models = {};
  async function load2(config2) {
    if (!models.embedding) {
      models.embedding = await loadGraphModel(config2.face.embedding.modelPath);
      console.log(`Human: load model: ${config2.face.embedding.modelPath.match(/\/(.*)\./)[1]}`);
    }
    return models.embedding;
  }
  function simmilarity2(embedding1, embedding2) {
    if ((embedding1 == null ? void 0 : embedding1.length) !== (embedding2 == null ? void 0 : embedding2.length))
      return 0;
    const distance = 10 * Math.sqrt(embedding1.map((val, i) => val - embedding2[i]).reduce((dist2, diff) => dist2 + diff ** 2, 0));
    const confidence = 2 * (0.5 - distance);
    return Math.trunc(1e3 * confidence) / 1e3;
  }
  async function predict2(image2, config2) {
    if (!models.embedding)
      return null;
    return new Promise(async (resolve) => {
      const resize = tf.image.resizeBilinear(image2, [config2.face.embedding.inputSize, config2.face.embedding.inputSize], false);
      let data2 = [];
      if (config2.face.embedding.enabled) {
        if (!config2.profile) {
          const embeddingT = await models.embedding.predict({img_inputs: resize});
          data2 = [...embeddingT.dataSync()];
          tf.dispose(embeddingT);
        } else {
          const profileData = await tf.profile(() => models.embedding.predict({img_inputs: resize}));
          data2 = [...profileData.result.dataSync()];
          profileData.result.dispose();
          profile2.run("emotion", profileData);
        }
      }
      resize.dispose();
      resolve(data2);
    });
  }
  exports.predict = predict2;
  exports.simmilarity = simmilarity2;
  exports.load = load2;
});
var require_modelBase = __commonJS((exports) => {
  class BaseModel {
    constructor(model, outputStride) {
      this.model = model;
      this.outputStride = outputStride;
    }
    predict(input) {
      return tf.tidy(() => {
        const asFloat = this.preprocessInput(input.toFloat());
        const asBatch = asFloat.expandDims(0);
        const results = this.model.predict(asBatch);
        const results3d = results.map((y) => y.squeeze([0]));
        const namedResults = this.nameOutputResults(results3d);
        return {
          heatmapScores: namedResults.heatmap.sigmoid(),
          offsets: namedResults.offsets,
          displacementFwd: namedResults.displacementFwd,
          displacementBwd: namedResults.displacementBwd
        };
      });
    }
    dispose() {
      this.model.dispose();
    }
  }
  exports.BaseModel = BaseModel;
});
var require_modelMobileNet = __commonJS((exports) => {
  const modelBase = __toModule(require_modelBase());
  class MobileNet extends modelBase.BaseModel {
    preprocessInput(input) {
      return tf.tidy(() => tf.div(input, 127.5).sub(1));
    }
    nameOutputResults(results) {
      const [offsets, heatmap, displacementFwd, displacementBwd] = results;
      return {offsets, heatmap, displacementFwd, displacementBwd};
    }
  }
  exports.MobileNet = MobileNet;
});
var require_heapSort = __commonJS((exports) => {
  function half(k) {
    return Math.floor(k / 2);
  }
  class MaxHeap {
    constructor(maxSize, getElementValue) {
      this.priorityQueue = new Array(maxSize);
      this.numberOfElements = -1;
      this.getElementValue = getElementValue;
    }
    enqueue(x) {
      this.priorityQueue[++this.numberOfElements] = x;
      this.swim(this.numberOfElements);
    }
    dequeue() {
      const max2 = this.priorityQueue[0];
      this.exchange(0, this.numberOfElements--);
      this.sink(0);
      this.priorityQueue[this.numberOfElements + 1] = null;
      return max2;
    }
    empty() {
      return this.numberOfElements === -1;
    }
    size() {
      return this.numberOfElements + 1;
    }
    all() {
      return this.priorityQueue.slice(0, this.numberOfElements + 1);
    }
    max() {
      return this.priorityQueue[0];
    }
    swim(k) {
      while (k > 0 && this.less(half(k), k)) {
        this.exchange(k, half(k));
        k = half(k);
      }
    }
    sink(k) {
      while (2 * k <= this.numberOfElements) {
        let j = 2 * k;
        if (j < this.numberOfElements && this.less(j, j + 1))
          j++;
        if (!this.less(k, j))
          break;
        this.exchange(k, j);
        k = j;
      }
    }
    getValueAt(i) {
      return this.getElementValue(this.priorityQueue[i]);
    }
    less(i, j) {
      return this.getValueAt(i) < this.getValueAt(j);
    }
    exchange(i, j) {
      const t = this.priorityQueue[i];
      this.priorityQueue[i] = this.priorityQueue[j];
      this.priorityQueue[j] = t;
    }
  }
  exports.MaxHeap = MaxHeap;
});
var require_buildParts = __commonJS((exports) => {
  const heapSort = __toModule(require_heapSort());
  function scoreIsMaximumInLocalWindow(keypointId, score, heatmapY, heatmapX, localMaximumRadius, scores) {
    const [height, width] = scores.shape;
    let localMaximum = true;
    const yStart = Math.max(heatmapY - localMaximumRadius, 0);
    const yEnd = Math.min(heatmapY + localMaximumRadius + 1, height);
    for (let yCurrent = yStart; yCurrent < yEnd; ++yCurrent) {
      const xStart = Math.max(heatmapX - localMaximumRadius, 0);
      const xEnd = Math.min(heatmapX + localMaximumRadius + 1, width);
      for (let xCurrent = xStart; xCurrent < xEnd; ++xCurrent) {
        if (scores.get(yCurrent, xCurrent, keypointId) > score) {
          localMaximum = false;
          break;
        }
      }
      if (!localMaximum) {
        break;
      }
    }
    return localMaximum;
  }
  function buildPartWithScoreQueue(scoreThreshold, localMaximumRadius, scores) {
    const [height, width, numKeypoints] = scores.shape;
    const queue = new heapSort.MaxHeap(height * width * numKeypoints, ({score}) => score);
    for (let heatmapY = 0; heatmapY < height; ++heatmapY) {
      for (let heatmapX = 0; heatmapX < width; ++heatmapX) {
        for (let keypointId = 0; keypointId < numKeypoints; ++keypointId) {
          const score = scores.get(heatmapY, heatmapX, keypointId);
          if (score < scoreThreshold)
            continue;
          if (scoreIsMaximumInLocalWindow(keypointId, score, heatmapY, heatmapX, localMaximumRadius, scores)) {
            queue.enqueue({score, part: {heatmapY, heatmapX, id: keypointId}});
          }
        }
      }
    }
    return queue;
  }
  exports.buildPartWithScoreQueue = buildPartWithScoreQueue;
});
var require_keypoints = __commonJS((exports) => {
  exports.partNames = [
    "nose",
    "leftEye",
    "rightEye",
    "leftEar",
    "rightEar",
    "leftShoulder",
    "rightShoulder",
    "leftElbow",
    "rightElbow",
    "leftWrist",
    "rightWrist",
    "leftHip",
    "rightHip",
    "leftKnee",
    "rightKnee",
    "leftAnkle",
    "rightAnkle"
  ];
  exports.NUM_KEYPOINTS = exports.partNames.length;
  exports.partIds = exports.partNames.reduce((result, jointName, i) => {
    result[jointName] = i;
    return result;
  }, {});
  const connectedPartNames = [
    ["leftHip", "leftShoulder"],
    ["leftElbow", "leftShoulder"],
    ["leftElbow", "leftWrist"],
    ["leftHip", "leftKnee"],
    ["leftKnee", "leftAnkle"],
    ["rightHip", "rightShoulder"],
    ["rightElbow", "rightShoulder"],
    ["rightElbow", "rightWrist"],
    ["rightHip", "rightKnee"],
    ["rightKnee", "rightAnkle"],
    ["leftShoulder", "rightShoulder"],
    ["leftHip", "rightHip"]
  ];
  exports.poseChain = [
    ["nose", "leftEye"],
    ["leftEye", "leftEar"],
    ["nose", "rightEye"],
    ["rightEye", "rightEar"],
    ["nose", "leftShoulder"],
    ["leftShoulder", "leftElbow"],
    ["leftElbow", "leftWrist"],
    ["leftShoulder", "leftHip"],
    ["leftHip", "leftKnee"],
    ["leftKnee", "leftAnkle"],
    ["nose", "rightShoulder"],
    ["rightShoulder", "rightElbow"],
    ["rightElbow", "rightWrist"],
    ["rightShoulder", "rightHip"],
    ["rightHip", "rightKnee"],
    ["rightKnee", "rightAnkle"]
  ];
  exports.connectedPartIndices = connectedPartNames.map(([jointNameA, jointNameB]) => [exports.partIds[jointNameA], exports.partIds[jointNameB]]);
  exports.partChannels = [
    "left_face",
    "right_face",
    "right_upper_leg_front",
    "right_lower_leg_back",
    "right_upper_leg_back",
    "left_lower_leg_front",
    "left_upper_leg_front",
    "left_upper_leg_back",
    "left_lower_leg_back",
    "right_feet",
    "right_lower_leg_front",
    "left_feet",
    "torso_front",
    "torso_back",
    "right_upper_arm_front",
    "right_upper_arm_back",
    "right_lower_arm_back",
    "left_lower_arm_front",
    "left_upper_arm_front",
    "left_upper_arm_back",
    "left_lower_arm_back",
    "right_hand",
    "right_lower_arm_front",
    "left_hand"
  ];
});
var require_vectors = __commonJS((exports) => {
  const kpt = __toModule(require_keypoints());
  function getOffsetPoint(y, x, keypoint, offsets) {
    return {
      y: offsets.get(y, x, keypoint),
      x: offsets.get(y, x, keypoint + kpt.NUM_KEYPOINTS)
    };
  }
  exports.getOffsetPoint = getOffsetPoint;
  function getImageCoords(part, outputStride, offsets) {
    const {heatmapY, heatmapX, id: keypoint} = part;
    const {y, x} = getOffsetPoint(heatmapY, heatmapX, keypoint, offsets);
    return {
      x: part.heatmapX * outputStride + x,
      y: part.heatmapY * outputStride + y
    };
  }
  exports.getImageCoords = getImageCoords;
  function fillArray(element, size) {
    const result = new Array(size);
    for (let i = 0; i < size; i++) {
      result[i] = element;
    }
    return result;
  }
  exports.fillArray = fillArray;
  function clamp2(a, min2, max2) {
    if (a < min2)
      return min2;
    if (a > max2)
      return max2;
    return a;
  }
  exports.clamp = clamp2;
  function squaredDistance(y1, x1, y2, x2) {
    const dy = y2 - y1;
    const dx = x2 - x1;
    return dy * dy + dx * dx;
  }
  exports.squaredDistance = squaredDistance;
  function addVectors(a, b) {
    return {x: a.x + b.x, y: a.y + b.y};
  }
  exports.addVectors = addVectors;
  function clampVector(a, min2, max2) {
    return {y: clamp2(a.y, min2, max2), x: clamp2(a.x, min2, max2)};
  }
  exports.clampVector = clampVector;
});
var require_decodePose = __commonJS((exports) => {
  const keypoints = __toModule(require_keypoints());
  const vectors = __toModule(require_vectors());
  const parentChildrenTuples = keypoints.poseChain.map(([parentJoinName, childJoinName]) => [keypoints.partIds[parentJoinName], keypoints.partIds[childJoinName]]);
  const parentToChildEdges = parentChildrenTuples.map(([, childJointId]) => childJointId);
  const childToParentEdges = parentChildrenTuples.map(([parentJointId]) => parentJointId);
  function getDisplacement(edgeId, point, displacements) {
    const numEdges = displacements.shape[2] / 2;
    return {
      y: displacements.get(point.y, point.x, edgeId),
      x: displacements.get(point.y, point.x, numEdges + edgeId)
    };
  }
  function getStridedIndexNearPoint(point, outputStride, height, width) {
    return {
      y: vectors.clamp(Math.round(point.y / outputStride), 0, height - 1),
      x: vectors.clamp(Math.round(point.x / outputStride), 0, width - 1)
    };
  }
  function traverseToTargetKeypoint(edgeId, sourceKeypoint, targetKeypointId, scoresBuffer, offsets, outputStride, displacements, offsetRefineStep = 2) {
    const [height, width] = scoresBuffer.shape;
    const sourceKeypointIndices = getStridedIndexNearPoint(sourceKeypoint.position, outputStride, height, width);
    const displacement = getDisplacement(edgeId, sourceKeypointIndices, displacements);
    const displacedPoint = vectors.addVectors(sourceKeypoint.position, displacement);
    let targetKeypoint = displacedPoint;
    for (let i = 0; i < offsetRefineStep; i++) {
      const targetKeypointIndices = getStridedIndexNearPoint(targetKeypoint, outputStride, height, width);
      const offsetPoint = vectors.getOffsetPoint(targetKeypointIndices.y, targetKeypointIndices.x, targetKeypointId, offsets);
      targetKeypoint = vectors.addVectors({
        x: targetKeypointIndices.x * outputStride,
        y: targetKeypointIndices.y * outputStride
      }, {x: offsetPoint.x, y: offsetPoint.y});
    }
    const targetKeyPointIndices = getStridedIndexNearPoint(targetKeypoint, outputStride, height, width);
    const score = scoresBuffer.get(targetKeyPointIndices.y, targetKeyPointIndices.x, targetKeypointId);
    return {position: targetKeypoint, part: keypoints.partNames[targetKeypointId], score};
  }
  function decodePose(root, scores, offsets, outputStride, displacementsFwd, displacementsBwd) {
    const numParts = scores.shape[2];
    const numEdges = parentToChildEdges.length;
    const instanceKeypoints = new Array(numParts);
    const {part: rootPart, score: rootScore} = root;
    const rootPoint = vectors.getImageCoords(rootPart, outputStride, offsets);
    instanceKeypoints[rootPart.id] = {
      score: rootScore,
      part: keypoints.partNames[rootPart.id],
      position: rootPoint
    };
    for (let edge = numEdges - 1; edge >= 0; --edge) {
      const sourceKeypointId = parentToChildEdges[edge];
      const targetKeypointId = childToParentEdges[edge];
      if (instanceKeypoints[sourceKeypointId] && !instanceKeypoints[targetKeypointId]) {
        instanceKeypoints[targetKeypointId] = traverseToTargetKeypoint(edge, instanceKeypoints[sourceKeypointId], targetKeypointId, scores, offsets, outputStride, displacementsBwd);
      }
    }
    for (let edge = 0; edge < numEdges; ++edge) {
      const sourceKeypointId = childToParentEdges[edge];
      const targetKeypointId = parentToChildEdges[edge];
      if (instanceKeypoints[sourceKeypointId] && !instanceKeypoints[targetKeypointId]) {
        instanceKeypoints[targetKeypointId] = traverseToTargetKeypoint(edge, instanceKeypoints[sourceKeypointId], targetKeypointId, scores, offsets, outputStride, displacementsFwd);
      }
    }
    return instanceKeypoints;
  }
  exports.decodePose = decodePose;
});
var require_decodeMultiple = __commonJS((exports) => {
  const buildParts = __toModule(require_buildParts());
  const decodePose = __toModule(require_decodePose());
  const vectors = __toModule(require_vectors());
  function withinNmsRadiusOfCorrespondingPoint(poses, squaredNmsRadius, {x, y}, keypointId) {
    return poses.some(({keypoints}) => {
      const correspondingKeypoint = keypoints[keypointId].position;
      return vectors.squaredDistance(y, x, correspondingKeypoint.y, correspondingKeypoint.x) <= squaredNmsRadius;
    });
  }
  function getInstanceScore(existingPoses, squaredNmsRadius, instanceKeypoints) {
    const notOverlappedKeypointScores = instanceKeypoints.reduce((result, {position, score}, keypointId) => {
      if (!withinNmsRadiusOfCorrespondingPoint(existingPoses, squaredNmsRadius, position, keypointId)) {
        result += score;
      }
      return result;
    }, 0);
    return notOverlappedKeypointScores / instanceKeypoints.length;
  }
  const kLocalMaximumRadius = 1;
  function decodeMultiplePoses(scoresBuffer, offsetsBuffer, displacementsFwdBuffer, displacementsBwdBuffer, outputStride, maxPoseDetections, scoreThreshold = 0.5, nmsRadius = 20) {
    const poses = [];
    const queue = buildParts.buildPartWithScoreQueue(scoreThreshold, kLocalMaximumRadius, scoresBuffer);
    const squaredNmsRadius = nmsRadius * nmsRadius;
    while (poses.length < maxPoseDetections && !queue.empty()) {
      const root = queue.dequeue();
      const rootImageCoords = vectors.getImageCoords(root.part, outputStride, offsetsBuffer);
      if (withinNmsRadiusOfCorrespondingPoint(poses, squaredNmsRadius, rootImageCoords, root.part.id))
        continue;
      const keypoints = decodePose.decodePose(root, scoresBuffer, offsetsBuffer, outputStride, displacementsFwdBuffer, displacementsBwdBuffer);
      const score = getInstanceScore(poses, squaredNmsRadius, keypoints);
      poses.push({keypoints, score});
    }
    return poses;
  }
  exports.decodeMultiplePoses = decodeMultiplePoses;
});
var require_util2 = __commonJS((exports) => {
  const kpt = __toModule(require_keypoints());
  function eitherPointDoesntMeetConfidence(a, b, minConfidence) {
    return a < minConfidence || b < minConfidence;
  }
  function getAdjacentKeyPoints(keypoints, minConfidence) {
    return kpt.connectedPartIndices.reduce((result, [leftJoint, rightJoint]) => {
      if (eitherPointDoesntMeetConfidence(keypoints[leftJoint].score, keypoints[rightJoint].score, minConfidence)) {
        return result;
      }
      result.push([keypoints[leftJoint], keypoints[rightJoint]]);
      return result;
    }, []);
  }
  exports.getAdjacentKeyPoints = getAdjacentKeyPoints;
  const {NEGATIVE_INFINITY, POSITIVE_INFINITY} = Number;
  function getBoundingBox(keypoints) {
    return keypoints.reduce(({maxX, maxY, minX, minY}, {position: {x, y}}) => ({
      maxX: Math.max(maxX, x),
      maxY: Math.max(maxY, y),
      minX: Math.min(minX, x),
      minY: Math.min(minY, y)
    }), {
      maxX: NEGATIVE_INFINITY,
      maxY: NEGATIVE_INFINITY,
      minX: POSITIVE_INFINITY,
      minY: POSITIVE_INFINITY
    });
  }
  exports.getBoundingBox = getBoundingBox;
  function getBoundingBoxPoints(keypoints) {
    const {minX, minY, maxX, maxY} = getBoundingBox(keypoints);
    return [{x: minX, y: minY}, {x: maxX, y: minY}, {x: maxX, y: maxY}, {x: minX, y: maxY}];
  }
  exports.getBoundingBoxPoints = getBoundingBoxPoints;
  async function toTensorBuffers3D(tensors) {
    return Promise.all(tensors.map((tensor6) => tensor6.buffer()));
  }
  exports.toTensorBuffers3D = toTensorBuffers3D;
  function scalePose(pose, scaleY, scaleX) {
    return {
      score: pose.score,
      keypoints: pose.keypoints.map(({score, part, position}) => ({
        score,
        part,
        position: {x: position.x * scaleX, y: position.y * scaleY}
      }))
    };
  }
  exports.scalePose = scalePose;
  function resizeTo(image2, [targetH, targetW]) {
    const input = image2.squeeze(0);
    const resized = input.resizeBilinear([targetH, targetW]);
    input.dispose();
    return resized;
  }
  exports.resizeTo = resizeTo;
  function scaleAndFlipPoses(poses, [height, width], [inputResolutionHeight, inputResolutionWidth]) {
    const scaledPoses = poses.map((pose) => scalePose(pose, height / inputResolutionHeight, width / inputResolutionWidth));
    return scaledPoses;
  }
  exports.scaleAndFlipPoses = scaleAndFlipPoses;
});
var require_modelPoseNet = __commonJS((exports) => {
  const modelMobileNet = __toModule(require_modelMobileNet());
  const decodeMultiple = __toModule(require_decodeMultiple());
  const util30 = __toModule(require_util2());
  class PoseNet {
    constructor(net) {
      this.baseModel = net;
      this.outputStride = 16;
    }
    async estimatePoses(input, config2) {
      return new Promise(async (resolve) => {
        const height = input.shape[1];
        const width = input.shape[2];
        const resized = util30.resizeTo(input, [config2.body.inputSize, config2.body.inputSize]);
        const res = this.baseModel.predict(resized);
        const allTensorBuffers = await util30.toTensorBuffers3D([res.heatmapScores, res.offsets, res.displacementFwd, res.displacementBwd]);
        const scoresBuffer = allTensorBuffers[0];
        const offsetsBuffer = allTensorBuffers[1];
        const displacementsFwdBuffer = allTensorBuffers[2];
        const displacementsBwdBuffer = allTensorBuffers[3];
        const poses = await decodeMultiple.decodeMultiplePoses(scoresBuffer, offsetsBuffer, displacementsFwdBuffer, displacementsBwdBuffer, this.outputStride, config2.body.maxDetections, config2.body.scoreThreshold, config2.body.nmsRadius);
        const resultPoses = util30.scaleAndFlipPoses(poses, [height, width], [config2.body.inputSize, config2.body.inputSize]);
        res.heatmapScores.dispose();
        res.offsets.dispose();
        res.displacementFwd.dispose();
        res.displacementBwd.dispose();
        resized.dispose();
        resolve(resultPoses);
      });
    }
    dispose() {
      this.baseModel.dispose();
    }
  }
  exports.PoseNet = PoseNet;
  async function load2(config2) {
    const graphModel = await loadGraphModel(config2.body.modelPath);
    const mobilenet = new modelMobileNet.MobileNet(graphModel, this.outputStride);
    console.log(`Human: load model: ${config2.body.modelPath.match(/\/(.*)\./)[1]}`);
    return new PoseNet(mobilenet);
  }
  exports.load = load2;
});
var require_posenet = __commonJS((exports) => {
  const modelMobileNet = __toModule(require_modelMobileNet());
  const modelPoseNet = __toModule(require_modelPoseNet());
  const decodeMultiple = __toModule(require_decodeMultiple());
  const keypoints = __toModule(require_keypoints());
  const util30 = __toModule(require_util2());
  exports.load = modelPoseNet.load;
  exports.PoseNet = modelPoseNet.PoseNet;
  exports.MobileNet = modelMobileNet.MobileNet;
  exports.decodeMultiplePoses = decodeMultiple.decodeMultiplePoses;
  exports.partChannels = keypoints.partChannels;
  exports.partIds = keypoints.partIds;
  exports.partNames = keypoints.partNames;
  exports.poseChain = keypoints.poseChain;
  exports.getAdjacentKeyPoints = util30.getAdjacentKeyPoints;
  exports.getBoundingBox = util30.getBoundingBox;
  exports.getBoundingBoxPoints = util30.getBoundingBoxPoints;
  exports.scaleAndFlipPoses = util30.scaleAndFlipPoses;
  exports.scalePose = util30.scalePose;
});
var require_handdetector = __commonJS((exports) => {
  /**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * https://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   */
  class HandDetector {
    constructor(model, inputSize, anchorsAnnotated) {
      this.model = model;
      this.anchors = anchorsAnnotated.map((anchor) => [anchor.x_center, anchor.y_center]);
      this.anchorsTensor = tf.tensor2d(this.anchors);
      this.inputSizeTensor = tf.tensor1d([inputSize, inputSize]);
      this.doubleInputSizeTensor = tf.tensor1d([inputSize * 2, inputSize * 2]);
    }
    normalizeBoxes(boxes) {
      return tf.tidy(() => {
        const boxOffsets = tf.slice(boxes, [0, 0], [-1, 2]);
        const boxSizes = tf.slice(boxes, [0, 2], [-1, 2]);
        const boxCenterPoints = tf.add(tf.div(boxOffsets, this.inputSizeTensor), this.anchorsTensor);
        const halfBoxSizes = tf.div(boxSizes, this.doubleInputSizeTensor);
        const startPoints = tf.mul(tf.sub(boxCenterPoints, halfBoxSizes), this.inputSizeTensor);
        const endPoints = tf.mul(tf.add(boxCenterPoints, halfBoxSizes), this.inputSizeTensor);
        return tf.concat2d([startPoints, endPoints], 1);
      });
    }
    normalizeLandmarks(rawPalmLandmarks, index) {
      return tf.tidy(() => {
        const landmarks = tf.add(tf.div(rawPalmLandmarks.reshape([-1, 7, 2]), this.inputSizeTensor), this.anchors[index]);
        return tf.mul(landmarks, this.inputSizeTensor);
      });
    }
    async getBoxes(input, config2) {
      const batched = this.model.predict(input);
      const predictions = batched.squeeze();
      batched.dispose();
      const scores = tf.tidy(() => tf.sigmoid(tf.slice(predictions, [0, 0], [-1, 1])).squeeze());
      const scoresVal = scores.dataSync();
      const rawBoxes = tf.slice(predictions, [0, 1], [-1, 4]);
      const boxes = this.normalizeBoxes(rawBoxes);
      rawBoxes.dispose();
      const filteredT = await tf.image.nonMaxSuppressionAsync(boxes, scores, config2.maxHands, config2.iouThreshold, config2.scoreThreshold);
      const filtered = filteredT.arraySync();
      scores.dispose();
      filteredT.dispose();
      const hands = [];
      for (const boxIndex of filtered) {
        if (scoresVal[boxIndex] >= config2.minConfidence) {
          const matchingBox = tf.slice(boxes, [boxIndex, 0], [1, -1]);
          const rawPalmLandmarks = tf.slice(predictions, [boxIndex, 5], [1, 14]);
          const palmLandmarks = tf.tidy(() => this.normalizeLandmarks(rawPalmLandmarks, boxIndex).reshape([-1, 2]));
          rawPalmLandmarks.dispose();
          hands.push({box: matchingBox, palmLandmarks, confidence: scoresVal[boxIndex]});
        }
      }
      predictions.dispose();
      boxes.dispose();
      return hands;
    }
    async estimateHandBounds(input, config2) {
      const inputHeight = input.shape[1];
      const inputWidth = input.shape[2];
      const image2 = tf.tidy(() => input.resizeBilinear([config2.inputSize, config2.inputSize]).div(127.5).sub(1));
      const predictions = await this.getBoxes(image2, config2);
      image2.dispose();
      if (!predictions || predictions.length === 0)
        return null;
      const hands = [];
      for (const prediction of predictions) {
        const boxes = prediction.box.dataSync();
        const startPoint = boxes.slice(0, 2);
        const endPoint = boxes.slice(2, 4);
        const palmLandmarks = prediction.palmLandmarks.arraySync();
        prediction.box.dispose();
        prediction.palmLandmarks.dispose();
        hands.push(scaleBoxCoordinates({startPoint, endPoint, palmLandmarks, confidence: prediction.confidence}, [inputWidth / config2.inputSize, inputHeight / config2.inputSize]));
      }
      return hands;
    }
  }
  exports.HandDetector = HandDetector;
});
var require_handpipeline = __commonJS((exports) => {
  /**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * https://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   */
  const PALM_BOX_SHIFT_VECTOR = [0, -0.4];
  const PALM_BOX_ENLARGE_FACTOR = 3;
  const HAND_BOX_SHIFT_VECTOR = [0, -0.1];
  const HAND_BOX_ENLARGE_FACTOR = 1.65;
  const PALM_LANDMARK_IDS = [0, 5, 9, 13, 17, 1, 2];
  const PALM_LANDMARKS_INDEX_OF_PALM_BASE = 0;
  const PALM_LANDMARKS_INDEX_OF_MIDDLE_FINGER_BASE = 2;
  class HandPipeline {
    constructor(boundingBoxDetector, meshDetector, inputSize) {
      this.boxDetector = boundingBoxDetector;
      this.meshDetector = meshDetector;
      this.inputSize = inputSize;
      this.storedBoxes = [];
      this.skipped = 1e3;
      this.detectedHands = 0;
    }
    getBoxForPalmLandmarks(palmLandmarks, rotationMatrix) {
      const rotatedPalmLandmarks = palmLandmarks.map((coord) => {
        const homogeneousCoordinate = [...coord, 1];
        return rotatePoint(homogeneousCoordinate, rotationMatrix);
      });
      const boxAroundPalm = this.calculateLandmarksBoundingBox(rotatedPalmLandmarks);
      return enlargeBox(squarifyBox(shiftBox(boxAroundPalm, PALM_BOX_SHIFT_VECTOR)), PALM_BOX_ENLARGE_FACTOR);
    }
    getBoxForHandLandmarks(landmarks) {
      const boundingBox = this.calculateLandmarksBoundingBox(landmarks);
      const boxAroundHand = enlargeBox(squarifyBox(shiftBox(boundingBox, HAND_BOX_SHIFT_VECTOR)), HAND_BOX_ENLARGE_FACTOR);
      const palmLandmarks = [];
      for (let i = 0; i < PALM_LANDMARK_IDS.length; i++) {
        palmLandmarks.push(landmarks[PALM_LANDMARK_IDS[i]].slice(0, 2));
      }
      boxAroundHand.palmLandmarks = palmLandmarks;
      return boxAroundHand;
    }
    transformRawCoords(rawCoords, box2, angle, rotationMatrix) {
      const boxSize = getBoxSize(box2);
      const scaleFactor = [boxSize[0] / this.inputSize, boxSize[1] / this.inputSize];
      const coordsScaled = rawCoords.map((coord) => [
        scaleFactor[0] * (coord[0] - this.inputSize / 2),
        scaleFactor[1] * (coord[1] - this.inputSize / 2),
        coord[2]
      ]);
      const coordsRotationMatrix = buildRotationMatrix(angle, [0, 0]);
      const coordsRotated = coordsScaled.map((coord) => {
        const rotated = rotatePoint(coord, coordsRotationMatrix);
        return [...rotated, coord[2]];
      });
      const inverseRotationMatrix = invertTransformMatrix(rotationMatrix);
      const boxCenter = [...getBoxCenter(box2), 1];
      const originalBoxCenter = [
        dot(boxCenter, inverseRotationMatrix[0]),
        dot(boxCenter, inverseRotationMatrix[1])
      ];
      return coordsRotated.map((coord) => [
        coord[0] + originalBoxCenter[0],
        coord[1] + originalBoxCenter[1],
        coord[2]
      ]);
    }
    async estimateHands(image2, config2) {
      this.skipped++;
      let useFreshBox = false;
      let boxes;
      if (this.skipped > config2.skipFrames || !config2.landmarks || !config2.videoOptimized) {
        boxes = await this.boxDetector.estimateHandBounds(image2, config2);
        if (image2.shape[1] !== 255 && image2.shape[2] !== 255)
          this.skipped = 0;
      }
      if (boxes && boxes.length > 0 && (boxes.length !== this.detectedHands && this.detectedHands !== config2.maxHands || !config2.landmarks)) {
        this.storedBoxes = [];
        this.detectedHands = 0;
        for (const possible of boxes)
          this.storedBoxes.push(possible);
        if (this.storedBoxes.length > 0)
          useFreshBox = true;
      }
      const hands = [];
      for (const i in this.storedBoxes) {
        const currentBox = this.storedBoxes[i];
        if (!currentBox)
          continue;
        if (config2.landmarks) {
          const angle = computeRotation(currentBox.palmLandmarks[PALM_LANDMARKS_INDEX_OF_PALM_BASE], currentBox.palmLandmarks[PALM_LANDMARKS_INDEX_OF_MIDDLE_FINGER_BASE]);
          const palmCenter = getBoxCenter(currentBox);
          const palmCenterNormalized = [palmCenter[0] / image2.shape[2], palmCenter[1] / image2.shape[1]];
          const rotatedImage = tf.image.rotateWithOffset(image2, angle, 0, palmCenterNormalized);
          const rotationMatrix = buildRotationMatrix(-angle, palmCenter);
          const newBox = useFreshBox ? this.getBoxForPalmLandmarks(currentBox.palmLandmarks, rotationMatrix) : currentBox;
          const croppedInput = cutBoxFromImageAndResize(newBox, rotatedImage, [this.inputSize, this.inputSize]);
          const handImage = croppedInput.div(255);
          croppedInput.dispose();
          rotatedImage.dispose();
          const [confidence, keypoints] = await this.meshDetector.predict(handImage);
          handImage.dispose();
          const confidenceValue = confidence.dataSync()[0];
          confidence.dispose();
          if (confidenceValue >= config2.minConfidence) {
            const keypointsReshaped = tf.reshape(keypoints, [-1, 3]);
            const rawCoords = keypointsReshaped.arraySync();
            keypoints.dispose();
            keypointsReshaped.dispose();
            const coords = this.transformRawCoords(rawCoords, newBox, angle, rotationMatrix);
            const nextBoundingBox = this.getBoxForHandLandmarks(coords);
            this.storedBoxes[i] = nextBoundingBox;
            const result = {
              landmarks: coords,
              confidence: confidenceValue,
              box: {
                topLeft: nextBoundingBox.startPoint,
                bottomRight: nextBoundingBox.endPoint
              }
            };
            hands.push(result);
          } else {
            this.storedBoxes[i] = null;
          }
          keypoints.dispose();
        } else {
          const enlarged = enlargeBox(squarifyBox(shiftBox(currentBox, HAND_BOX_SHIFT_VECTOR)), HAND_BOX_ENLARGE_FACTOR);
          const result = {
            confidence: currentBox.confidence,
            box: {
              topLeft: enlarged.startPoint,
              bottomRight: enlarged.endPoint
            }
          };
          hands.push(result);
        }
      }
      this.storedBoxes = this.storedBoxes.filter((a) => a !== null);
      this.detectedHands = hands.length;
      return hands;
    }
    calculateLandmarksBoundingBox(landmarks) {
      const xs = landmarks.map((d) => d[0]);
      const ys = landmarks.map((d) => d[1]);
      const startPoint = [Math.min(...xs), Math.min(...ys)];
      const endPoint = [Math.max(...xs), Math.max(...ys)];
      return {startPoint, endPoint};
    }
  }
  exports.HandPipeline = HandPipeline;
});
var require_anchors = __commonJS((exports) => {
  exports.anchors = [
    {
      w: 1,
      h: 1,
      x_center: 0.015625,
      y_center: 0.015625
    },
    {
      w: 1,
      h: 1,
      x_center: 0.015625,
      y_center: 0.015625
    },
    {
      w: 1,
      h: 1,
      x_center: 0.046875,
      y_center: 0.015625
    },
    {
      w: 1,
      h: 1,
      x_center: 0.046875,
      y_center: 0.015625
    },
    {
      w: 1,
      h: 1,
      x_center: 0.078125,
      y_center: 0.015625
    },
    {
      w: 1,
      h: 1,
      x_center: 0.078125,
      y_center: 0.015625
    },
    {
      w: 1,
      h: 1,
      x_center: 0.109375,
      y_center: 0.015625
    },
    {
      w: 1,
      h: 1,
      x_center: 0.109375,
      y_center: 0.015625
    },
    {
      w: 1,
      h: 1,
      x_center: 0.140625,
      y_center: 0.015625
    },
    {
      w: 1,
      h: 1,
      x_center: 0.140625,
      y_center: 0.015625
    },
    {
      w: 1,
      h: 1,
      x_center: 0.171875,
      y_center: 0.015625
    },
    {
      w: 1,
      h: 1,
      x_center: 0.171875,
      y_center: 0.015625
    },
    {
      w: 1,
      h: 1,
      x_center: 0.203125,
      y_center: 0.015625
    },
    {
      w: 1,
      h: 1,
      x_center: 0.203125,
      y_center: 0.015625
    },
    {
      w: 1,
      h: 1,
      x_center: 0.234375,
      y_center: 0.015625
    },
    {
      w: 1,
      h: 1,
      x_center: 0.234375,
      y_center: 0.015625
    },
    {
      w: 1,
      h: 1,
      x_center: 0.265625,
      y_center: 0.015625
    },
    {
      w: 1,
      h: 1,
      x_center: 0.265625,
      y_center: 0.015625
    },
    {
      w: 1,
      h: 1,
      x_center: 0.296875,
      y_center: 0.015625
    },
    {
      w: 1,
      h: 1,
      x_center: 0.296875,
      y_center: 0.015625
    },
    {
      w: 1,
      h: 1,
      x_center: 0.328125,
      y_center: 0.015625
    },
    {
      w: 1,
      h: 1,
      x_center: 0.328125,
      y_center: 0.015625
    },
    {
      w: 1,
      h: 1,
      x_center: 0.359375,
      y_center: 0.015625
    },
    {
      w: 1,
      h: 1,
      x_center: 0.359375,
      y_center: 0.015625
    },
    {
      w: 1,
      h: 1,
      x_center: 0.390625,
      y_center: 0.015625
    },
    {
      w: 1,
      h: 1,
      x_center: 0.390625,
      y_center: 0.015625
    },
    {
      w: 1,
      h: 1,
      x_center: 0.421875,
      y_center: 0.015625
    },
    {
      w: 1,
      h: 1,
      x_center: 0.421875,
      y_center: 0.015625
    },
    {
      w: 1,
      h: 1,
      x_center: 0.453125,
      y_center: 0.015625
    },
    {
      w: 1,
      h: 1,
      x_center: 0.453125,
      y_center: 0.015625
    },
    {
      w: 1,
      h: 1,
      x_center: 0.484375,
      y_center: 0.015625
    },
    {
      w: 1,
      h: 1,
      x_center: 0.484375,
      y_center: 0.015625
    },
    {
      w: 1,
      h: 1,
      x_center: 0.515625,
      y_center: 0.015625
    },
    {
      w: 1,
      h: 1,
      x_center: 0.515625,
      y_center: 0.015625
    },
    {
      w: 1,
      h: 1,
      x_center: 0.546875,
      y_center: 0.015625
    },
    {
      w: 1,
      h: 1,
      x_center: 0.546875,
      y_center: 0.015625
    },
    {
      w: 1,
      h: 1,
      x_center: 0.578125,
      y_center: 0.015625
    },
    {
      w: 1,
      h: 1,
      x_center: 0.578125,
      y_center: 0.015625
    },
    {
      w: 1,
      h: 1,
      x_center: 0.609375,
      y_center: 0.015625
    },
    {
      w: 1,
      h: 1,
      x_center: 0.609375,
      y_center: 0.015625
    },
    {
      w: 1,
      h: 1,
      x_center: 0.640625,
      y_center: 0.015625
    },
    {
      w: 1,
      h: 1,
      x_center: 0.640625,
      y_center: 0.015625
    },
    {
      w: 1,
      h: 1,
      x_center: 0.671875,
      y_center: 0.015625
    },
    {
      w: 1,
      h: 1,
      x_center: 0.671875,
      y_center: 0.015625
    },
    {
      w: 1,
      h: 1,
      x_center: 0.703125,
      y_center: 0.015625
    },
    {
      w: 1,
      h: 1,
      x_center: 0.703125,
      y_center: 0.015625
    },
    {
      w: 1,
      h: 1,
      x_center: 0.734375,
      y_center: 0.015625
    },
    {
      w: 1,
      h: 1,
      x_center: 0.734375,
      y_center: 0.015625
    },
    {
      w: 1,
      h: 1,
      x_center: 0.765625,
      y_center: 0.015625
    },
    {
      w: 1,
      h: 1,
      x_center: 0.765625,
      y_center: 0.015625
    },
    {
      w: 1,
      h: 1,
      x_center: 0.796875,
      y_center: 0.015625
    },
    {
      w: 1,
      h: 1,
      x_center: 0.796875,
      y_center: 0.015625
    },
    {
      w: 1,
      h: 1,
      x_center: 0.828125,
      y_center: 0.015625
    },
    {
      w: 1,
      h: 1,
      x_center: 0.828125,
      y_center: 0.015625
    },
    {
      w: 1,
      h: 1,
      x_center: 0.859375,
      y_center: 0.015625
    },
    {
      w: 1,
      h: 1,
      x_center: 0.859375,
      y_center: 0.015625
    },
    {
      w: 1,
      h: 1,
      x_center: 0.890625,
      y_center: 0.015625
    },
    {
      w: 1,
      h: 1,
      x_center: 0.890625,
      y_center: 0.015625
    },
    {
      w: 1,
      h: 1,
      x_center: 0.921875,
      y_center: 0.015625
    },
    {
      w: 1,
      h: 1,
      x_center: 0.921875,
      y_center: 0.015625
    },
    {
      w: 1,
      h: 1,
      x_center: 0.953125,
      y_center: 0.015625
    },
    {
      w: 1,
      h: 1,
      x_center: 0.953125,
      y_center: 0.015625
    },
    {
      w: 1,
      h: 1,
      x_center: 0.984375,
      y_center: 0.015625
    },
    {
      w: 1,
      h: 1,
      x_center: 0.984375,
      y_center: 0.015625
    },
    {
      w: 1,
      h: 1,
      x_center: 0.015625,
      y_center: 0.046875
    },
    {
      w: 1,
      h: 1,
      x_center: 0.015625,
      y_center: 0.046875
    },
    {
      w: 1,
      h: 1,
      x_center: 0.046875,
      y_center: 0.046875
    },
    {
      w: 1,
      h: 1,
      x_center: 0.046875,
      y_center: 0.046875
    },
    {
      w: 1,
      h: 1,
      x_center: 0.078125,
      y_center: 0.046875
    },
    {
      w: 1,
      h: 1,
      x_center: 0.078125,
      y_center: 0.046875
    },
    {
      w: 1,
      h: 1,
      x_center: 0.109375,
      y_center: 0.046875
    },
    {
      w: 1,
      h: 1,
      x_center: 0.109375,
      y_center: 0.046875
    },
    {
      w: 1,
      h: 1,
      x_center: 0.140625,
      y_center: 0.046875
    },
    {
      w: 1,
      h: 1,
      x_center: 0.140625,
      y_center: 0.046875
    },
    {
      w: 1,
      h: 1,
      x_center: 0.171875,
      y_center: 0.046875
    },
    {
      w: 1,
      h: 1,
      x_center: 0.171875,
      y_center: 0.046875
    },
    {
      w: 1,
      h: 1,
      x_center: 0.203125,
      y_center: 0.046875
    },
    {
      w: 1,
      h: 1,
      x_center: 0.203125,
      y_center: 0.046875
    },
    {
      w: 1,
      h: 1,
      x_center: 0.234375,
      y_center: 0.046875
    },
    {
      w: 1,
      h: 1,
      x_center: 0.234375,
      y_center: 0.046875
    },
    {
      w: 1,
      h: 1,
      x_center: 0.265625,
      y_center: 0.046875
    },
    {
      w: 1,
      h: 1,
      x_center: 0.265625,
      y_center: 0.046875
    },
    {
      w: 1,
      h: 1,
      x_center: 0.296875,
      y_center: 0.046875
    },
    {
      w: 1,
      h: 1,
      x_center: 0.296875,
      y_center: 0.046875
    },
    {
      w: 1,
      h: 1,
      x_center: 0.328125,
      y_center: 0.046875
    },
    {
      w: 1,
      h: 1,
      x_center: 0.328125,
      y_center: 0.046875
    },
    {
      w: 1,
      h: 1,
      x_center: 0.359375,
      y_center: 0.046875
    },
    {
      w: 1,
      h: 1,
      x_center: 0.359375,
      y_center: 0.046875
    },
    {
      w: 1,
      h: 1,
      x_center: 0.390625,
      y_center: 0.046875
    },
    {
      w: 1,
      h: 1,
      x_center: 0.390625,
      y_center: 0.046875
    },
    {
      w: 1,
      h: 1,
      x_center: 0.421875,
      y_center: 0.046875
    },
    {
      w: 1,
      h: 1,
      x_center: 0.421875,
      y_center: 0.046875
    },
    {
      w: 1,
      h: 1,
      x_center: 0.453125,
      y_center: 0.046875
    },
    {
      w: 1,
      h: 1,
      x_center: 0.453125,
      y_center: 0.046875
    },
    {
      w: 1,
      h: 1,
      x_center: 0.484375,
      y_center: 0.046875
    },
    {
      w: 1,
      h: 1,
      x_center: 0.484375,
      y_center: 0.046875
    },
    {
      w: 1,
      h: 1,
      x_center: 0.515625,
      y_center: 0.046875
    },
    {
      w: 1,
      h: 1,
      x_center: 0.515625,
      y_center: 0.046875
    },
    {
      w: 1,
      h: 1,
      x_center: 0.546875,
      y_center: 0.046875
    },
    {
      w: 1,
      h: 1,
      x_center: 0.546875,
      y_center: 0.046875
    },
    {
      w: 1,
      h: 1,
      x_center: 0.578125,
      y_center: 0.046875
    },
    {
      w: 1,
      h: 1,
      x_center: 0.578125,
      y_center: 0.046875
    },
    {
      w: 1,
      h: 1,
      x_center: 0.609375,
      y_center: 0.046875
    },
    {
      w: 1,
      h: 1,
      x_center: 0.609375,
      y_center: 0.046875
    },
    {
      w: 1,
      h: 1,
      x_center: 0.640625,
      y_center: 0.046875
    },
    {
      w: 1,
      h: 1,
      x_center: 0.640625,
      y_center: 0.046875
    },
    {
      w: 1,
      h: 1,
      x_center: 0.671875,
      y_center: 0.046875
    },
    {
      w: 1,
      h: 1,
      x_center: 0.671875,
      y_center: 0.046875
    },
    {
      w: 1,
      h: 1,
      x_center: 0.703125,
      y_center: 0.046875
    },
    {
      w: 1,
      h: 1,
      x_center: 0.703125,
      y_center: 0.046875
    },
    {
      w: 1,
      h: 1,
      x_center: 0.734375,
      y_center: 0.046875
    },
    {
      w: 1,
      h: 1,
      x_center: 0.734375,
      y_center: 0.046875
    },
    {
      w: 1,
      h: 1,
      x_center: 0.765625,
      y_center: 0.046875
    },
    {
      w: 1,
      h: 1,
      x_center: 0.765625,
      y_center: 0.046875
    },
    {
      w: 1,
      h: 1,
      x_center: 0.796875,
      y_center: 0.046875
    },
    {
      w: 1,
      h: 1,
      x_center: 0.796875,
      y_center: 0.046875
    },
    {
      w: 1,
      h: 1,
      x_center: 0.828125,
      y_center: 0.046875
    },
    {
      w: 1,
      h: 1,
      x_center: 0.828125,
      y_center: 0.046875
    },
    {
      w: 1,
      h: 1,
      x_center: 0.859375,
      y_center: 0.046875
    },
    {
      w: 1,
      h: 1,
      x_center: 0.859375,
      y_center: 0.046875
    },
    {
      w: 1,
      h: 1,
      x_center: 0.890625,
      y_center: 0.046875
    },
    {
      w: 1,
      h: 1,
      x_center: 0.890625,
      y_center: 0.046875
    },
    {
      w: 1,
      h: 1,
      x_center: 0.921875,
      y_center: 0.046875
    },
    {
      w: 1,
      h: 1,
      x_center: 0.921875,
      y_center: 0.046875
    },
    {
      w: 1,
      h: 1,
      x_center: 0.953125,
      y_center: 0.046875
    },
    {
      w: 1,
      h: 1,
      x_center: 0.953125,
      y_center: 0.046875
    },
    {
      w: 1,
      h: 1,
      x_center: 0.984375,
      y_center: 0.046875
    },
    {
      w: 1,
      h: 1,
      x_center: 0.984375,
      y_center: 0.046875
    },
    {
      w: 1,
      h: 1,
      x_center: 0.015625,
      y_center: 0.078125
    },
    {
      w: 1,
      h: 1,
      x_center: 0.015625,
      y_center: 0.078125
    },
    {
      w: 1,
      h: 1,
      x_center: 0.046875,
      y_center: 0.078125
    },
    {
      w: 1,
      h: 1,
      x_center: 0.046875,
      y_center: 0.078125
    },
    {
      w: 1,
      h: 1,
      x_center: 0.078125,
      y_center: 0.078125
    },
    {
      w: 1,
      h: 1,
      x_center: 0.078125,
      y_center: 0.078125
    },
    {
      w: 1,
      h: 1,
      x_center: 0.109375,
      y_center: 0.078125
    },
    {
      w: 1,
      h: 1,
      x_center: 0.109375,
      y_center: 0.078125
    },
    {
      w: 1,
      h: 1,
      x_center: 0.140625,
      y_center: 0.078125
    },
    {
      w: 1,
      h: 1,
      x_center: 0.140625,
      y_center: 0.078125
    },
    {
      w: 1,
      h: 1,
      x_center: 0.171875,
      y_center: 0.078125
    },
    {
      w: 1,
      h: 1,
      x_center: 0.171875,
      y_center: 0.078125
    },
    {
      w: 1,
      h: 1,
      x_center: 0.203125,
      y_center: 0.078125
    },
    {
      w: 1,
      h: 1,
      x_center: 0.203125,
      y_center: 0.078125
    },
    {
      w: 1,
      h: 1,
      x_center: 0.234375,
      y_center: 0.078125
    },
    {
      w: 1,
      h: 1,
      x_center: 0.234375,
      y_center: 0.078125
    },
    {
      w: 1,
      h: 1,
      x_center: 0.265625,
      y_center: 0.078125
    },
    {
      w: 1,
      h: 1,
      x_center: 0.265625,
      y_center: 0.078125
    },
    {
      w: 1,
      h: 1,
      x_center: 0.296875,
      y_center: 0.078125
    },
    {
      w: 1,
      h: 1,
      x_center: 0.296875,
      y_center: 0.078125
    },
    {
      w: 1,
      h: 1,
      x_center: 0.328125,
      y_center: 0.078125
    },
    {
      w: 1,
      h: 1,
      x_center: 0.328125,
      y_center: 0.078125
    },
    {
      w: 1,
      h: 1,
      x_center: 0.359375,
      y_center: 0.078125
    },
    {
      w: 1,
      h: 1,
      x_center: 0.359375,
      y_center: 0.078125
    },
    {
      w: 1,
      h: 1,
      x_center: 0.390625,
      y_center: 0.078125
    },
    {
      w: 1,
      h: 1,
      x_center: 0.390625,
      y_center: 0.078125
    },
    {
      w: 1,
      h: 1,
      x_center: 0.421875,
      y_center: 0.078125
    },
    {
      w: 1,
      h: 1,
      x_center: 0.421875,
      y_center: 0.078125
    },
    {
      w: 1,
      h: 1,
      x_center: 0.453125,
      y_center: 0.078125
    },
    {
      w: 1,
      h: 1,
      x_center: 0.453125,
      y_center: 0.078125
    },
    {
      w: 1,
      h: 1,
      x_center: 0.484375,
      y_center: 0.078125
    },
    {
      w: 1,
      h: 1,
      x_center: 0.484375,
      y_center: 0.078125
    },
    {
      w: 1,
      h: 1,
      x_center: 0.515625,
      y_center: 0.078125
    },
    {
      w: 1,
      h: 1,
      x_center: 0.515625,
      y_center: 0.078125
    },
    {
      w: 1,
      h: 1,
      x_center: 0.546875,
      y_center: 0.078125
    },
    {
      w: 1,
      h: 1,
      x_center: 0.546875,
      y_center: 0.078125
    },
    {
      w: 1,
      h: 1,
      x_center: 0.578125,
      y_center: 0.078125
    },
    {
      w: 1,
      h: 1,
      x_center: 0.578125,
      y_center: 0.078125
    },
    {
      w: 1,
      h: 1,
      x_center: 0.609375,
      y_center: 0.078125
    },
    {
      w: 1,
      h: 1,
      x_center: 0.609375,
      y_center: 0.078125
    },
    {
      w: 1,
      h: 1,
      x_center: 0.640625,
      y_center: 0.078125
    },
    {
      w: 1,
      h: 1,
      x_center: 0.640625,
      y_center: 0.078125
    },
    {
      w: 1,
      h: 1,
      x_center: 0.671875,
      y_center: 0.078125
    },
    {
      w: 1,
      h: 1,
      x_center: 0.671875,
      y_center: 0.078125
    },
    {
      w: 1,
      h: 1,
      x_center: 0.703125,
      y_center: 0.078125
    },
    {
      w: 1,
      h: 1,
      x_center: 0.703125,
      y_center: 0.078125
    },
    {
      w: 1,
      h: 1,
      x_center: 0.734375,
      y_center: 0.078125
    },
    {
      w: 1,
      h: 1,
      x_center: 0.734375,
      y_center: 0.078125
    },
    {
      w: 1,
      h: 1,
      x_center: 0.765625,
      y_center: 0.078125
    },
    {
      w: 1,
      h: 1,
      x_center: 0.765625,
      y_center: 0.078125
    },
    {
      w: 1,
      h: 1,
      x_center: 0.796875,
      y_center: 0.078125
    },
    {
      w: 1,
      h: 1,
      x_center: 0.796875,
      y_center: 0.078125
    },
    {
      w: 1,
      h: 1,
      x_center: 0.828125,
      y_center: 0.078125
    },
    {
      w: 1,
      h: 1,
      x_center: 0.828125,
      y_center: 0.078125
    },
    {
      w: 1,
      h: 1,
      x_center: 0.859375,
      y_center: 0.078125
    },
    {
      w: 1,
      h: 1,
      x_center: 0.859375,
      y_center: 0.078125
    },
    {
      w: 1,
      h: 1,
      x_center: 0.890625,
      y_center: 0.078125
    },
    {
      w: 1,
      h: 1,
      x_center: 0.890625,
      y_center: 0.078125
    },
    {
      w: 1,
      h: 1,
      x_center: 0.921875,
      y_center: 0.078125
    },
    {
      w: 1,
      h: 1,
      x_center: 0.921875,
      y_center: 0.078125
    },
    {
      w: 1,
      h: 1,
      x_center: 0.953125,
      y_center: 0.078125
    },
    {
      w: 1,
      h: 1,
      x_center: 0.953125,
      y_center: 0.078125
    },
    {
      w: 1,
      h: 1,
      x_center: 0.984375,
      y_center: 0.078125
    },
    {
      w: 1,
      h: 1,
      x_center: 0.984375,
      y_center: 0.078125
    },
    {
      w: 1,
      h: 1,
      x_center: 0.015625,
      y_center: 0.109375
    },
    {
      w: 1,
      h: 1,
      x_center: 0.015625,
      y_center: 0.109375
    },
    {
      w: 1,
      h: 1,
      x_center: 0.046875,
      y_center: 0.109375
    },
    {
      w: 1,
      h: 1,
      x_center: 0.046875,
      y_center: 0.109375
    },
    {
      w: 1,
      h: 1,
      x_center: 0.078125,
      y_center: 0.109375
    },
    {
      w: 1,
      h: 1,
      x_center: 0.078125,
      y_center: 0.109375
    },
    {
      w: 1,
      h: 1,
      x_center: 0.109375,
      y_center: 0.109375
    },
    {
      w: 1,
      h: 1,
      x_center: 0.109375,
      y_center: 0.109375
    },
    {
      w: 1,
      h: 1,
      x_center: 0.140625,
      y_center: 0.109375
    },
    {
      w: 1,
      h: 1,
      x_center: 0.140625,
      y_center: 0.109375
    },
    {
      w: 1,
      h: 1,
      x_center: 0.171875,
      y_center: 0.109375
    },
    {
      w: 1,
      h: 1,
      x_center: 0.171875,
      y_center: 0.109375
    },
    {
      w: 1,
      h: 1,
      x_center: 0.203125,
      y_center: 0.109375
    },
    {
      w: 1,
      h: 1,
      x_center: 0.203125,
      y_center: 0.109375
    },
    {
      w: 1,
      h: 1,
      x_center: 0.234375,
      y_center: 0.109375
    },
    {
      w: 1,
      h: 1,
      x_center: 0.234375,
      y_center: 0.109375
    },
    {
      w: 1,
      h: 1,
      x_center: 0.265625,
      y_center: 0.109375
    },
    {
      w: 1,
      h: 1,
      x_center: 0.265625,
      y_center: 0.109375
    },
    {
      w: 1,
      h: 1,
      x_center: 0.296875,
      y_center: 0.109375
    },
    {
      w: 1,
      h: 1,
      x_center: 0.296875,
      y_center: 0.109375
    },
    {
      w: 1,
      h: 1,
      x_center: 0.328125,
      y_center: 0.109375
    },
    {
      w: 1,
      h: 1,
      x_center: 0.328125,
      y_center: 0.109375
    },
    {
      w: 1,
      h: 1,
      x_center: 0.359375,
      y_center: 0.109375
    },
    {
      w: 1,
      h: 1,
      x_center: 0.359375,
      y_center: 0.109375
    },
    {
      w: 1,
      h: 1,
      x_center: 0.390625,
      y_center: 0.109375
    },
    {
      w: 1,
      h: 1,
      x_center: 0.390625,
      y_center: 0.109375
    },
    {
      w: 1,
      h: 1,
      x_center: 0.421875,
      y_center: 0.109375
    },
    {
      w: 1,
      h: 1,
      x_center: 0.421875,
      y_center: 0.109375
    },
    {
      w: 1,
      h: 1,
      x_center: 0.453125,
      y_center: 0.109375
    },
    {
      w: 1,
      h: 1,
      x_center: 0.453125,
      y_center: 0.109375
    },
    {
      w: 1,
      h: 1,
      x_center: 0.484375,
      y_center: 0.109375
    },
    {
      w: 1,
      h: 1,
      x_center: 0.484375,
      y_center: 0.109375
    },
    {
      w: 1,
      h: 1,
      x_center: 0.515625,
      y_center: 0.109375
    },
    {
      w: 1,
      h: 1,
      x_center: 0.515625,
      y_center: 0.109375
    },
    {
      w: 1,
      h: 1,
      x_center: 0.546875,
      y_center: 0.109375
    },
    {
      w: 1,
      h: 1,
      x_center: 0.546875,
      y_center: 0.109375
    },
    {
      w: 1,
      h: 1,
      x_center: 0.578125,
      y_center: 0.109375
    },
    {
      w: 1,
      h: 1,
      x_center: 0.578125,
      y_center: 0.109375
    },
    {
      w: 1,
      h: 1,
      x_center: 0.609375,
      y_center: 0.109375
    },
    {
      w: 1,
      h: 1,
      x_center: 0.609375,
      y_center: 0.109375
    },
    {
      w: 1,
      h: 1,
      x_center: 0.640625,
      y_center: 0.109375
    },
    {
      w: 1,
      h: 1,
      x_center: 0.640625,
      y_center: 0.109375
    },
    {
      w: 1,
      h: 1,
      x_center: 0.671875,
      y_center: 0.109375
    },
    {
      w: 1,
      h: 1,
      x_center: 0.671875,
      y_center: 0.109375
    },
    {
      w: 1,
      h: 1,
      x_center: 0.703125,
      y_center: 0.109375
    },
    {
      w: 1,
      h: 1,
      x_center: 0.703125,
      y_center: 0.109375
    },
    {
      w: 1,
      h: 1,
      x_center: 0.734375,
      y_center: 0.109375
    },
    {
      w: 1,
      h: 1,
      x_center: 0.734375,
      y_center: 0.109375
    },
    {
      w: 1,
      h: 1,
      x_center: 0.765625,
      y_center: 0.109375
    },
    {
      w: 1,
      h: 1,
      x_center: 0.765625,
      y_center: 0.109375
    },
    {
      w: 1,
      h: 1,
      x_center: 0.796875,
      y_center: 0.109375
    },
    {
      w: 1,
      h: 1,
      x_center: 0.796875,
      y_center: 0.109375
    },
    {
      w: 1,
      h: 1,
      x_center: 0.828125,
      y_center: 0.109375
    },
    {
      w: 1,
      h: 1,
      x_center: 0.828125,
      y_center: 0.109375
    },
    {
      w: 1,
      h: 1,
      x_center: 0.859375,
      y_center: 0.109375
    },
    {
      w: 1,
      h: 1,
      x_center: 0.859375,
      y_center: 0.109375
    },
    {
      w: 1,
      h: 1,
      x_center: 0.890625,
      y_center: 0.109375
    },
    {
      w: 1,
      h: 1,
      x_center: 0.890625,
      y_center: 0.109375
    },
    {
      w: 1,
      h: 1,
      x_center: 0.921875,
      y_center: 0.109375
    },
    {
      w: 1,
      h: 1,
      x_center: 0.921875,
      y_center: 0.109375
    },
    {
      w: 1,
      h: 1,
      x_center: 0.953125,
      y_center: 0.109375
    },
    {
      w: 1,
      h: 1,
      x_center: 0.953125,
      y_center: 0.109375
    },
    {
      w: 1,
      h: 1,
      x_center: 0.984375,
      y_center: 0.109375
    },
    {
      w: 1,
      h: 1,
      x_center: 0.984375,
      y_center: 0.109375
    },
    {
      w: 1,
      h: 1,
      x_center: 0.015625,
      y_center: 0.140625
    },
    {
      w: 1,
      h: 1,
      x_center: 0.015625,
      y_center: 0.140625
    },
    {
      w: 1,
      h: 1,
      x_center: 0.046875,
      y_center: 0.140625
    },
    {
      w: 1,
      h: 1,
      x_center: 0.046875,
      y_center: 0.140625
    },
    {
      w: 1,
      h: 1,
      x_center: 0.078125,
      y_center: 0.140625
    },
    {
      w: 1,
      h: 1,
      x_center: 0.078125,
      y_center: 0.140625
    },
    {
      w: 1,
      h: 1,
      x_center: 0.109375,
      y_center: 0.140625
    },
    {
      w: 1,
      h: 1,
      x_center: 0.109375,
      y_center: 0.140625
    },
    {
      w: 1,
      h: 1,
      x_center: 0.140625,
      y_center: 0.140625
    },
    {
      w: 1,
      h: 1,
      x_center: 0.140625,
      y_center: 0.140625
    },
    {
      w: 1,
      h: 1,
      x_center: 0.171875,
      y_center: 0.140625
    },
    {
      w: 1,
      h: 1,
      x_center: 0.171875,
      y_center: 0.140625
    },
    {
      w: 1,
      h: 1,
      x_center: 0.203125,
      y_center: 0.140625
    },
    {
      w: 1,
      h: 1,
      x_center: 0.203125,
      y_center: 0.140625
    },
    {
      w: 1,
      h: 1,
      x_center: 0.234375,
      y_center: 0.140625
    },
    {
      w: 1,
      h: 1,
      x_center: 0.234375,
      y_center: 0.140625
    },
    {
      w: 1,
      h: 1,
      x_center: 0.265625,
      y_center: 0.140625
    },
    {
      w: 1,
      h: 1,
      x_center: 0.265625,
      y_center: 0.140625
    },
    {
      w: 1,
      h: 1,
      x_center: 0.296875,
      y_center: 0.140625
    },
    {
      w: 1,
      h: 1,
      x_center: 0.296875,
      y_center: 0.140625
    },
    {
      w: 1,
      h: 1,
      x_center: 0.328125,
      y_center: 0.140625
    },
    {
      w: 1,
      h: 1,
      x_center: 0.328125,
      y_center: 0.140625
    },
    {
      w: 1,
      h: 1,
      x_center: 0.359375,
      y_center: 0.140625
    },
    {
      w: 1,
      h: 1,
      x_center: 0.359375,
      y_center: 0.140625
    },
    {
      w: 1,
      h: 1,
      x_center: 0.390625,
      y_center: 0.140625
    },
    {
      w: 1,
      h: 1,
      x_center: 0.390625,
      y_center: 0.140625
    },
    {
      w: 1,
      h: 1,
      x_center: 0.421875,
      y_center: 0.140625
    },
    {
      w: 1,
      h: 1,
      x_center: 0.421875,
      y_center: 0.140625
    },
    {
      w: 1,
      h: 1,
      x_center: 0.453125,
      y_center: 0.140625
    },
    {
      w: 1,
      h: 1,
      x_center: 0.453125,
      y_center: 0.140625
    },
    {
      w: 1,
      h: 1,
      x_center: 0.484375,
      y_center: 0.140625
    },
    {
      w: 1,
      h: 1,
      x_center: 0.484375,
      y_center: 0.140625
    },
    {
      w: 1,
      h: 1,
      x_center: 0.515625,
      y_center: 0.140625
    },
    {
      w: 1,
      h: 1,
      x_center: 0.515625,
      y_center: 0.140625
    },
    {
      w: 1,
      h: 1,
      x_center: 0.546875,
      y_center: 0.140625
    },
    {
      w: 1,
      h: 1,
      x_center: 0.546875,
      y_center: 0.140625
    },
    {
      w: 1,
      h: 1,
      x_center: 0.578125,
      y_center: 0.140625
    },
    {
      w: 1,
      h: 1,
      x_center: 0.578125,
      y_center: 0.140625
    },
    {
      w: 1,
      h: 1,
      x_center: 0.609375,
      y_center: 0.140625
    },
    {
      w: 1,
      h: 1,
      x_center: 0.609375,
      y_center: 0.140625
    },
    {
      w: 1,
      h: 1,
      x_center: 0.640625,
      y_center: 0.140625
    },
    {
      w: 1,
      h: 1,
      x_center: 0.640625,
      y_center: 0.140625
    },
    {
      w: 1,
      h: 1,
      x_center: 0.671875,
      y_center: 0.140625
    },
    {
      w: 1,
      h: 1,
      x_center: 0.671875,
      y_center: 0.140625
    },
    {
      w: 1,
      h: 1,
      x_center: 0.703125,
      y_center: 0.140625
    },
    {
      w: 1,
      h: 1,
      x_center: 0.703125,
      y_center: 0.140625
    },
    {
      w: 1,
      h: 1,
      x_center: 0.734375,
      y_center: 0.140625
    },
    {
      w: 1,
      h: 1,
      x_center: 0.734375,
      y_center: 0.140625
    },
    {
      w: 1,
      h: 1,
      x_center: 0.765625,
      y_center: 0.140625
    },
    {
      w: 1,
      h: 1,
      x_center: 0.765625,
      y_center: 0.140625
    },
    {
      w: 1,
      h: 1,
      x_center: 0.796875,
      y_center: 0.140625
    },
    {
      w: 1,
      h: 1,
      x_center: 0.796875,
      y_center: 0.140625
    },
    {
      w: 1,
      h: 1,
      x_center: 0.828125,
      y_center: 0.140625
    },
    {
      w: 1,
      h: 1,
      x_center: 0.828125,
      y_center: 0.140625
    },
    {
      w: 1,
      h: 1,
      x_center: 0.859375,
      y_center: 0.140625
    },
    {
      w: 1,
      h: 1,
      x_center: 0.859375,
      y_center: 0.140625
    },
    {
      w: 1,
      h: 1,
      x_center: 0.890625,
      y_center: 0.140625
    },
    {
      w: 1,
      h: 1,
      x_center: 0.890625,
      y_center: 0.140625
    },
    {
      w: 1,
      h: 1,
      x_center: 0.921875,
      y_center: 0.140625
    },
    {
      w: 1,
      h: 1,
      x_center: 0.921875,
      y_center: 0.140625
    },
    {
      w: 1,
      h: 1,
      x_center: 0.953125,
      y_center: 0.140625
    },
    {
      w: 1,
      h: 1,
      x_center: 0.953125,
      y_center: 0.140625
    },
    {
      w: 1,
      h: 1,
      x_center: 0.984375,
      y_center: 0.140625
    },
    {
      w: 1,
      h: 1,
      x_center: 0.984375,
      y_center: 0.140625
    },
    {
      w: 1,
      h: 1,
      x_center: 0.015625,
      y_center: 0.171875
    },
    {
      w: 1,
      h: 1,
      x_center: 0.015625,
      y_center: 0.171875
    },
    {
      w: 1,
      h: 1,
      x_center: 0.046875,
      y_center: 0.171875
    },
    {
      w: 1,
      h: 1,
      x_center: 0.046875,
      y_center: 0.171875
    },
    {
      w: 1,
      h: 1,
      x_center: 0.078125,
      y_center: 0.171875
    },
    {
      w: 1,
      h: 1,
      x_center: 0.078125,
      y_center: 0.171875
    },
    {
      w: 1,
      h: 1,
      x_center: 0.109375,
      y_center: 0.171875
    },
    {
      w: 1,
      h: 1,
      x_center: 0.109375,
      y_center: 0.171875
    },
    {
      w: 1,
      h: 1,
      x_center: 0.140625,
      y_center: 0.171875
    },
    {
      w: 1,
      h: 1,
      x_center: 0.140625,
      y_center: 0.171875
    },
    {
      w: 1,
      h: 1,
      x_center: 0.171875,
      y_center: 0.171875
    },
    {
      w: 1,
      h: 1,
      x_center: 0.171875,
      y_center: 0.171875
    },
    {
      w: 1,
      h: 1,
      x_center: 0.203125,
      y_center: 0.171875
    },
    {
      w: 1,
      h: 1,
      x_center: 0.203125,
      y_center: 0.171875
    },
    {
      w: 1,
      h: 1,
      x_center: 0.234375,
      y_center: 0.171875
    },
    {
      w: 1,
      h: 1,
      x_center: 0.234375,
      y_center: 0.171875
    },
    {
      w: 1,
      h: 1,
      x_center: 0.265625,
      y_center: 0.171875
    },
    {
      w: 1,
      h: 1,
      x_center: 0.265625,
      y_center: 0.171875
    },
    {
      w: 1,
      h: 1,
      x_center: 0.296875,
      y_center: 0.171875
    },
    {
      w: 1,
      h: 1,
      x_center: 0.296875,
      y_center: 0.171875
    },
    {
      w: 1,
      h: 1,
      x_center: 0.328125,
      y_center: 0.171875
    },
    {
      w: 1,
      h: 1,
      x_center: 0.328125,
      y_center: 0.171875
    },
    {
      w: 1,
      h: 1,
      x_center: 0.359375,
      y_center: 0.171875
    },
    {
      w: 1,
      h: 1,
      x_center: 0.359375,
      y_center: 0.171875
    },
    {
      w: 1,
      h: 1,
      x_center: 0.390625,
      y_center: 0.171875
    },
    {
      w: 1,
      h: 1,
      x_center: 0.390625,
      y_center: 0.171875
    },
    {
      w: 1,
      h: 1,
      x_center: 0.421875,
      y_center: 0.171875
    },
    {
      w: 1,
      h: 1,
      x_center: 0.421875,
      y_center: 0.171875
    },
    {
      w: 1,
      h: 1,
      x_center: 0.453125,
      y_center: 0.171875
    },
    {
      w: 1,
      h: 1,
      x_center: 0.453125,
      y_center: 0.171875
    },
    {
      w: 1,
      h: 1,
      x_center: 0.484375,
      y_center: 0.171875
    },
    {
      w: 1,
      h: 1,
      x_center: 0.484375,
      y_center: 0.171875
    },
    {
      w: 1,
      h: 1,
      x_center: 0.515625,
      y_center: 0.171875
    },
    {
      w: 1,
      h: 1,
      x_center: 0.515625,
      y_center: 0.171875
    },
    {
      w: 1,
      h: 1,
      x_center: 0.546875,
      y_center: 0.171875
    },
    {
      w: 1,
      h: 1,
      x_center: 0.546875,
      y_center: 0.171875
    },
    {
      w: 1,
      h: 1,
      x_center: 0.578125,
      y_center: 0.171875
    },
    {
      w: 1,
      h: 1,
      x_center: 0.578125,
      y_center: 0.171875
    },
    {
      w: 1,
      h: 1,
      x_center: 0.609375,
      y_center: 0.171875
    },
    {
      w: 1,
      h: 1,
      x_center: 0.609375,
      y_center: 0.171875
    },
    {
      w: 1,
      h: 1,
      x_center: 0.640625,
      y_center: 0.171875
    },
    {
      w: 1,
      h: 1,
      x_center: 0.640625,
      y_center: 0.171875
    },
    {
      w: 1,
      h: 1,
      x_center: 0.671875,
      y_center: 0.171875
    },
    {
      w: 1,
      h: 1,
      x_center: 0.671875,
      y_center: 0.171875
    },
    {
      w: 1,
      h: 1,
      x_center: 0.703125,
      y_center: 0.171875
    },
    {
      w: 1,
      h: 1,
      x_center: 0.703125,
      y_center: 0.171875
    },
    {
      w: 1,
      h: 1,
      x_center: 0.734375,
      y_center: 0.171875
    },
    {
      w: 1,
      h: 1,
      x_center: 0.734375,
      y_center: 0.171875
    },
    {
      w: 1,
      h: 1,
      x_center: 0.765625,
      y_center: 0.171875
    },
    {
      w: 1,
      h: 1,
      x_center: 0.765625,
      y_center: 0.171875
    },
    {
      w: 1,
      h: 1,
      x_center: 0.796875,
      y_center: 0.171875
    },
    {
      w: 1,
      h: 1,
      x_center: 0.796875,
      y_center: 0.171875
    },
    {
      w: 1,
      h: 1,
      x_center: 0.828125,
      y_center: 0.171875
    },
    {
      w: 1,
      h: 1,
      x_center: 0.828125,
      y_center: 0.171875
    },
    {
      w: 1,
      h: 1,
      x_center: 0.859375,
      y_center: 0.171875
    },
    {
      w: 1,
      h: 1,
      x_center: 0.859375,
      y_center: 0.171875
    },
    {
      w: 1,
      h: 1,
      x_center: 0.890625,
      y_center: 0.171875
    },
    {
      w: 1,
      h: 1,
      x_center: 0.890625,
      y_center: 0.171875
    },
    {
      w: 1,
      h: 1,
      x_center: 0.921875,
      y_center: 0.171875
    },
    {
      w: 1,
      h: 1,
      x_center: 0.921875,
      y_center: 0.171875
    },
    {
      w: 1,
      h: 1,
      x_center: 0.953125,
      y_center: 0.171875
    },
    {
      w: 1,
      h: 1,
      x_center: 0.953125,
      y_center: 0.171875
    },
    {
      w: 1,
      h: 1,
      x_center: 0.984375,
      y_center: 0.171875
    },
    {
      w: 1,
      h: 1,
      x_center: 0.984375,
      y_center: 0.171875
    },
    {
      w: 1,
      h: 1,
      x_center: 0.015625,
      y_center: 0.203125
    },
    {
      w: 1,
      h: 1,
      x_center: 0.015625,
      y_center: 0.203125
    },
    {
      w: 1,
      h: 1,
      x_center: 0.046875,
      y_center: 0.203125
    },
    {
      w: 1,
      h: 1,
      x_center: 0.046875,
      y_center: 0.203125
    },
    {
      w: 1,
      h: 1,
      x_center: 0.078125,
      y_center: 0.203125
    },
    {
      w: 1,
      h: 1,
      x_center: 0.078125,
      y_center: 0.203125
    },
    {
      w: 1,
      h: 1,
      x_center: 0.109375,
      y_center: 0.203125
    },
    {
      w: 1,
      h: 1,
      x_center: 0.109375,
      y_center: 0.203125
    },
    {
      w: 1,
      h: 1,
      x_center: 0.140625,
      y_center: 0.203125
    },
    {
      w: 1,
      h: 1,
      x_center: 0.140625,
      y_center: 0.203125
    },
    {
      w: 1,
      h: 1,
      x_center: 0.171875,
      y_center: 0.203125
    },
    {
      w: 1,
      h: 1,
      x_center: 0.171875,
      y_center: 0.203125
    },
    {
      w: 1,
      h: 1,
      x_center: 0.203125,
      y_center: 0.203125
    },
    {
      w: 1,
      h: 1,
      x_center: 0.203125,
      y_center: 0.203125
    },
    {
      w: 1,
      h: 1,
      x_center: 0.234375,
      y_center: 0.203125
    },
    {
      w: 1,
      h: 1,
      x_center: 0.234375,
      y_center: 0.203125
    },
    {
      w: 1,
      h: 1,
      x_center: 0.265625,
      y_center: 0.203125
    },
    {
      w: 1,
      h: 1,
      x_center: 0.265625,
      y_center: 0.203125
    },
    {
      w: 1,
      h: 1,
      x_center: 0.296875,
      y_center: 0.203125
    },
    {
      w: 1,
      h: 1,
      x_center: 0.296875,
      y_center: 0.203125
    },
    {
      w: 1,
      h: 1,
      x_center: 0.328125,
      y_center: 0.203125
    },
    {
      w: 1,
      h: 1,
      x_center: 0.328125,
      y_center: 0.203125
    },
    {
      w: 1,
      h: 1,
      x_center: 0.359375,
      y_center: 0.203125
    },
    {
      w: 1,
      h: 1,
      x_center: 0.359375,
      y_center: 0.203125
    },
    {
      w: 1,
      h: 1,
      x_center: 0.390625,
      y_center: 0.203125
    },
    {
      w: 1,
      h: 1,
      x_center: 0.390625,
      y_center: 0.203125
    },
    {
      w: 1,
      h: 1,
      x_center: 0.421875,
      y_center: 0.203125
    },
    {
      w: 1,
      h: 1,
      x_center: 0.421875,
      y_center: 0.203125
    },
    {
      w: 1,
      h: 1,
      x_center: 0.453125,
      y_center: 0.203125
    },
    {
      w: 1,
      h: 1,
      x_center: 0.453125,
      y_center: 0.203125
    },
    {
      w: 1,
      h: 1,
      x_center: 0.484375,
      y_center: 0.203125
    },
    {
      w: 1,
      h: 1,
      x_center: 0.484375,
      y_center: 0.203125
    },
    {
      w: 1,
      h: 1,
      x_center: 0.515625,
      y_center: 0.203125
    },
    {
      w: 1,
      h: 1,
      x_center: 0.515625,
      y_center: 0.203125
    },
    {
      w: 1,
      h: 1,
      x_center: 0.546875,
      y_center: 0.203125
    },
    {
      w: 1,
      h: 1,
      x_center: 0.546875,
      y_center: 0.203125
    },
    {
      w: 1,
      h: 1,
      x_center: 0.578125,
      y_center: 0.203125
    },
    {
      w: 1,
      h: 1,
      x_center: 0.578125,
      y_center: 0.203125
    },
    {
      w: 1,
      h: 1,
      x_center: 0.609375,
      y_center: 0.203125
    },
    {
      w: 1,
      h: 1,
      x_center: 0.609375,
      y_center: 0.203125
    },
    {
      w: 1,
      h: 1,
      x_center: 0.640625,
      y_center: 0.203125
    },
    {
      w: 1,
      h: 1,
      x_center: 0.640625,
      y_center: 0.203125
    },
    {
      w: 1,
      h: 1,
      x_center: 0.671875,
      y_center: 0.203125
    },
    {
      w: 1,
      h: 1,
      x_center: 0.671875,
      y_center: 0.203125
    },
    {
      w: 1,
      h: 1,
      x_center: 0.703125,
      y_center: 0.203125
    },
    {
      w: 1,
      h: 1,
      x_center: 0.703125,
      y_center: 0.203125
    },
    {
      w: 1,
      h: 1,
      x_center: 0.734375,
      y_center: 0.203125
    },
    {
      w: 1,
      h: 1,
      x_center: 0.734375,
      y_center: 0.203125
    },
    {
      w: 1,
      h: 1,
      x_center: 0.765625,
      y_center: 0.203125
    },
    {
      w: 1,
      h: 1,
      x_center: 0.765625,
      y_center: 0.203125
    },
    {
      w: 1,
      h: 1,
      x_center: 0.796875,
      y_center: 0.203125
    },
    {
      w: 1,
      h: 1,
      x_center: 0.796875,
      y_center: 0.203125
    },
    {
      w: 1,
      h: 1,
      x_center: 0.828125,
      y_center: 0.203125
    },
    {
      w: 1,
      h: 1,
      x_center: 0.828125,
      y_center: 0.203125
    },
    {
      w: 1,
      h: 1,
      x_center: 0.859375,
      y_center: 0.203125
    },
    {
      w: 1,
      h: 1,
      x_center: 0.859375,
      y_center: 0.203125
    },
    {
      w: 1,
      h: 1,
      x_center: 0.890625,
      y_center: 0.203125
    },
    {
      w: 1,
      h: 1,
      x_center: 0.890625,
      y_center: 0.203125
    },
    {
      w: 1,
      h: 1,
      x_center: 0.921875,
      y_center: 0.203125
    },
    {
      w: 1,
      h: 1,
      x_center: 0.921875,
      y_center: 0.203125
    },
    {
      w: 1,
      h: 1,
      x_center: 0.953125,
      y_center: 0.203125
    },
    {
      w: 1,
      h: 1,
      x_center: 0.953125,
      y_center: 0.203125
    },
    {
      w: 1,
      h: 1,
      x_center: 0.984375,
      y_center: 0.203125
    },
    {
      w: 1,
      h: 1,
      x_center: 0.984375,
      y_center: 0.203125
    },
    {
      w: 1,
      h: 1,
      x_center: 0.015625,
      y_center: 0.234375
    },
    {
      w: 1,
      h: 1,
      x_center: 0.015625,
      y_center: 0.234375
    },
    {
      w: 1,
      h: 1,
      x_center: 0.046875,
      y_center: 0.234375
    },
    {
      w: 1,
      h: 1,
      x_center: 0.046875,
      y_center: 0.234375
    },
    {
      w: 1,
      h: 1,
      x_center: 0.078125,
      y_center: 0.234375
    },
    {
      w: 1,
      h: 1,
      x_center: 0.078125,
      y_center: 0.234375
    },
    {
      w: 1,
      h: 1,
      x_center: 0.109375,
      y_center: 0.234375
    },
    {
      w: 1,
      h: 1,
      x_center: 0.109375,
      y_center: 0.234375
    },
    {
      w: 1,
      h: 1,
      x_center: 0.140625,
      y_center: 0.234375
    },
    {
      w: 1,
      h: 1,
      x_center: 0.140625,
      y_center: 0.234375
    },
    {
      w: 1,
      h: 1,
      x_center: 0.171875,
      y_center: 0.234375
    },
    {
      w: 1,
      h: 1,
      x_center: 0.171875,
      y_center: 0.234375
    },
    {
      w: 1,
      h: 1,
      x_center: 0.203125,
      y_center: 0.234375
    },
    {
      w: 1,
      h: 1,
      x_center: 0.203125,
      y_center: 0.234375
    },
    {
      w: 1,
      h: 1,
      x_center: 0.234375,
      y_center: 0.234375
    },
    {
      w: 1,
      h: 1,
      x_center: 0.234375,
      y_center: 0.234375
    },
    {
      w: 1,
      h: 1,
      x_center: 0.265625,
      y_center: 0.234375
    },
    {
      w: 1,
      h: 1,
      x_center: 0.265625,
      y_center: 0.234375
    },
    {
      w: 1,
      h: 1,
      x_center: 0.296875,
      y_center: 0.234375
    },
    {
      w: 1,
      h: 1,
      x_center: 0.296875,
      y_center: 0.234375
    },
    {
      w: 1,
      h: 1,
      x_center: 0.328125,
      y_center: 0.234375
    },
    {
      w: 1,
      h: 1,
      x_center: 0.328125,
      y_center: 0.234375
    },
    {
      w: 1,
      h: 1,
      x_center: 0.359375,
      y_center: 0.234375
    },
    {
      w: 1,
      h: 1,
      x_center: 0.359375,
      y_center: 0.234375
    },
    {
      w: 1,
      h: 1,
      x_center: 0.390625,
      y_center: 0.234375
    },
    {
      w: 1,
      h: 1,
      x_center: 0.390625,
      y_center: 0.234375
    },
    {
      w: 1,
      h: 1,
      x_center: 0.421875,
      y_center: 0.234375
    },
    {
      w: 1,
      h: 1,
      x_center: 0.421875,
      y_center: 0.234375
    },
    {
      w: 1,
      h: 1,
      x_center: 0.453125,
      y_center: 0.234375
    },
    {
      w: 1,
      h: 1,
      x_center: 0.453125,
      y_center: 0.234375
    },
    {
      w: 1,
      h: 1,
      x_center: 0.484375,
      y_center: 0.234375
    },
    {
      w: 1,
      h: 1,
      x_center: 0.484375,
      y_center: 0.234375
    },
    {
      w: 1,
      h: 1,
      x_center: 0.515625,
      y_center: 0.234375
    },
    {
      w: 1,
      h: 1,
      x_center: 0.515625,
      y_center: 0.234375
    },
    {
      w: 1,
      h: 1,
      x_center: 0.546875,
      y_center: 0.234375
    },
    {
      w: 1,
      h: 1,
      x_center: 0.546875,
      y_center: 0.234375
    },
    {
      w: 1,
      h: 1,
      x_center: 0.578125,
      y_center: 0.234375
    },
    {
      w: 1,
      h: 1,
      x_center: 0.578125,
      y_center: 0.234375
    },
    {
      w: 1,
      h: 1,
      x_center: 0.609375,
      y_center: 0.234375
    },
    {
      w: 1,
      h: 1,
      x_center: 0.609375,
      y_center: 0.234375
    },
    {
      w: 1,
      h: 1,
      x_center: 0.640625,
      y_center: 0.234375
    },
    {
      w: 1,
      h: 1,
      x_center: 0.640625,
      y_center: 0.234375
    },
    {
      w: 1,
      h: 1,
      x_center: 0.671875,
      y_center: 0.234375
    },
    {
      w: 1,
      h: 1,
      x_center: 0.671875,
      y_center: 0.234375
    },
    {
      w: 1,
      h: 1,
      x_center: 0.703125,
      y_center: 0.234375
    },
    {
      w: 1,
      h: 1,
      x_center: 0.703125,
      y_center: 0.234375
    },
    {
      w: 1,
      h: 1,
      x_center: 0.734375,
      y_center: 0.234375
    },
    {
      w: 1,
      h: 1,
      x_center: 0.734375,
      y_center: 0.234375
    },
    {
      w: 1,
      h: 1,
      x_center: 0.765625,
      y_center: 0.234375
    },
    {
      w: 1,
      h: 1,
      x_center: 0.765625,
      y_center: 0.234375
    },
    {
      w: 1,
      h: 1,
      x_center: 0.796875,
      y_center: 0.234375
    },
    {
      w: 1,
      h: 1,
      x_center: 0.796875,
      y_center: 0.234375
    },
    {
      w: 1,
      h: 1,
      x_center: 0.828125,
      y_center: 0.234375
    },
    {
      w: 1,
      h: 1,
      x_center: 0.828125,
      y_center: 0.234375
    },
    {
      w: 1,
      h: 1,
      x_center: 0.859375,
      y_center: 0.234375
    },
    {
      w: 1,
      h: 1,
      x_center: 0.859375,
      y_center: 0.234375
    },
    {
      w: 1,
      h: 1,
      x_center: 0.890625,
      y_center: 0.234375
    },
    {
      w: 1,
      h: 1,
      x_center: 0.890625,
      y_center: 0.234375
    },
    {
      w: 1,
      h: 1,
      x_center: 0.921875,
      y_center: 0.234375
    },
    {
      w: 1,
      h: 1,
      x_center: 0.921875,
      y_center: 0.234375
    },
    {
      w: 1,
      h: 1,
      x_center: 0.953125,
      y_center: 0.234375
    },
    {
      w: 1,
      h: 1,
      x_center: 0.953125,
      y_center: 0.234375
    },
    {
      w: 1,
      h: 1,
      x_center: 0.984375,
      y_center: 0.234375
    },
    {
      w: 1,
      h: 1,
      x_center: 0.984375,
      y_center: 0.234375
    },
    {
      w: 1,
      h: 1,
      x_center: 0.015625,
      y_center: 0.265625
    },
    {
      w: 1,
      h: 1,
      x_center: 0.015625,
      y_center: 0.265625
    },
    {
      w: 1,
      h: 1,
      x_center: 0.046875,
      y_center: 0.265625
    },
    {
      w: 1,
      h: 1,
      x_center: 0.046875,
      y_center: 0.265625
    },
    {
      w: 1,
      h: 1,
      x_center: 0.078125,
      y_center: 0.265625
    },
    {
      w: 1,
      h: 1,
      x_center: 0.078125,
      y_center: 0.265625
    },
    {
      w: 1,
      h: 1,
      x_center: 0.109375,
      y_center: 0.265625
    },
    {
      w: 1,
      h: 1,
      x_center: 0.109375,
      y_center: 0.265625
    },
    {
      w: 1,
      h: 1,
      x_center: 0.140625,
      y_center: 0.265625
    },
    {
      w: 1,
      h: 1,
      x_center: 0.140625,
      y_center: 0.265625
    },
    {
      w: 1,
      h: 1,
      x_center: 0.171875,
      y_center: 0.265625
    },
    {
      w: 1,
      h: 1,
      x_center: 0.171875,
      y_center: 0.265625
    },
    {
      w: 1,
      h: 1,
      x_center: 0.203125,
      y_center: 0.265625
    },
    {
      w: 1,
      h: 1,
      x_center: 0.203125,
      y_center: 0.265625
    },
    {
      w: 1,
      h: 1,
      x_center: 0.234375,
      y_center: 0.265625
    },
    {
      w: 1,
      h: 1,
      x_center: 0.234375,
      y_center: 0.265625
    },
    {
      w: 1,
      h: 1,
      x_center: 0.265625,
      y_center: 0.265625
    },
    {
      w: 1,
      h: 1,
      x_center: 0.265625,
      y_center: 0.265625
    },
    {
      w: 1,
      h: 1,
      x_center: 0.296875,
      y_center: 0.265625
    },
    {
      w: 1,
      h: 1,
      x_center: 0.296875,
      y_center: 0.265625
    },
    {
      w: 1,
      h: 1,
      x_center: 0.328125,
      y_center: 0.265625
    },
    {
      w: 1,
      h: 1,
      x_center: 0.328125,
      y_center: 0.265625
    },
    {
      w: 1,
      h: 1,
      x_center: 0.359375,
      y_center: 0.265625
    },
    {
      w: 1,
      h: 1,
      x_center: 0.359375,
      y_center: 0.265625
    },
    {
      w: 1,
      h: 1,
      x_center: 0.390625,
      y_center: 0.265625
    },
    {
      w: 1,
      h: 1,
      x_center: 0.390625,
      y_center: 0.265625
    },
    {
      w: 1,
      h: 1,
      x_center: 0.421875,
      y_center: 0.265625
    },
    {
      w: 1,
      h: 1,
      x_center: 0.421875,
      y_center: 0.265625
    },
    {
      w: 1,
      h: 1,
      x_center: 0.453125,
      y_center: 0.265625
    },
    {
      w: 1,
      h: 1,
      x_center: 0.453125,
      y_center: 0.265625
    },
    {
      w: 1,
      h: 1,
      x_center: 0.484375,
      y_center: 0.265625
    },
    {
      w: 1,
      h: 1,
      x_center: 0.484375,
      y_center: 0.265625
    },
    {
      w: 1,
      h: 1,
      x_center: 0.515625,
      y_center: 0.265625
    },
    {
      w: 1,
      h: 1,
      x_center: 0.515625,
      y_center: 0.265625
    },
    {
      w: 1,
      h: 1,
      x_center: 0.546875,
      y_center: 0.265625
    },
    {
      w: 1,
      h: 1,
      x_center: 0.546875,
      y_center: 0.265625
    },
    {
      w: 1,
      h: 1,
      x_center: 0.578125,
      y_center: 0.265625
    },
    {
      w: 1,
      h: 1,
      x_center: 0.578125,
      y_center: 0.265625
    },
    {
      w: 1,
      h: 1,
      x_center: 0.609375,
      y_center: 0.265625
    },
    {
      w: 1,
      h: 1,
      x_center: 0.609375,
      y_center: 0.265625
    },
    {
      w: 1,
      h: 1,
      x_center: 0.640625,
      y_center: 0.265625
    },
    {
      w: 1,
      h: 1,
      x_center: 0.640625,
      y_center: 0.265625
    },
    {
      w: 1,
      h: 1,
      x_center: 0.671875,
      y_center: 0.265625
    },
    {
      w: 1,
      h: 1,
      x_center: 0.671875,
      y_center: 0.265625
    },
    {
      w: 1,
      h: 1,
      x_center: 0.703125,
      y_center: 0.265625
    },
    {
      w: 1,
      h: 1,
      x_center: 0.703125,
      y_center: 0.265625
    },
    {
      w: 1,
      h: 1,
      x_center: 0.734375,
      y_center: 0.265625
    },
    {
      w: 1,
      h: 1,
      x_center: 0.734375,
      y_center: 0.265625
    },
    {
      w: 1,
      h: 1,
      x_center: 0.765625,
      y_center: 0.265625
    },
    {
      w: 1,
      h: 1,
      x_center: 0.765625,
      y_center: 0.265625
    },
    {
      w: 1,
      h: 1,
      x_center: 0.796875,
      y_center: 0.265625
    },
    {
      w: 1,
      h: 1,
      x_center: 0.796875,
      y_center: 0.265625
    },
    {
      w: 1,
      h: 1,
      x_center: 0.828125,
      y_center: 0.265625
    },
    {
      w: 1,
      h: 1,
      x_center: 0.828125,
      y_center: 0.265625
    },
    {
      w: 1,
      h: 1,
      x_center: 0.859375,
      y_center: 0.265625
    },
    {
      w: 1,
      h: 1,
      x_center: 0.859375,
      y_center: 0.265625
    },
    {
      w: 1,
      h: 1,
      x_center: 0.890625,
      y_center: 0.265625
    },
    {
      w: 1,
      h: 1,
      x_center: 0.890625,
      y_center: 0.265625
    },
    {
      w: 1,
      h: 1,
      x_center: 0.921875,
      y_center: 0.265625
    },
    {
      w: 1,
      h: 1,
      x_center: 0.921875,
      y_center: 0.265625
    },
    {
      w: 1,
      h: 1,
      x_center: 0.953125,
      y_center: 0.265625
    },
    {
      w: 1,
      h: 1,
      x_center: 0.953125,
      y_center: 0.265625
    },
    {
      w: 1,
      h: 1,
      x_center: 0.984375,
      y_center: 0.265625
    },
    {
      w: 1,
      h: 1,
      x_center: 0.984375,
      y_center: 0.265625
    },
    {
      w: 1,
      h: 1,
      x_center: 0.015625,
      y_center: 0.296875
    },
    {
      w: 1,
      h: 1,
      x_center: 0.015625,
      y_center: 0.296875
    },
    {
      w: 1,
      h: 1,
      x_center: 0.046875,
      y_center: 0.296875
    },
    {
      w: 1,
      h: 1,
      x_center: 0.046875,
      y_center: 0.296875
    },
    {
      w: 1,
      h: 1,
      x_center: 0.078125,
      y_center: 0.296875
    },
    {
      w: 1,
      h: 1,
      x_center: 0.078125,
      y_center: 0.296875
    },
    {
      w: 1,
      h: 1,
      x_center: 0.109375,
      y_center: 0.296875
    },
    {
      w: 1,
      h: 1,
      x_center: 0.109375,
      y_center: 0.296875
    },
    {
      w: 1,
      h: 1,
      x_center: 0.140625,
      y_center: 0.296875
    },
    {
      w: 1,
      h: 1,
      x_center: 0.140625,
      y_center: 0.296875
    },
    {
      w: 1,
      h: 1,
      x_center: 0.171875,
      y_center: 0.296875
    },
    {
      w: 1,
      h: 1,
      x_center: 0.171875,
      y_center: 0.296875
    },
    {
      w: 1,
      h: 1,
      x_center: 0.203125,
      y_center: 0.296875
    },
    {
      w: 1,
      h: 1,
      x_center: 0.203125,
      y_center: 0.296875
    },
    {
      w: 1,
      h: 1,
      x_center: 0.234375,
      y_center: 0.296875
    },
    {
      w: 1,
      h: 1,
      x_center: 0.234375,
      y_center: 0.296875
    },
    {
      w: 1,
      h: 1,
      x_center: 0.265625,
      y_center: 0.296875
    },
    {
      w: 1,
      h: 1,
      x_center: 0.265625,
      y_center: 0.296875
    },
    {
      w: 1,
      h: 1,
      x_center: 0.296875,
      y_center: 0.296875
    },
    {
      w: 1,
      h: 1,
      x_center: 0.296875,
      y_center: 0.296875
    },
    {
      w: 1,
      h: 1,
      x_center: 0.328125,
      y_center: 0.296875
    },
    {
      w: 1,
      h: 1,
      x_center: 0.328125,
      y_center: 0.296875
    },
    {
      w: 1,
      h: 1,
      x_center: 0.359375,
      y_center: 0.296875
    },
    {
      w: 1,
      h: 1,
      x_center: 0.359375,
      y_center: 0.296875
    },
    {
      w: 1,
      h: 1,
      x_center: 0.390625,
      y_center: 0.296875
    },
    {
      w: 1,
      h: 1,
      x_center: 0.390625,
      y_center: 0.296875
    },
    {
      w: 1,
      h: 1,
      x_center: 0.421875,
      y_center: 0.296875
    },
    {
      w: 1,
      h: 1,
      x_center: 0.421875,
      y_center: 0.296875
    },
    {
      w: 1,
      h: 1,
      x_center: 0.453125,
      y_center: 0.296875
    },
    {
      w: 1,
      h: 1,
      x_center: 0.453125,
      y_center: 0.296875
    },
    {
      w: 1,
      h: 1,
      x_center: 0.484375,
      y_center: 0.296875
    },
    {
      w: 1,
      h: 1,
      x_center: 0.484375,
      y_center: 0.296875
    },
    {
      w: 1,
      h: 1,
      x_center: 0.515625,
      y_center: 0.296875
    },
    {
      w: 1,
      h: 1,
      x_center: 0.515625,
      y_center: 0.296875
    },
    {
      w: 1,
      h: 1,
      x_center: 0.546875,
      y_center: 0.296875
    },
    {
      w: 1,
      h: 1,
      x_center: 0.546875,
      y_center: 0.296875
    },
    {
      w: 1,
      h: 1,
      x_center: 0.578125,
      y_center: 0.296875
    },
    {
      w: 1,
      h: 1,
      x_center: 0.578125,
      y_center: 0.296875
    },
    {
      w: 1,
      h: 1,
      x_center: 0.609375,
      y_center: 0.296875
    },
    {
      w: 1,
      h: 1,
      x_center: 0.609375,
      y_center: 0.296875
    },
    {
      w: 1,
      h: 1,
      x_center: 0.640625,
      y_center: 0.296875
    },
    {
      w: 1,
      h: 1,
      x_center: 0.640625,
      y_center: 0.296875
    },
    {
      w: 1,
      h: 1,
      x_center: 0.671875,
      y_center: 0.296875
    },
    {
      w: 1,
      h: 1,
      x_center: 0.671875,
      y_center: 0.296875
    },
    {
      w: 1,
      h: 1,
      x_center: 0.703125,
      y_center: 0.296875
    },
    {
      w: 1,
      h: 1,
      x_center: 0.703125,
      y_center: 0.296875
    },
    {
      w: 1,
      h: 1,
      x_center: 0.734375,
      y_center: 0.296875
    },
    {
      w: 1,
      h: 1,
      x_center: 0.734375,
      y_center: 0.296875
    },
    {
      w: 1,
      h: 1,
      x_center: 0.765625,
      y_center: 0.296875
    },
    {
      w: 1,
      h: 1,
      x_center: 0.765625,
      y_center: 0.296875
    },
    {
      w: 1,
      h: 1,
      x_center: 0.796875,
      y_center: 0.296875
    },
    {
      w: 1,
      h: 1,
      x_center: 0.796875,
      y_center: 0.296875
    },
    {
      w: 1,
      h: 1,
      x_center: 0.828125,
      y_center: 0.296875
    },
    {
      w: 1,
      h: 1,
      x_center: 0.828125,
      y_center: 0.296875
    },
    {
      w: 1,
      h: 1,
      x_center: 0.859375,
      y_center: 0.296875
    },
    {
      w: 1,
      h: 1,
      x_center: 0.859375,
      y_center: 0.296875
    },
    {
      w: 1,
      h: 1,
      x_center: 0.890625,
      y_center: 0.296875
    },
    {
      w: 1,
      h: 1,
      x_center: 0.890625,
      y_center: 0.296875
    },
    {
      w: 1,
      h: 1,
      x_center: 0.921875,
      y_center: 0.296875
    },
    {
      w: 1,
      h: 1,
      x_center: 0.921875,
      y_center: 0.296875
    },
    {
      w: 1,
      h: 1,
      x_center: 0.953125,
      y_center: 0.296875
    },
    {
      w: 1,
      h: 1,
      x_center: 0.953125,
      y_center: 0.296875
    },
    {
      w: 1,
      h: 1,
      x_center: 0.984375,
      y_center: 0.296875
    },
    {
      w: 1,
      h: 1,
      x_center: 0.984375,
      y_center: 0.296875
    },
    {
      w: 1,
      h: 1,
      x_center: 0.015625,
      y_center: 0.328125
    },
    {
      w: 1,
      h: 1,
      x_center: 0.015625,
      y_center: 0.328125
    },
    {
      w: 1,
      h: 1,
      x_center: 0.046875,
      y_center: 0.328125
    },
    {
      w: 1,
      h: 1,
      x_center: 0.046875,
      y_center: 0.328125
    },
    {
      w: 1,
      h: 1,
      x_center: 0.078125,
      y_center: 0.328125
    },
    {
      w: 1,
      h: 1,
      x_center: 0.078125,
      y_center: 0.328125
    },
    {
      w: 1,
      h: 1,
      x_center: 0.109375,
      y_center: 0.328125
    },
    {
      w: 1,
      h: 1,
      x_center: 0.109375,
      y_center: 0.328125
    },
    {
      w: 1,
      h: 1,
      x_center: 0.140625,
      y_center: 0.328125
    },
    {
      w: 1,
      h: 1,
      x_center: 0.140625,
      y_center: 0.328125
    },
    {
      w: 1,
      h: 1,
      x_center: 0.171875,
      y_center: 0.328125
    },
    {
      w: 1,
      h: 1,
      x_center: 0.171875,
      y_center: 0.328125
    },
    {
      w: 1,
      h: 1,
      x_center: 0.203125,
      y_center: 0.328125
    },
    {
      w: 1,
      h: 1,
      x_center: 0.203125,
      y_center: 0.328125
    },
    {
      w: 1,
      h: 1,
      x_center: 0.234375,
      y_center: 0.328125
    },
    {
      w: 1,
      h: 1,
      x_center: 0.234375,
      y_center: 0.328125
    },
    {
      w: 1,
      h: 1,
      x_center: 0.265625,
      y_center: 0.328125
    },
    {
      w: 1,
      h: 1,
      x_center: 0.265625,
      y_center: 0.328125
    },
    {
      w: 1,
      h: 1,
      x_center: 0.296875,
      y_center: 0.328125
    },
    {
      w: 1,
      h: 1,
      x_center: 0.296875,
      y_center: 0.328125
    },
    {
      w: 1,
      h: 1,
      x_center: 0.328125,
      y_center: 0.328125
    },
    {
      w: 1,
      h: 1,
      x_center: 0.328125,
      y_center: 0.328125
    },
    {
      w: 1,
      h: 1,
      x_center: 0.359375,
      y_center: 0.328125
    },
    {
      w: 1,
      h: 1,
      x_center: 0.359375,
      y_center: 0.328125
    },
    {
      w: 1,
      h: 1,
      x_center: 0.390625,
      y_center: 0.328125
    },
    {
      w: 1,
      h: 1,
      x_center: 0.390625,
      y_center: 0.328125
    },
    {
      w: 1,
      h: 1,
      x_center: 0.421875,
      y_center: 0.328125
    },
    {
      w: 1,
      h: 1,
      x_center: 0.421875,
      y_center: 0.328125
    },
    {
      w: 1,
      h: 1,
      x_center: 0.453125,
      y_center: 0.328125
    },
    {
      w: 1,
      h: 1,
      x_center: 0.453125,
      y_center: 0.328125
    },
    {
      w: 1,
      h: 1,
      x_center: 0.484375,
      y_center: 0.328125
    },
    {
      w: 1,
      h: 1,
      x_center: 0.484375,
      y_center: 0.328125
    },
    {
      w: 1,
      h: 1,
      x_center: 0.515625,
      y_center: 0.328125
    },
    {
      w: 1,
      h: 1,
      x_center: 0.515625,
      y_center: 0.328125
    },
    {
      w: 1,
      h: 1,
      x_center: 0.546875,
      y_center: 0.328125
    },
    {
      w: 1,
      h: 1,
      x_center: 0.546875,
      y_center: 0.328125
    },
    {
      w: 1,
      h: 1,
      x_center: 0.578125,
      y_center: 0.328125
    },
    {
      w: 1,
      h: 1,
      x_center: 0.578125,
      y_center: 0.328125
    },
    {
      w: 1,
      h: 1,
      x_center: 0.609375,
      y_center: 0.328125
    },
    {
      w: 1,
      h: 1,
      x_center: 0.609375,
      y_center: 0.328125
    },
    {
      w: 1,
      h: 1,
      x_center: 0.640625,
      y_center: 0.328125
    },
    {
      w: 1,
      h: 1,
      x_center: 0.640625,
      y_center: 0.328125
    },
    {
      w: 1,
      h: 1,
      x_center: 0.671875,
      y_center: 0.328125
    },
    {
      w: 1,
      h: 1,
      x_center: 0.671875,
      y_center: 0.328125
    },
    {
      w: 1,
      h: 1,
      x_center: 0.703125,
      y_center: 0.328125
    },
    {
      w: 1,
      h: 1,
      x_center: 0.703125,
      y_center: 0.328125
    },
    {
      w: 1,
      h: 1,
      x_center: 0.734375,
      y_center: 0.328125
    },
    {
      w: 1,
      h: 1,
      x_center: 0.734375,
      y_center: 0.328125
    },
    {
      w: 1,
      h: 1,
      x_center: 0.765625,
      y_center: 0.328125
    },
    {
      w: 1,
      h: 1,
      x_center: 0.765625,
      y_center: 0.328125
    },
    {
      w: 1,
      h: 1,
      x_center: 0.796875,
      y_center: 0.328125
    },
    {
      w: 1,
      h: 1,
      x_center: 0.796875,
      y_center: 0.328125
    },
    {
      w: 1,
      h: 1,
      x_center: 0.828125,
      y_center: 0.328125
    },
    {
      w: 1,
      h: 1,
      x_center: 0.828125,
      y_center: 0.328125
    },
    {
      w: 1,
      h: 1,
      x_center: 0.859375,
      y_center: 0.328125
    },
    {
      w: 1,
      h: 1,
      x_center: 0.859375,
      y_center: 0.328125
    },
    {
      w: 1,
      h: 1,
      x_center: 0.890625,
      y_center: 0.328125
    },
    {
      w: 1,
      h: 1,
      x_center: 0.890625,
      y_center: 0.328125
    },
    {
      w: 1,
      h: 1,
      x_center: 0.921875,
      y_center: 0.328125
    },
    {
      w: 1,
      h: 1,
      x_center: 0.921875,
      y_center: 0.328125
    },
    {
      w: 1,
      h: 1,
      x_center: 0.953125,
      y_center: 0.328125
    },
    {
      w: 1,
      h: 1,
      x_center: 0.953125,
      y_center: 0.328125
    },
    {
      w: 1,
      h: 1,
      x_center: 0.984375,
      y_center: 0.328125
    },
    {
      w: 1,
      h: 1,
      x_center: 0.984375,
      y_center: 0.328125
    },
    {
      w: 1,
      h: 1,
      x_center: 0.015625,
      y_center: 0.359375
    },
    {
      w: 1,
      h: 1,
      x_center: 0.015625,
      y_center: 0.359375
    },
    {
      w: 1,
      h: 1,
      x_center: 0.046875,
      y_center: 0.359375
    },
    {
      w: 1,
      h: 1,
      x_center: 0.046875,
      y_center: 0.359375
    },
    {
      w: 1,
      h: 1,
      x_center: 0.078125,
      y_center: 0.359375
    },
    {
      w: 1,
      h: 1,
      x_center: 0.078125,
      y_center: 0.359375
    },
    {
      w: 1,
      h: 1,
      x_center: 0.109375,
      y_center: 0.359375
    },
    {
      w: 1,
      h: 1,
      x_center: 0.109375,
      y_center: 0.359375
    },
    {
      w: 1,
      h: 1,
      x_center: 0.140625,
      y_center: 0.359375
    },
    {
      w: 1,
      h: 1,
      x_center: 0.140625,
      y_center: 0.359375
    },
    {
      w: 1,
      h: 1,
      x_center: 0.171875,
      y_center: 0.359375
    },
    {
      w: 1,
      h: 1,
      x_center: 0.171875,
      y_center: 0.359375
    },
    {
      w: 1,
      h: 1,
      x_center: 0.203125,
      y_center: 0.359375
    },
    {
      w: 1,
      h: 1,
      x_center: 0.203125,
      y_center: 0.359375
    },
    {
      w: 1,
      h: 1,
      x_center: 0.234375,
      y_center: 0.359375
    },
    {
      w: 1,
      h: 1,
      x_center: 0.234375,
      y_center: 0.359375
    },
    {
      w: 1,
      h: 1,
      x_center: 0.265625,
      y_center: 0.359375
    },
    {
      w: 1,
      h: 1,
      x_center: 0.265625,
      y_center: 0.359375
    },
    {
      w: 1,
      h: 1,
      x_center: 0.296875,
      y_center: 0.359375
    },
    {
      w: 1,
      h: 1,
      x_center: 0.296875,
      y_center: 0.359375
    },
    {
      w: 1,
      h: 1,
      x_center: 0.328125,
      y_center: 0.359375
    },
    {
      w: 1,
      h: 1,
      x_center: 0.328125,
      y_center: 0.359375
    },
    {
      w: 1,
      h: 1,
      x_center: 0.359375,
      y_center: 0.359375
    },
    {
      w: 1,
      h: 1,
      x_center: 0.359375,
      y_center: 0.359375
    },
    {
      w: 1,
      h: 1,
      x_center: 0.390625,
      y_center: 0.359375
    },
    {
      w: 1,
      h: 1,
      x_center: 0.390625,
      y_center: 0.359375
    },
    {
      w: 1,
      h: 1,
      x_center: 0.421875,
      y_center: 0.359375
    },
    {
      w: 1,
      h: 1,
      x_center: 0.421875,
      y_center: 0.359375
    },
    {
      w: 1,
      h: 1,
      x_center: 0.453125,
      y_center: 0.359375
    },
    {
      w: 1,
      h: 1,
      x_center: 0.453125,
      y_center: 0.359375
    },
    {
      w: 1,
      h: 1,
      x_center: 0.484375,
      y_center: 0.359375
    },
    {
      w: 1,
      h: 1,
      x_center: 0.484375,
      y_center: 0.359375
    },
    {
      w: 1,
      h: 1,
      x_center: 0.515625,
      y_center: 0.359375
    },
    {
      w: 1,
      h: 1,
      x_center: 0.515625,
      y_center: 0.359375
    },
    {
      w: 1,
      h: 1,
      x_center: 0.546875,
      y_center: 0.359375
    },
    {
      w: 1,
      h: 1,
      x_center: 0.546875,
      y_center: 0.359375
    },
    {
      w: 1,
      h: 1,
      x_center: 0.578125,
      y_center: 0.359375
    },
    {
      w: 1,
      h: 1,
      x_center: 0.578125,
      y_center: 0.359375
    },
    {
      w: 1,
      h: 1,
      x_center: 0.609375,
      y_center: 0.359375
    },
    {
      w: 1,
      h: 1,
      x_center: 0.609375,
      y_center: 0.359375
    },
    {
      w: 1,
      h: 1,
      x_center: 0.640625,
      y_center: 0.359375
    },
    {
      w: 1,
      h: 1,
      x_center: 0.640625,
      y_center: 0.359375
    },
    {
      w: 1,
      h: 1,
      x_center: 0.671875,
      y_center: 0.359375
    },
    {
      w: 1,
      h: 1,
      x_center: 0.671875,
      y_center: 0.359375
    },
    {
      w: 1,
      h: 1,
      x_center: 0.703125,
      y_center: 0.359375
    },
    {
      w: 1,
      h: 1,
      x_center: 0.703125,
      y_center: 0.359375
    },
    {
      w: 1,
      h: 1,
      x_center: 0.734375,
      y_center: 0.359375
    },
    {
      w: 1,
      h: 1,
      x_center: 0.734375,
      y_center: 0.359375
    },
    {
      w: 1,
      h: 1,
      x_center: 0.765625,
      y_center: 0.359375
    },
    {
      w: 1,
      h: 1,
      x_center: 0.765625,
      y_center: 0.359375
    },
    {
      w: 1,
      h: 1,
      x_center: 0.796875,
      y_center: 0.359375
    },
    {
      w: 1,
      h: 1,
      x_center: 0.796875,
      y_center: 0.359375
    },
    {
      w: 1,
      h: 1,
      x_center: 0.828125,
      y_center: 0.359375
    },
    {
      w: 1,
      h: 1,
      x_center: 0.828125,
      y_center: 0.359375
    },
    {
      w: 1,
      h: 1,
      x_center: 0.859375,
      y_center: 0.359375
    },
    {
      w: 1,
      h: 1,
      x_center: 0.859375,
      y_center: 0.359375
    },
    {
      w: 1,
      h: 1,
      x_center: 0.890625,
      y_center: 0.359375
    },
    {
      w: 1,
      h: 1,
      x_center: 0.890625,
      y_center: 0.359375
    },
    {
      w: 1,
      h: 1,
      x_center: 0.921875,
      y_center: 0.359375
    },
    {
      w: 1,
      h: 1,
      x_center: 0.921875,
      y_center: 0.359375
    },
    {
      w: 1,
      h: 1,
      x_center: 0.953125,
      y_center: 0.359375
    },
    {
      w: 1,
      h: 1,
      x_center: 0.953125,
      y_center: 0.359375
    },
    {
      w: 1,
      h: 1,
      x_center: 0.984375,
      y_center: 0.359375
    },
    {
      w: 1,
      h: 1,
      x_center: 0.984375,
      y_center: 0.359375
    },
    {
      w: 1,
      h: 1,
      x_center: 0.015625,
      y_center: 0.390625
    },
    {
      w: 1,
      h: 1,
      x_center: 0.015625,
      y_center: 0.390625
    },
    {
      w: 1,
      h: 1,
      x_center: 0.046875,
      y_center: 0.390625
    },
    {
      w: 1,
      h: 1,
      x_center: 0.046875,
      y_center: 0.390625
    },
    {
      w: 1,
      h: 1,
      x_center: 0.078125,
      y_center: 0.390625
    },
    {
      w: 1,
      h: 1,
      x_center: 0.078125,
      y_center: 0.390625
    },
    {
      w: 1,
      h: 1,
      x_center: 0.109375,
      y_center: 0.390625
    },
    {
      w: 1,
      h: 1,
      x_center: 0.109375,
      y_center: 0.390625
    },
    {
      w: 1,
      h: 1,
      x_center: 0.140625,
      y_center: 0.390625
    },
    {
      w: 1,
      h: 1,
      x_center: 0.140625,
      y_center: 0.390625
    },
    {
      w: 1,
      h: 1,
      x_center: 0.171875,
      y_center: 0.390625
    },
    {
      w: 1,
      h: 1,
      x_center: 0.171875,
      y_center: 0.390625
    },
    {
      w: 1,
      h: 1,
      x_center: 0.203125,
      y_center: 0.390625
    },
    {
      w: 1,
      h: 1,
      x_center: 0.203125,
      y_center: 0.390625
    },
    {
      w: 1,
      h: 1,
      x_center: 0.234375,
      y_center: 0.390625
    },
    {
      w: 1,
      h: 1,
      x_center: 0.234375,
      y_center: 0.390625
    },
    {
      w: 1,
      h: 1,
      x_center: 0.265625,
      y_center: 0.390625
    },
    {
      w: 1,
      h: 1,
      x_center: 0.265625,
      y_center: 0.390625
    },
    {
      w: 1,
      h: 1,
      x_center: 0.296875,
      y_center: 0.390625
    },
    {
      w: 1,
      h: 1,
      x_center: 0.296875,
      y_center: 0.390625
    },
    {
      w: 1,
      h: 1,
      x_center: 0.328125,
      y_center: 0.390625
    },
    {
      w: 1,
      h: 1,
      x_center: 0.328125,
      y_center: 0.390625
    },
    {
      w: 1,
      h: 1,
      x_center: 0.359375,
      y_center: 0.390625
    },
    {
      w: 1,
      h: 1,
      x_center: 0.359375,
      y_center: 0.390625
    },
    {
      w: 1,
      h: 1,
      x_center: 0.390625,
      y_center: 0.390625
    },
    {
      w: 1,
      h: 1,
      x_center: 0.390625,
      y_center: 0.390625
    },
    {
      w: 1,
      h: 1,
      x_center: 0.421875,
      y_center: 0.390625
    },
    {
      w: 1,
      h: 1,
      x_center: 0.421875,
      y_center: 0.390625
    },
    {
      w: 1,
      h: 1,
      x_center: 0.453125,
      y_center: 0.390625
    },
    {
      w: 1,
      h: 1,
      x_center: 0.453125,
      y_center: 0.390625
    },
    {
      w: 1,
      h: 1,
      x_center: 0.484375,
      y_center: 0.390625
    },
    {
      w: 1,
      h: 1,
      x_center: 0.484375,
      y_center: 0.390625
    },
    {
      w: 1,
      h: 1,
      x_center: 0.515625,
      y_center: 0.390625
    },
    {
      w: 1,
      h: 1,
      x_center: 0.515625,
      y_center: 0.390625
    },
    {
      w: 1,
      h: 1,
      x_center: 0.546875,
      y_center: 0.390625
    },
    {
      w: 1,
      h: 1,
      x_center: 0.546875,
      y_center: 0.390625
    },
    {
      w: 1,
      h: 1,
      x_center: 0.578125,
      y_center: 0.390625
    },
    {
      w: 1,
      h: 1,
      x_center: 0.578125,
      y_center: 0.390625
    },
    {
      w: 1,
      h: 1,
      x_center: 0.609375,
      y_center: 0.390625
    },
    {
      w: 1,
      h: 1,
      x_center: 0.609375,
      y_center: 0.390625
    },
    {
      w: 1,
      h: 1,
      x_center: 0.640625,
      y_center: 0.390625
    },
    {
      w: 1,
      h: 1,
      x_center: 0.640625,
      y_center: 0.390625
    },
    {
      w: 1,
      h: 1,
      x_center: 0.671875,
      y_center: 0.390625
    },
    {
      w: 1,
      h: 1,
      x_center: 0.671875,
      y_center: 0.390625
    },
    {
      w: 1,
      h: 1,
      x_center: 0.703125,
      y_center: 0.390625
    },
    {
      w: 1,
      h: 1,
      x_center: 0.703125,
      y_center: 0.390625
    },
    {
      w: 1,
      h: 1,
      x_center: 0.734375,
      y_center: 0.390625
    },
    {
      w: 1,
      h: 1,
      x_center: 0.734375,
      y_center: 0.390625
    },
    {
      w: 1,
      h: 1,
      x_center: 0.765625,
      y_center: 0.390625
    },
    {
      w: 1,
      h: 1,
      x_center: 0.765625,
      y_center: 0.390625
    },
    {
      w: 1,
      h: 1,
      x_center: 0.796875,
      y_center: 0.390625
    },
    {
      w: 1,
      h: 1,
      x_center: 0.796875,
      y_center: 0.390625
    },
    {
      w: 1,
      h: 1,
      x_center: 0.828125,
      y_center: 0.390625
    },
    {
      w: 1,
      h: 1,
      x_center: 0.828125,
      y_center: 0.390625
    },
    {
      w: 1,
      h: 1,
      x_center: 0.859375,
      y_center: 0.390625
    },
    {
      w: 1,
      h: 1,
      x_center: 0.859375,
      y_center: 0.390625
    },
    {
      w: 1,
      h: 1,
      x_center: 0.890625,
      y_center: 0.390625
    },
    {
      w: 1,
      h: 1,
      x_center: 0.890625,
      y_center: 0.390625
    },
    {
      w: 1,
      h: 1,
      x_center: 0.921875,
      y_center: 0.390625
    },
    {
      w: 1,
      h: 1,
      x_center: 0.921875,
      y_center: 0.390625
    },
    {
      w: 1,
      h: 1,
      x_center: 0.953125,
      y_center: 0.390625
    },
    {
      w: 1,
      h: 1,
      x_center: 0.953125,
      y_center: 0.390625
    },
    {
      w: 1,
      h: 1,
      x_center: 0.984375,
      y_center: 0.390625
    },
    {
      w: 1,
      h: 1,
      x_center: 0.984375,
      y_center: 0.390625
    },
    {
      w: 1,
      h: 1,
      x_center: 0.015625,
      y_center: 0.421875
    },
    {
      w: 1,
      h: 1,
      x_center: 0.015625,
      y_center: 0.421875
    },
    {
      w: 1,
      h: 1,
      x_center: 0.046875,
      y_center: 0.421875
    },
    {
      w: 1,
      h: 1,
      x_center: 0.046875,
      y_center: 0.421875
    },
    {
      w: 1,
      h: 1,
      x_center: 0.078125,
      y_center: 0.421875
    },
    {
      w: 1,
      h: 1,
      x_center: 0.078125,
      y_center: 0.421875
    },
    {
      w: 1,
      h: 1,
      x_center: 0.109375,
      y_center: 0.421875
    },
    {
      w: 1,
      h: 1,
      x_center: 0.109375,
      y_center: 0.421875
    },
    {
      w: 1,
      h: 1,
      x_center: 0.140625,
      y_center: 0.421875
    },
    {
      w: 1,
      h: 1,
      x_center: 0.140625,
      y_center: 0.421875
    },
    {
      w: 1,
      h: 1,
      x_center: 0.171875,
      y_center: 0.421875
    },
    {
      w: 1,
      h: 1,
      x_center: 0.171875,
      y_center: 0.421875
    },
    {
      w: 1,
      h: 1,
      x_center: 0.203125,
      y_center: 0.421875
    },
    {
      w: 1,
      h: 1,
      x_center: 0.203125,
      y_center: 0.421875
    },
    {
      w: 1,
      h: 1,
      x_center: 0.234375,
      y_center: 0.421875
    },
    {
      w: 1,
      h: 1,
      x_center: 0.234375,
      y_center: 0.421875
    },
    {
      w: 1,
      h: 1,
      x_center: 0.265625,
      y_center: 0.421875
    },
    {
      w: 1,
      h: 1,
      x_center: 0.265625,
      y_center: 0.421875
    },
    {
      w: 1,
      h: 1,
      x_center: 0.296875,
      y_center: 0.421875
    },
    {
      w: 1,
      h: 1,
      x_center: 0.296875,
      y_center: 0.421875
    },
    {
      w: 1,
      h: 1,
      x_center: 0.328125,
      y_center: 0.421875
    },
    {
      w: 1,
      h: 1,
      x_center: 0.328125,
      y_center: 0.421875
    },
    {
      w: 1,
      h: 1,
      x_center: 0.359375,
      y_center: 0.421875
    },
    {
      w: 1,
      h: 1,
      x_center: 0.359375,
      y_center: 0.421875
    },
    {
      w: 1,
      h: 1,
      x_center: 0.390625,
      y_center: 0.421875
    },
    {
      w: 1,
      h: 1,
      x_center: 0.390625,
      y_center: 0.421875
    },
    {
      w: 1,
      h: 1,
      x_center: 0.421875,
      y_center: 0.421875
    },
    {
      w: 1,
      h: 1,
      x_center: 0.421875,
      y_center: 0.421875
    },
    {
      w: 1,
      h: 1,
      x_center: 0.453125,
      y_center: 0.421875
    },
    {
      w: 1,
      h: 1,
      x_center: 0.453125,
      y_center: 0.421875
    },
    {
      w: 1,
      h: 1,
      x_center: 0.484375,
      y_center: 0.421875
    },
    {
      w: 1,
      h: 1,
      x_center: 0.484375,
      y_center: 0.421875
    },
    {
      w: 1,
      h: 1,
      x_center: 0.515625,
      y_center: 0.421875
    },
    {
      w: 1,
      h: 1,
      x_center: 0.515625,
      y_center: 0.421875
    },
    {
      w: 1,
      h: 1,
      x_center: 0.546875,
      y_center: 0.421875
    },
    {
      w: 1,
      h: 1,
      x_center: 0.546875,
      y_center: 0.421875
    },
    {
      w: 1,
      h: 1,
      x_center: 0.578125,
      y_center: 0.421875
    },
    {
      w: 1,
      h: 1,
      x_center: 0.578125,
      y_center: 0.421875
    },
    {
      w: 1,
      h: 1,
      x_center: 0.609375,
      y_center: 0.421875
    },
    {
      w: 1,
      h: 1,
      x_center: 0.609375,
      y_center: 0.421875
    },
    {
      w: 1,
      h: 1,
      x_center: 0.640625,
      y_center: 0.421875
    },
    {
      w: 1,
      h: 1,
      x_center: 0.640625,
      y_center: 0.421875
    },
    {
      w: 1,
      h: 1,
      x_center: 0.671875,
      y_center: 0.421875
    },
    {
      w: 1,
      h: 1,
      x_center: 0.671875,
      y_center: 0.421875
    },
    {
      w: 1,
      h: 1,
      x_center: 0.703125,
      y_center: 0.421875
    },
    {
      w: 1,
      h: 1,
      x_center: 0.703125,
      y_center: 0.421875
    },
    {
      w: 1,
      h: 1,
      x_center: 0.734375,
      y_center: 0.421875
    },
    {
      w: 1,
      h: 1,
      x_center: 0.734375,
      y_center: 0.421875
    },
    {
      w: 1,
      h: 1,
      x_center: 0.765625,
      y_center: 0.421875
    },
    {
      w: 1,
      h: 1,
      x_center: 0.765625,
      y_center: 0.421875
    },
    {
      w: 1,
      h: 1,
      x_center: 0.796875,
      y_center: 0.421875
    },
    {
      w: 1,
      h: 1,
      x_center: 0.796875,
      y_center: 0.421875
    },
    {
      w: 1,
      h: 1,
      x_center: 0.828125,
      y_center: 0.421875
    },
    {
      w: 1,
      h: 1,
      x_center: 0.828125,
      y_center: 0.421875
    },
    {
      w: 1,
      h: 1,
      x_center: 0.859375,
      y_center: 0.421875
    },
    {
      w: 1,
      h: 1,
      x_center: 0.859375,
      y_center: 0.421875
    },
    {
      w: 1,
      h: 1,
      x_center: 0.890625,
      y_center: 0.421875
    },
    {
      w: 1,
      h: 1,
      x_center: 0.890625,
      y_center: 0.421875
    },
    {
      w: 1,
      h: 1,
      x_center: 0.921875,
      y_center: 0.421875
    },
    {
      w: 1,
      h: 1,
      x_center: 0.921875,
      y_center: 0.421875
    },
    {
      w: 1,
      h: 1,
      x_center: 0.953125,
      y_center: 0.421875
    },
    {
      w: 1,
      h: 1,
      x_center: 0.953125,
      y_center: 0.421875
    },
    {
      w: 1,
      h: 1,
      x_center: 0.984375,
      y_center: 0.421875
    },
    {
      w: 1,
      h: 1,
      x_center: 0.984375,
      y_center: 0.421875
    },
    {
      w: 1,
      h: 1,
      x_center: 0.015625,
      y_center: 0.453125
    },
    {
      w: 1,
      h: 1,
      x_center: 0.015625,
      y_center: 0.453125
    },
    {
      w: 1,
      h: 1,
      x_center: 0.046875,
      y_center: 0.453125
    },
    {
      w: 1,
      h: 1,
      x_center: 0.046875,
      y_center: 0.453125
    },
    {
      w: 1,
      h: 1,
      x_center: 0.078125,
      y_center: 0.453125
    },
    {
      w: 1,
      h: 1,
      x_center: 0.078125,
      y_center: 0.453125
    },
    {
      w: 1,
      h: 1,
      x_center: 0.109375,
      y_center: 0.453125
    },
    {
      w: 1,
      h: 1,
      x_center: 0.109375,
      y_center: 0.453125
    },
    {
      w: 1,
      h: 1,
      x_center: 0.140625,
      y_center: 0.453125
    },
    {
      w: 1,
      h: 1,
      x_center: 0.140625,
      y_center: 0.453125
    },
    {
      w: 1,
      h: 1,
      x_center: 0.171875,
      y_center: 0.453125
    },
    {
      w: 1,
      h: 1,
      x_center: 0.171875,
      y_center: 0.453125
    },
    {
      w: 1,
      h: 1,
      x_center: 0.203125,
      y_center: 0.453125
    },
    {
      w: 1,
      h: 1,
      x_center: 0.203125,
      y_center: 0.453125
    },
    {
      w: 1,
      h: 1,
      x_center: 0.234375,
      y_center: 0.453125
    },
    {
      w: 1,
      h: 1,
      x_center: 0.234375,
      y_center: 0.453125
    },
    {
      w: 1,
      h: 1,
      x_center: 0.265625,
      y_center: 0.453125
    },
    {
      w: 1,
      h: 1,
      x_center: 0.265625,
      y_center: 0.453125
    },
    {
      w: 1,
      h: 1,
      x_center: 0.296875,
      y_center: 0.453125
    },
    {
      w: 1,
      h: 1,
      x_center: 0.296875,
      y_center: 0.453125
    },
    {
      w: 1,
      h: 1,
      x_center: 0.328125,
      y_center: 0.453125
    },
    {
      w: 1,
      h: 1,
      x_center: 0.328125,
      y_center: 0.453125
    },
    {
      w: 1,
      h: 1,
      x_center: 0.359375,
      y_center: 0.453125
    },
    {
      w: 1,
      h: 1,
      x_center: 0.359375,
      y_center: 0.453125
    },
    {
      w: 1,
      h: 1,
      x_center: 0.390625,
      y_center: 0.453125
    },
    {
      w: 1,
      h: 1,
      x_center: 0.390625,
      y_center: 0.453125
    },
    {
      w: 1,
      h: 1,
      x_center: 0.421875,
      y_center: 0.453125
    },
    {
      w: 1,
      h: 1,
      x_center: 0.421875,
      y_center: 0.453125
    },
    {
      w: 1,
      h: 1,
      x_center: 0.453125,
      y_center: 0.453125
    },
    {
      w: 1,
      h: 1,
      x_center: 0.453125,
      y_center: 0.453125
    },
    {
      w: 1,
      h: 1,
      x_center: 0.484375,
      y_center: 0.453125
    },
    {
      w: 1,
      h: 1,
      x_center: 0.484375,
      y_center: 0.453125
    },
    {
      w: 1,
      h: 1,
      x_center: 0.515625,
      y_center: 0.453125
    },
    {
      w: 1,
      h: 1,
      x_center: 0.515625,
      y_center: 0.453125
    },
    {
      w: 1,
      h: 1,
      x_center: 0.546875,
      y_center: 0.453125
    },
    {
      w: 1,
      h: 1,
      x_center: 0.546875,
      y_center: 0.453125
    },
    {
      w: 1,
      h: 1,
      x_center: 0.578125,
      y_center: 0.453125
    },
    {
      w: 1,
      h: 1,
      x_center: 0.578125,
      y_center: 0.453125
    },
    {
      w: 1,
      h: 1,
      x_center: 0.609375,
      y_center: 0.453125
    },
    {
      w: 1,
      h: 1,
      x_center: 0.609375,
      y_center: 0.453125
    },
    {
      w: 1,
      h: 1,
      x_center: 0.640625,
      y_center: 0.453125
    },
    {
      w: 1,
      h: 1,
      x_center: 0.640625,
      y_center: 0.453125
    },
    {
      w: 1,
      h: 1,
      x_center: 0.671875,
      y_center: 0.453125
    },
    {
      w: 1,
      h: 1,
      x_center: 0.671875,
      y_center: 0.453125
    },
    {
      w: 1,
      h: 1,
      x_center: 0.703125,
      y_center: 0.453125
    },
    {
      w: 1,
      h: 1,
      x_center: 0.703125,
      y_center: 0.453125
    },
    {
      w: 1,
      h: 1,
      x_center: 0.734375,
      y_center: 0.453125
    },
    {
      w: 1,
      h: 1,
      x_center: 0.734375,
      y_center: 0.453125
    },
    {
      w: 1,
      h: 1,
      x_center: 0.765625,
      y_center: 0.453125
    },
    {
      w: 1,
      h: 1,
      x_center: 0.765625,
      y_center: 0.453125
    },
    {
      w: 1,
      h: 1,
      x_center: 0.796875,
      y_center: 0.453125
    },
    {
      w: 1,
      h: 1,
      x_center: 0.796875,
      y_center: 0.453125
    },
    {
      w: 1,
      h: 1,
      x_center: 0.828125,
      y_center: 0.453125
    },
    {
      w: 1,
      h: 1,
      x_center: 0.828125,
      y_center: 0.453125
    },
    {
      w: 1,
      h: 1,
      x_center: 0.859375,
      y_center: 0.453125
    },
    {
      w: 1,
      h: 1,
      x_center: 0.859375,
      y_center: 0.453125
    },
    {
      w: 1,
      h: 1,
      x_center: 0.890625,
      y_center: 0.453125
    },
    {
      w: 1,
      h: 1,
      x_center: 0.890625,
      y_center: 0.453125
    },
    {
      w: 1,
      h: 1,
      x_center: 0.921875,
      y_center: 0.453125
    },
    {
      w: 1,
      h: 1,
      x_center: 0.921875,
      y_center: 0.453125
    },
    {
      w: 1,
      h: 1,
      x_center: 0.953125,
      y_center: 0.453125
    },
    {
      w: 1,
      h: 1,
      x_center: 0.953125,
      y_center: 0.453125
    },
    {
      w: 1,
      h: 1,
      x_center: 0.984375,
      y_center: 0.453125
    },
    {
      w: 1,
      h: 1,
      x_center: 0.984375,
      y_center: 0.453125
    },
    {
      w: 1,
      h: 1,
      x_center: 0.015625,
      y_center: 0.484375
    },
    {
      w: 1,
      h: 1,
      x_center: 0.015625,
      y_center: 0.484375
    },
    {
      w: 1,
      h: 1,
      x_center: 0.046875,
      y_center: 0.484375
    },
    {
      w: 1,
      h: 1,
      x_center: 0.046875,
      y_center: 0.484375
    },
    {
      w: 1,
      h: 1,
      x_center: 0.078125,
      y_center: 0.484375
    },
    {
      w: 1,
      h: 1,
      x_center: 0.078125,
      y_center: 0.484375
    },
    {
      w: 1,
      h: 1,
      x_center: 0.109375,
      y_center: 0.484375
    },
    {
      w: 1,
      h: 1,
      x_center: 0.109375,
      y_center: 0.484375
    },
    {
      w: 1,
      h: 1,
      x_center: 0.140625,
      y_center: 0.484375
    },
    {
      w: 1,
      h: 1,
      x_center: 0.140625,
      y_center: 0.484375
    },
    {
      w: 1,
      h: 1,
      x_center: 0.171875,
      y_center: 0.484375
    },
    {
      w: 1,
      h: 1,
      x_center: 0.171875,
      y_center: 0.484375
    },
    {
      w: 1,
      h: 1,
      x_center: 0.203125,
      y_center: 0.484375
    },
    {
      w: 1,
      h: 1,
      x_center: 0.203125,
      y_center: 0.484375
    },
    {
      w: 1,
      h: 1,
      x_center: 0.234375,
      y_center: 0.484375
    },
    {
      w: 1,
      h: 1,
      x_center: 0.234375,
      y_center: 0.484375
    },
    {
      w: 1,
      h: 1,
      x_center: 0.265625,
      y_center: 0.484375
    },
    {
      w: 1,
      h: 1,
      x_center: 0.265625,
      y_center: 0.484375
    },
    {
      w: 1,
      h: 1,
      x_center: 0.296875,
      y_center: 0.484375
    },
    {
      w: 1,
      h: 1,
      x_center: 0.296875,
      y_center: 0.484375
    },
    {
      w: 1,
      h: 1,
      x_center: 0.328125,
      y_center: 0.484375
    },
    {
      w: 1,
      h: 1,
      x_center: 0.328125,
      y_center: 0.484375
    },
    {
      w: 1,
      h: 1,
      x_center: 0.359375,
      y_center: 0.484375
    },
    {
      w: 1,
      h: 1,
      x_center: 0.359375,
      y_center: 0.484375
    },
    {
      w: 1,
      h: 1,
      x_center: 0.390625,
      y_center: 0.484375
    },
    {
      w: 1,
      h: 1,
      x_center: 0.390625,
      y_center: 0.484375
    },
    {
      w: 1,
      h: 1,
      x_center: 0.421875,
      y_center: 0.484375
    },
    {
      w: 1,
      h: 1,
      x_center: 0.421875,
      y_center: 0.484375
    },
    {
      w: 1,
      h: 1,
      x_center: 0.453125,
      y_center: 0.484375
    },
    {
      w: 1,
      h: 1,
      x_center: 0.453125,
      y_center: 0.484375
    },
    {
      w: 1,
      h: 1,
      x_center: 0.484375,
      y_center: 0.484375
    },
    {
      w: 1,
      h: 1,
      x_center: 0.484375,
      y_center: 0.484375
    },
    {
      w: 1,
      h: 1,
      x_center: 0.515625,
      y_center: 0.484375
    },
    {
      w: 1,
      h: 1,
      x_center: 0.515625,
      y_center: 0.484375
    },
    {
      w: 1,
      h: 1,
      x_center: 0.546875,
      y_center: 0.484375
    },
    {
      w: 1,
      h: 1,
      x_center: 0.546875,
      y_center: 0.484375
    },
    {
      w: 1,
      h: 1,
      x_center: 0.578125,
      y_center: 0.484375
    },
    {
      w: 1,
      h: 1,
      x_center: 0.578125,
      y_center: 0.484375
    },
    {
      w: 1,
      h: 1,
      x_center: 0.609375,
      y_center: 0.484375
    },
    {
      w: 1,
      h: 1,
      x_center: 0.609375,
      y_center: 0.484375
    },
    {
      w: 1,
      h: 1,
      x_center: 0.640625,
      y_center: 0.484375
    },
    {
      w: 1,
      h: 1,
      x_center: 0.640625,
      y_center: 0.484375
    },
    {
      w: 1,
      h: 1,
      x_center: 0.671875,
      y_center: 0.484375
    },
    {
      w: 1,
      h: 1,
      x_center: 0.671875,
      y_center: 0.484375
    },
    {
      w: 1,
      h: 1,
      x_center: 0.703125,
      y_center: 0.484375
    },
    {
      w: 1,
      h: 1,
      x_center: 0.703125,
      y_center: 0.484375
    },
    {
      w: 1,
      h: 1,
      x_center: 0.734375,
      y_center: 0.484375
    },
    {
      w: 1,
      h: 1,
      x_center: 0.734375,
      y_center: 0.484375
    },
    {
      w: 1,
      h: 1,
      x_center: 0.765625,
      y_center: 0.484375
    },
    {
      w: 1,
      h: 1,
      x_center: 0.765625,
      y_center: 0.484375
    },
    {
      w: 1,
      h: 1,
      x_center: 0.796875,
      y_center: 0.484375
    },
    {
      w: 1,
      h: 1,
      x_center: 0.796875,
      y_center: 0.484375
    },
    {
      w: 1,
      h: 1,
      x_center: 0.828125,
      y_center: 0.484375
    },
    {
      w: 1,
      h: 1,
      x_center: 0.828125,
      y_center: 0.484375
    },
    {
      w: 1,
      h: 1,
      x_center: 0.859375,
      y_center: 0.484375
    },
    {
      w: 1,
      h: 1,
      x_center: 0.859375,
      y_center: 0.484375
    },
    {
      w: 1,
      h: 1,
      x_center: 0.890625,
      y_center: 0.484375
    },
    {
      w: 1,
      h: 1,
      x_center: 0.890625,
      y_center: 0.484375
    },
    {
      w: 1,
      h: 1,
      x_center: 0.921875,
      y_center: 0.484375
    },
    {
      w: 1,
      h: 1,
      x_center: 0.921875,
      y_center: 0.484375
    },
    {
      w: 1,
      h: 1,
      x_center: 0.953125,
      y_center: 0.484375
    },
    {
      w: 1,
      h: 1,
      x_center: 0.953125,
      y_center: 0.484375
    },
    {
      w: 1,
      h: 1,
      x_center: 0.984375,
      y_center: 0.484375
    },
    {
      w: 1,
      h: 1,
      x_center: 0.984375,
      y_center: 0.484375
    },
    {
      w: 1,
      h: 1,
      x_center: 0.015625,
      y_center: 0.515625
    },
    {
      w: 1,
      h: 1,
      x_center: 0.015625,
      y_center: 0.515625
    },
    {
      w: 1,
      h: 1,
      x_center: 0.046875,
      y_center: 0.515625
    },
    {
      w: 1,
      h: 1,
      x_center: 0.046875,
      y_center: 0.515625
    },
    {
      w: 1,
      h: 1,
      x_center: 0.078125,
      y_center: 0.515625
    },
    {
      w: 1,
      h: 1,
      x_center: 0.078125,
      y_center: 0.515625
    },
    {
      w: 1,
      h: 1,
      x_center: 0.109375,
      y_center: 0.515625
    },
    {
      w: 1,
      h: 1,
      x_center: 0.109375,
      y_center: 0.515625
    },
    {
      w: 1,
      h: 1,
      x_center: 0.140625,
      y_center: 0.515625
    },
    {
      w: 1,
      h: 1,
      x_center: 0.140625,
      y_center: 0.515625
    },
    {
      w: 1,
      h: 1,
      x_center: 0.171875,
      y_center: 0.515625
    },
    {
      w: 1,
      h: 1,
      x_center: 0.171875,
      y_center: 0.515625
    },
    {
      w: 1,
      h: 1,
      x_center: 0.203125,
      y_center: 0.515625
    },
    {
      w: 1,
      h: 1,
      x_center: 0.203125,
      y_center: 0.515625
    },
    {
      w: 1,
      h: 1,
      x_center: 0.234375,
      y_center: 0.515625
    },
    {
      w: 1,
      h: 1,
      x_center: 0.234375,
      y_center: 0.515625
    },
    {
      w: 1,
      h: 1,
      x_center: 0.265625,
      y_center: 0.515625
    },
    {
      w: 1,
      h: 1,
      x_center: 0.265625,
      y_center: 0.515625
    },
    {
      w: 1,
      h: 1,
      x_center: 0.296875,
      y_center: 0.515625
    },
    {
      w: 1,
      h: 1,
      x_center: 0.296875,
      y_center: 0.515625
    },
    {
      w: 1,
      h: 1,
      x_center: 0.328125,
      y_center: 0.515625
    },
    {
      w: 1,
      h: 1,
      x_center: 0.328125,
      y_center: 0.515625
    },
    {
      w: 1,
      h: 1,
      x_center: 0.359375,
      y_center: 0.515625
    },
    {
      w: 1,
      h: 1,
      x_center: 0.359375,
      y_center: 0.515625
    },
    {
      w: 1,
      h: 1,
      x_center: 0.390625,
      y_center: 0.515625
    },
    {
      w: 1,
      h: 1,
      x_center: 0.390625,
      y_center: 0.515625
    },
    {
      w: 1,
      h: 1,
      x_center: 0.421875,
      y_center: 0.515625
    },
    {
      w: 1,
      h: 1,
      x_center: 0.421875,
      y_center: 0.515625
    },
    {
      w: 1,
      h: 1,
      x_center: 0.453125,
      y_center: 0.515625
    },
    {
      w: 1,
      h: 1,
      x_center: 0.453125,
      y_center: 0.515625
    },
    {
      w: 1,
      h: 1,
      x_center: 0.484375,
      y_center: 0.515625
    },
    {
      w: 1,
      h: 1,
      x_center: 0.484375,
      y_center: 0.515625
    },
    {
      w: 1,
      h: 1,
      x_center: 0.515625,
      y_center: 0.515625
    },
    {
      w: 1,
      h: 1,
      x_center: 0.515625,
      y_center: 0.515625
    },
    {
      w: 1,
      h: 1,
      x_center: 0.546875,
      y_center: 0.515625
    },
    {
      w: 1,
      h: 1,
      x_center: 0.546875,
      y_center: 0.515625
    },
    {
      w: 1,
      h: 1,
      x_center: 0.578125,
      y_center: 0.515625
    },
    {
      w: 1,
      h: 1,
      x_center: 0.578125,
      y_center: 0.515625
    },
    {
      w: 1,
      h: 1,
      x_center: 0.609375,
      y_center: 0.515625
    },
    {
      w: 1,
      h: 1,
      x_center: 0.609375,
      y_center: 0.515625
    },
    {
      w: 1,
      h: 1,
      x_center: 0.640625,
      y_center: 0.515625
    },
    {
      w: 1,
      h: 1,
      x_center: 0.640625,
      y_center: 0.515625
    },
    {
      w: 1,
      h: 1,
      x_center: 0.671875,
      y_center: 0.515625
    },
    {
      w: 1,
      h: 1,
      x_center: 0.671875,
      y_center: 0.515625
    },
    {
      w: 1,
      h: 1,
      x_center: 0.703125,
      y_center: 0.515625
    },
    {
      w: 1,
      h: 1,
      x_center: 0.703125,
      y_center: 0.515625
    },
    {
      w: 1,
      h: 1,
      x_center: 0.734375,
      y_center: 0.515625
    },
    {
      w: 1,
      h: 1,
      x_center: 0.734375,
      y_center: 0.515625
    },
    {
      w: 1,
      h: 1,
      x_center: 0.765625,
      y_center: 0.515625
    },
    {
      w: 1,
      h: 1,
      x_center: 0.765625,
      y_center: 0.515625
    },
    {
      w: 1,
      h: 1,
      x_center: 0.796875,
      y_center: 0.515625
    },
    {
      w: 1,
      h: 1,
      x_center: 0.796875,
      y_center: 0.515625
    },
    {
      w: 1,
      h: 1,
      x_center: 0.828125,
      y_center: 0.515625
    },
    {
      w: 1,
      h: 1,
      x_center: 0.828125,
      y_center: 0.515625
    },
    {
      w: 1,
      h: 1,
      x_center: 0.859375,
      y_center: 0.515625
    },
    {
      w: 1,
      h: 1,
      x_center: 0.859375,
      y_center: 0.515625
    },
    {
      w: 1,
      h: 1,
      x_center: 0.890625,
      y_center: 0.515625
    },
    {
      w: 1,
      h: 1,
      x_center: 0.890625,
      y_center: 0.515625
    },
    {
      w: 1,
      h: 1,
      x_center: 0.921875,
      y_center: 0.515625
    },
    {
      w: 1,
      h: 1,
      x_center: 0.921875,
      y_center: 0.515625
    },
    {
      w: 1,
      h: 1,
      x_center: 0.953125,
      y_center: 0.515625
    },
    {
      w: 1,
      h: 1,
      x_center: 0.953125,
      y_center: 0.515625
    },
    {
      w: 1,
      h: 1,
      x_center: 0.984375,
      y_center: 0.515625
    },
    {
      w: 1,
      h: 1,
      x_center: 0.984375,
      y_center: 0.515625
    },
    {
      w: 1,
      h: 1,
      x_center: 0.015625,
      y_center: 0.546875
    },
    {
      w: 1,
      h: 1,
      x_center: 0.015625,
      y_center: 0.546875
    },
    {
      w: 1,
      h: 1,
      x_center: 0.046875,
      y_center: 0.546875
    },
    {
      w: 1,
      h: 1,
      x_center: 0.046875,
      y_center: 0.546875
    },
    {
      w: 1,
      h: 1,
      x_center: 0.078125,
      y_center: 0.546875
    },
    {
      w: 1,
      h: 1,
      x_center: 0.078125,
      y_center: 0.546875
    },
    {
      w: 1,
      h: 1,
      x_center: 0.109375,
      y_center: 0.546875
    },
    {
      w: 1,
      h: 1,
      x_center: 0.109375,
      y_center: 0.546875
    },
    {
      w: 1,
      h: 1,
      x_center: 0.140625,
      y_center: 0.546875
    },
    {
      w: 1,
      h: 1,
      x_center: 0.140625,
      y_center: 0.546875
    },
    {
      w: 1,
      h: 1,
      x_center: 0.171875,
      y_center: 0.546875
    },
    {
      w: 1,
      h: 1,
      x_center: 0.171875,
      y_center: 0.546875
    },
    {
      w: 1,
      h: 1,
      x_center: 0.203125,
      y_center: 0.546875
    },
    {
      w: 1,
      h: 1,
      x_center: 0.203125,
      y_center: 0.546875
    },
    {
      w: 1,
      h: 1,
      x_center: 0.234375,
      y_center: 0.546875
    },
    {
      w: 1,
      h: 1,
      x_center: 0.234375,
      y_center: 0.546875
    },
    {
      w: 1,
      h: 1,
      x_center: 0.265625,
      y_center: 0.546875
    },
    {
      w: 1,
      h: 1,
      x_center: 0.265625,
      y_center: 0.546875
    },
    {
      w: 1,
      h: 1,
      x_center: 0.296875,
      y_center: 0.546875
    },
    {
      w: 1,
      h: 1,
      x_center: 0.296875,
      y_center: 0.546875
    },
    {
      w: 1,
      h: 1,
      x_center: 0.328125,
      y_center: 0.546875
    },
    {
      w: 1,
      h: 1,
      x_center: 0.328125,
      y_center: 0.546875
    },
    {
      w: 1,
      h: 1,
      x_center: 0.359375,
      y_center: 0.546875
    },
    {
      w: 1,
      h: 1,
      x_center: 0.359375,
      y_center: 0.546875
    },
    {
      w: 1,
      h: 1,
      x_center: 0.390625,
      y_center: 0.546875
    },
    {
      w: 1,
      h: 1,
      x_center: 0.390625,
      y_center: 0.546875
    },
    {
      w: 1,
      h: 1,
      x_center: 0.421875,
      y_center: 0.546875
    },
    {
      w: 1,
      h: 1,
      x_center: 0.421875,
      y_center: 0.546875
    },
    {
      w: 1,
      h: 1,
      x_center: 0.453125,
      y_center: 0.546875
    },
    {
      w: 1,
      h: 1,
      x_center: 0.453125,
      y_center: 0.546875
    },
    {
      w: 1,
      h: 1,
      x_center: 0.484375,
      y_center: 0.546875
    },
    {
      w: 1,
      h: 1,
      x_center: 0.484375,
      y_center: 0.546875
    },
    {
      w: 1,
      h: 1,
      x_center: 0.515625,
      y_center: 0.546875
    },
    {
      w: 1,
      h: 1,
      x_center: 0.515625,
      y_center: 0.546875
    },
    {
      w: 1,
      h: 1,
      x_center: 0.546875,
      y_center: 0.546875
    },
    {
      w: 1,
      h: 1,
      x_center: 0.546875,
      y_center: 0.546875
    },
    {
      w: 1,
      h: 1,
      x_center: 0.578125,
      y_center: 0.546875
    },
    {
      w: 1,
      h: 1,
      x_center: 0.578125,
      y_center: 0.546875
    },
    {
      w: 1,
      h: 1,
      x_center: 0.609375,
      y_center: 0.546875
    },
    {
      w: 1,
      h: 1,
      x_center: 0.609375,
      y_center: 0.546875
    },
    {
      w: 1,
      h: 1,
      x_center: 0.640625,
      y_center: 0.546875
    },
    {
      w: 1,
      h: 1,
      x_center: 0.640625,
      y_center: 0.546875
    },
    {
      w: 1,
      h: 1,
      x_center: 0.671875,
      y_center: 0.546875
    },
    {
      w: 1,
      h: 1,
      x_center: 0.671875,
      y_center: 0.546875
    },
    {
      w: 1,
      h: 1,
      x_center: 0.703125,
      y_center: 0.546875
    },
    {
      w: 1,
      h: 1,
      x_center: 0.703125,
      y_center: 0.546875
    },
    {
      w: 1,
      h: 1,
      x_center: 0.734375,
      y_center: 0.546875
    },
    {
      w: 1,
      h: 1,
      x_center: 0.734375,
      y_center: 0.546875
    },
    {
      w: 1,
      h: 1,
      x_center: 0.765625,
      y_center: 0.546875
    },
    {
      w: 1,
      h: 1,
      x_center: 0.765625,
      y_center: 0.546875
    },
    {
      w: 1,
      h: 1,
      x_center: 0.796875,
      y_center: 0.546875
    },
    {
      w: 1,
      h: 1,
      x_center: 0.796875,
      y_center: 0.546875
    },
    {
      w: 1,
      h: 1,
      x_center: 0.828125,
      y_center: 0.546875
    },
    {
      w: 1,
      h: 1,
      x_center: 0.828125,
      y_center: 0.546875
    },
    {
      w: 1,
      h: 1,
      x_center: 0.859375,
      y_center: 0.546875
    },
    {
      w: 1,
      h: 1,
      x_center: 0.859375,
      y_center: 0.546875
    },
    {
      w: 1,
      h: 1,
      x_center: 0.890625,
      y_center: 0.546875
    },
    {
      w: 1,
      h: 1,
      x_center: 0.890625,
      y_center: 0.546875
    },
    {
      w: 1,
      h: 1,
      x_center: 0.921875,
      y_center: 0.546875
    },
    {
      w: 1,
      h: 1,
      x_center: 0.921875,
      y_center: 0.546875
    },
    {
      w: 1,
      h: 1,
      x_center: 0.953125,
      y_center: 0.546875
    },
    {
      w: 1,
      h: 1,
      x_center: 0.953125,
      y_center: 0.546875
    },
    {
      w: 1,
      h: 1,
      x_center: 0.984375,
      y_center: 0.546875
    },
    {
      w: 1,
      h: 1,
      x_center: 0.984375,
      y_center: 0.546875
    },
    {
      w: 1,
      h: 1,
      x_center: 0.015625,
      y_center: 0.578125
    },
    {
      w: 1,
      h: 1,
      x_center: 0.015625,
      y_center: 0.578125
    },
    {
      w: 1,
      h: 1,
      x_center: 0.046875,
      y_center: 0.578125
    },
    {
      w: 1,
      h: 1,
      x_center: 0.046875,
      y_center: 0.578125
    },
    {
      w: 1,
      h: 1,
      x_center: 0.078125,
      y_center: 0.578125
    },
    {
      w: 1,
      h: 1,
      x_center: 0.078125,
      y_center: 0.578125
    },
    {
      w: 1,
      h: 1,
      x_center: 0.109375,
      y_center: 0.578125
    },
    {
      w: 1,
      h: 1,
      x_center: 0.109375,
      y_center: 0.578125
    },
    {
      w: 1,
      h: 1,
      x_center: 0.140625,
      y_center: 0.578125
    },
    {
      w: 1,
      h: 1,
      x_center: 0.140625,
      y_center: 0.578125
    },
    {
      w: 1,
      h: 1,
      x_center: 0.171875,
      y_center: 0.578125
    },
    {
      w: 1,
      h: 1,
      x_center: 0.171875,
      y_center: 0.578125
    },
    {
      w: 1,
      h: 1,
      x_center: 0.203125,
      y_center: 0.578125
    },
    {
      w: 1,
      h: 1,
      x_center: 0.203125,
      y_center: 0.578125
    },
    {
      w: 1,
      h: 1,
      x_center: 0.234375,
      y_center: 0.578125
    },
    {
      w: 1,
      h: 1,
      x_center: 0.234375,
      y_center: 0.578125
    },
    {
      w: 1,
      h: 1,
      x_center: 0.265625,
      y_center: 0.578125
    },
    {
      w: 1,
      h: 1,
      x_center: 0.265625,
      y_center: 0.578125
    },
    {
      w: 1,
      h: 1,
      x_center: 0.296875,
      y_center: 0.578125
    },
    {
      w: 1,
      h: 1,
      x_center: 0.296875,
      y_center: 0.578125
    },
    {
      w: 1,
      h: 1,
      x_center: 0.328125,
      y_center: 0.578125
    },
    {
      w: 1,
      h: 1,
      x_center: 0.328125,
      y_center: 0.578125
    },
    {
      w: 1,
      h: 1,
      x_center: 0.359375,
      y_center: 0.578125
    },
    {
      w: 1,
      h: 1,
      x_center: 0.359375,
      y_center: 0.578125
    },
    {
      w: 1,
      h: 1,
      x_center: 0.390625,
      y_center: 0.578125
    },
    {
      w: 1,
      h: 1,
      x_center: 0.390625,
      y_center: 0.578125
    },
    {
      w: 1,
      h: 1,
      x_center: 0.421875,
      y_center: 0.578125
    },
    {
      w: 1,
      h: 1,
      x_center: 0.421875,
      y_center: 0.578125
    },
    {
      w: 1,
      h: 1,
      x_center: 0.453125,
      y_center: 0.578125
    },
    {
      w: 1,
      h: 1,
      x_center: 0.453125,
      y_center: 0.578125
    },
    {
      w: 1,
      h: 1,
      x_center: 0.484375,
      y_center: 0.578125
    },
    {
      w: 1,
      h: 1,
      x_center: 0.484375,
      y_center: 0.578125
    },
    {
      w: 1,
      h: 1,
      x_center: 0.515625,
      y_center: 0.578125
    },
    {
      w: 1,
      h: 1,
      x_center: 0.515625,
      y_center: 0.578125
    },
    {
      w: 1,
      h: 1,
      x_center: 0.546875,
      y_center: 0.578125
    },
    {
      w: 1,
      h: 1,
      x_center: 0.546875,
      y_center: 0.578125
    },
    {
      w: 1,
      h: 1,
      x_center: 0.578125,
      y_center: 0.578125
    },
    {
      w: 1,
      h: 1,
      x_center: 0.578125,
      y_center: 0.578125
    },
    {
      w: 1,
      h: 1,
      x_center: 0.609375,
      y_center: 0.578125
    },
    {
      w: 1,
      h: 1,
      x_center: 0.609375,
      y_center: 0.578125
    },
    {
      w: 1,
      h: 1,
      x_center: 0.640625,
      y_center: 0.578125
    },
    {
      w: 1,
      h: 1,
      x_center: 0.640625,
      y_center: 0.578125
    },
    {
      w: 1,
      h: 1,
      x_center: 0.671875,
      y_center: 0.578125
    },
    {
      w: 1,
      h: 1,
      x_center: 0.671875,
      y_center: 0.578125
    },
    {
      w: 1,
      h: 1,
      x_center: 0.703125,
      y_center: 0.578125
    },
    {
      w: 1,
      h: 1,
      x_center: 0.703125,
      y_center: 0.578125
    },
    {
      w: 1,
      h: 1,
      x_center: 0.734375,
      y_center: 0.578125
    },
    {
      w: 1,
      h: 1,
      x_center: 0.734375,
      y_center: 0.578125
    },
    {
      w: 1,
      h: 1,
      x_center: 0.765625,
      y_center: 0.578125
    },
    {
      w: 1,
      h: 1,
      x_center: 0.765625,
      y_center: 0.578125
    },
    {
      w: 1,
      h: 1,
      x_center: 0.796875,
      y_center: 0.578125
    },
    {
      w: 1,
      h: 1,
      x_center: 0.796875,
      y_center: 0.578125
    },
    {
      w: 1,
      h: 1,
      x_center: 0.828125,
      y_center: 0.578125
    },
    {
      w: 1,
      h: 1,
      x_center: 0.828125,
      y_center: 0.578125
    },
    {
      w: 1,
      h: 1,
      x_center: 0.859375,
      y_center: 0.578125
    },
    {
      w: 1,
      h: 1,
      x_center: 0.859375,
      y_center: 0.578125
    },
    {
      w: 1,
      h: 1,
      x_center: 0.890625,
      y_center: 0.578125
    },
    {
      w: 1,
      h: 1,
      x_center: 0.890625,
      y_center: 0.578125
    },
    {
      w: 1,
      h: 1,
      x_center: 0.921875,
      y_center: 0.578125
    },
    {
      w: 1,
      h: 1,
      x_center: 0.921875,
      y_center: 0.578125
    },
    {
      w: 1,
      h: 1,
      x_center: 0.953125,
      y_center: 0.578125
    },
    {
      w: 1,
      h: 1,
      x_center: 0.953125,
      y_center: 0.578125
    },
    {
      w: 1,
      h: 1,
      x_center: 0.984375,
      y_center: 0.578125
    },
    {
      w: 1,
      h: 1,
      x_center: 0.984375,
      y_center: 0.578125
    },
    {
      w: 1,
      h: 1,
      x_center: 0.015625,
      y_center: 0.609375
    },
    {
      w: 1,
      h: 1,
      x_center: 0.015625,
      y_center: 0.609375
    },
    {
      w: 1,
      h: 1,
      x_center: 0.046875,
      y_center: 0.609375
    },
    {
      w: 1,
      h: 1,
      x_center: 0.046875,
      y_center: 0.609375
    },
    {
      w: 1,
      h: 1,
      x_center: 0.078125,
      y_center: 0.609375
    },
    {
      w: 1,
      h: 1,
      x_center: 0.078125,
      y_center: 0.609375
    },
    {
      w: 1,
      h: 1,
      x_center: 0.109375,
      y_center: 0.609375
    },
    {
      w: 1,
      h: 1,
      x_center: 0.109375,
      y_center: 0.609375
    },
    {
      w: 1,
      h: 1,
      x_center: 0.140625,
      y_center: 0.609375
    },
    {
      w: 1,
      h: 1,
      x_center: 0.140625,
      y_center: 0.609375
    },
    {
      w: 1,
      h: 1,
      x_center: 0.171875,
      y_center: 0.609375
    },
    {
      w: 1,
      h: 1,
      x_center: 0.171875,
      y_center: 0.609375
    },
    {
      w: 1,
      h: 1,
      x_center: 0.203125,
      y_center: 0.609375
    },
    {
      w: 1,
      h: 1,
      x_center: 0.203125,
      y_center: 0.609375
    },
    {
      w: 1,
      h: 1,
      x_center: 0.234375,
      y_center: 0.609375
    },
    {
      w: 1,
      h: 1,
      x_center: 0.234375,
      y_center: 0.609375
    },
    {
      w: 1,
      h: 1,
      x_center: 0.265625,
      y_center: 0.609375
    },
    {
      w: 1,
      h: 1,
      x_center: 0.265625,
      y_center: 0.609375
    },
    {
      w: 1,
      h: 1,
      x_center: 0.296875,
      y_center: 0.609375
    },
    {
      w: 1,
      h: 1,
      x_center: 0.296875,
      y_center: 0.609375
    },
    {
      w: 1,
      h: 1,
      x_center: 0.328125,
      y_center: 0.609375
    },
    {
      w: 1,
      h: 1,
      x_center: 0.328125,
      y_center: 0.609375
    },
    {
      w: 1,
      h: 1,
      x_center: 0.359375,
      y_center: 0.609375
    },
    {
      w: 1,
      h: 1,
      x_center: 0.359375,
      y_center: 0.609375
    },
    {
      w: 1,
      h: 1,
      x_center: 0.390625,
      y_center: 0.609375
    },
    {
      w: 1,
      h: 1,
      x_center: 0.390625,
      y_center: 0.609375
    },
    {
      w: 1,
      h: 1,
      x_center: 0.421875,
      y_center: 0.609375
    },
    {
      w: 1,
      h: 1,
      x_center: 0.421875,
      y_center: 0.609375
    },
    {
      w: 1,
      h: 1,
      x_center: 0.453125,
      y_center: 0.609375
    },
    {
      w: 1,
      h: 1,
      x_center: 0.453125,
      y_center: 0.609375
    },
    {
      w: 1,
      h: 1,
      x_center: 0.484375,
      y_center: 0.609375
    },
    {
      w: 1,
      h: 1,
      x_center: 0.484375,
      y_center: 0.609375
    },
    {
      w: 1,
      h: 1,
      x_center: 0.515625,
      y_center: 0.609375
    },
    {
      w: 1,
      h: 1,
      x_center: 0.515625,
      y_center: 0.609375
    },
    {
      w: 1,
      h: 1,
      x_center: 0.546875,
      y_center: 0.609375
    },
    {
      w: 1,
      h: 1,
      x_center: 0.546875,
      y_center: 0.609375
    },
    {
      w: 1,
      h: 1,
      x_center: 0.578125,
      y_center: 0.609375
    },
    {
      w: 1,
      h: 1,
      x_center: 0.578125,
      y_center: 0.609375
    },
    {
      w: 1,
      h: 1,
      x_center: 0.609375,
      y_center: 0.609375
    },
    {
      w: 1,
      h: 1,
      x_center: 0.609375,
      y_center: 0.609375
    },
    {
      w: 1,
      h: 1,
      x_center: 0.640625,
      y_center: 0.609375
    },
    {
      w: 1,
      h: 1,
      x_center: 0.640625,
      y_center: 0.609375
    },
    {
      w: 1,
      h: 1,
      x_center: 0.671875,
      y_center: 0.609375
    },
    {
      w: 1,
      h: 1,
      x_center: 0.671875,
      y_center: 0.609375
    },
    {
      w: 1,
      h: 1,
      x_center: 0.703125,
      y_center: 0.609375
    },
    {
      w: 1,
      h: 1,
      x_center: 0.703125,
      y_center: 0.609375
    },
    {
      w: 1,
      h: 1,
      x_center: 0.734375,
      y_center: 0.609375
    },
    {
      w: 1,
      h: 1,
      x_center: 0.734375,
      y_center: 0.609375
    },
    {
      w: 1,
      h: 1,
      x_center: 0.765625,
      y_center: 0.609375
    },
    {
      w: 1,
      h: 1,
      x_center: 0.765625,
      y_center: 0.609375
    },
    {
      w: 1,
      h: 1,
      x_center: 0.796875,
      y_center: 0.609375
    },
    {
      w: 1,
      h: 1,
      x_center: 0.796875,
      y_center: 0.609375
    },
    {
      w: 1,
      h: 1,
      x_center: 0.828125,
      y_center: 0.609375
    },
    {
      w: 1,
      h: 1,
      x_center: 0.828125,
      y_center: 0.609375
    },
    {
      w: 1,
      h: 1,
      x_center: 0.859375,
      y_center: 0.609375
    },
    {
      w: 1,
      h: 1,
      x_center: 0.859375,
      y_center: 0.609375
    },
    {
      w: 1,
      h: 1,
      x_center: 0.890625,
      y_center: 0.609375
    },
    {
      w: 1,
      h: 1,
      x_center: 0.890625,
      y_center: 0.609375
    },
    {
      w: 1,
      h: 1,
      x_center: 0.921875,
      y_center: 0.609375
    },
    {
      w: 1,
      h: 1,
      x_center: 0.921875,
      y_center: 0.609375
    },
    {
      w: 1,
      h: 1,
      x_center: 0.953125,
      y_center: 0.609375
    },
    {
      w: 1,
      h: 1,
      x_center: 0.953125,
      y_center: 0.609375
    },
    {
      w: 1,
      h: 1,
      x_center: 0.984375,
      y_center: 0.609375
    },
    {
      w: 1,
      h: 1,
      x_center: 0.984375,
      y_center: 0.609375
    },
    {
      w: 1,
      h: 1,
      x_center: 0.015625,
      y_center: 0.640625
    },
    {
      w: 1,
      h: 1,
      x_center: 0.015625,
      y_center: 0.640625
    },
    {
      w: 1,
      h: 1,
      x_center: 0.046875,
      y_center: 0.640625
    },
    {
      w: 1,
      h: 1,
      x_center: 0.046875,
      y_center: 0.640625
    },
    {
      w: 1,
      h: 1,
      x_center: 0.078125,
      y_center: 0.640625
    },
    {
      w: 1,
      h: 1,
      x_center: 0.078125,
      y_center: 0.640625
    },
    {
      w: 1,
      h: 1,
      x_center: 0.109375,
      y_center: 0.640625
    },
    {
      w: 1,
      h: 1,
      x_center: 0.109375,
      y_center: 0.640625
    },
    {
      w: 1,
      h: 1,
      x_center: 0.140625,
      y_center: 0.640625
    },
    {
      w: 1,
      h: 1,
      x_center: 0.140625,
      y_center: 0.640625
    },
    {
      w: 1,
      h: 1,
      x_center: 0.171875,
      y_center: 0.640625
    },
    {
      w: 1,
      h: 1,
      x_center: 0.171875,
      y_center: 0.640625
    },
    {
      w: 1,
      h: 1,
      x_center: 0.203125,
      y_center: 0.640625
    },
    {
      w: 1,
      h: 1,
      x_center: 0.203125,
      y_center: 0.640625
    },
    {
      w: 1,
      h: 1,
      x_center: 0.234375,
      y_center: 0.640625
    },
    {
      w: 1,
      h: 1,
      x_center: 0.234375,
      y_center: 0.640625
    },
    {
      w: 1,
      h: 1,
      x_center: 0.265625,
      y_center: 0.640625
    },
    {
      w: 1,
      h: 1,
      x_center: 0.265625,
      y_center: 0.640625
    },
    {
      w: 1,
      h: 1,
      x_center: 0.296875,
      y_center: 0.640625
    },
    {
      w: 1,
      h: 1,
      x_center: 0.296875,
      y_center: 0.640625
    },
    {
      w: 1,
      h: 1,
      x_center: 0.328125,
      y_center: 0.640625
    },
    {
      w: 1,
      h: 1,
      x_center: 0.328125,
      y_center: 0.640625
    },
    {
      w: 1,
      h: 1,
      x_center: 0.359375,
      y_center: 0.640625
    },
    {
      w: 1,
      h: 1,
      x_center: 0.359375,
      y_center: 0.640625
    },
    {
      w: 1,
      h: 1,
      x_center: 0.390625,
      y_center: 0.640625
    },
    {
      w: 1,
      h: 1,
      x_center: 0.390625,
      y_center: 0.640625
    },
    {
      w: 1,
      h: 1,
      x_center: 0.421875,
      y_center: 0.640625
    },
    {
      w: 1,
      h: 1,
      x_center: 0.421875,
      y_center: 0.640625
    },
    {
      w: 1,
      h: 1,
      x_center: 0.453125,
      y_center: 0.640625
    },
    {
      w: 1,
      h: 1,
      x_center: 0.453125,
      y_center: 0.640625
    },
    {
      w: 1,
      h: 1,
      x_center: 0.484375,
      y_center: 0.640625
    },
    {
      w: 1,
      h: 1,
      x_center: 0.484375,
      y_center: 0.640625
    },
    {
      w: 1,
      h: 1,
      x_center: 0.515625,
      y_center: 0.640625
    },
    {
      w: 1,
      h: 1,
      x_center: 0.515625,
      y_center: 0.640625
    },
    {
      w: 1,
      h: 1,
      x_center: 0.546875,
      y_center: 0.640625
    },
    {
      w: 1,
      h: 1,
      x_center: 0.546875,
      y_center: 0.640625
    },
    {
      w: 1,
      h: 1,
      x_center: 0.578125,
      y_center: 0.640625
    },
    {
      w: 1,
      h: 1,
      x_center: 0.578125,
      y_center: 0.640625
    },
    {
      w: 1,
      h: 1,
      x_center: 0.609375,
      y_center: 0.640625
    },
    {
      w: 1,
      h: 1,
      x_center: 0.609375,
      y_center: 0.640625
    },
    {
      w: 1,
      h: 1,
      x_center: 0.640625,
      y_center: 0.640625
    },
    {
      w: 1,
      h: 1,
      x_center: 0.640625,
      y_center: 0.640625
    },
    {
      w: 1,
      h: 1,
      x_center: 0.671875,
      y_center: 0.640625
    },
    {
      w: 1,
      h: 1,
      x_center: 0.671875,
      y_center: 0.640625
    },
    {
      w: 1,
      h: 1,
      x_center: 0.703125,
      y_center: 0.640625
    },
    {
      w: 1,
      h: 1,
      x_center: 0.703125,
      y_center: 0.640625
    },
    {
      w: 1,
      h: 1,
      x_center: 0.734375,
      y_center: 0.640625
    },
    {
      w: 1,
      h: 1,
      x_center: 0.734375,
      y_center: 0.640625
    },
    {
      w: 1,
      h: 1,
      x_center: 0.765625,
      y_center: 0.640625
    },
    {
      w: 1,
      h: 1,
      x_center: 0.765625,
      y_center: 0.640625
    },
    {
      w: 1,
      h: 1,
      x_center: 0.796875,
      y_center: 0.640625
    },
    {
      w: 1,
      h: 1,
      x_center: 0.796875,
      y_center: 0.640625
    },
    {
      w: 1,
      h: 1,
      x_center: 0.828125,
      y_center: 0.640625
    },
    {
      w: 1,
      h: 1,
      x_center: 0.828125,
      y_center: 0.640625
    },
    {
      w: 1,
      h: 1,
      x_center: 0.859375,
      y_center: 0.640625
    },
    {
      w: 1,
      h: 1,
      x_center: 0.859375,
      y_center: 0.640625
    },
    {
      w: 1,
      h: 1,
      x_center: 0.890625,
      y_center: 0.640625
    },
    {
      w: 1,
      h: 1,
      x_center: 0.890625,
      y_center: 0.640625
    },
    {
      w: 1,
      h: 1,
      x_center: 0.921875,
      y_center: 0.640625
    },
    {
      w: 1,
      h: 1,
      x_center: 0.921875,
      y_center: 0.640625
    },
    {
      w: 1,
      h: 1,
      x_center: 0.953125,
      y_center: 0.640625
    },
    {
      w: 1,
      h: 1,
      x_center: 0.953125,
      y_center: 0.640625
    },
    {
      w: 1,
      h: 1,
      x_center: 0.984375,
      y_center: 0.640625
    },
    {
      w: 1,
      h: 1,
      x_center: 0.984375,
      y_center: 0.640625
    },
    {
      w: 1,
      h: 1,
      x_center: 0.015625,
      y_center: 0.671875
    },
    {
      w: 1,
      h: 1,
      x_center: 0.015625,
      y_center: 0.671875
    },
    {
      w: 1,
      h: 1,
      x_center: 0.046875,
      y_center: 0.671875
    },
    {
      w: 1,
      h: 1,
      x_center: 0.046875,
      y_center: 0.671875
    },
    {
      w: 1,
      h: 1,
      x_center: 0.078125,
      y_center: 0.671875
    },
    {
      w: 1,
      h: 1,
      x_center: 0.078125,
      y_center: 0.671875
    },
    {
      w: 1,
      h: 1,
      x_center: 0.109375,
      y_center: 0.671875
    },
    {
      w: 1,
      h: 1,
      x_center: 0.109375,
      y_center: 0.671875
    },
    {
      w: 1,
      h: 1,
      x_center: 0.140625,
      y_center: 0.671875
    },
    {
      w: 1,
      h: 1,
      x_center: 0.140625,
      y_center: 0.671875
    },
    {
      w: 1,
      h: 1,
      x_center: 0.171875,
      y_center: 0.671875
    },
    {
      w: 1,
      h: 1,
      x_center: 0.171875,
      y_center: 0.671875
    },
    {
      w: 1,
      h: 1,
      x_center: 0.203125,
      y_center: 0.671875
    },
    {
      w: 1,
      h: 1,
      x_center: 0.203125,
      y_center: 0.671875
    },
    {
      w: 1,
      h: 1,
      x_center: 0.234375,
      y_center: 0.671875
    },
    {
      w: 1,
      h: 1,
      x_center: 0.234375,
      y_center: 0.671875
    },
    {
      w: 1,
      h: 1,
      x_center: 0.265625,
      y_center: 0.671875
    },
    {
      w: 1,
      h: 1,
      x_center: 0.265625,
      y_center: 0.671875
    },
    {
      w: 1,
      h: 1,
      x_center: 0.296875,
      y_center: 0.671875
    },
    {
      w: 1,
      h: 1,
      x_center: 0.296875,
      y_center: 0.671875
    },
    {
      w: 1,
      h: 1,
      x_center: 0.328125,
      y_center: 0.671875
    },
    {
      w: 1,
      h: 1,
      x_center: 0.328125,
      y_center: 0.671875
    },
    {
      w: 1,
      h: 1,
      x_center: 0.359375,
      y_center: 0.671875
    },
    {
      w: 1,
      h: 1,
      x_center: 0.359375,
      y_center: 0.671875
    },
    {
      w: 1,
      h: 1,
      x_center: 0.390625,
      y_center: 0.671875
    },
    {
      w: 1,
      h: 1,
      x_center: 0.390625,
      y_center: 0.671875
    },
    {
      w: 1,
      h: 1,
      x_center: 0.421875,
      y_center: 0.671875
    },
    {
      w: 1,
      h: 1,
      x_center: 0.421875,
      y_center: 0.671875
    },
    {
      w: 1,
      h: 1,
      x_center: 0.453125,
      y_center: 0.671875
    },
    {
      w: 1,
      h: 1,
      x_center: 0.453125,
      y_center: 0.671875
    },
    {
      w: 1,
      h: 1,
      x_center: 0.484375,
      y_center: 0.671875
    },
    {
      w: 1,
      h: 1,
      x_center: 0.484375,
      y_center: 0.671875
    },
    {
      w: 1,
      h: 1,
      x_center: 0.515625,
      y_center: 0.671875
    },
    {
      w: 1,
      h: 1,
      x_center: 0.515625,
      y_center: 0.671875
    },
    {
      w: 1,
      h: 1,
      x_center: 0.546875,
      y_center: 0.671875
    },
    {
      w: 1,
      h: 1,
      x_center: 0.546875,
      y_center: 0.671875
    },
    {
      w: 1,
      h: 1,
      x_center: 0.578125,
      y_center: 0.671875
    },
    {
      w: 1,
      h: 1,
      x_center: 0.578125,
      y_center: 0.671875
    },
    {
      w: 1,
      h: 1,
      x_center: 0.609375,
      y_center: 0.671875
    },
    {
      w: 1,
      h: 1,
      x_center: 0.609375,
      y_center: 0.671875
    },
    {
      w: 1,
      h: 1,
      x_center: 0.640625,
      y_center: 0.671875
    },
    {
      w: 1,
      h: 1,
      x_center: 0.640625,
      y_center: 0.671875
    },
    {
      w: 1,
      h: 1,
      x_center: 0.671875,
      y_center: 0.671875
    },
    {
      w: 1,
      h: 1,
      x_center: 0.671875,
      y_center: 0.671875
    },
    {
      w: 1,
      h: 1,
      x_center: 0.703125,
      y_center: 0.671875
    },
    {
      w: 1,
      h: 1,
      x_center: 0.703125,
      y_center: 0.671875
    },
    {
      w: 1,
      h: 1,
      x_center: 0.734375,
      y_center: 0.671875
    },
    {
      w: 1,
      h: 1,
      x_center: 0.734375,
      y_center: 0.671875
    },
    {
      w: 1,
      h: 1,
      x_center: 0.765625,
      y_center: 0.671875
    },
    {
      w: 1,
      h: 1,
      x_center: 0.765625,
      y_center: 0.671875
    },
    {
      w: 1,
      h: 1,
      x_center: 0.796875,
      y_center: 0.671875
    },
    {
      w: 1,
      h: 1,
      x_center: 0.796875,
      y_center: 0.671875
    },
    {
      w: 1,
      h: 1,
      x_center: 0.828125,
      y_center: 0.671875
    },
    {
      w: 1,
      h: 1,
      x_center: 0.828125,
      y_center: 0.671875
    },
    {
      w: 1,
      h: 1,
      x_center: 0.859375,
      y_center: 0.671875
    },
    {
      w: 1,
      h: 1,
      x_center: 0.859375,
      y_center: 0.671875
    },
    {
      w: 1,
      h: 1,
      x_center: 0.890625,
      y_center: 0.671875
    },
    {
      w: 1,
      h: 1,
      x_center: 0.890625,
      y_center: 0.671875
    },
    {
      w: 1,
      h: 1,
      x_center: 0.921875,
      y_center: 0.671875
    },
    {
      w: 1,
      h: 1,
      x_center: 0.921875,
      y_center: 0.671875
    },
    {
      w: 1,
      h: 1,
      x_center: 0.953125,
      y_center: 0.671875
    },
    {
      w: 1,
      h: 1,
      x_center: 0.953125,
      y_center: 0.671875
    },
    {
      w: 1,
      h: 1,
      x_center: 0.984375,
      y_center: 0.671875
    },
    {
      w: 1,
      h: 1,
      x_center: 0.984375,
      y_center: 0.671875
    },
    {
      w: 1,
      h: 1,
      x_center: 0.015625,
      y_center: 0.703125
    },
    {
      w: 1,
      h: 1,
      x_center: 0.015625,
      y_center: 0.703125
    },
    {
      w: 1,
      h: 1,
      x_center: 0.046875,
      y_center: 0.703125
    },
    {
      w: 1,
      h: 1,
      x_center: 0.046875,
      y_center: 0.703125
    },
    {
      w: 1,
      h: 1,
      x_center: 0.078125,
      y_center: 0.703125
    },
    {
      w: 1,
      h: 1,
      x_center: 0.078125,
      y_center: 0.703125
    },
    {
      w: 1,
      h: 1,
      x_center: 0.109375,
      y_center: 0.703125
    },
    {
      w: 1,
      h: 1,
      x_center: 0.109375,
      y_center: 0.703125
    },
    {
      w: 1,
      h: 1,
      x_center: 0.140625,
      y_center: 0.703125
    },
    {
      w: 1,
      h: 1,
      x_center: 0.140625,
      y_center: 0.703125
    },
    {
      w: 1,
      h: 1,
      x_center: 0.171875,
      y_center: 0.703125
    },
    {
      w: 1,
      h: 1,
      x_center: 0.171875,
      y_center: 0.703125
    },
    {
      w: 1,
      h: 1,
      x_center: 0.203125,
      y_center: 0.703125
    },
    {
      w: 1,
      h: 1,
      x_center: 0.203125,
      y_center: 0.703125
    },
    {
      w: 1,
      h: 1,
      x_center: 0.234375,
      y_center: 0.703125
    },
    {
      w: 1,
      h: 1,
      x_center: 0.234375,
      y_center: 0.703125
    },
    {
      w: 1,
      h: 1,
      x_center: 0.265625,
      y_center: 0.703125
    },
    {
      w: 1,
      h: 1,
      x_center: 0.265625,
      y_center: 0.703125
    },
    {
      w: 1,
      h: 1,
      x_center: 0.296875,
      y_center: 0.703125
    },
    {
      w: 1,
      h: 1,
      x_center: 0.296875,
      y_center: 0.703125
    },
    {
      w: 1,
      h: 1,
      x_center: 0.328125,
      y_center: 0.703125
    },
    {
      w: 1,
      h: 1,
      x_center: 0.328125,
      y_center: 0.703125
    },
    {
      w: 1,
      h: 1,
      x_center: 0.359375,
      y_center: 0.703125
    },
    {
      w: 1,
      h: 1,
      x_center: 0.359375,
      y_center: 0.703125
    },
    {
      w: 1,
      h: 1,
      x_center: 0.390625,
      y_center: 0.703125
    },
    {
      w: 1,
      h: 1,
      x_center: 0.390625,
      y_center: 0.703125
    },
    {
      w: 1,
      h: 1,
      x_center: 0.421875,
      y_center: 0.703125
    },
    {
      w: 1,
      h: 1,
      x_center: 0.421875,
      y_center: 0.703125
    },
    {
      w: 1,
      h: 1,
      x_center: 0.453125,
      y_center: 0.703125
    },
    {
      w: 1,
      h: 1,
      x_center: 0.453125,
      y_center: 0.703125
    },
    {
      w: 1,
      h: 1,
      x_center: 0.484375,
      y_center: 0.703125
    },
    {
      w: 1,
      h: 1,
      x_center: 0.484375,
      y_center: 0.703125
    },
    {
      w: 1,
      h: 1,
      x_center: 0.515625,
      y_center: 0.703125
    },
    {
      w: 1,
      h: 1,
      x_center: 0.515625,
      y_center: 0.703125
    },
    {
      w: 1,
      h: 1,
      x_center: 0.546875,
      y_center: 0.703125
    },
    {
      w: 1,
      h: 1,
      x_center: 0.546875,
      y_center: 0.703125
    },
    {
      w: 1,
      h: 1,
      x_center: 0.578125,
      y_center: 0.703125
    },
    {
      w: 1,
      h: 1,
      x_center: 0.578125,
      y_center: 0.703125
    },
    {
      w: 1,
      h: 1,
      x_center: 0.609375,
      y_center: 0.703125
    },
    {
      w: 1,
      h: 1,
      x_center: 0.609375,
      y_center: 0.703125
    },
    {
      w: 1,
      h: 1,
      x_center: 0.640625,
      y_center: 0.703125
    },
    {
      w: 1,
      h: 1,
      x_center: 0.640625,
      y_center: 0.703125
    },
    {
      w: 1,
      h: 1,
      x_center: 0.671875,
      y_center: 0.703125
    },
    {
      w: 1,
      h: 1,
      x_center: 0.671875,
      y_center: 0.703125
    },
    {
      w: 1,
      h: 1,
      x_center: 0.703125,
      y_center: 0.703125
    },
    {
      w: 1,
      h: 1,
      x_center: 0.703125,
      y_center: 0.703125
    },
    {
      w: 1,
      h: 1,
      x_center: 0.734375,
      y_center: 0.703125
    },
    {
      w: 1,
      h: 1,
      x_center: 0.734375,
      y_center: 0.703125
    },
    {
      w: 1,
      h: 1,
      x_center: 0.765625,
      y_center: 0.703125
    },
    {
      w: 1,
      h: 1,
      x_center: 0.765625,
      y_center: 0.703125
    },
    {
      w: 1,
      h: 1,
      x_center: 0.796875,
      y_center: 0.703125
    },
    {
      w: 1,
      h: 1,
      x_center: 0.796875,
      y_center: 0.703125
    },
    {
      w: 1,
      h: 1,
      x_center: 0.828125,
      y_center: 0.703125
    },
    {
      w: 1,
      h: 1,
      x_center: 0.828125,
      y_center: 0.703125
    },
    {
      w: 1,
      h: 1,
      x_center: 0.859375,
      y_center: 0.703125
    },
    {
      w: 1,
      h: 1,
      x_center: 0.859375,
      y_center: 0.703125
    },
    {
      w: 1,
      h: 1,
      x_center: 0.890625,
      y_center: 0.703125
    },
    {
      w: 1,
      h: 1,
      x_center: 0.890625,
      y_center: 0.703125
    },
    {
      w: 1,
      h: 1,
      x_center: 0.921875,
      y_center: 0.703125
    },
    {
      w: 1,
      h: 1,
      x_center: 0.921875,
      y_center: 0.703125
    },
    {
      w: 1,
      h: 1,
      x_center: 0.953125,
      y_center: 0.703125
    },
    {
      w: 1,
      h: 1,
      x_center: 0.953125,
      y_center: 0.703125
    },
    {
      w: 1,
      h: 1,
      x_center: 0.984375,
      y_center: 0.703125
    },
    {
      w: 1,
      h: 1,
      x_center: 0.984375,
      y_center: 0.703125
    },
    {
      w: 1,
      h: 1,
      x_center: 0.015625,
      y_center: 0.734375
    },
    {
      w: 1,
      h: 1,
      x_center: 0.015625,
      y_center: 0.734375
    },
    {
      w: 1,
      h: 1,
      x_center: 0.046875,
      y_center: 0.734375
    },
    {
      w: 1,
      h: 1,
      x_center: 0.046875,
      y_center: 0.734375
    },
    {
      w: 1,
      h: 1,
      x_center: 0.078125,
      y_center: 0.734375
    },
    {
      w: 1,
      h: 1,
      x_center: 0.078125,
      y_center: 0.734375
    },
    {
      w: 1,
      h: 1,
      x_center: 0.109375,
      y_center: 0.734375
    },
    {
      w: 1,
      h: 1,
      x_center: 0.109375,
      y_center: 0.734375
    },
    {
      w: 1,
      h: 1,
      x_center: 0.140625,
      y_center: 0.734375
    },
    {
      w: 1,
      h: 1,
      x_center: 0.140625,
      y_center: 0.734375
    },
    {
      w: 1,
      h: 1,
      x_center: 0.171875,
      y_center: 0.734375
    },
    {
      w: 1,
      h: 1,
      x_center: 0.171875,
      y_center: 0.734375
    },
    {
      w: 1,
      h: 1,
      x_center: 0.203125,
      y_center: 0.734375
    },
    {
      w: 1,
      h: 1,
      x_center: 0.203125,
      y_center: 0.734375
    },
    {
      w: 1,
      h: 1,
      x_center: 0.234375,
      y_center: 0.734375
    },
    {
      w: 1,
      h: 1,
      x_center: 0.234375,
      y_center: 0.734375
    },
    {
      w: 1,
      h: 1,
      x_center: 0.265625,
      y_center: 0.734375
    },
    {
      w: 1,
      h: 1,
      x_center: 0.265625,
      y_center: 0.734375
    },
    {
      w: 1,
      h: 1,
      x_center: 0.296875,
      y_center: 0.734375
    },
    {
      w: 1,
      h: 1,
      x_center: 0.296875,
      y_center: 0.734375
    },
    {
      w: 1,
      h: 1,
      x_center: 0.328125,
      y_center: 0.734375
    },
    {
      w: 1,
      h: 1,
      x_center: 0.328125,
      y_center: 0.734375
    },
    {
      w: 1,
      h: 1,
      x_center: 0.359375,
      y_center: 0.734375
    },
    {
      w: 1,
      h: 1,
      x_center: 0.359375,
      y_center: 0.734375
    },
    {
      w: 1,
      h: 1,
      x_center: 0.390625,
      y_center: 0.734375
    },
    {
      w: 1,
      h: 1,
      x_center: 0.390625,
      y_center: 0.734375
    },
    {
      w: 1,
      h: 1,
      x_center: 0.421875,
      y_center: 0.734375
    },
    {
      w: 1,
      h: 1,
      x_center: 0.421875,
      y_center: 0.734375
    },
    {
      w: 1,
      h: 1,
      x_center: 0.453125,
      y_center: 0.734375
    },
    {
      w: 1,
      h: 1,
      x_center: 0.453125,
      y_center: 0.734375
    },
    {
      w: 1,
      h: 1,
      x_center: 0.484375,
      y_center: 0.734375
    },
    {
      w: 1,
      h: 1,
      x_center: 0.484375,
      y_center: 0.734375
    },
    {
      w: 1,
      h: 1,
      x_center: 0.515625,
      y_center: 0.734375
    },
    {
      w: 1,
      h: 1,
      x_center: 0.515625,
      y_center: 0.734375
    },
    {
      w: 1,
      h: 1,
      x_center: 0.546875,
      y_center: 0.734375
    },
    {
      w: 1,
      h: 1,
      x_center: 0.546875,
      y_center: 0.734375
    },
    {
      w: 1,
      h: 1,
      x_center: 0.578125,
      y_center: 0.734375
    },
    {
      w: 1,
      h: 1,
      x_center: 0.578125,
      y_center: 0.734375
    },
    {
      w: 1,
      h: 1,
      x_center: 0.609375,
      y_center: 0.734375
    },
    {
      w: 1,
      h: 1,
      x_center: 0.609375,
      y_center: 0.734375
    },
    {
      w: 1,
      h: 1,
      x_center: 0.640625,
      y_center: 0.734375
    },
    {
      w: 1,
      h: 1,
      x_center: 0.640625,
      y_center: 0.734375
    },
    {
      w: 1,
      h: 1,
      x_center: 0.671875,
      y_center: 0.734375
    },
    {
      w: 1,
      h: 1,
      x_center: 0.671875,
      y_center: 0.734375
    },
    {
      w: 1,
      h: 1,
      x_center: 0.703125,
      y_center: 0.734375
    },
    {
      w: 1,
      h: 1,
      x_center: 0.703125,
      y_center: 0.734375
    },
    {
      w: 1,
      h: 1,
      x_center: 0.734375,
      y_center: 0.734375
    },
    {
      w: 1,
      h: 1,
      x_center: 0.734375,
      y_center: 0.734375
    },
    {
      w: 1,
      h: 1,
      x_center: 0.765625,
      y_center: 0.734375
    },
    {
      w: 1,
      h: 1,
      x_center: 0.765625,
      y_center: 0.734375
    },
    {
      w: 1,
      h: 1,
      x_center: 0.796875,
      y_center: 0.734375
    },
    {
      w: 1,
      h: 1,
      x_center: 0.796875,
      y_center: 0.734375
    },
    {
      w: 1,
      h: 1,
      x_center: 0.828125,
      y_center: 0.734375
    },
    {
      w: 1,
      h: 1,
      x_center: 0.828125,
      y_center: 0.734375
    },
    {
      w: 1,
      h: 1,
      x_center: 0.859375,
      y_center: 0.734375
    },
    {
      w: 1,
      h: 1,
      x_center: 0.859375,
      y_center: 0.734375
    },
    {
      w: 1,
      h: 1,
      x_center: 0.890625,
      y_center: 0.734375
    },
    {
      w: 1,
      h: 1,
      x_center: 0.890625,
      y_center: 0.734375
    },
    {
      w: 1,
      h: 1,
      x_center: 0.921875,
      y_center: 0.734375
    },
    {
      w: 1,
      h: 1,
      x_center: 0.921875,
      y_center: 0.734375
    },
    {
      w: 1,
      h: 1,
      x_center: 0.953125,
      y_center: 0.734375
    },
    {
      w: 1,
      h: 1,
      x_center: 0.953125,
      y_center: 0.734375
    },
    {
      w: 1,
      h: 1,
      x_center: 0.984375,
      y_center: 0.734375
    },
    {
      w: 1,
      h: 1,
      x_center: 0.984375,
      y_center: 0.734375
    },
    {
      w: 1,
      h: 1,
      x_center: 0.015625,
      y_center: 0.765625
    },
    {
      w: 1,
      h: 1,
      x_center: 0.015625,
      y_center: 0.765625
    },
    {
      w: 1,
      h: 1,
      x_center: 0.046875,
      y_center: 0.765625
    },
    {
      w: 1,
      h: 1,
      x_center: 0.046875,
      y_center: 0.765625
    },
    {
      w: 1,
      h: 1,
      x_center: 0.078125,
      y_center: 0.765625
    },
    {
      w: 1,
      h: 1,
      x_center: 0.078125,
      y_center: 0.765625
    },
    {
      w: 1,
      h: 1,
      x_center: 0.109375,
      y_center: 0.765625
    },
    {
      w: 1,
      h: 1,
      x_center: 0.109375,
      y_center: 0.765625
    },
    {
      w: 1,
      h: 1,
      x_center: 0.140625,
      y_center: 0.765625
    },
    {
      w: 1,
      h: 1,
      x_center: 0.140625,
      y_center: 0.765625
    },
    {
      w: 1,
      h: 1,
      x_center: 0.171875,
      y_center: 0.765625
    },
    {
      w: 1,
      h: 1,
      x_center: 0.171875,
      y_center: 0.765625
    },
    {
      w: 1,
      h: 1,
      x_center: 0.203125,
      y_center: 0.765625
    },
    {
      w: 1,
      h: 1,
      x_center: 0.203125,
      y_center: 0.765625
    },
    {
      w: 1,
      h: 1,
      x_center: 0.234375,
      y_center: 0.765625
    },
    {
      w: 1,
      h: 1,
      x_center: 0.234375,
      y_center: 0.765625
    },
    {
      w: 1,
      h: 1,
      x_center: 0.265625,
      y_center: 0.765625
    },
    {
      w: 1,
      h: 1,
      x_center: 0.265625,
      y_center: 0.765625
    },
    {
      w: 1,
      h: 1,
      x_center: 0.296875,
      y_center: 0.765625
    },
    {
      w: 1,
      h: 1,
      x_center: 0.296875,
      y_center: 0.765625
    },
    {
      w: 1,
      h: 1,
      x_center: 0.328125,
      y_center: 0.765625
    },
    {
      w: 1,
      h: 1,
      x_center: 0.328125,
      y_center: 0.765625
    },
    {
      w: 1,
      h: 1,
      x_center: 0.359375,
      y_center: 0.765625
    },
    {
      w: 1,
      h: 1,
      x_center: 0.359375,
      y_center: 0.765625
    },
    {
      w: 1,
      h: 1,
      x_center: 0.390625,
      y_center: 0.765625
    },
    {
      w: 1,
      h: 1,
      x_center: 0.390625,
      y_center: 0.765625
    },
    {
      w: 1,
      h: 1,
      x_center: 0.421875,
      y_center: 0.765625
    },
    {
      w: 1,
      h: 1,
      x_center: 0.421875,
      y_center: 0.765625
    },
    {
      w: 1,
      h: 1,
      x_center: 0.453125,
      y_center: 0.765625
    },
    {
      w: 1,
      h: 1,
      x_center: 0.453125,
      y_center: 0.765625
    },
    {
      w: 1,
      h: 1,
      x_center: 0.484375,
      y_center: 0.765625
    },
    {
      w: 1,
      h: 1,
      x_center: 0.484375,
      y_center: 0.765625
    },
    {
      w: 1,
      h: 1,
      x_center: 0.515625,
      y_center: 0.765625
    },
    {
      w: 1,
      h: 1,
      x_center: 0.515625,
      y_center: 0.765625
    },
    {
      w: 1,
      h: 1,
      x_center: 0.546875,
      y_center: 0.765625
    },
    {
      w: 1,
      h: 1,
      x_center: 0.546875,
      y_center: 0.765625
    },
    {
      w: 1,
      h: 1,
      x_center: 0.578125,
      y_center: 0.765625
    },
    {
      w: 1,
      h: 1,
      x_center: 0.578125,
      y_center: 0.765625
    },
    {
      w: 1,
      h: 1,
      x_center: 0.609375,
      y_center: 0.765625
    },
    {
      w: 1,
      h: 1,
      x_center: 0.609375,
      y_center: 0.765625
    },
    {
      w: 1,
      h: 1,
      x_center: 0.640625,
      y_center: 0.765625
    },
    {
      w: 1,
      h: 1,
      x_center: 0.640625,
      y_center: 0.765625
    },
    {
      w: 1,
      h: 1,
      x_center: 0.671875,
      y_center: 0.765625
    },
    {
      w: 1,
      h: 1,
      x_center: 0.671875,
      y_center: 0.765625
    },
    {
      w: 1,
      h: 1,
      x_center: 0.703125,
      y_center: 0.765625
    },
    {
      w: 1,
      h: 1,
      x_center: 0.703125,
      y_center: 0.765625
    },
    {
      w: 1,
      h: 1,
      x_center: 0.734375,
      y_center: 0.765625
    },
    {
      w: 1,
      h: 1,
      x_center: 0.734375,
      y_center: 0.765625
    },
    {
      w: 1,
      h: 1,
      x_center: 0.765625,
      y_center: 0.765625
    },
    {
      w: 1,
      h: 1,
      x_center: 0.765625,
      y_center: 0.765625
    },
    {
      w: 1,
      h: 1,
      x_center: 0.796875,
      y_center: 0.765625
    },
    {
      w: 1,
      h: 1,
      x_center: 0.796875,
      y_center: 0.765625
    },
    {
      w: 1,
      h: 1,
      x_center: 0.828125,
      y_center: 0.765625
    },
    {
      w: 1,
      h: 1,
      x_center: 0.828125,
      y_center: 0.765625
    },
    {
      w: 1,
      h: 1,
      x_center: 0.859375,
      y_center: 0.765625
    },
    {
      w: 1,
      h: 1,
      x_center: 0.859375,
      y_center: 0.765625
    },
    {
      w: 1,
      h: 1,
      x_center: 0.890625,
      y_center: 0.765625
    },
    {
      w: 1,
      h: 1,
      x_center: 0.890625,
      y_center: 0.765625
    },
    {
      w: 1,
      h: 1,
      x_center: 0.921875,
      y_center: 0.765625
    },
    {
      w: 1,
      h: 1,
      x_center: 0.921875,
      y_center: 0.765625
    },
    {
      w: 1,
      h: 1,
      x_center: 0.953125,
      y_center: 0.765625
    },
    {
      w: 1,
      h: 1,
      x_center: 0.953125,
      y_center: 0.765625
    },
    {
      w: 1,
      h: 1,
      x_center: 0.984375,
      y_center: 0.765625
    },
    {
      w: 1,
      h: 1,
      x_center: 0.984375,
      y_center: 0.765625
    },
    {
      w: 1,
      h: 1,
      x_center: 0.015625,
      y_center: 0.796875
    },
    {
      w: 1,
      h: 1,
      x_center: 0.015625,
      y_center: 0.796875
    },
    {
      w: 1,
      h: 1,
      x_center: 0.046875,
      y_center: 0.796875
    },
    {
      w: 1,
      h: 1,
      x_center: 0.046875,
      y_center: 0.796875
    },
    {
      w: 1,
      h: 1,
      x_center: 0.078125,
      y_center: 0.796875
    },
    {
      w: 1,
      h: 1,
      x_center: 0.078125,
      y_center: 0.796875
    },
    {
      w: 1,
      h: 1,
      x_center: 0.109375,
      y_center: 0.796875
    },
    {
      w: 1,
      h: 1,
      x_center: 0.109375,
      y_center: 0.796875
    },
    {
      w: 1,
      h: 1,
      x_center: 0.140625,
      y_center: 0.796875
    },
    {
      w: 1,
      h: 1,
      x_center: 0.140625,
      y_center: 0.796875
    },
    {
      w: 1,
      h: 1,
      x_center: 0.171875,
      y_center: 0.796875
    },
    {
      w: 1,
      h: 1,
      x_center: 0.171875,
      y_center: 0.796875
    },
    {
      w: 1,
      h: 1,
      x_center: 0.203125,
      y_center: 0.796875
    },
    {
      w: 1,
      h: 1,
      x_center: 0.203125,
      y_center: 0.796875
    },
    {
      w: 1,
      h: 1,
      x_center: 0.234375,
      y_center: 0.796875
    },
    {
      w: 1,
      h: 1,
      x_center: 0.234375,
      y_center: 0.796875
    },
    {
      w: 1,
      h: 1,
      x_center: 0.265625,
      y_center: 0.796875
    },
    {
      w: 1,
      h: 1,
      x_center: 0.265625,
      y_center: 0.796875
    },
    {
      w: 1,
      h: 1,
      x_center: 0.296875,
      y_center: 0.796875
    },
    {
      w: 1,
      h: 1,
      x_center: 0.296875,
      y_center: 0.796875
    },
    {
      w: 1,
      h: 1,
      x_center: 0.328125,
      y_center: 0.796875
    },
    {
      w: 1,
      h: 1,
      x_center: 0.328125,
      y_center: 0.796875
    },
    {
      w: 1,
      h: 1,
      x_center: 0.359375,
      y_center: 0.796875
    },
    {
      w: 1,
      h: 1,
      x_center: 0.359375,
      y_center: 0.796875
    },
    {
      w: 1,
      h: 1,
      x_center: 0.390625,
      y_center: 0.796875
    },
    {
      w: 1,
      h: 1,
      x_center: 0.390625,
      y_center: 0.796875
    },
    {
      w: 1,
      h: 1,
      x_center: 0.421875,
      y_center: 0.796875
    },
    {
      w: 1,
      h: 1,
      x_center: 0.421875,
      y_center: 0.796875
    },
    {
      w: 1,
      h: 1,
      x_center: 0.453125,
      y_center: 0.796875
    },
    {
      w: 1,
      h: 1,
      x_center: 0.453125,
      y_center: 0.796875
    },
    {
      w: 1,
      h: 1,
      x_center: 0.484375,
      y_center: 0.796875
    },
    {
      w: 1,
      h: 1,
      x_center: 0.484375,
      y_center: 0.796875
    },
    {
      w: 1,
      h: 1,
      x_center: 0.515625,
      y_center: 0.796875
    },
    {
      w: 1,
      h: 1,
      x_center: 0.515625,
      y_center: 0.796875
    },
    {
      w: 1,
      h: 1,
      x_center: 0.546875,
      y_center: 0.796875
    },
    {
      w: 1,
      h: 1,
      x_center: 0.546875,
      y_center: 0.796875
    },
    {
      w: 1,
      h: 1,
      x_center: 0.578125,
      y_center: 0.796875
    },
    {
      w: 1,
      h: 1,
      x_center: 0.578125,
      y_center: 0.796875
    },
    {
      w: 1,
      h: 1,
      x_center: 0.609375,
      y_center: 0.796875
    },
    {
      w: 1,
      h: 1,
      x_center: 0.609375,
      y_center: 0.796875
    },
    {
      w: 1,
      h: 1,
      x_center: 0.640625,
      y_center: 0.796875
    },
    {
      w: 1,
      h: 1,
      x_center: 0.640625,
      y_center: 0.796875
    },
    {
      w: 1,
      h: 1,
      x_center: 0.671875,
      y_center: 0.796875
    },
    {
      w: 1,
      h: 1,
      x_center: 0.671875,
      y_center: 0.796875
    },
    {
      w: 1,
      h: 1,
      x_center: 0.703125,
      y_center: 0.796875
    },
    {
      w: 1,
      h: 1,
      x_center: 0.703125,
      y_center: 0.796875
    },
    {
      w: 1,
      h: 1,
      x_center: 0.734375,
      y_center: 0.796875
    },
    {
      w: 1,
      h: 1,
      x_center: 0.734375,
      y_center: 0.796875
    },
    {
      w: 1,
      h: 1,
      x_center: 0.765625,
      y_center: 0.796875
    },
    {
      w: 1,
      h: 1,
      x_center: 0.765625,
      y_center: 0.796875
    },
    {
      w: 1,
      h: 1,
      x_center: 0.796875,
      y_center: 0.796875
    },
    {
      w: 1,
      h: 1,
      x_center: 0.796875,
      y_center: 0.796875
    },
    {
      w: 1,
      h: 1,
      x_center: 0.828125,
      y_center: 0.796875
    },
    {
      w: 1,
      h: 1,
      x_center: 0.828125,
      y_center: 0.796875
    },
    {
      w: 1,
      h: 1,
      x_center: 0.859375,
      y_center: 0.796875
    },
    {
      w: 1,
      h: 1,
      x_center: 0.859375,
      y_center: 0.796875
    },
    {
      w: 1,
      h: 1,
      x_center: 0.890625,
      y_center: 0.796875
    },
    {
      w: 1,
      h: 1,
      x_center: 0.890625,
      y_center: 0.796875
    },
    {
      w: 1,
      h: 1,
      x_center: 0.921875,
      y_center: 0.796875
    },
    {
      w: 1,
      h: 1,
      x_center: 0.921875,
      y_center: 0.796875
    },
    {
      w: 1,
      h: 1,
      x_center: 0.953125,
      y_center: 0.796875
    },
    {
      w: 1,
      h: 1,
      x_center: 0.953125,
      y_center: 0.796875
    },
    {
      w: 1,
      h: 1,
      x_center: 0.984375,
      y_center: 0.796875
    },
    {
      w: 1,
      h: 1,
      x_center: 0.984375,
      y_center: 0.796875
    },
    {
      w: 1,
      h: 1,
      x_center: 0.015625,
      y_center: 0.828125
    },
    {
      w: 1,
      h: 1,
      x_center: 0.015625,
      y_center: 0.828125
    },
    {
      w: 1,
      h: 1,
      x_center: 0.046875,
      y_center: 0.828125
    },
    {
      w: 1,
      h: 1,
      x_center: 0.046875,
      y_center: 0.828125
    },
    {
      w: 1,
      h: 1,
      x_center: 0.078125,
      y_center: 0.828125
    },
    {
      w: 1,
      h: 1,
      x_center: 0.078125,
      y_center: 0.828125
    },
    {
      w: 1,
      h: 1,
      x_center: 0.109375,
      y_center: 0.828125
    },
    {
      w: 1,
      h: 1,
      x_center: 0.109375,
      y_center: 0.828125
    },
    {
      w: 1,
      h: 1,
      x_center: 0.140625,
      y_center: 0.828125
    },
    {
      w: 1,
      h: 1,
      x_center: 0.140625,
      y_center: 0.828125
    },
    {
      w: 1,
      h: 1,
      x_center: 0.171875,
      y_center: 0.828125
    },
    {
      w: 1,
      h: 1,
      x_center: 0.171875,
      y_center: 0.828125
    },
    {
      w: 1,
      h: 1,
      x_center: 0.203125,
      y_center: 0.828125
    },
    {
      w: 1,
      h: 1,
      x_center: 0.203125,
      y_center: 0.828125
    },
    {
      w: 1,
      h: 1,
      x_center: 0.234375,
      y_center: 0.828125
    },
    {
      w: 1,
      h: 1,
      x_center: 0.234375,
      y_center: 0.828125
    },
    {
      w: 1,
      h: 1,
      x_center: 0.265625,
      y_center: 0.828125
    },
    {
      w: 1,
      h: 1,
      x_center: 0.265625,
      y_center: 0.828125
    },
    {
      w: 1,
      h: 1,
      x_center: 0.296875,
      y_center: 0.828125
    },
    {
      w: 1,
      h: 1,
      x_center: 0.296875,
      y_center: 0.828125
    },
    {
      w: 1,
      h: 1,
      x_center: 0.328125,
      y_center: 0.828125
    },
    {
      w: 1,
      h: 1,
      x_center: 0.328125,
      y_center: 0.828125
    },
    {
      w: 1,
      h: 1,
      x_center: 0.359375,
      y_center: 0.828125
    },
    {
      w: 1,
      h: 1,
      x_center: 0.359375,
      y_center: 0.828125
    },
    {
      w: 1,
      h: 1,
      x_center: 0.390625,
      y_center: 0.828125
    },
    {
      w: 1,
      h: 1,
      x_center: 0.390625,
      y_center: 0.828125
    },
    {
      w: 1,
      h: 1,
      x_center: 0.421875,
      y_center: 0.828125
    },
    {
      w: 1,
      h: 1,
      x_center: 0.421875,
      y_center: 0.828125
    },
    {
      w: 1,
      h: 1,
      x_center: 0.453125,
      y_center: 0.828125
    },
    {
      w: 1,
      h: 1,
      x_center: 0.453125,
      y_center: 0.828125
    },
    {
      w: 1,
      h: 1,
      x_center: 0.484375,
      y_center: 0.828125
    },
    {
      w: 1,
      h: 1,
      x_center: 0.484375,
      y_center: 0.828125
    },
    {
      w: 1,
      h: 1,
      x_center: 0.515625,
      y_center: 0.828125
    },
    {
      w: 1,
      h: 1,
      x_center: 0.515625,
      y_center: 0.828125
    },
    {
      w: 1,
      h: 1,
      x_center: 0.546875,
      y_center: 0.828125
    },
    {
      w: 1,
      h: 1,
      x_center: 0.546875,
      y_center: 0.828125
    },
    {
      w: 1,
      h: 1,
      x_center: 0.578125,
      y_center: 0.828125
    },
    {
      w: 1,
      h: 1,
      x_center: 0.578125,
      y_center: 0.828125
    },
    {
      w: 1,
      h: 1,
      x_center: 0.609375,
      y_center: 0.828125
    },
    {
      w: 1,
      h: 1,
      x_center: 0.609375,
      y_center: 0.828125
    },
    {
      w: 1,
      h: 1,
      x_center: 0.640625,
      y_center: 0.828125
    },
    {
      w: 1,
      h: 1,
      x_center: 0.640625,
      y_center: 0.828125
    },
    {
      w: 1,
      h: 1,
      x_center: 0.671875,
      y_center: 0.828125
    },
    {
      w: 1,
      h: 1,
      x_center: 0.671875,
      y_center: 0.828125
    },
    {
      w: 1,
      h: 1,
      x_center: 0.703125,
      y_center: 0.828125
    },
    {
      w: 1,
      h: 1,
      x_center: 0.703125,
      y_center: 0.828125
    },
    {
      w: 1,
      h: 1,
      x_center: 0.734375,
      y_center: 0.828125
    },
    {
      w: 1,
      h: 1,
      x_center: 0.734375,
      y_center: 0.828125
    },
    {
      w: 1,
      h: 1,
      x_center: 0.765625,
      y_center: 0.828125
    },
    {
      w: 1,
      h: 1,
      x_center: 0.765625,
      y_center: 0.828125
    },
    {
      w: 1,
      h: 1,
      x_center: 0.796875,
      y_center: 0.828125
    },
    {
      w: 1,
      h: 1,
      x_center: 0.796875,
      y_center: 0.828125
    },
    {
      w: 1,
      h: 1,
      x_center: 0.828125,
      y_center: 0.828125
    },
    {
      w: 1,
      h: 1,
      x_center: 0.828125,
      y_center: 0.828125
    },
    {
      w: 1,
      h: 1,
      x_center: 0.859375,
      y_center: 0.828125
    },
    {
      w: 1,
      h: 1,
      x_center: 0.859375,
      y_center: 0.828125
    },
    {
      w: 1,
      h: 1,
      x_center: 0.890625,
      y_center: 0.828125
    },
    {
      w: 1,
      h: 1,
      x_center: 0.890625,
      y_center: 0.828125
    },
    {
      w: 1,
      h: 1,
      x_center: 0.921875,
      y_center: 0.828125
    },
    {
      w: 1,
      h: 1,
      x_center: 0.921875,
      y_center: 0.828125
    },
    {
      w: 1,
      h: 1,
      x_center: 0.953125,
      y_center: 0.828125
    },
    {
      w: 1,
      h: 1,
      x_center: 0.953125,
      y_center: 0.828125
    },
    {
      w: 1,
      h: 1,
      x_center: 0.984375,
      y_center: 0.828125
    },
    {
      w: 1,
      h: 1,
      x_center: 0.984375,
      y_center: 0.828125
    },
    {
      w: 1,
      h: 1,
      x_center: 0.015625,
      y_center: 0.859375
    },
    {
      w: 1,
      h: 1,
      x_center: 0.015625,
      y_center: 0.859375
    },
    {
      w: 1,
      h: 1,
      x_center: 0.046875,
      y_center: 0.859375
    },
    {
      w: 1,
      h: 1,
      x_center: 0.046875,
      y_center: 0.859375
    },
    {
      w: 1,
      h: 1,
      x_center: 0.078125,
      y_center: 0.859375
    },
    {
      w: 1,
      h: 1,
      x_center: 0.078125,
      y_center: 0.859375
    },
    {
      w: 1,
      h: 1,
      x_center: 0.109375,
      y_center: 0.859375
    },
    {
      w: 1,
      h: 1,
      x_center: 0.109375,
      y_center: 0.859375
    },
    {
      w: 1,
      h: 1,
      x_center: 0.140625,
      y_center: 0.859375
    },
    {
      w: 1,
      h: 1,
      x_center: 0.140625,
      y_center: 0.859375
    },
    {
      w: 1,
      h: 1,
      x_center: 0.171875,
      y_center: 0.859375
    },
    {
      w: 1,
      h: 1,
      x_center: 0.171875,
      y_center: 0.859375
    },
    {
      w: 1,
      h: 1,
      x_center: 0.203125,
      y_center: 0.859375
    },
    {
      w: 1,
      h: 1,
      x_center: 0.203125,
      y_center: 0.859375
    },
    {
      w: 1,
      h: 1,
      x_center: 0.234375,
      y_center: 0.859375
    },
    {
      w: 1,
      h: 1,
      x_center: 0.234375,
      y_center: 0.859375
    },
    {
      w: 1,
      h: 1,
      x_center: 0.265625,
      y_center: 0.859375
    },
    {
      w: 1,
      h: 1,
      x_center: 0.265625,
      y_center: 0.859375
    },
    {
      w: 1,
      h: 1,
      x_center: 0.296875,
      y_center: 0.859375
    },
    {
      w: 1,
      h: 1,
      x_center: 0.296875,
      y_center: 0.859375
    },
    {
      w: 1,
      h: 1,
      x_center: 0.328125,
      y_center: 0.859375
    },
    {
      w: 1,
      h: 1,
      x_center: 0.328125,
      y_center: 0.859375
    },
    {
      w: 1,
      h: 1,
      x_center: 0.359375,
      y_center: 0.859375
    },
    {
      w: 1,
      h: 1,
      x_center: 0.359375,
      y_center: 0.859375
    },
    {
      w: 1,
      h: 1,
      x_center: 0.390625,
      y_center: 0.859375
    },
    {
      w: 1,
      h: 1,
      x_center: 0.390625,
      y_center: 0.859375
    },
    {
      w: 1,
      h: 1,
      x_center: 0.421875,
      y_center: 0.859375
    },
    {
      w: 1,
      h: 1,
      x_center: 0.421875,
      y_center: 0.859375
    },
    {
      w: 1,
      h: 1,
      x_center: 0.453125,
      y_center: 0.859375
    },
    {
      w: 1,
      h: 1,
      x_center: 0.453125,
      y_center: 0.859375
    },
    {
      w: 1,
      h: 1,
      x_center: 0.484375,
      y_center: 0.859375
    },
    {
      w: 1,
      h: 1,
      x_center: 0.484375,
      y_center: 0.859375
    },
    {
      w: 1,
      h: 1,
      x_center: 0.515625,
      y_center: 0.859375
    },
    {
      w: 1,
      h: 1,
      x_center: 0.515625,
      y_center: 0.859375
    },
    {
      w: 1,
      h: 1,
      x_center: 0.546875,
      y_center: 0.859375
    },
    {
      w: 1,
      h: 1,
      x_center: 0.546875,
      y_center: 0.859375
    },
    {
      w: 1,
      h: 1,
      x_center: 0.578125,
      y_center: 0.859375
    },
    {
      w: 1,
      h: 1,
      x_center: 0.578125,
      y_center: 0.859375
    },
    {
      w: 1,
      h: 1,
      x_center: 0.609375,
      y_center: 0.859375
    },
    {
      w: 1,
      h: 1,
      x_center: 0.609375,
      y_center: 0.859375
    },
    {
      w: 1,
      h: 1,
      x_center: 0.640625,
      y_center: 0.859375
    },
    {
      w: 1,
      h: 1,
      x_center: 0.640625,
      y_center: 0.859375
    },
    {
      w: 1,
      h: 1,
      x_center: 0.671875,
      y_center: 0.859375
    },
    {
      w: 1,
      h: 1,
      x_center: 0.671875,
      y_center: 0.859375
    },
    {
      w: 1,
      h: 1,
      x_center: 0.703125,
      y_center: 0.859375
    },
    {
      w: 1,
      h: 1,
      x_center: 0.703125,
      y_center: 0.859375
    },
    {
      w: 1,
      h: 1,
      x_center: 0.734375,
      y_center: 0.859375
    },
    {
      w: 1,
      h: 1,
      x_center: 0.734375,
      y_center: 0.859375
    },
    {
      w: 1,
      h: 1,
      x_center: 0.765625,
      y_center: 0.859375
    },
    {
      w: 1,
      h: 1,
      x_center: 0.765625,
      y_center: 0.859375
    },
    {
      w: 1,
      h: 1,
      x_center: 0.796875,
      y_center: 0.859375
    },
    {
      w: 1,
      h: 1,
      x_center: 0.796875,
      y_center: 0.859375
    },
    {
      w: 1,
      h: 1,
      x_center: 0.828125,
      y_center: 0.859375
    },
    {
      w: 1,
      h: 1,
      x_center: 0.828125,
      y_center: 0.859375
    },
    {
      w: 1,
      h: 1,
      x_center: 0.859375,
      y_center: 0.859375
    },
    {
      w: 1,
      h: 1,
      x_center: 0.859375,
      y_center: 0.859375
    },
    {
      w: 1,
      h: 1,
      x_center: 0.890625,
      y_center: 0.859375
    },
    {
      w: 1,
      h: 1,
      x_center: 0.890625,
      y_center: 0.859375
    },
    {
      w: 1,
      h: 1,
      x_center: 0.921875,
      y_center: 0.859375
    },
    {
      w: 1,
      h: 1,
      x_center: 0.921875,
      y_center: 0.859375
    },
    {
      w: 1,
      h: 1,
      x_center: 0.953125,
      y_center: 0.859375
    },
    {
      w: 1,
      h: 1,
      x_center: 0.953125,
      y_center: 0.859375
    },
    {
      w: 1,
      h: 1,
      x_center: 0.984375,
      y_center: 0.859375
    },
    {
      w: 1,
      h: 1,
      x_center: 0.984375,
      y_center: 0.859375
    },
    {
      w: 1,
      h: 1,
      x_center: 0.015625,
      y_center: 0.890625
    },
    {
      w: 1,
      h: 1,
      x_center: 0.015625,
      y_center: 0.890625
    },
    {
      w: 1,
      h: 1,
      x_center: 0.046875,
      y_center: 0.890625
    },
    {
      w: 1,
      h: 1,
      x_center: 0.046875,
      y_center: 0.890625
    },
    {
      w: 1,
      h: 1,
      x_center: 0.078125,
      y_center: 0.890625
    },
    {
      w: 1,
      h: 1,
      x_center: 0.078125,
      y_center: 0.890625
    },
    {
      w: 1,
      h: 1,
      x_center: 0.109375,
      y_center: 0.890625
    },
    {
      w: 1,
      h: 1,
      x_center: 0.109375,
      y_center: 0.890625
    },
    {
      w: 1,
      h: 1,
      x_center: 0.140625,
      y_center: 0.890625
    },
    {
      w: 1,
      h: 1,
      x_center: 0.140625,
      y_center: 0.890625
    },
    {
      w: 1,
      h: 1,
      x_center: 0.171875,
      y_center: 0.890625
    },
    {
      w: 1,
      h: 1,
      x_center: 0.171875,
      y_center: 0.890625
    },
    {
      w: 1,
      h: 1,
      x_center: 0.203125,
      y_center: 0.890625
    },
    {
      w: 1,
      h: 1,
      x_center: 0.203125,
      y_center: 0.890625
    },
    {
      w: 1,
      h: 1,
      x_center: 0.234375,
      y_center: 0.890625
    },
    {
      w: 1,
      h: 1,
      x_center: 0.234375,
      y_center: 0.890625
    },
    {
      w: 1,
      h: 1,
      x_center: 0.265625,
      y_center: 0.890625
    },
    {
      w: 1,
      h: 1,
      x_center: 0.265625,
      y_center: 0.890625
    },
    {
      w: 1,
      h: 1,
      x_center: 0.296875,
      y_center: 0.890625
    },
    {
      w: 1,
      h: 1,
      x_center: 0.296875,
      y_center: 0.890625
    },
    {
      w: 1,
      h: 1,
      x_center: 0.328125,
      y_center: 0.890625
    },
    {
      w: 1,
      h: 1,
      x_center: 0.328125,
      y_center: 0.890625
    },
    {
      w: 1,
      h: 1,
      x_center: 0.359375,
      y_center: 0.890625
    },
    {
      w: 1,
      h: 1,
      x_center: 0.359375,
      y_center: 0.890625
    },
    {
      w: 1,
      h: 1,
      x_center: 0.390625,
      y_center: 0.890625
    },
    {
      w: 1,
      h: 1,
      x_center: 0.390625,
      y_center: 0.890625
    },
    {
      w: 1,
      h: 1,
      x_center: 0.421875,
      y_center: 0.890625
    },
    {
      w: 1,
      h: 1,
      x_center: 0.421875,
      y_center: 0.890625
    },
    {
      w: 1,
      h: 1,
      x_center: 0.453125,
      y_center: 0.890625
    },
    {
      w: 1,
      h: 1,
      x_center: 0.453125,
      y_center: 0.890625
    },
    {
      w: 1,
      h: 1,
      x_center: 0.484375,
      y_center: 0.890625
    },
    {
      w: 1,
      h: 1,
      x_center: 0.484375,
      y_center: 0.890625
    },
    {
      w: 1,
      h: 1,
      x_center: 0.515625,
      y_center: 0.890625
    },
    {
      w: 1,
      h: 1,
      x_center: 0.515625,
      y_center: 0.890625
    },
    {
      w: 1,
      h: 1,
      x_center: 0.546875,
      y_center: 0.890625
    },
    {
      w: 1,
      h: 1,
      x_center: 0.546875,
      y_center: 0.890625
    },
    {
      w: 1,
      h: 1,
      x_center: 0.578125,
      y_center: 0.890625
    },
    {
      w: 1,
      h: 1,
      x_center: 0.578125,
      y_center: 0.890625
    },
    {
      w: 1,
      h: 1,
      x_center: 0.609375,
      y_center: 0.890625
    },
    {
      w: 1,
      h: 1,
      x_center: 0.609375,
      y_center: 0.890625
    },
    {
      w: 1,
      h: 1,
      x_center: 0.640625,
      y_center: 0.890625
    },
    {
      w: 1,
      h: 1,
      x_center: 0.640625,
      y_center: 0.890625
    },
    {
      w: 1,
      h: 1,
      x_center: 0.671875,
      y_center: 0.890625
    },
    {
      w: 1,
      h: 1,
      x_center: 0.671875,
      y_center: 0.890625
    },
    {
      w: 1,
      h: 1,
      x_center: 0.703125,
      y_center: 0.890625
    },
    {
      w: 1,
      h: 1,
      x_center: 0.703125,
      y_center: 0.890625
    },
    {
      w: 1,
      h: 1,
      x_center: 0.734375,
      y_center: 0.890625
    },
    {
      w: 1,
      h: 1,
      x_center: 0.734375,
      y_center: 0.890625
    },
    {
      w: 1,
      h: 1,
      x_center: 0.765625,
      y_center: 0.890625
    },
    {
      w: 1,
      h: 1,
      x_center: 0.765625,
      y_center: 0.890625
    },
    {
      w: 1,
      h: 1,
      x_center: 0.796875,
      y_center: 0.890625
    },
    {
      w: 1,
      h: 1,
      x_center: 0.796875,
      y_center: 0.890625
    },
    {
      w: 1,
      h: 1,
      x_center: 0.828125,
      y_center: 0.890625
    },
    {
      w: 1,
      h: 1,
      x_center: 0.828125,
      y_center: 0.890625
    },
    {
      w: 1,
      h: 1,
      x_center: 0.859375,
      y_center: 0.890625
    },
    {
      w: 1,
      h: 1,
      x_center: 0.859375,
      y_center: 0.890625
    },
    {
      w: 1,
      h: 1,
      x_center: 0.890625,
      y_center: 0.890625
    },
    {
      w: 1,
      h: 1,
      x_center: 0.890625,
      y_center: 0.890625
    },
    {
      w: 1,
      h: 1,
      x_center: 0.921875,
      y_center: 0.890625
    },
    {
      w: 1,
      h: 1,
      x_center: 0.921875,
      y_center: 0.890625
    },
    {
      w: 1,
      h: 1,
      x_center: 0.953125,
      y_center: 0.890625
    },
    {
      w: 1,
      h: 1,
      x_center: 0.953125,
      y_center: 0.890625
    },
    {
      w: 1,
      h: 1,
      x_center: 0.984375,
      y_center: 0.890625
    },
    {
      w: 1,
      h: 1,
      x_center: 0.984375,
      y_center: 0.890625
    },
    {
      w: 1,
      h: 1,
      x_center: 0.015625,
      y_center: 0.921875
    },
    {
      w: 1,
      h: 1,
      x_center: 0.015625,
      y_center: 0.921875
    },
    {
      w: 1,
      h: 1,
      x_center: 0.046875,
      y_center: 0.921875
    },
    {
      w: 1,
      h: 1,
      x_center: 0.046875,
      y_center: 0.921875
    },
    {
      w: 1,
      h: 1,
      x_center: 0.078125,
      y_center: 0.921875
    },
    {
      w: 1,
      h: 1,
      x_center: 0.078125,
      y_center: 0.921875
    },
    {
      w: 1,
      h: 1,
      x_center: 0.109375,
      y_center: 0.921875
    },
    {
      w: 1,
      h: 1,
      x_center: 0.109375,
      y_center: 0.921875
    },
    {
      w: 1,
      h: 1,
      x_center: 0.140625,
      y_center: 0.921875
    },
    {
      w: 1,
      h: 1,
      x_center: 0.140625,
      y_center: 0.921875
    },
    {
      w: 1,
      h: 1,
      x_center: 0.171875,
      y_center: 0.921875
    },
    {
      w: 1,
      h: 1,
      x_center: 0.171875,
      y_center: 0.921875
    },
    {
      w: 1,
      h: 1,
      x_center: 0.203125,
      y_center: 0.921875
    },
    {
      w: 1,
      h: 1,
      x_center: 0.203125,
      y_center: 0.921875
    },
    {
      w: 1,
      h: 1,
      x_center: 0.234375,
      y_center: 0.921875
    },
    {
      w: 1,
      h: 1,
      x_center: 0.234375,
      y_center: 0.921875
    },
    {
      w: 1,
      h: 1,
      x_center: 0.265625,
      y_center: 0.921875
    },
    {
      w: 1,
      h: 1,
      x_center: 0.265625,
      y_center: 0.921875
    },
    {
      w: 1,
      h: 1,
      x_center: 0.296875,
      y_center: 0.921875
    },
    {
      w: 1,
      h: 1,
      x_center: 0.296875,
      y_center: 0.921875
    },
    {
      w: 1,
      h: 1,
      x_center: 0.328125,
      y_center: 0.921875
    },
    {
      w: 1,
      h: 1,
      x_center: 0.328125,
      y_center: 0.921875
    },
    {
      w: 1,
      h: 1,
      x_center: 0.359375,
      y_center: 0.921875
    },
    {
      w: 1,
      h: 1,
      x_center: 0.359375,
      y_center: 0.921875
    },
    {
      w: 1,
      h: 1,
      x_center: 0.390625,
      y_center: 0.921875
    },
    {
      w: 1,
      h: 1,
      x_center: 0.390625,
      y_center: 0.921875
    },
    {
      w: 1,
      h: 1,
      x_center: 0.421875,
      y_center: 0.921875
    },
    {
      w: 1,
      h: 1,
      x_center: 0.421875,
      y_center: 0.921875
    },
    {
      w: 1,
      h: 1,
      x_center: 0.453125,
      y_center: 0.921875
    },
    {
      w: 1,
      h: 1,
      x_center: 0.453125,
      y_center: 0.921875
    },
    {
      w: 1,
      h: 1,
      x_center: 0.484375,
      y_center: 0.921875
    },
    {
      w: 1,
      h: 1,
      x_center: 0.484375,
      y_center: 0.921875
    },
    {
      w: 1,
      h: 1,
      x_center: 0.515625,
      y_center: 0.921875
    },
    {
      w: 1,
      h: 1,
      x_center: 0.515625,
      y_center: 0.921875
    },
    {
      w: 1,
      h: 1,
      x_center: 0.546875,
      y_center: 0.921875
    },
    {
      w: 1,
      h: 1,
      x_center: 0.546875,
      y_center: 0.921875
    },
    {
      w: 1,
      h: 1,
      x_center: 0.578125,
      y_center: 0.921875
    },
    {
      w: 1,
      h: 1,
      x_center: 0.578125,
      y_center: 0.921875
    },
    {
      w: 1,
      h: 1,
      x_center: 0.609375,
      y_center: 0.921875
    },
    {
      w: 1,
      h: 1,
      x_center: 0.609375,
      y_center: 0.921875
    },
    {
      w: 1,
      h: 1,
      x_center: 0.640625,
      y_center: 0.921875
    },
    {
      w: 1,
      h: 1,
      x_center: 0.640625,
      y_center: 0.921875
    },
    {
      w: 1,
      h: 1,
      x_center: 0.671875,
      y_center: 0.921875
    },
    {
      w: 1,
      h: 1,
      x_center: 0.671875,
      y_center: 0.921875
    },
    {
      w: 1,
      h: 1,
      x_center: 0.703125,
      y_center: 0.921875
    },
    {
      w: 1,
      h: 1,
      x_center: 0.703125,
      y_center: 0.921875
    },
    {
      w: 1,
      h: 1,
      x_center: 0.734375,
      y_center: 0.921875
    },
    {
      w: 1,
      h: 1,
      x_center: 0.734375,
      y_center: 0.921875
    },
    {
      w: 1,
      h: 1,
      x_center: 0.765625,
      y_center: 0.921875
    },
    {
      w: 1,
      h: 1,
      x_center: 0.765625,
      y_center: 0.921875
    },
    {
      w: 1,
      h: 1,
      x_center: 0.796875,
      y_center: 0.921875
    },
    {
      w: 1,
      h: 1,
      x_center: 0.796875,
      y_center: 0.921875
    },
    {
      w: 1,
      h: 1,
      x_center: 0.828125,
      y_center: 0.921875
    },
    {
      w: 1,
      h: 1,
      x_center: 0.828125,
      y_center: 0.921875
    },
    {
      w: 1,
      h: 1,
      x_center: 0.859375,
      y_center: 0.921875
    },
    {
      w: 1,
      h: 1,
      x_center: 0.859375,
      y_center: 0.921875
    },
    {
      w: 1,
      h: 1,
      x_center: 0.890625,
      y_center: 0.921875
    },
    {
      w: 1,
      h: 1,
      x_center: 0.890625,
      y_center: 0.921875
    },
    {
      w: 1,
      h: 1,
      x_center: 0.921875,
      y_center: 0.921875
    },
    {
      w: 1,
      h: 1,
      x_center: 0.921875,
      y_center: 0.921875
    },
    {
      w: 1,
      h: 1,
      x_center: 0.953125,
      y_center: 0.921875
    },
    {
      w: 1,
      h: 1,
      x_center: 0.953125,
      y_center: 0.921875
    },
    {
      w: 1,
      h: 1,
      x_center: 0.984375,
      y_center: 0.921875
    },
    {
      w: 1,
      h: 1,
      x_center: 0.984375,
      y_center: 0.921875
    },
    {
      w: 1,
      h: 1,
      x_center: 0.015625,
      y_center: 0.953125
    },
    {
      w: 1,
      h: 1,
      x_center: 0.015625,
      y_center: 0.953125
    },
    {
      w: 1,
      h: 1,
      x_center: 0.046875,
      y_center: 0.953125
    },
    {
      w: 1,
      h: 1,
      x_center: 0.046875,
      y_center: 0.953125
    },
    {
      w: 1,
      h: 1,
      x_center: 0.078125,
      y_center: 0.953125
    },
    {
      w: 1,
      h: 1,
      x_center: 0.078125,
      y_center: 0.953125
    },
    {
      w: 1,
      h: 1,
      x_center: 0.109375,
      y_center: 0.953125
    },
    {
      w: 1,
      h: 1,
      x_center: 0.109375,
      y_center: 0.953125
    },
    {
      w: 1,
      h: 1,
      x_center: 0.140625,
      y_center: 0.953125
    },
    {
      w: 1,
      h: 1,
      x_center: 0.140625,
      y_center: 0.953125
    },
    {
      w: 1,
      h: 1,
      x_center: 0.171875,
      y_center: 0.953125
    },
    {
      w: 1,
      h: 1,
      x_center: 0.171875,
      y_center: 0.953125
    },
    {
      w: 1,
      h: 1,
      x_center: 0.203125,
      y_center: 0.953125
    },
    {
      w: 1,
      h: 1,
      x_center: 0.203125,
      y_center: 0.953125
    },
    {
      w: 1,
      h: 1,
      x_center: 0.234375,
      y_center: 0.953125
    },
    {
      w: 1,
      h: 1,
      x_center: 0.234375,
      y_center: 0.953125
    },
    {
      w: 1,
      h: 1,
      x_center: 0.265625,
      y_center: 0.953125
    },
    {
      w: 1,
      h: 1,
      x_center: 0.265625,
      y_center: 0.953125
    },
    {
      w: 1,
      h: 1,
      x_center: 0.296875,
      y_center: 0.953125
    },
    {
      w: 1,
      h: 1,
      x_center: 0.296875,
      y_center: 0.953125
    },
    {
      w: 1,
      h: 1,
      x_center: 0.328125,
      y_center: 0.953125
    },
    {
      w: 1,
      h: 1,
      x_center: 0.328125,
      y_center: 0.953125
    },
    {
      w: 1,
      h: 1,
      x_center: 0.359375,
      y_center: 0.953125
    },
    {
      w: 1,
      h: 1,
      x_center: 0.359375,
      y_center: 0.953125
    },
    {
      w: 1,
      h: 1,
      x_center: 0.390625,
      y_center: 0.953125
    },
    {
      w: 1,
      h: 1,
      x_center: 0.390625,
      y_center: 0.953125
    },
    {
      w: 1,
      h: 1,
      x_center: 0.421875,
      y_center: 0.953125
    },
    {
      w: 1,
      h: 1,
      x_center: 0.421875,
      y_center: 0.953125
    },
    {
      w: 1,
      h: 1,
      x_center: 0.453125,
      y_center: 0.953125
    },
    {
      w: 1,
      h: 1,
      x_center: 0.453125,
      y_center: 0.953125
    },
    {
      w: 1,
      h: 1,
      x_center: 0.484375,
      y_center: 0.953125
    },
    {
      w: 1,
      h: 1,
      x_center: 0.484375,
      y_center: 0.953125
    },
    {
      w: 1,
      h: 1,
      x_center: 0.515625,
      y_center: 0.953125
    },
    {
      w: 1,
      h: 1,
      x_center: 0.515625,
      y_center: 0.953125
    },
    {
      w: 1,
      h: 1,
      x_center: 0.546875,
      y_center: 0.953125
    },
    {
      w: 1,
      h: 1,
      x_center: 0.546875,
      y_center: 0.953125
    },
    {
      w: 1,
      h: 1,
      x_center: 0.578125,
      y_center: 0.953125
    },
    {
      w: 1,
      h: 1,
      x_center: 0.578125,
      y_center: 0.953125
    },
    {
      w: 1,
      h: 1,
      x_center: 0.609375,
      y_center: 0.953125
    },
    {
      w: 1,
      h: 1,
      x_center: 0.609375,
      y_center: 0.953125
    },
    {
      w: 1,
      h: 1,
      x_center: 0.640625,
      y_center: 0.953125
    },
    {
      w: 1,
      h: 1,
      x_center: 0.640625,
      y_center: 0.953125
    },
    {
      w: 1,
      h: 1,
      x_center: 0.671875,
      y_center: 0.953125
    },
    {
      w: 1,
      h: 1,
      x_center: 0.671875,
      y_center: 0.953125
    },
    {
      w: 1,
      h: 1,
      x_center: 0.703125,
      y_center: 0.953125
    },
    {
      w: 1,
      h: 1,
      x_center: 0.703125,
      y_center: 0.953125
    },
    {
      w: 1,
      h: 1,
      x_center: 0.734375,
      y_center: 0.953125
    },
    {
      w: 1,
      h: 1,
      x_center: 0.734375,
      y_center: 0.953125
    },
    {
      w: 1,
      h: 1,
      x_center: 0.765625,
      y_center: 0.953125
    },
    {
      w: 1,
      h: 1,
      x_center: 0.765625,
      y_center: 0.953125
    },
    {
      w: 1,
      h: 1,
      x_center: 0.796875,
      y_center: 0.953125
    },
    {
      w: 1,
      h: 1,
      x_center: 0.796875,
      y_center: 0.953125
    },
    {
      w: 1,
      h: 1,
      x_center: 0.828125,
      y_center: 0.953125
    },
    {
      w: 1,
      h: 1,
      x_center: 0.828125,
      y_center: 0.953125
    },
    {
      w: 1,
      h: 1,
      x_center: 0.859375,
      y_center: 0.953125
    },
    {
      w: 1,
      h: 1,
      x_center: 0.859375,
      y_center: 0.953125
    },
    {
      w: 1,
      h: 1,
      x_center: 0.890625,
      y_center: 0.953125
    },
    {
      w: 1,
      h: 1,
      x_center: 0.890625,
      y_center: 0.953125
    },
    {
      w: 1,
      h: 1,
      x_center: 0.921875,
      y_center: 0.953125
    },
    {
      w: 1,
      h: 1,
      x_center: 0.921875,
      y_center: 0.953125
    },
    {
      w: 1,
      h: 1,
      x_center: 0.953125,
      y_center: 0.953125
    },
    {
      w: 1,
      h: 1,
      x_center: 0.953125,
      y_center: 0.953125
    },
    {
      w: 1,
      h: 1,
      x_center: 0.984375,
      y_center: 0.953125
    },
    {
      w: 1,
      h: 1,
      x_center: 0.984375,
      y_center: 0.953125
    },
    {
      w: 1,
      h: 1,
      x_center: 0.015625,
      y_center: 0.984375
    },
    {
      w: 1,
      h: 1,
      x_center: 0.015625,
      y_center: 0.984375
    },
    {
      w: 1,
      h: 1,
      x_center: 0.046875,
      y_center: 0.984375
    },
    {
      w: 1,
      h: 1,
      x_center: 0.046875,
      y_center: 0.984375
    },
    {
      w: 1,
      h: 1,
      x_center: 0.078125,
      y_center: 0.984375
    },
    {
      w: 1,
      h: 1,
      x_center: 0.078125,
      y_center: 0.984375
    },
    {
      w: 1,
      h: 1,
      x_center: 0.109375,
      y_center: 0.984375
    },
    {
      w: 1,
      h: 1,
      x_center: 0.109375,
      y_center: 0.984375
    },
    {
      w: 1,
      h: 1,
      x_center: 0.140625,
      y_center: 0.984375
    },
    {
      w: 1,
      h: 1,
      x_center: 0.140625,
      y_center: 0.984375
    },
    {
      w: 1,
      h: 1,
      x_center: 0.171875,
      y_center: 0.984375
    },
    {
      w: 1,
      h: 1,
      x_center: 0.171875,
      y_center: 0.984375
    },
    {
      w: 1,
      h: 1,
      x_center: 0.203125,
      y_center: 0.984375
    },
    {
      w: 1,
      h: 1,
      x_center: 0.203125,
      y_center: 0.984375
    },
    {
      w: 1,
      h: 1,
      x_center: 0.234375,
      y_center: 0.984375
    },
    {
      w: 1,
      h: 1,
      x_center: 0.234375,
      y_center: 0.984375
    },
    {
      w: 1,
      h: 1,
      x_center: 0.265625,
      y_center: 0.984375
    },
    {
      w: 1,
      h: 1,
      x_center: 0.265625,
      y_center: 0.984375
    },
    {
      w: 1,
      h: 1,
      x_center: 0.296875,
      y_center: 0.984375
    },
    {
      w: 1,
      h: 1,
      x_center: 0.296875,
      y_center: 0.984375
    },
    {
      w: 1,
      h: 1,
      x_center: 0.328125,
      y_center: 0.984375
    },
    {
      w: 1,
      h: 1,
      x_center: 0.328125,
      y_center: 0.984375
    },
    {
      w: 1,
      h: 1,
      x_center: 0.359375,
      y_center: 0.984375
    },
    {
      w: 1,
      h: 1,
      x_center: 0.359375,
      y_center: 0.984375
    },
    {
      w: 1,
      h: 1,
      x_center: 0.390625,
      y_center: 0.984375
    },
    {
      w: 1,
      h: 1,
      x_center: 0.390625,
      y_center: 0.984375
    },
    {
      w: 1,
      h: 1,
      x_center: 0.421875,
      y_center: 0.984375
    },
    {
      w: 1,
      h: 1,
      x_center: 0.421875,
      y_center: 0.984375
    },
    {
      w: 1,
      h: 1,
      x_center: 0.453125,
      y_center: 0.984375
    },
    {
      w: 1,
      h: 1,
      x_center: 0.453125,
      y_center: 0.984375
    },
    {
      w: 1,
      h: 1,
      x_center: 0.484375,
      y_center: 0.984375
    },
    {
      w: 1,
      h: 1,
      x_center: 0.484375,
      y_center: 0.984375
    },
    {
      w: 1,
      h: 1,
      x_center: 0.515625,
      y_center: 0.984375
    },
    {
      w: 1,
      h: 1,
      x_center: 0.515625,
      y_center: 0.984375
    },
    {
      w: 1,
      h: 1,
      x_center: 0.546875,
      y_center: 0.984375
    },
    {
      w: 1,
      h: 1,
      x_center: 0.546875,
      y_center: 0.984375
    },
    {
      w: 1,
      h: 1,
      x_center: 0.578125,
      y_center: 0.984375
    },
    {
      w: 1,
      h: 1,
      x_center: 0.578125,
      y_center: 0.984375
    },
    {
      w: 1,
      h: 1,
      x_center: 0.609375,
      y_center: 0.984375
    },
    {
      w: 1,
      h: 1,
      x_center: 0.609375,
      y_center: 0.984375
    },
    {
      w: 1,
      h: 1,
      x_center: 0.640625,
      y_center: 0.984375
    },
    {
      w: 1,
      h: 1,
      x_center: 0.640625,
      y_center: 0.984375
    },
    {
      w: 1,
      h: 1,
      x_center: 0.671875,
      y_center: 0.984375
    },
    {
      w: 1,
      h: 1,
      x_center: 0.671875,
      y_center: 0.984375
    },
    {
      w: 1,
      h: 1,
      x_center: 0.703125,
      y_center: 0.984375
    },
    {
      w: 1,
      h: 1,
      x_center: 0.703125,
      y_center: 0.984375
    },
    {
      w: 1,
      h: 1,
      x_center: 0.734375,
      y_center: 0.984375
    },
    {
      w: 1,
      h: 1,
      x_center: 0.734375,
      y_center: 0.984375
    },
    {
      w: 1,
      h: 1,
      x_center: 0.765625,
      y_center: 0.984375
    },
    {
      w: 1,
      h: 1,
      x_center: 0.765625,
      y_center: 0.984375
    },
    {
      w: 1,
      h: 1,
      x_center: 0.796875,
      y_center: 0.984375
    },
    {
      w: 1,
      h: 1,
      x_center: 0.796875,
      y_center: 0.984375
    },
    {
      w: 1,
      h: 1,
      x_center: 0.828125,
      y_center: 0.984375
    },
    {
      w: 1,
      h: 1,
      x_center: 0.828125,
      y_center: 0.984375
    },
    {
      w: 1,
      h: 1,
      x_center: 0.859375,
      y_center: 0.984375
    },
    {
      w: 1,
      h: 1,
      x_center: 0.859375,
      y_center: 0.984375
    },
    {
      w: 1,
      h: 1,
      x_center: 0.890625,
      y_center: 0.984375
    },
    {
      w: 1,
      h: 1,
      x_center: 0.890625,
      y_center: 0.984375
    },
    {
      w: 1,
      h: 1,
      x_center: 0.921875,
      y_center: 0.984375
    },
    {
      w: 1,
      h: 1,
      x_center: 0.921875,
      y_center: 0.984375
    },
    {
      w: 1,
      h: 1,
      x_center: 0.953125,
      y_center: 0.984375
    },
    {
      w: 1,
      h: 1,
      x_center: 0.953125,
      y_center: 0.984375
    },
    {
      w: 1,
      h: 1,
      x_center: 0.984375,
      y_center: 0.984375
    },
    {
      w: 1,
      h: 1,
      x_center: 0.984375,
      y_center: 0.984375
    },
    {
      w: 1,
      h: 1,
      x_center: 0.03125,
      y_center: 0.03125
    },
    {
      w: 1,
      h: 1,
      x_center: 0.03125,
      y_center: 0.03125
    },
    {
      w: 1,
      h: 1,
      x_center: 0.09375,
      y_center: 0.03125
    },
    {
      w: 1,
      h: 1,
      x_center: 0.09375,
      y_center: 0.03125
    },
    {
      w: 1,
      h: 1,
      x_center: 0.15625,
      y_center: 0.03125
    },
    {
      w: 1,
      h: 1,
      x_center: 0.15625,
      y_center: 0.03125
    },
    {
      w: 1,
      h: 1,
      x_center: 0.21875,
      y_center: 0.03125
    },
    {
      w: 1,
      h: 1,
      x_center: 0.21875,
      y_center: 0.03125
    },
    {
      w: 1,
      h: 1,
      x_center: 0.28125,
      y_center: 0.03125
    },
    {
      w: 1,
      h: 1,
      x_center: 0.28125,
      y_center: 0.03125
    },
    {
      w: 1,
      h: 1,
      x_center: 0.34375,
      y_center: 0.03125
    },
    {
      w: 1,
      h: 1,
      x_center: 0.34375,
      y_center: 0.03125
    },
    {
      w: 1,
      h: 1,
      x_center: 0.40625,
      y_center: 0.03125
    },
    {
      w: 1,
      h: 1,
      x_center: 0.40625,
      y_center: 0.03125
    },
    {
      w: 1,
      h: 1,
      x_center: 0.46875,
      y_center: 0.03125
    },
    {
      w: 1,
      h: 1,
      x_center: 0.46875,
      y_center: 0.03125
    },
    {
      w: 1,
      h: 1,
      x_center: 0.53125,
      y_center: 0.03125
    },
    {
      w: 1,
      h: 1,
      x_center: 0.53125,
      y_center: 0.03125
    },
    {
      w: 1,
      h: 1,
      x_center: 0.59375,
      y_center: 0.03125
    },
    {
      w: 1,
      h: 1,
      x_center: 0.59375,
      y_center: 0.03125
    },
    {
      w: 1,
      h: 1,
      x_center: 0.65625,
      y_center: 0.03125
    },
    {
      w: 1,
      h: 1,
      x_center: 0.65625,
      y_center: 0.03125
    },
    {
      w: 1,
      h: 1,
      x_center: 0.71875,
      y_center: 0.03125
    },
    {
      w: 1,
      h: 1,
      x_center: 0.71875,
      y_center: 0.03125
    },
    {
      w: 1,
      h: 1,
      x_center: 0.78125,
      y_center: 0.03125
    },
    {
      w: 1,
      h: 1,
      x_center: 0.78125,
      y_center: 0.03125
    },
    {
      w: 1,
      h: 1,
      x_center: 0.84375,
      y_center: 0.03125
    },
    {
      w: 1,
      h: 1,
      x_center: 0.84375,
      y_center: 0.03125
    },
    {
      w: 1,
      h: 1,
      x_center: 0.90625,
      y_center: 0.03125
    },
    {
      w: 1,
      h: 1,
      x_center: 0.90625,
      y_center: 0.03125
    },
    {
      w: 1,
      h: 1,
      x_center: 0.96875,
      y_center: 0.03125
    },
    {
      w: 1,
      h: 1,
      x_center: 0.96875,
      y_center: 0.03125
    },
    {
      w: 1,
      h: 1,
      x_center: 0.03125,
      y_center: 0.09375
    },
    {
      w: 1,
      h: 1,
      x_center: 0.03125,
      y_center: 0.09375
    },
    {
      w: 1,
      h: 1,
      x_center: 0.09375,
      y_center: 0.09375
    },
    {
      w: 1,
      h: 1,
      x_center: 0.09375,
      y_center: 0.09375
    },
    {
      w: 1,
      h: 1,
      x_center: 0.15625,
      y_center: 0.09375
    },
    {
      w: 1,
      h: 1,
      x_center: 0.15625,
      y_center: 0.09375
    },
    {
      w: 1,
      h: 1,
      x_center: 0.21875,
      y_center: 0.09375
    },
    {
      w: 1,
      h: 1,
      x_center: 0.21875,
      y_center: 0.09375
    },
    {
      w: 1,
      h: 1,
      x_center: 0.28125,
      y_center: 0.09375
    },
    {
      w: 1,
      h: 1,
      x_center: 0.28125,
      y_center: 0.09375
    },
    {
      w: 1,
      h: 1,
      x_center: 0.34375,
      y_center: 0.09375
    },
    {
      w: 1,
      h: 1,
      x_center: 0.34375,
      y_center: 0.09375
    },
    {
      w: 1,
      h: 1,
      x_center: 0.40625,
      y_center: 0.09375
    },
    {
      w: 1,
      h: 1,
      x_center: 0.40625,
      y_center: 0.09375
    },
    {
      w: 1,
      h: 1,
      x_center: 0.46875,
      y_center: 0.09375
    },
    {
      w: 1,
      h: 1,
      x_center: 0.46875,
      y_center: 0.09375
    },
    {
      w: 1,
      h: 1,
      x_center: 0.53125,
      y_center: 0.09375
    },
    {
      w: 1,
      h: 1,
      x_center: 0.53125,
      y_center: 0.09375
    },
    {
      w: 1,
      h: 1,
      x_center: 0.59375,
      y_center: 0.09375
    },
    {
      w: 1,
      h: 1,
      x_center: 0.59375,
      y_center: 0.09375
    },
    {
      w: 1,
      h: 1,
      x_center: 0.65625,
      y_center: 0.09375
    },
    {
      w: 1,
      h: 1,
      x_center: 0.65625,
      y_center: 0.09375
    },
    {
      w: 1,
      h: 1,
      x_center: 0.71875,
      y_center: 0.09375
    },
    {
      w: 1,
      h: 1,
      x_center: 0.71875,
      y_center: 0.09375
    },
    {
      w: 1,
      h: 1,
      x_center: 0.78125,
      y_center: 0.09375
    },
    {
      w: 1,
      h: 1,
      x_center: 0.78125,
      y_center: 0.09375
    },
    {
      w: 1,
      h: 1,
      x_center: 0.84375,
      y_center: 0.09375
    },
    {
      w: 1,
      h: 1,
      x_center: 0.84375,
      y_center: 0.09375
    },
    {
      w: 1,
      h: 1,
      x_center: 0.90625,
      y_center: 0.09375
    },
    {
      w: 1,
      h: 1,
      x_center: 0.90625,
      y_center: 0.09375
    },
    {
      w: 1,
      h: 1,
      x_center: 0.96875,
      y_center: 0.09375
    },
    {
      w: 1,
      h: 1,
      x_center: 0.96875,
      y_center: 0.09375
    },
    {
      w: 1,
      h: 1,
      x_center: 0.03125,
      y_center: 0.15625
    },
    {
      w: 1,
      h: 1,
      x_center: 0.03125,
      y_center: 0.15625
    },
    {
      w: 1,
      h: 1,
      x_center: 0.09375,
      y_center: 0.15625
    },
    {
      w: 1,
      h: 1,
      x_center: 0.09375,
      y_center: 0.15625
    },
    {
      w: 1,
      h: 1,
      x_center: 0.15625,
      y_center: 0.15625
    },
    {
      w: 1,
      h: 1,
      x_center: 0.15625,
      y_center: 0.15625
    },
    {
      w: 1,
      h: 1,
      x_center: 0.21875,
      y_center: 0.15625
    },
    {
      w: 1,
      h: 1,
      x_center: 0.21875,
      y_center: 0.15625
    },
    {
      w: 1,
      h: 1,
      x_center: 0.28125,
      y_center: 0.15625
    },
    {
      w: 1,
      h: 1,
      x_center: 0.28125,
      y_center: 0.15625
    },
    {
      w: 1,
      h: 1,
      x_center: 0.34375,
      y_center: 0.15625
    },
    {
      w: 1,
      h: 1,
      x_center: 0.34375,
      y_center: 0.15625
    },
    {
      w: 1,
      h: 1,
      x_center: 0.40625,
      y_center: 0.15625
    },
    {
      w: 1,
      h: 1,
      x_center: 0.40625,
      y_center: 0.15625
    },
    {
      w: 1,
      h: 1,
      x_center: 0.46875,
      y_center: 0.15625
    },
    {
      w: 1,
      h: 1,
      x_center: 0.46875,
      y_center: 0.15625
    },
    {
      w: 1,
      h: 1,
      x_center: 0.53125,
      y_center: 0.15625
    },
    {
      w: 1,
      h: 1,
      x_center: 0.53125,
      y_center: 0.15625
    },
    {
      w: 1,
      h: 1,
      x_center: 0.59375,
      y_center: 0.15625
    },
    {
      w: 1,
      h: 1,
      x_center: 0.59375,
      y_center: 0.15625
    },
    {
      w: 1,
      h: 1,
      x_center: 0.65625,
      y_center: 0.15625
    },
    {
      w: 1,
      h: 1,
      x_center: 0.65625,
      y_center: 0.15625
    },
    {
      w: 1,
      h: 1,
      x_center: 0.71875,
      y_center: 0.15625
    },
    {
      w: 1,
      h: 1,
      x_center: 0.71875,
      y_center: 0.15625
    },
    {
      w: 1,
      h: 1,
      x_center: 0.78125,
      y_center: 0.15625
    },
    {
      w: 1,
      h: 1,
      x_center: 0.78125,
      y_center: 0.15625
    },
    {
      w: 1,
      h: 1,
      x_center: 0.84375,
      y_center: 0.15625
    },
    {
      w: 1,
      h: 1,
      x_center: 0.84375,
      y_center: 0.15625
    },
    {
      w: 1,
      h: 1,
      x_center: 0.90625,
      y_center: 0.15625
    },
    {
      w: 1,
      h: 1,
      x_center: 0.90625,
      y_center: 0.15625
    },
    {
      w: 1,
      h: 1,
      x_center: 0.96875,
      y_center: 0.15625
    },
    {
      w: 1,
      h: 1,
      x_center: 0.96875,
      y_center: 0.15625
    },
    {
      w: 1,
      h: 1,
      x_center: 0.03125,
      y_center: 0.21875
    },
    {
      w: 1,
      h: 1,
      x_center: 0.03125,
      y_center: 0.21875
    },
    {
      w: 1,
      h: 1,
      x_center: 0.09375,
      y_center: 0.21875
    },
    {
      w: 1,
      h: 1,
      x_center: 0.09375,
      y_center: 0.21875
    },
    {
      w: 1,
      h: 1,
      x_center: 0.15625,
      y_center: 0.21875
    },
    {
      w: 1,
      h: 1,
      x_center: 0.15625,
      y_center: 0.21875
    },
    {
      w: 1,
      h: 1,
      x_center: 0.21875,
      y_center: 0.21875
    },
    {
      w: 1,
      h: 1,
      x_center: 0.21875,
      y_center: 0.21875
    },
    {
      w: 1,
      h: 1,
      x_center: 0.28125,
      y_center: 0.21875
    },
    {
      w: 1,
      h: 1,
      x_center: 0.28125,
      y_center: 0.21875
    },
    {
      w: 1,
      h: 1,
      x_center: 0.34375,
      y_center: 0.21875
    },
    {
      w: 1,
      h: 1,
      x_center: 0.34375,
      y_center: 0.21875
    },
    {
      w: 1,
      h: 1,
      x_center: 0.40625,
      y_center: 0.21875
    },
    {
      w: 1,
      h: 1,
      x_center: 0.40625,
      y_center: 0.21875
    },
    {
      w: 1,
      h: 1,
      x_center: 0.46875,
      y_center: 0.21875
    },
    {
      w: 1,
      h: 1,
      x_center: 0.46875,
      y_center: 0.21875
    },
    {
      w: 1,
      h: 1,
      x_center: 0.53125,
      y_center: 0.21875
    },
    {
      w: 1,
      h: 1,
      x_center: 0.53125,
      y_center: 0.21875
    },
    {
      w: 1,
      h: 1,
      x_center: 0.59375,
      y_center: 0.21875
    },
    {
      w: 1,
      h: 1,
      x_center: 0.59375,
      y_center: 0.21875
    },
    {
      w: 1,
      h: 1,
      x_center: 0.65625,
      y_center: 0.21875
    },
    {
      w: 1,
      h: 1,
      x_center: 0.65625,
      y_center: 0.21875
    },
    {
      w: 1,
      h: 1,
      x_center: 0.71875,
      y_center: 0.21875
    },
    {
      w: 1,
      h: 1,
      x_center: 0.71875,
      y_center: 0.21875
    },
    {
      w: 1,
      h: 1,
      x_center: 0.78125,
      y_center: 0.21875
    },
    {
      w: 1,
      h: 1,
      x_center: 0.78125,
      y_center: 0.21875
    },
    {
      w: 1,
      h: 1,
      x_center: 0.84375,
      y_center: 0.21875
    },
    {
      w: 1,
      h: 1,
      x_center: 0.84375,
      y_center: 0.21875
    },
    {
      w: 1,
      h: 1,
      x_center: 0.90625,
      y_center: 0.21875
    },
    {
      w: 1,
      h: 1,
      x_center: 0.90625,
      y_center: 0.21875
    },
    {
      w: 1,
      h: 1,
      x_center: 0.96875,
      y_center: 0.21875
    },
    {
      w: 1,
      h: 1,
      x_center: 0.96875,
      y_center: 0.21875
    },
    {
      w: 1,
      h: 1,
      x_center: 0.03125,
      y_center: 0.28125
    },
    {
      w: 1,
      h: 1,
      x_center: 0.03125,
      y_center: 0.28125
    },
    {
      w: 1,
      h: 1,
      x_center: 0.09375,
      y_center: 0.28125
    },
    {
      w: 1,
      h: 1,
      x_center: 0.09375,
      y_center: 0.28125
    },
    {
      w: 1,
      h: 1,
      x_center: 0.15625,
      y_center: 0.28125
    },
    {
      w: 1,
      h: 1,
      x_center: 0.15625,
      y_center: 0.28125
    },
    {
      w: 1,
      h: 1,
      x_center: 0.21875,
      y_center: 0.28125
    },
    {
      w: 1,
      h: 1,
      x_center: 0.21875,
      y_center: 0.28125
    },
    {
      w: 1,
      h: 1,
      x_center: 0.28125,
      y_center: 0.28125
    },
    {
      w: 1,
      h: 1,
      x_center: 0.28125,
      y_center: 0.28125
    },
    {
      w: 1,
      h: 1,
      x_center: 0.34375,
      y_center: 0.28125
    },
    {
      w: 1,
      h: 1,
      x_center: 0.34375,
      y_center: 0.28125
    },
    {
      w: 1,
      h: 1,
      x_center: 0.40625,
      y_center: 0.28125
    },
    {
      w: 1,
      h: 1,
      x_center: 0.40625,
      y_center: 0.28125
    },
    {
      w: 1,
      h: 1,
      x_center: 0.46875,
      y_center: 0.28125
    },
    {
      w: 1,
      h: 1,
      x_center: 0.46875,
      y_center: 0.28125
    },
    {
      w: 1,
      h: 1,
      x_center: 0.53125,
      y_center: 0.28125
    },
    {
      w: 1,
      h: 1,
      x_center: 0.53125,
      y_center: 0.28125
    },
    {
      w: 1,
      h: 1,
      x_center: 0.59375,
      y_center: 0.28125
    },
    {
      w: 1,
      h: 1,
      x_center: 0.59375,
      y_center: 0.28125
    },
    {
      w: 1,
      h: 1,
      x_center: 0.65625,
      y_center: 0.28125
    },
    {
      w: 1,
      h: 1,
      x_center: 0.65625,
      y_center: 0.28125
    },
    {
      w: 1,
      h: 1,
      x_center: 0.71875,
      y_center: 0.28125
    },
    {
      w: 1,
      h: 1,
      x_center: 0.71875,
      y_center: 0.28125
    },
    {
      w: 1,
      h: 1,
      x_center: 0.78125,
      y_center: 0.28125
    },
    {
      w: 1,
      h: 1,
      x_center: 0.78125,
      y_center: 0.28125
    },
    {
      w: 1,
      h: 1,
      x_center: 0.84375,
      y_center: 0.28125
    },
    {
      w: 1,
      h: 1,
      x_center: 0.84375,
      y_center: 0.28125
    },
    {
      w: 1,
      h: 1,
      x_center: 0.90625,
      y_center: 0.28125
    },
    {
      w: 1,
      h: 1,
      x_center: 0.90625,
      y_center: 0.28125
    },
    {
      w: 1,
      h: 1,
      x_center: 0.96875,
      y_center: 0.28125
    },
    {
      w: 1,
      h: 1,
      x_center: 0.96875,
      y_center: 0.28125
    },
    {
      w: 1,
      h: 1,
      x_center: 0.03125,
      y_center: 0.34375
    },
    {
      w: 1,
      h: 1,
      x_center: 0.03125,
      y_center: 0.34375
    },
    {
      w: 1,
      h: 1,
      x_center: 0.09375,
      y_center: 0.34375
    },
    {
      w: 1,
      h: 1,
      x_center: 0.09375,
      y_center: 0.34375
    },
    {
      w: 1,
      h: 1,
      x_center: 0.15625,
      y_center: 0.34375
    },
    {
      w: 1,
      h: 1,
      x_center: 0.15625,
      y_center: 0.34375
    },
    {
      w: 1,
      h: 1,
      x_center: 0.21875,
      y_center: 0.34375
    },
    {
      w: 1,
      h: 1,
      x_center: 0.21875,
      y_center: 0.34375
    },
    {
      w: 1,
      h: 1,
      x_center: 0.28125,
      y_center: 0.34375
    },
    {
      w: 1,
      h: 1,
      x_center: 0.28125,
      y_center: 0.34375
    },
    {
      w: 1,
      h: 1,
      x_center: 0.34375,
      y_center: 0.34375
    },
    {
      w: 1,
      h: 1,
      x_center: 0.34375,
      y_center: 0.34375
    },
    {
      w: 1,
      h: 1,
      x_center: 0.40625,
      y_center: 0.34375
    },
    {
      w: 1,
      h: 1,
      x_center: 0.40625,
      y_center: 0.34375
    },
    {
      w: 1,
      h: 1,
      x_center: 0.46875,
      y_center: 0.34375
    },
    {
      w: 1,
      h: 1,
      x_center: 0.46875,
      y_center: 0.34375
    },
    {
      w: 1,
      h: 1,
      x_center: 0.53125,
      y_center: 0.34375
    },
    {
      w: 1,
      h: 1,
      x_center: 0.53125,
      y_center: 0.34375
    },
    {
      w: 1,
      h: 1,
      x_center: 0.59375,
      y_center: 0.34375
    },
    {
      w: 1,
      h: 1,
      x_center: 0.59375,
      y_center: 0.34375
    },
    {
      w: 1,
      h: 1,
      x_center: 0.65625,
      y_center: 0.34375
    },
    {
      w: 1,
      h: 1,
      x_center: 0.65625,
      y_center: 0.34375
    },
    {
      w: 1,
      h: 1,
      x_center: 0.71875,
      y_center: 0.34375
    },
    {
      w: 1,
      h: 1,
      x_center: 0.71875,
      y_center: 0.34375
    },
    {
      w: 1,
      h: 1,
      x_center: 0.78125,
      y_center: 0.34375
    },
    {
      w: 1,
      h: 1,
      x_center: 0.78125,
      y_center: 0.34375
    },
    {
      w: 1,
      h: 1,
      x_center: 0.84375,
      y_center: 0.34375
    },
    {
      w: 1,
      h: 1,
      x_center: 0.84375,
      y_center: 0.34375
    },
    {
      w: 1,
      h: 1,
      x_center: 0.90625,
      y_center: 0.34375
    },
    {
      w: 1,
      h: 1,
      x_center: 0.90625,
      y_center: 0.34375
    },
    {
      w: 1,
      h: 1,
      x_center: 0.96875,
      y_center: 0.34375
    },
    {
      w: 1,
      h: 1,
      x_center: 0.96875,
      y_center: 0.34375
    },
    {
      w: 1,
      h: 1,
      x_center: 0.03125,
      y_center: 0.40625
    },
    {
      w: 1,
      h: 1,
      x_center: 0.03125,
      y_center: 0.40625
    },
    {
      w: 1,
      h: 1,
      x_center: 0.09375,
      y_center: 0.40625
    },
    {
      w: 1,
      h: 1,
      x_center: 0.09375,
      y_center: 0.40625
    },
    {
      w: 1,
      h: 1,
      x_center: 0.15625,
      y_center: 0.40625
    },
    {
      w: 1,
      h: 1,
      x_center: 0.15625,
      y_center: 0.40625
    },
    {
      w: 1,
      h: 1,
      x_center: 0.21875,
      y_center: 0.40625
    },
    {
      w: 1,
      h: 1,
      x_center: 0.21875,
      y_center: 0.40625
    },
    {
      w: 1,
      h: 1,
      x_center: 0.28125,
      y_center: 0.40625
    },
    {
      w: 1,
      h: 1,
      x_center: 0.28125,
      y_center: 0.40625
    },
    {
      w: 1,
      h: 1,
      x_center: 0.34375,
      y_center: 0.40625
    },
    {
      w: 1,
      h: 1,
      x_center: 0.34375,
      y_center: 0.40625
    },
    {
      w: 1,
      h: 1,
      x_center: 0.40625,
      y_center: 0.40625
    },
    {
      w: 1,
      h: 1,
      x_center: 0.40625,
      y_center: 0.40625
    },
    {
      w: 1,
      h: 1,
      x_center: 0.46875,
      y_center: 0.40625
    },
    {
      w: 1,
      h: 1,
      x_center: 0.46875,
      y_center: 0.40625
    },
    {
      w: 1,
      h: 1,
      x_center: 0.53125,
      y_center: 0.40625
    },
    {
      w: 1,
      h: 1,
      x_center: 0.53125,
      y_center: 0.40625
    },
    {
      w: 1,
      h: 1,
      x_center: 0.59375,
      y_center: 0.40625
    },
    {
      w: 1,
      h: 1,
      x_center: 0.59375,
      y_center: 0.40625
    },
    {
      w: 1,
      h: 1,
      x_center: 0.65625,
      y_center: 0.40625
    },
    {
      w: 1,
      h: 1,
      x_center: 0.65625,
      y_center: 0.40625
    },
    {
      w: 1,
      h: 1,
      x_center: 0.71875,
      y_center: 0.40625
    },
    {
      w: 1,
      h: 1,
      x_center: 0.71875,
      y_center: 0.40625
    },
    {
      w: 1,
      h: 1,
      x_center: 0.78125,
      y_center: 0.40625
    },
    {
      w: 1,
      h: 1,
      x_center: 0.78125,
      y_center: 0.40625
    },
    {
      w: 1,
      h: 1,
      x_center: 0.84375,
      y_center: 0.40625
    },
    {
      w: 1,
      h: 1,
      x_center: 0.84375,
      y_center: 0.40625
    },
    {
      w: 1,
      h: 1,
      x_center: 0.90625,
      y_center: 0.40625
    },
    {
      w: 1,
      h: 1,
      x_center: 0.90625,
      y_center: 0.40625
    },
    {
      w: 1,
      h: 1,
      x_center: 0.96875,
      y_center: 0.40625
    },
    {
      w: 1,
      h: 1,
      x_center: 0.96875,
      y_center: 0.40625
    },
    {
      w: 1,
      h: 1,
      x_center: 0.03125,
      y_center: 0.46875
    },
    {
      w: 1,
      h: 1,
      x_center: 0.03125,
      y_center: 0.46875
    },
    {
      w: 1,
      h: 1,
      x_center: 0.09375,
      y_center: 0.46875
    },
    {
      w: 1,
      h: 1,
      x_center: 0.09375,
      y_center: 0.46875
    },
    {
      w: 1,
      h: 1,
      x_center: 0.15625,
      y_center: 0.46875
    },
    {
      w: 1,
      h: 1,
      x_center: 0.15625,
      y_center: 0.46875
    },
    {
      w: 1,
      h: 1,
      x_center: 0.21875,
      y_center: 0.46875
    },
    {
      w: 1,
      h: 1,
      x_center: 0.21875,
      y_center: 0.46875
    },
    {
      w: 1,
      h: 1,
      x_center: 0.28125,
      y_center: 0.46875
    },
    {
      w: 1,
      h: 1,
      x_center: 0.28125,
      y_center: 0.46875
    },
    {
      w: 1,
      h: 1,
      x_center: 0.34375,
      y_center: 0.46875
    },
    {
      w: 1,
      h: 1,
      x_center: 0.34375,
      y_center: 0.46875
    },
    {
      w: 1,
      h: 1,
      x_center: 0.40625,
      y_center: 0.46875
    },
    {
      w: 1,
      h: 1,
      x_center: 0.40625,
      y_center: 0.46875
    },
    {
      w: 1,
      h: 1,
      x_center: 0.46875,
      y_center: 0.46875
    },
    {
      w: 1,
      h: 1,
      x_center: 0.46875,
      y_center: 0.46875
    },
    {
      w: 1,
      h: 1,
      x_center: 0.53125,
      y_center: 0.46875
    },
    {
      w: 1,
      h: 1,
      x_center: 0.53125,
      y_center: 0.46875
    },
    {
      w: 1,
      h: 1,
      x_center: 0.59375,
      y_center: 0.46875
    },
    {
      w: 1,
      h: 1,
      x_center: 0.59375,
      y_center: 0.46875
    },
    {
      w: 1,
      h: 1,
      x_center: 0.65625,
      y_center: 0.46875
    },
    {
      w: 1,
      h: 1,
      x_center: 0.65625,
      y_center: 0.46875
    },
    {
      w: 1,
      h: 1,
      x_center: 0.71875,
      y_center: 0.46875
    },
    {
      w: 1,
      h: 1,
      x_center: 0.71875,
      y_center: 0.46875
    },
    {
      w: 1,
      h: 1,
      x_center: 0.78125,
      y_center: 0.46875
    },
    {
      w: 1,
      h: 1,
      x_center: 0.78125,
      y_center: 0.46875
    },
    {
      w: 1,
      h: 1,
      x_center: 0.84375,
      y_center: 0.46875
    },
    {
      w: 1,
      h: 1,
      x_center: 0.84375,
      y_center: 0.46875
    },
    {
      w: 1,
      h: 1,
      x_center: 0.90625,
      y_center: 0.46875
    },
    {
      w: 1,
      h: 1,
      x_center: 0.90625,
      y_center: 0.46875
    },
    {
      w: 1,
      h: 1,
      x_center: 0.96875,
      y_center: 0.46875
    },
    {
      w: 1,
      h: 1,
      x_center: 0.96875,
      y_center: 0.46875
    },
    {
      w: 1,
      h: 1,
      x_center: 0.03125,
      y_center: 0.53125
    },
    {
      w: 1,
      h: 1,
      x_center: 0.03125,
      y_center: 0.53125
    },
    {
      w: 1,
      h: 1,
      x_center: 0.09375,
      y_center: 0.53125
    },
    {
      w: 1,
      h: 1,
      x_center: 0.09375,
      y_center: 0.53125
    },
    {
      w: 1,
      h: 1,
      x_center: 0.15625,
      y_center: 0.53125
    },
    {
      w: 1,
      h: 1,
      x_center: 0.15625,
      y_center: 0.53125
    },
    {
      w: 1,
      h: 1,
      x_center: 0.21875,
      y_center: 0.53125
    },
    {
      w: 1,
      h: 1,
      x_center: 0.21875,
      y_center: 0.53125
    },
    {
      w: 1,
      h: 1,
      x_center: 0.28125,
      y_center: 0.53125
    },
    {
      w: 1,
      h: 1,
      x_center: 0.28125,
      y_center: 0.53125
    },
    {
      w: 1,
      h: 1,
      x_center: 0.34375,
      y_center: 0.53125
    },
    {
      w: 1,
      h: 1,
      x_center: 0.34375,
      y_center: 0.53125
    },
    {
      w: 1,
      h: 1,
      x_center: 0.40625,
      y_center: 0.53125
    },
    {
      w: 1,
      h: 1,
      x_center: 0.40625,
      y_center: 0.53125
    },
    {
      w: 1,
      h: 1,
      x_center: 0.46875,
      y_center: 0.53125
    },
    {
      w: 1,
      h: 1,
      x_center: 0.46875,
      y_center: 0.53125
    },
    {
      w: 1,
      h: 1,
      x_center: 0.53125,
      y_center: 0.53125
    },
    {
      w: 1,
      h: 1,
      x_center: 0.53125,
      y_center: 0.53125
    },
    {
      w: 1,
      h: 1,
      x_center: 0.59375,
      y_center: 0.53125
    },
    {
      w: 1,
      h: 1,
      x_center: 0.59375,
      y_center: 0.53125
    },
    {
      w: 1,
      h: 1,
      x_center: 0.65625,
      y_center: 0.53125
    },
    {
      w: 1,
      h: 1,
      x_center: 0.65625,
      y_center: 0.53125
    },
    {
      w: 1,
      h: 1,
      x_center: 0.71875,
      y_center: 0.53125
    },
    {
      w: 1,
      h: 1,
      x_center: 0.71875,
      y_center: 0.53125
    },
    {
      w: 1,
      h: 1,
      x_center: 0.78125,
      y_center: 0.53125
    },
    {
      w: 1,
      h: 1,
      x_center: 0.78125,
      y_center: 0.53125
    },
    {
      w: 1,
      h: 1,
      x_center: 0.84375,
      y_center: 0.53125
    },
    {
      w: 1,
      h: 1,
      x_center: 0.84375,
      y_center: 0.53125
    },
    {
      w: 1,
      h: 1,
      x_center: 0.90625,
      y_center: 0.53125
    },
    {
      w: 1,
      h: 1,
      x_center: 0.90625,
      y_center: 0.53125
    },
    {
      w: 1,
      h: 1,
      x_center: 0.96875,
      y_center: 0.53125
    },
    {
      w: 1,
      h: 1,
      x_center: 0.96875,
      y_center: 0.53125
    },
    {
      w: 1,
      h: 1,
      x_center: 0.03125,
      y_center: 0.59375
    },
    {
      w: 1,
      h: 1,
      x_center: 0.03125,
      y_center: 0.59375
    },
    {
      w: 1,
      h: 1,
      x_center: 0.09375,
      y_center: 0.59375
    },
    {
      w: 1,
      h: 1,
      x_center: 0.09375,
      y_center: 0.59375
    },
    {
      w: 1,
      h: 1,
      x_center: 0.15625,
      y_center: 0.59375
    },
    {
      w: 1,
      h: 1,
      x_center: 0.15625,
      y_center: 0.59375
    },
    {
      w: 1,
      h: 1,
      x_center: 0.21875,
      y_center: 0.59375
    },
    {
      w: 1,
      h: 1,
      x_center: 0.21875,
      y_center: 0.59375
    },
    {
      w: 1,
      h: 1,
      x_center: 0.28125,
      y_center: 0.59375
    },
    {
      w: 1,
      h: 1,
      x_center: 0.28125,
      y_center: 0.59375
    },
    {
      w: 1,
      h: 1,
      x_center: 0.34375,
      y_center: 0.59375
    },
    {
      w: 1,
      h: 1,
      x_center: 0.34375,
      y_center: 0.59375
    },
    {
      w: 1,
      h: 1,
      x_center: 0.40625,
      y_center: 0.59375
    },
    {
      w: 1,
      h: 1,
      x_center: 0.40625,
      y_center: 0.59375
    },
    {
      w: 1,
      h: 1,
      x_center: 0.46875,
      y_center: 0.59375
    },
    {
      w: 1,
      h: 1,
      x_center: 0.46875,
      y_center: 0.59375
    },
    {
      w: 1,
      h: 1,
      x_center: 0.53125,
      y_center: 0.59375
    },
    {
      w: 1,
      h: 1,
      x_center: 0.53125,
      y_center: 0.59375
    },
    {
      w: 1,
      h: 1,
      x_center: 0.59375,
      y_center: 0.59375
    },
    {
      w: 1,
      h: 1,
      x_center: 0.59375,
      y_center: 0.59375
    },
    {
      w: 1,
      h: 1,
      x_center: 0.65625,
      y_center: 0.59375
    },
    {
      w: 1,
      h: 1,
      x_center: 0.65625,
      y_center: 0.59375
    },
    {
      w: 1,
      h: 1,
      x_center: 0.71875,
      y_center: 0.59375
    },
    {
      w: 1,
      h: 1,
      x_center: 0.71875,
      y_center: 0.59375
    },
    {
      w: 1,
      h: 1,
      x_center: 0.78125,
      y_center: 0.59375
    },
    {
      w: 1,
      h: 1,
      x_center: 0.78125,
      y_center: 0.59375
    },
    {
      w: 1,
      h: 1,
      x_center: 0.84375,
      y_center: 0.59375
    },
    {
      w: 1,
      h: 1,
      x_center: 0.84375,
      y_center: 0.59375
    },
    {
      w: 1,
      h: 1,
      x_center: 0.90625,
      y_center: 0.59375
    },
    {
      w: 1,
      h: 1,
      x_center: 0.90625,
      y_center: 0.59375
    },
    {
      w: 1,
      h: 1,
      x_center: 0.96875,
      y_center: 0.59375
    },
    {
      w: 1,
      h: 1,
      x_center: 0.96875,
      y_center: 0.59375
    },
    {
      w: 1,
      h: 1,
      x_center: 0.03125,
      y_center: 0.65625
    },
    {
      w: 1,
      h: 1,
      x_center: 0.03125,
      y_center: 0.65625
    },
    {
      w: 1,
      h: 1,
      x_center: 0.09375,
      y_center: 0.65625
    },
    {
      w: 1,
      h: 1,
      x_center: 0.09375,
      y_center: 0.65625
    },
    {
      w: 1,
      h: 1,
      x_center: 0.15625,
      y_center: 0.65625
    },
    {
      w: 1,
      h: 1,
      x_center: 0.15625,
      y_center: 0.65625
    },
    {
      w: 1,
      h: 1,
      x_center: 0.21875,
      y_center: 0.65625
    },
    {
      w: 1,
      h: 1,
      x_center: 0.21875,
      y_center: 0.65625
    },
    {
      w: 1,
      h: 1,
      x_center: 0.28125,
      y_center: 0.65625
    },
    {
      w: 1,
      h: 1,
      x_center: 0.28125,
      y_center: 0.65625
    },
    {
      w: 1,
      h: 1,
      x_center: 0.34375,
      y_center: 0.65625
    },
    {
      w: 1,
      h: 1,
      x_center: 0.34375,
      y_center: 0.65625
    },
    {
      w: 1,
      h: 1,
      x_center: 0.40625,
      y_center: 0.65625
    },
    {
      w: 1,
      h: 1,
      x_center: 0.40625,
      y_center: 0.65625
    },
    {
      w: 1,
      h: 1,
      x_center: 0.46875,
      y_center: 0.65625
    },
    {
      w: 1,
      h: 1,
      x_center: 0.46875,
      y_center: 0.65625
    },
    {
      w: 1,
      h: 1,
      x_center: 0.53125,
      y_center: 0.65625
    },
    {
      w: 1,
      h: 1,
      x_center: 0.53125,
      y_center: 0.65625
    },
    {
      w: 1,
      h: 1,
      x_center: 0.59375,
      y_center: 0.65625
    },
    {
      w: 1,
      h: 1,
      x_center: 0.59375,
      y_center: 0.65625
    },
    {
      w: 1,
      h: 1,
      x_center: 0.65625,
      y_center: 0.65625
    },
    {
      w: 1,
      h: 1,
      x_center: 0.65625,
      y_center: 0.65625
    },
    {
      w: 1,
      h: 1,
      x_center: 0.71875,
      y_center: 0.65625
    },
    {
      w: 1,
      h: 1,
      x_center: 0.71875,
      y_center: 0.65625
    },
    {
      w: 1,
      h: 1,
      x_center: 0.78125,
      y_center: 0.65625
    },
    {
      w: 1,
      h: 1,
      x_center: 0.78125,
      y_center: 0.65625
    },
    {
      w: 1,
      h: 1,
      x_center: 0.84375,
      y_center: 0.65625
    },
    {
      w: 1,
      h: 1,
      x_center: 0.84375,
      y_center: 0.65625
    },
    {
      w: 1,
      h: 1,
      x_center: 0.90625,
      y_center: 0.65625
    },
    {
      w: 1,
      h: 1,
      x_center: 0.90625,
      y_center: 0.65625
    },
    {
      w: 1,
      h: 1,
      x_center: 0.96875,
      y_center: 0.65625
    },
    {
      w: 1,
      h: 1,
      x_center: 0.96875,
      y_center: 0.65625
    },
    {
      w: 1,
      h: 1,
      x_center: 0.03125,
      y_center: 0.71875
    },
    {
      w: 1,
      h: 1,
      x_center: 0.03125,
      y_center: 0.71875
    },
    {
      w: 1,
      h: 1,
      x_center: 0.09375,
      y_center: 0.71875
    },
    {
      w: 1,
      h: 1,
      x_center: 0.09375,
      y_center: 0.71875
    },
    {
      w: 1,
      h: 1,
      x_center: 0.15625,
      y_center: 0.71875
    },
    {
      w: 1,
      h: 1,
      x_center: 0.15625,
      y_center: 0.71875
    },
    {
      w: 1,
      h: 1,
      x_center: 0.21875,
      y_center: 0.71875
    },
    {
      w: 1,
      h: 1,
      x_center: 0.21875,
      y_center: 0.71875
    },
    {
      w: 1,
      h: 1,
      x_center: 0.28125,
      y_center: 0.71875
    },
    {
      w: 1,
      h: 1,
      x_center: 0.28125,
      y_center: 0.71875
    },
    {
      w: 1,
      h: 1,
      x_center: 0.34375,
      y_center: 0.71875
    },
    {
      w: 1,
      h: 1,
      x_center: 0.34375,
      y_center: 0.71875
    },
    {
      w: 1,
      h: 1,
      x_center: 0.40625,
      y_center: 0.71875
    },
    {
      w: 1,
      h: 1,
      x_center: 0.40625,
      y_center: 0.71875
    },
    {
      w: 1,
      h: 1,
      x_center: 0.46875,
      y_center: 0.71875
    },
    {
      w: 1,
      h: 1,
      x_center: 0.46875,
      y_center: 0.71875
    },
    {
      w: 1,
      h: 1,
      x_center: 0.53125,
      y_center: 0.71875
    },
    {
      w: 1,
      h: 1,
      x_center: 0.53125,
      y_center: 0.71875
    },
    {
      w: 1,
      h: 1,
      x_center: 0.59375,
      y_center: 0.71875
    },
    {
      w: 1,
      h: 1,
      x_center: 0.59375,
      y_center: 0.71875
    },
    {
      w: 1,
      h: 1,
      x_center: 0.65625,
      y_center: 0.71875
    },
    {
      w: 1,
      h: 1,
      x_center: 0.65625,
      y_center: 0.71875
    },
    {
      w: 1,
      h: 1,
      x_center: 0.71875,
      y_center: 0.71875
    },
    {
      w: 1,
      h: 1,
      x_center: 0.71875,
      y_center: 0.71875
    },
    {
      w: 1,
      h: 1,
      x_center: 0.78125,
      y_center: 0.71875
    },
    {
      w: 1,
      h: 1,
      x_center: 0.78125,
      y_center: 0.71875
    },
    {
      w: 1,
      h: 1,
      x_center: 0.84375,
      y_center: 0.71875
    },
    {
      w: 1,
      h: 1,
      x_center: 0.84375,
      y_center: 0.71875
    },
    {
      w: 1,
      h: 1,
      x_center: 0.90625,
      y_center: 0.71875
    },
    {
      w: 1,
      h: 1,
      x_center: 0.90625,
      y_center: 0.71875
    },
    {
      w: 1,
      h: 1,
      x_center: 0.96875,
      y_center: 0.71875
    },
    {
      w: 1,
      h: 1,
      x_center: 0.96875,
      y_center: 0.71875
    },
    {
      w: 1,
      h: 1,
      x_center: 0.03125,
      y_center: 0.78125
    },
    {
      w: 1,
      h: 1,
      x_center: 0.03125,
      y_center: 0.78125
    },
    {
      w: 1,
      h: 1,
      x_center: 0.09375,
      y_center: 0.78125
    },
    {
      w: 1,
      h: 1,
      x_center: 0.09375,
      y_center: 0.78125
    },
    {
      w: 1,
      h: 1,
      x_center: 0.15625,
      y_center: 0.78125
    },
    {
      w: 1,
      h: 1,
      x_center: 0.15625,
      y_center: 0.78125
    },
    {
      w: 1,
      h: 1,
      x_center: 0.21875,
      y_center: 0.78125
    },
    {
      w: 1,
      h: 1,
      x_center: 0.21875,
      y_center: 0.78125
    },
    {
      w: 1,
      h: 1,
      x_center: 0.28125,
      y_center: 0.78125
    },
    {
      w: 1,
      h: 1,
      x_center: 0.28125,
      y_center: 0.78125
    },
    {
      w: 1,
      h: 1,
      x_center: 0.34375,
      y_center: 0.78125
    },
    {
      w: 1,
      h: 1,
      x_center: 0.34375,
      y_center: 0.78125
    },
    {
      w: 1,
      h: 1,
      x_center: 0.40625,
      y_center: 0.78125
    },
    {
      w: 1,
      h: 1,
      x_center: 0.40625,
      y_center: 0.78125
    },
    {
      w: 1,
      h: 1,
      x_center: 0.46875,
      y_center: 0.78125
    },
    {
      w: 1,
      h: 1,
      x_center: 0.46875,
      y_center: 0.78125
    },
    {
      w: 1,
      h: 1,
      x_center: 0.53125,
      y_center: 0.78125
    },
    {
      w: 1,
      h: 1,
      x_center: 0.53125,
      y_center: 0.78125
    },
    {
      w: 1,
      h: 1,
      x_center: 0.59375,
      y_center: 0.78125
    },
    {
      w: 1,
      h: 1,
      x_center: 0.59375,
      y_center: 0.78125
    },
    {
      w: 1,
      h: 1,
      x_center: 0.65625,
      y_center: 0.78125
    },
    {
      w: 1,
      h: 1,
      x_center: 0.65625,
      y_center: 0.78125
    },
    {
      w: 1,
      h: 1,
      x_center: 0.71875,
      y_center: 0.78125
    },
    {
      w: 1,
      h: 1,
      x_center: 0.71875,
      y_center: 0.78125
    },
    {
      w: 1,
      h: 1,
      x_center: 0.78125,
      y_center: 0.78125
    },
    {
      w: 1,
      h: 1,
      x_center: 0.78125,
      y_center: 0.78125
    },
    {
      w: 1,
      h: 1,
      x_center: 0.84375,
      y_center: 0.78125
    },
    {
      w: 1,
      h: 1,
      x_center: 0.84375,
      y_center: 0.78125
    },
    {
      w: 1,
      h: 1,
      x_center: 0.90625,
      y_center: 0.78125
    },
    {
      w: 1,
      h: 1,
      x_center: 0.90625,
      y_center: 0.78125
    },
    {
      w: 1,
      h: 1,
      x_center: 0.96875,
      y_center: 0.78125
    },
    {
      w: 1,
      h: 1,
      x_center: 0.96875,
      y_center: 0.78125
    },
    {
      w: 1,
      h: 1,
      x_center: 0.03125,
      y_center: 0.84375
    },
    {
      w: 1,
      h: 1,
      x_center: 0.03125,
      y_center: 0.84375
    },
    {
      w: 1,
      h: 1,
      x_center: 0.09375,
      y_center: 0.84375
    },
    {
      w: 1,
      h: 1,
      x_center: 0.09375,
      y_center: 0.84375
    },
    {
      w: 1,
      h: 1,
      x_center: 0.15625,
      y_center: 0.84375
    },
    {
      w: 1,
      h: 1,
      x_center: 0.15625,
      y_center: 0.84375
    },
    {
      w: 1,
      h: 1,
      x_center: 0.21875,
      y_center: 0.84375
    },
    {
      w: 1,
      h: 1,
      x_center: 0.21875,
      y_center: 0.84375
    },
    {
      w: 1,
      h: 1,
      x_center: 0.28125,
      y_center: 0.84375
    },
    {
      w: 1,
      h: 1,
      x_center: 0.28125,
      y_center: 0.84375
    },
    {
      w: 1,
      h: 1,
      x_center: 0.34375,
      y_center: 0.84375
    },
    {
      w: 1,
      h: 1,
      x_center: 0.34375,
      y_center: 0.84375
    },
    {
      w: 1,
      h: 1,
      x_center: 0.40625,
      y_center: 0.84375
    },
    {
      w: 1,
      h: 1,
      x_center: 0.40625,
      y_center: 0.84375
    },
    {
      w: 1,
      h: 1,
      x_center: 0.46875,
      y_center: 0.84375
    },
    {
      w: 1,
      h: 1,
      x_center: 0.46875,
      y_center: 0.84375
    },
    {
      w: 1,
      h: 1,
      x_center: 0.53125,
      y_center: 0.84375
    },
    {
      w: 1,
      h: 1,
      x_center: 0.53125,
      y_center: 0.84375
    },
    {
      w: 1,
      h: 1,
      x_center: 0.59375,
      y_center: 0.84375
    },
    {
      w: 1,
      h: 1,
      x_center: 0.59375,
      y_center: 0.84375
    },
    {
      w: 1,
      h: 1,
      x_center: 0.65625,
      y_center: 0.84375
    },
    {
      w: 1,
      h: 1,
      x_center: 0.65625,
      y_center: 0.84375
    },
    {
      w: 1,
      h: 1,
      x_center: 0.71875,
      y_center: 0.84375
    },
    {
      w: 1,
      h: 1,
      x_center: 0.71875,
      y_center: 0.84375
    },
    {
      w: 1,
      h: 1,
      x_center: 0.78125,
      y_center: 0.84375
    },
    {
      w: 1,
      h: 1,
      x_center: 0.78125,
      y_center: 0.84375
    },
    {
      w: 1,
      h: 1,
      x_center: 0.84375,
      y_center: 0.84375
    },
    {
      w: 1,
      h: 1,
      x_center: 0.84375,
      y_center: 0.84375
    },
    {
      w: 1,
      h: 1,
      x_center: 0.90625,
      y_center: 0.84375
    },
    {
      w: 1,
      h: 1,
      x_center: 0.90625,
      y_center: 0.84375
    },
    {
      w: 1,
      h: 1,
      x_center: 0.96875,
      y_center: 0.84375
    },
    {
      w: 1,
      h: 1,
      x_center: 0.96875,
      y_center: 0.84375
    },
    {
      w: 1,
      h: 1,
      x_center: 0.03125,
      y_center: 0.90625
    },
    {
      w: 1,
      h: 1,
      x_center: 0.03125,
      y_center: 0.90625
    },
    {
      w: 1,
      h: 1,
      x_center: 0.09375,
      y_center: 0.90625
    },
    {
      w: 1,
      h: 1,
      x_center: 0.09375,
      y_center: 0.90625
    },
    {
      w: 1,
      h: 1,
      x_center: 0.15625,
      y_center: 0.90625
    },
    {
      w: 1,
      h: 1,
      x_center: 0.15625,
      y_center: 0.90625
    },
    {
      w: 1,
      h: 1,
      x_center: 0.21875,
      y_center: 0.90625
    },
    {
      w: 1,
      h: 1,
      x_center: 0.21875,
      y_center: 0.90625
    },
    {
      w: 1,
      h: 1,
      x_center: 0.28125,
      y_center: 0.90625
    },
    {
      w: 1,
      h: 1,
      x_center: 0.28125,
      y_center: 0.90625
    },
    {
      w: 1,
      h: 1,
      x_center: 0.34375,
      y_center: 0.90625
    },
    {
      w: 1,
      h: 1,
      x_center: 0.34375,
      y_center: 0.90625
    },
    {
      w: 1,
      h: 1,
      x_center: 0.40625,
      y_center: 0.90625
    },
    {
      w: 1,
      h: 1,
      x_center: 0.40625,
      y_center: 0.90625
    },
    {
      w: 1,
      h: 1,
      x_center: 0.46875,
      y_center: 0.90625
    },
    {
      w: 1,
      h: 1,
      x_center: 0.46875,
      y_center: 0.90625
    },
    {
      w: 1,
      h: 1,
      x_center: 0.53125,
      y_center: 0.90625
    },
    {
      w: 1,
      h: 1,
      x_center: 0.53125,
      y_center: 0.90625
    },
    {
      w: 1,
      h: 1,
      x_center: 0.59375,
      y_center: 0.90625
    },
    {
      w: 1,
      h: 1,
      x_center: 0.59375,
      y_center: 0.90625
    },
    {
      w: 1,
      h: 1,
      x_center: 0.65625,
      y_center: 0.90625
    },
    {
      w: 1,
      h: 1,
      x_center: 0.65625,
      y_center: 0.90625
    },
    {
      w: 1,
      h: 1,
      x_center: 0.71875,
      y_center: 0.90625
    },
    {
      w: 1,
      h: 1,
      x_center: 0.71875,
      y_center: 0.90625
    },
    {
      w: 1,
      h: 1,
      x_center: 0.78125,
      y_center: 0.90625
    },
    {
      w: 1,
      h: 1,
      x_center: 0.78125,
      y_center: 0.90625
    },
    {
      w: 1,
      h: 1,
      x_center: 0.84375,
      y_center: 0.90625
    },
    {
      w: 1,
      h: 1,
      x_center: 0.84375,
      y_center: 0.90625
    },
    {
      w: 1,
      h: 1,
      x_center: 0.90625,
      y_center: 0.90625
    },
    {
      w: 1,
      h: 1,
      x_center: 0.90625,
      y_center: 0.90625
    },
    {
      w: 1,
      h: 1,
      x_center: 0.96875,
      y_center: 0.90625
    },
    {
      w: 1,
      h: 1,
      x_center: 0.96875,
      y_center: 0.90625
    },
    {
      w: 1,
      h: 1,
      x_center: 0.03125,
      y_center: 0.96875
    },
    {
      w: 1,
      h: 1,
      x_center: 0.03125,
      y_center: 0.96875
    },
    {
      w: 1,
      h: 1,
      x_center: 0.09375,
      y_center: 0.96875
    },
    {
      w: 1,
      h: 1,
      x_center: 0.09375,
      y_center: 0.96875
    },
    {
      w: 1,
      h: 1,
      x_center: 0.15625,
      y_center: 0.96875
    },
    {
      w: 1,
      h: 1,
      x_center: 0.15625,
      y_center: 0.96875
    },
    {
      w: 1,
      h: 1,
      x_center: 0.21875,
      y_center: 0.96875
    },
    {
      w: 1,
      h: 1,
      x_center: 0.21875,
      y_center: 0.96875
    },
    {
      w: 1,
      h: 1,
      x_center: 0.28125,
      y_center: 0.96875
    },
    {
      w: 1,
      h: 1,
      x_center: 0.28125,
      y_center: 0.96875
    },
    {
      w: 1,
      h: 1,
      x_center: 0.34375,
      y_center: 0.96875
    },
    {
      w: 1,
      h: 1,
      x_center: 0.34375,
      y_center: 0.96875
    },
    {
      w: 1,
      h: 1,
      x_center: 0.40625,
      y_center: 0.96875
    },
    {
      w: 1,
      h: 1,
      x_center: 0.40625,
      y_center: 0.96875
    },
    {
      w: 1,
      h: 1,
      x_center: 0.46875,
      y_center: 0.96875
    },
    {
      w: 1,
      h: 1,
      x_center: 0.46875,
      y_center: 0.96875
    },
    {
      w: 1,
      h: 1,
      x_center: 0.53125,
      y_center: 0.96875
    },
    {
      w: 1,
      h: 1,
      x_center: 0.53125,
      y_center: 0.96875
    },
    {
      w: 1,
      h: 1,
      x_center: 0.59375,
      y_center: 0.96875
    },
    {
      w: 1,
      h: 1,
      x_center: 0.59375,
      y_center: 0.96875
    },
    {
      w: 1,
      h: 1,
      x_center: 0.65625,
      y_center: 0.96875
    },
    {
      w: 1,
      h: 1,
      x_center: 0.65625,
      y_center: 0.96875
    },
    {
      w: 1,
      h: 1,
      x_center: 0.71875,
      y_center: 0.96875
    },
    {
      w: 1,
      h: 1,
      x_center: 0.71875,
      y_center: 0.96875
    },
    {
      w: 1,
      h: 1,
      x_center: 0.78125,
      y_center: 0.96875
    },
    {
      w: 1,
      h: 1,
      x_center: 0.78125,
      y_center: 0.96875
    },
    {
      w: 1,
      h: 1,
      x_center: 0.84375,
      y_center: 0.96875
    },
    {
      w: 1,
      h: 1,
      x_center: 0.84375,
      y_center: 0.96875
    },
    {
      w: 1,
      h: 1,
      x_center: 0.90625,
      y_center: 0.96875
    },
    {
      w: 1,
      h: 1,
      x_center: 0.90625,
      y_center: 0.96875
    },
    {
      w: 1,
      h: 1,
      x_center: 0.96875,
      y_center: 0.96875
    },
    {
      w: 1,
      h: 1,
      x_center: 0.96875,
      y_center: 0.96875
    },
    {
      w: 1,
      h: 1,
      x_center: 0.0625,
      y_center: 0.0625
    },
    {
      w: 1,
      h: 1,
      x_center: 0.0625,
      y_center: 0.0625
    },
    {
      w: 1,
      h: 1,
      x_center: 0.0625,
      y_center: 0.0625
    },
    {
      w: 1,
      h: 1,
      x_center: 0.0625,
      y_center: 0.0625
    },
    {
      w: 1,
      h: 1,
      x_center: 0.0625,
      y_center: 0.0625
    },
    {
      w: 1,
      h: 1,
      x_center: 0.0625,
      y_center: 0.0625
    },
    {
      w: 1,
      h: 1,
      x_center: 0.1875,
      y_center: 0.0625
    },
    {
      w: 1,
      h: 1,
      x_center: 0.1875,
      y_center: 0.0625
    },
    {
      w: 1,
      h: 1,
      x_center: 0.1875,
      y_center: 0.0625
    },
    {
      w: 1,
      h: 1,
      x_center: 0.1875,
      y_center: 0.0625
    },
    {
      w: 1,
      h: 1,
      x_center: 0.1875,
      y_center: 0.0625
    },
    {
      w: 1,
      h: 1,
      x_center: 0.1875,
      y_center: 0.0625
    },
    {
      w: 1,
      h: 1,
      x_center: 0.3125,
      y_center: 0.0625
    },
    {
      w: 1,
      h: 1,
      x_center: 0.3125,
      y_center: 0.0625
    },
    {
      w: 1,
      h: 1,
      x_center: 0.3125,
      y_center: 0.0625
    },
    {
      w: 1,
      h: 1,
      x_center: 0.3125,
      y_center: 0.0625
    },
    {
      w: 1,
      h: 1,
      x_center: 0.3125,
      y_center: 0.0625
    },
    {
      w: 1,
      h: 1,
      x_center: 0.3125,
      y_center: 0.0625
    },
    {
      w: 1,
      h: 1,
      x_center: 0.4375,
      y_center: 0.0625
    },
    {
      w: 1,
      h: 1,
      x_center: 0.4375,
      y_center: 0.0625
    },
    {
      w: 1,
      h: 1,
      x_center: 0.4375,
      y_center: 0.0625
    },
    {
      w: 1,
      h: 1,
      x_center: 0.4375,
      y_center: 0.0625
    },
    {
      w: 1,
      h: 1,
      x_center: 0.4375,
      y_center: 0.0625
    },
    {
      w: 1,
      h: 1,
      x_center: 0.4375,
      y_center: 0.0625
    },
    {
      w: 1,
      h: 1,
      x_center: 0.5625,
      y_center: 0.0625
    },
    {
      w: 1,
      h: 1,
      x_center: 0.5625,
      y_center: 0.0625
    },
    {
      w: 1,
      h: 1,
      x_center: 0.5625,
      y_center: 0.0625
    },
    {
      w: 1,
      h: 1,
      x_center: 0.5625,
      y_center: 0.0625
    },
    {
      w: 1,
      h: 1,
      x_center: 0.5625,
      y_center: 0.0625
    },
    {
      w: 1,
      h: 1,
      x_center: 0.5625,
      y_center: 0.0625
    },
    {
      w: 1,
      h: 1,
      x_center: 0.6875,
      y_center: 0.0625
    },
    {
      w: 1,
      h: 1,
      x_center: 0.6875,
      y_center: 0.0625
    },
    {
      w: 1,
      h: 1,
      x_center: 0.6875,
      y_center: 0.0625
    },
    {
      w: 1,
      h: 1,
      x_center: 0.6875,
      y_center: 0.0625
    },
    {
      w: 1,
      h: 1,
      x_center: 0.6875,
      y_center: 0.0625
    },
    {
      w: 1,
      h: 1,
      x_center: 0.6875,
      y_center: 0.0625
    },
    {
      w: 1,
      h: 1,
      x_center: 0.8125,
      y_center: 0.0625
    },
    {
      w: 1,
      h: 1,
      x_center: 0.8125,
      y_center: 0.0625
    },
    {
      w: 1,
      h: 1,
      x_center: 0.8125,
      y_center: 0.0625
    },
    {
      w: 1,
      h: 1,
      x_center: 0.8125,
      y_center: 0.0625
    },
    {
      w: 1,
      h: 1,
      x_center: 0.8125,
      y_center: 0.0625
    },
    {
      w: 1,
      h: 1,
      x_center: 0.8125,
      y_center: 0.0625
    },
    {
      w: 1,
      h: 1,
      x_center: 0.9375,
      y_center: 0.0625
    },
    {
      w: 1,
      h: 1,
      x_center: 0.9375,
      y_center: 0.0625
    },
    {
      w: 1,
      h: 1,
      x_center: 0.9375,
      y_center: 0.0625
    },
    {
      w: 1,
      h: 1,
      x_center: 0.9375,
      y_center: 0.0625
    },
    {
      w: 1,
      h: 1,
      x_center: 0.9375,
      y_center: 0.0625
    },
    {
      w: 1,
      h: 1,
      x_center: 0.9375,
      y_center: 0.0625
    },
    {
      w: 1,
      h: 1,
      x_center: 0.0625,
      y_center: 0.1875
    },
    {
      w: 1,
      h: 1,
      x_center: 0.0625,
      y_center: 0.1875
    },
    {
      w: 1,
      h: 1,
      x_center: 0.0625,
      y_center: 0.1875
    },
    {
      w: 1,
      h: 1,
      x_center: 0.0625,
      y_center: 0.1875
    },
    {
      w: 1,
      h: 1,
      x_center: 0.0625,
      y_center: 0.1875
    },
    {
      w: 1,
      h: 1,
      x_center: 0.0625,
      y_center: 0.1875
    },
    {
      w: 1,
      h: 1,
      x_center: 0.1875,
      y_center: 0.1875
    },
    {
      w: 1,
      h: 1,
      x_center: 0.1875,
      y_center: 0.1875
    },
    {
      w: 1,
      h: 1,
      x_center: 0.1875,
      y_center: 0.1875
    },
    {
      w: 1,
      h: 1,
      x_center: 0.1875,
      y_center: 0.1875
    },
    {
      w: 1,
      h: 1,
      x_center: 0.1875,
      y_center: 0.1875
    },
    {
      w: 1,
      h: 1,
      x_center: 0.1875,
      y_center: 0.1875
    },
    {
      w: 1,
      h: 1,
      x_center: 0.3125,
      y_center: 0.1875
    },
    {
      w: 1,
      h: 1,
      x_center: 0.3125,
      y_center: 0.1875
    },
    {
      w: 1,
      h: 1,
      x_center: 0.3125,
      y_center: 0.1875
    },
    {
      w: 1,
      h: 1,
      x_center: 0.3125,
      y_center: 0.1875
    },
    {
      w: 1,
      h: 1,
      x_center: 0.3125,
      y_center: 0.1875
    },
    {
      w: 1,
      h: 1,
      x_center: 0.3125,
      y_center: 0.1875
    },
    {
      w: 1,
      h: 1,
      x_center: 0.4375,
      y_center: 0.1875
    },
    {
      w: 1,
      h: 1,
      x_center: 0.4375,
      y_center: 0.1875
    },
    {
      w: 1,
      h: 1,
      x_center: 0.4375,
      y_center: 0.1875
    },
    {
      w: 1,
      h: 1,
      x_center: 0.4375,
      y_center: 0.1875
    },
    {
      w: 1,
      h: 1,
      x_center: 0.4375,
      y_center: 0.1875
    },
    {
      w: 1,
      h: 1,
      x_center: 0.4375,
      y_center: 0.1875
    },
    {
      w: 1,
      h: 1,
      x_center: 0.5625,
      y_center: 0.1875
    },
    {
      w: 1,
      h: 1,
      x_center: 0.5625,
      y_center: 0.1875
    },
    {
      w: 1,
      h: 1,
      x_center: 0.5625,
      y_center: 0.1875
    },
    {
      w: 1,
      h: 1,
      x_center: 0.5625,
      y_center: 0.1875
    },
    {
      w: 1,
      h: 1,
      x_center: 0.5625,
      y_center: 0.1875
    },
    {
      w: 1,
      h: 1,
      x_center: 0.5625,
      y_center: 0.1875
    },
    {
      w: 1,
      h: 1,
      x_center: 0.6875,
      y_center: 0.1875
    },
    {
      w: 1,
      h: 1,
      x_center: 0.6875,
      y_center: 0.1875
    },
    {
      w: 1,
      h: 1,
      x_center: 0.6875,
      y_center: 0.1875
    },
    {
      w: 1,
      h: 1,
      x_center: 0.6875,
      y_center: 0.1875
    },
    {
      w: 1,
      h: 1,
      x_center: 0.6875,
      y_center: 0.1875
    },
    {
      w: 1,
      h: 1,
      x_center: 0.6875,
      y_center: 0.1875
    },
    {
      w: 1,
      h: 1,
      x_center: 0.8125,
      y_center: 0.1875
    },
    {
      w: 1,
      h: 1,
      x_center: 0.8125,
      y_center: 0.1875
    },
    {
      w: 1,
      h: 1,
      x_center: 0.8125,
      y_center: 0.1875
    },
    {
      w: 1,
      h: 1,
      x_center: 0.8125,
      y_center: 0.1875
    },
    {
      w: 1,
      h: 1,
      x_center: 0.8125,
      y_center: 0.1875
    },
    {
      w: 1,
      h: 1,
      x_center: 0.8125,
      y_center: 0.1875
    },
    {
      w: 1,
      h: 1,
      x_center: 0.9375,
      y_center: 0.1875
    },
    {
      w: 1,
      h: 1,
      x_center: 0.9375,
      y_center: 0.1875
    },
    {
      w: 1,
      h: 1,
      x_center: 0.9375,
      y_center: 0.1875
    },
    {
      w: 1,
      h: 1,
      x_center: 0.9375,
      y_center: 0.1875
    },
    {
      w: 1,
      h: 1,
      x_center: 0.9375,
      y_center: 0.1875
    },
    {
      w: 1,
      h: 1,
      x_center: 0.9375,
      y_center: 0.1875
    },
    {
      w: 1,
      h: 1,
      x_center: 0.0625,
      y_center: 0.3125
    },
    {
      w: 1,
      h: 1,
      x_center: 0.0625,
      y_center: 0.3125
    },
    {
      w: 1,
      h: 1,
      x_center: 0.0625,
      y_center: 0.3125
    },
    {
      w: 1,
      h: 1,
      x_center: 0.0625,
      y_center: 0.3125
    },
    {
      w: 1,
      h: 1,
      x_center: 0.0625,
      y_center: 0.3125
    },
    {
      w: 1,
      h: 1,
      x_center: 0.0625,
      y_center: 0.3125
    },
    {
      w: 1,
      h: 1,
      x_center: 0.1875,
      y_center: 0.3125
    },
    {
      w: 1,
      h: 1,
      x_center: 0.1875,
      y_center: 0.3125
    },
    {
      w: 1,
      h: 1,
      x_center: 0.1875,
      y_center: 0.3125
    },
    {
      w: 1,
      h: 1,
      x_center: 0.1875,
      y_center: 0.3125
    },
    {
      w: 1,
      h: 1,
      x_center: 0.1875,
      y_center: 0.3125
    },
    {
      w: 1,
      h: 1,
      x_center: 0.1875,
      y_center: 0.3125
    },
    {
      w: 1,
      h: 1,
      x_center: 0.3125,
      y_center: 0.3125
    },
    {
      w: 1,
      h: 1,
      x_center: 0.3125,
      y_center: 0.3125
    },
    {
      w: 1,
      h: 1,
      x_center: 0.3125,
      y_center: 0.3125
    },
    {
      w: 1,
      h: 1,
      x_center: 0.3125,
      y_center: 0.3125
    },
    {
      w: 1,
      h: 1,
      x_center: 0.3125,
      y_center: 0.3125
    },
    {
      w: 1,
      h: 1,
      x_center: 0.3125,
      y_center: 0.3125
    },
    {
      w: 1,
      h: 1,
      x_center: 0.4375,
      y_center: 0.3125
    },
    {
      w: 1,
      h: 1,
      x_center: 0.4375,
      y_center: 0.3125
    },
    {
      w: 1,
      h: 1,
      x_center: 0.4375,
      y_center: 0.3125
    },
    {
      w: 1,
      h: 1,
      x_center: 0.4375,
      y_center: 0.3125
    },
    {
      w: 1,
      h: 1,
      x_center: 0.4375,
      y_center: 0.3125
    },
    {
      w: 1,
      h: 1,
      x_center: 0.4375,
      y_center: 0.3125
    },
    {
      w: 1,
      h: 1,
      x_center: 0.5625,
      y_center: 0.3125
    },
    {
      w: 1,
      h: 1,
      x_center: 0.5625,
      y_center: 0.3125
    },
    {
      w: 1,
      h: 1,
      x_center: 0.5625,
      y_center: 0.3125
    },
    {
      w: 1,
      h: 1,
      x_center: 0.5625,
      y_center: 0.3125
    },
    {
      w: 1,
      h: 1,
      x_center: 0.5625,
      y_center: 0.3125
    },
    {
      w: 1,
      h: 1,
      x_center: 0.5625,
      y_center: 0.3125
    },
    {
      w: 1,
      h: 1,
      x_center: 0.6875,
      y_center: 0.3125
    },
    {
      w: 1,
      h: 1,
      x_center: 0.6875,
      y_center: 0.3125
    },
    {
      w: 1,
      h: 1,
      x_center: 0.6875,
      y_center: 0.3125
    },
    {
      w: 1,
      h: 1,
      x_center: 0.6875,
      y_center: 0.3125
    },
    {
      w: 1,
      h: 1,
      x_center: 0.6875,
      y_center: 0.3125
    },
    {
      w: 1,
      h: 1,
      x_center: 0.6875,
      y_center: 0.3125
    },
    {
      w: 1,
      h: 1,
      x_center: 0.8125,
      y_center: 0.3125
    },
    {
      w: 1,
      h: 1,
      x_center: 0.8125,
      y_center: 0.3125
    },
    {
      w: 1,
      h: 1,
      x_center: 0.8125,
      y_center: 0.3125
    },
    {
      w: 1,
      h: 1,
      x_center: 0.8125,
      y_center: 0.3125
    },
    {
      w: 1,
      h: 1,
      x_center: 0.8125,
      y_center: 0.3125
    },
    {
      w: 1,
      h: 1,
      x_center: 0.8125,
      y_center: 0.3125
    },
    {
      w: 1,
      h: 1,
      x_center: 0.9375,
      y_center: 0.3125
    },
    {
      w: 1,
      h: 1,
      x_center: 0.9375,
      y_center: 0.3125
    },
    {
      w: 1,
      h: 1,
      x_center: 0.9375,
      y_center: 0.3125
    },
    {
      w: 1,
      h: 1,
      x_center: 0.9375,
      y_center: 0.3125
    },
    {
      w: 1,
      h: 1,
      x_center: 0.9375,
      y_center: 0.3125
    },
    {
      w: 1,
      h: 1,
      x_center: 0.9375,
      y_center: 0.3125
    },
    {
      w: 1,
      h: 1,
      x_center: 0.0625,
      y_center: 0.4375
    },
    {
      w: 1,
      h: 1,
      x_center: 0.0625,
      y_center: 0.4375
    },
    {
      w: 1,
      h: 1,
      x_center: 0.0625,
      y_center: 0.4375
    },
    {
      w: 1,
      h: 1,
      x_center: 0.0625,
      y_center: 0.4375
    },
    {
      w: 1,
      h: 1,
      x_center: 0.0625,
      y_center: 0.4375
    },
    {
      w: 1,
      h: 1,
      x_center: 0.0625,
      y_center: 0.4375
    },
    {
      w: 1,
      h: 1,
      x_center: 0.1875,
      y_center: 0.4375
    },
    {
      w: 1,
      h: 1,
      x_center: 0.1875,
      y_center: 0.4375
    },
    {
      w: 1,
      h: 1,
      x_center: 0.1875,
      y_center: 0.4375
    },
    {
      w: 1,
      h: 1,
      x_center: 0.1875,
      y_center: 0.4375
    },
    {
      w: 1,
      h: 1,
      x_center: 0.1875,
      y_center: 0.4375
    },
    {
      w: 1,
      h: 1,
      x_center: 0.1875,
      y_center: 0.4375
    },
    {
      w: 1,
      h: 1,
      x_center: 0.3125,
      y_center: 0.4375
    },
    {
      w: 1,
      h: 1,
      x_center: 0.3125,
      y_center: 0.4375
    },
    {
      w: 1,
      h: 1,
      x_center: 0.3125,
      y_center: 0.4375
    },
    {
      w: 1,
      h: 1,
      x_center: 0.3125,
      y_center: 0.4375
    },
    {
      w: 1,
      h: 1,
      x_center: 0.3125,
      y_center: 0.4375
    },
    {
      w: 1,
      h: 1,
      x_center: 0.3125,
      y_center: 0.4375
    },
    {
      w: 1,
      h: 1,
      x_center: 0.4375,
      y_center: 0.4375
    },
    {
      w: 1,
      h: 1,
      x_center: 0.4375,
      y_center: 0.4375
    },
    {
      w: 1,
      h: 1,
      x_center: 0.4375,
      y_center: 0.4375
    },
    {
      w: 1,
      h: 1,
      x_center: 0.4375,
      y_center: 0.4375
    },
    {
      w: 1,
      h: 1,
      x_center: 0.4375,
      y_center: 0.4375
    },
    {
      w: 1,
      h: 1,
      x_center: 0.4375,
      y_center: 0.4375
    },
    {
      w: 1,
      h: 1,
      x_center: 0.5625,
      y_center: 0.4375
    },
    {
      w: 1,
      h: 1,
      x_center: 0.5625,
      y_center: 0.4375
    },
    {
      w: 1,
      h: 1,
      x_center: 0.5625,
      y_center: 0.4375
    },
    {
      w: 1,
      h: 1,
      x_center: 0.5625,
      y_center: 0.4375
    },
    {
      w: 1,
      h: 1,
      x_center: 0.5625,
      y_center: 0.4375
    },
    {
      w: 1,
      h: 1,
      x_center: 0.5625,
      y_center: 0.4375
    },
    {
      w: 1,
      h: 1,
      x_center: 0.6875,
      y_center: 0.4375
    },
    {
      w: 1,
      h: 1,
      x_center: 0.6875,
      y_center: 0.4375
    },
    {
      w: 1,
      h: 1,
      x_center: 0.6875,
      y_center: 0.4375
    },
    {
      w: 1,
      h: 1,
      x_center: 0.6875,
      y_center: 0.4375
    },
    {
      w: 1,
      h: 1,
      x_center: 0.6875,
      y_center: 0.4375
    },
    {
      w: 1,
      h: 1,
      x_center: 0.6875,
      y_center: 0.4375
    },
    {
      w: 1,
      h: 1,
      x_center: 0.8125,
      y_center: 0.4375
    },
    {
      w: 1,
      h: 1,
      x_center: 0.8125,
      y_center: 0.4375
    },
    {
      w: 1,
      h: 1,
      x_center: 0.8125,
      y_center: 0.4375
    },
    {
      w: 1,
      h: 1,
      x_center: 0.8125,
      y_center: 0.4375
    },
    {
      w: 1,
      h: 1,
      x_center: 0.8125,
      y_center: 0.4375
    },
    {
      w: 1,
      h: 1,
      x_center: 0.8125,
      y_center: 0.4375
    },
    {
      w: 1,
      h: 1,
      x_center: 0.9375,
      y_center: 0.4375
    },
    {
      w: 1,
      h: 1,
      x_center: 0.9375,
      y_center: 0.4375
    },
    {
      w: 1,
      h: 1,
      x_center: 0.9375,
      y_center: 0.4375
    },
    {
      w: 1,
      h: 1,
      x_center: 0.9375,
      y_center: 0.4375
    },
    {
      w: 1,
      h: 1,
      x_center: 0.9375,
      y_center: 0.4375
    },
    {
      w: 1,
      h: 1,
      x_center: 0.9375,
      y_center: 0.4375
    },
    {
      w: 1,
      h: 1,
      x_center: 0.0625,
      y_center: 0.5625
    },
    {
      w: 1,
      h: 1,
      x_center: 0.0625,
      y_center: 0.5625
    },
    {
      w: 1,
      h: 1,
      x_center: 0.0625,
      y_center: 0.5625
    },
    {
      w: 1,
      h: 1,
      x_center: 0.0625,
      y_center: 0.5625
    },
    {
      w: 1,
      h: 1,
      x_center: 0.0625,
      y_center: 0.5625
    },
    {
      w: 1,
      h: 1,
      x_center: 0.0625,
      y_center: 0.5625
    },
    {
      w: 1,
      h: 1,
      x_center: 0.1875,
      y_center: 0.5625
    },
    {
      w: 1,
      h: 1,
      x_center: 0.1875,
      y_center: 0.5625
    },
    {
      w: 1,
      h: 1,
      x_center: 0.1875,
      y_center: 0.5625
    },
    {
      w: 1,
      h: 1,
      x_center: 0.1875,
      y_center: 0.5625
    },
    {
      w: 1,
      h: 1,
      x_center: 0.1875,
      y_center: 0.5625
    },
    {
      w: 1,
      h: 1,
      x_center: 0.1875,
      y_center: 0.5625
    },
    {
      w: 1,
      h: 1,
      x_center: 0.3125,
      y_center: 0.5625
    },
    {
      w: 1,
      h: 1,
      x_center: 0.3125,
      y_center: 0.5625
    },
    {
      w: 1,
      h: 1,
      x_center: 0.3125,
      y_center: 0.5625
    },
    {
      w: 1,
      h: 1,
      x_center: 0.3125,
      y_center: 0.5625
    },
    {
      w: 1,
      h: 1,
      x_center: 0.3125,
      y_center: 0.5625
    },
    {
      w: 1,
      h: 1,
      x_center: 0.3125,
      y_center: 0.5625
    },
    {
      w: 1,
      h: 1,
      x_center: 0.4375,
      y_center: 0.5625
    },
    {
      w: 1,
      h: 1,
      x_center: 0.4375,
      y_center: 0.5625
    },
    {
      w: 1,
      h: 1,
      x_center: 0.4375,
      y_center: 0.5625
    },
    {
      w: 1,
      h: 1,
      x_center: 0.4375,
      y_center: 0.5625
    },
    {
      w: 1,
      h: 1,
      x_center: 0.4375,
      y_center: 0.5625
    },
    {
      w: 1,
      h: 1,
      x_center: 0.4375,
      y_center: 0.5625
    },
    {
      w: 1,
      h: 1,
      x_center: 0.5625,
      y_center: 0.5625
    },
    {
      w: 1,
      h: 1,
      x_center: 0.5625,
      y_center: 0.5625
    },
    {
      w: 1,
      h: 1,
      x_center: 0.5625,
      y_center: 0.5625
    },
    {
      w: 1,
      h: 1,
      x_center: 0.5625,
      y_center: 0.5625
    },
    {
      w: 1,
      h: 1,
      x_center: 0.5625,
      y_center: 0.5625
    },
    {
      w: 1,
      h: 1,
      x_center: 0.5625,
      y_center: 0.5625
    },
    {
      w: 1,
      h: 1,
      x_center: 0.6875,
      y_center: 0.5625
    },
    {
      w: 1,
      h: 1,
      x_center: 0.6875,
      y_center: 0.5625
    },
    {
      w: 1,
      h: 1,
      x_center: 0.6875,
      y_center: 0.5625
    },
    {
      w: 1,
      h: 1,
      x_center: 0.6875,
      y_center: 0.5625
    },
    {
      w: 1,
      h: 1,
      x_center: 0.6875,
      y_center: 0.5625
    },
    {
      w: 1,
      h: 1,
      x_center: 0.6875,
      y_center: 0.5625
    },
    {
      w: 1,
      h: 1,
      x_center: 0.8125,
      y_center: 0.5625
    },
    {
      w: 1,
      h: 1,
      x_center: 0.8125,
      y_center: 0.5625
    },
    {
      w: 1,
      h: 1,
      x_center: 0.8125,
      y_center: 0.5625
    },
    {
      w: 1,
      h: 1,
      x_center: 0.8125,
      y_center: 0.5625
    },
    {
      w: 1,
      h: 1,
      x_center: 0.8125,
      y_center: 0.5625
    },
    {
      w: 1,
      h: 1,
      x_center: 0.8125,
      y_center: 0.5625
    },
    {
      w: 1,
      h: 1,
      x_center: 0.9375,
      y_center: 0.5625
    },
    {
      w: 1,
      h: 1,
      x_center: 0.9375,
      y_center: 0.5625
    },
    {
      w: 1,
      h: 1,
      x_center: 0.9375,
      y_center: 0.5625
    },
    {
      w: 1,
      h: 1,
      x_center: 0.9375,
      y_center: 0.5625
    },
    {
      w: 1,
      h: 1,
      x_center: 0.9375,
      y_center: 0.5625
    },
    {
      w: 1,
      h: 1,
      x_center: 0.9375,
      y_center: 0.5625
    },
    {
      w: 1,
      h: 1,
      x_center: 0.0625,
      y_center: 0.6875
    },
    {
      w: 1,
      h: 1,
      x_center: 0.0625,
      y_center: 0.6875
    },
    {
      w: 1,
      h: 1,
      x_center: 0.0625,
      y_center: 0.6875
    },
    {
      w: 1,
      h: 1,
      x_center: 0.0625,
      y_center: 0.6875
    },
    {
      w: 1,
      h: 1,
      x_center: 0.0625,
      y_center: 0.6875
    },
    {
      w: 1,
      h: 1,
      x_center: 0.0625,
      y_center: 0.6875
    },
    {
      w: 1,
      h: 1,
      x_center: 0.1875,
      y_center: 0.6875
    },
    {
      w: 1,
      h: 1,
      x_center: 0.1875,
      y_center: 0.6875
    },
    {
      w: 1,
      h: 1,
      x_center: 0.1875,
      y_center: 0.6875
    },
    {
      w: 1,
      h: 1,
      x_center: 0.1875,
      y_center: 0.6875
    },
    {
      w: 1,
      h: 1,
      x_center: 0.1875,
      y_center: 0.6875
    },
    {
      w: 1,
      h: 1,
      x_center: 0.1875,
      y_center: 0.6875
    },
    {
      w: 1,
      h: 1,
      x_center: 0.3125,
      y_center: 0.6875
    },
    {
      w: 1,
      h: 1,
      x_center: 0.3125,
      y_center: 0.6875
    },
    {
      w: 1,
      h: 1,
      x_center: 0.3125,
      y_center: 0.6875
    },
    {
      w: 1,
      h: 1,
      x_center: 0.3125,
      y_center: 0.6875
    },
    {
      w: 1,
      h: 1,
      x_center: 0.3125,
      y_center: 0.6875
    },
    {
      w: 1,
      h: 1,
      x_center: 0.3125,
      y_center: 0.6875
    },
    {
      w: 1,
      h: 1,
      x_center: 0.4375,
      y_center: 0.6875
    },
    {
      w: 1,
      h: 1,
      x_center: 0.4375,
      y_center: 0.6875
    },
    {
      w: 1,
      h: 1,
      x_center: 0.4375,
      y_center: 0.6875
    },
    {
      w: 1,
      h: 1,
      x_center: 0.4375,
      y_center: 0.6875
    },
    {
      w: 1,
      h: 1,
      x_center: 0.4375,
      y_center: 0.6875
    },
    {
      w: 1,
      h: 1,
      x_center: 0.4375,
      y_center: 0.6875
    },
    {
      w: 1,
      h: 1,
      x_center: 0.5625,
      y_center: 0.6875
    },
    {
      w: 1,
      h: 1,
      x_center: 0.5625,
      y_center: 0.6875
    },
    {
      w: 1,
      h: 1,
      x_center: 0.5625,
      y_center: 0.6875
    },
    {
      w: 1,
      h: 1,
      x_center: 0.5625,
      y_center: 0.6875
    },
    {
      w: 1,
      h: 1,
      x_center: 0.5625,
      y_center: 0.6875
    },
    {
      w: 1,
      h: 1,
      x_center: 0.5625,
      y_center: 0.6875
    },
    {
      w: 1,
      h: 1,
      x_center: 0.6875,
      y_center: 0.6875
    },
    {
      w: 1,
      h: 1,
      x_center: 0.6875,
      y_center: 0.6875
    },
    {
      w: 1,
      h: 1,
      x_center: 0.6875,
      y_center: 0.6875
    },
    {
      w: 1,
      h: 1,
      x_center: 0.6875,
      y_center: 0.6875
    },
    {
      w: 1,
      h: 1,
      x_center: 0.6875,
      y_center: 0.6875
    },
    {
      w: 1,
      h: 1,
      x_center: 0.6875,
      y_center: 0.6875
    },
    {
      w: 1,
      h: 1,
      x_center: 0.8125,
      y_center: 0.6875
    },
    {
      w: 1,
      h: 1,
      x_center: 0.8125,
      y_center: 0.6875
    },
    {
      w: 1,
      h: 1,
      x_center: 0.8125,
      y_center: 0.6875
    },
    {
      w: 1,
      h: 1,
      x_center: 0.8125,
      y_center: 0.6875
    },
    {
      w: 1,
      h: 1,
      x_center: 0.8125,
      y_center: 0.6875
    },
    {
      w: 1,
      h: 1,
      x_center: 0.8125,
      y_center: 0.6875
    },
    {
      w: 1,
      h: 1,
      x_center: 0.9375,
      y_center: 0.6875
    },
    {
      w: 1,
      h: 1,
      x_center: 0.9375,
      y_center: 0.6875
    },
    {
      w: 1,
      h: 1,
      x_center: 0.9375,
      y_center: 0.6875
    },
    {
      w: 1,
      h: 1,
      x_center: 0.9375,
      y_center: 0.6875
    },
    {
      w: 1,
      h: 1,
      x_center: 0.9375,
      y_center: 0.6875
    },
    {
      w: 1,
      h: 1,
      x_center: 0.9375,
      y_center: 0.6875
    },
    {
      w: 1,
      h: 1,
      x_center: 0.0625,
      y_center: 0.8125
    },
    {
      w: 1,
      h: 1,
      x_center: 0.0625,
      y_center: 0.8125
    },
    {
      w: 1,
      h: 1,
      x_center: 0.0625,
      y_center: 0.8125
    },
    {
      w: 1,
      h: 1,
      x_center: 0.0625,
      y_center: 0.8125
    },
    {
      w: 1,
      h: 1,
      x_center: 0.0625,
      y_center: 0.8125
    },
    {
      w: 1,
      h: 1,
      x_center: 0.0625,
      y_center: 0.8125
    },
    {
      w: 1,
      h: 1,
      x_center: 0.1875,
      y_center: 0.8125
    },
    {
      w: 1,
      h: 1,
      x_center: 0.1875,
      y_center: 0.8125
    },
    {
      w: 1,
      h: 1,
      x_center: 0.1875,
      y_center: 0.8125
    },
    {
      w: 1,
      h: 1,
      x_center: 0.1875,
      y_center: 0.8125
    },
    {
      w: 1,
      h: 1,
      x_center: 0.1875,
      y_center: 0.8125
    },
    {
      w: 1,
      h: 1,
      x_center: 0.1875,
      y_center: 0.8125
    },
    {
      w: 1,
      h: 1,
      x_center: 0.3125,
      y_center: 0.8125
    },
    {
      w: 1,
      h: 1,
      x_center: 0.3125,
      y_center: 0.8125
    },
    {
      w: 1,
      h: 1,
      x_center: 0.3125,
      y_center: 0.8125
    },
    {
      w: 1,
      h: 1,
      x_center: 0.3125,
      y_center: 0.8125
    },
    {
      w: 1,
      h: 1,
      x_center: 0.3125,
      y_center: 0.8125
    },
    {
      w: 1,
      h: 1,
      x_center: 0.3125,
      y_center: 0.8125
    },
    {
      w: 1,
      h: 1,
      x_center: 0.4375,
      y_center: 0.8125
    },
    {
      w: 1,
      h: 1,
      x_center: 0.4375,
      y_center: 0.8125
    },
    {
      w: 1,
      h: 1,
      x_center: 0.4375,
      y_center: 0.8125
    },
    {
      w: 1,
      h: 1,
      x_center: 0.4375,
      y_center: 0.8125
    },
    {
      w: 1,
      h: 1,
      x_center: 0.4375,
      y_center: 0.8125
    },
    {
      w: 1,
      h: 1,
      x_center: 0.4375,
      y_center: 0.8125
    },
    {
      w: 1,
      h: 1,
      x_center: 0.5625,
      y_center: 0.8125
    },
    {
      w: 1,
      h: 1,
      x_center: 0.5625,
      y_center: 0.8125
    },
    {
      w: 1,
      h: 1,
      x_center: 0.5625,
      y_center: 0.8125
    },
    {
      w: 1,
      h: 1,
      x_center: 0.5625,
      y_center: 0.8125
    },
    {
      w: 1,
      h: 1,
      x_center: 0.5625,
      y_center: 0.8125
    },
    {
      w: 1,
      h: 1,
      x_center: 0.5625,
      y_center: 0.8125
    },
    {
      w: 1,
      h: 1,
      x_center: 0.6875,
      y_center: 0.8125
    },
    {
      w: 1,
      h: 1,
      x_center: 0.6875,
      y_center: 0.8125
    },
    {
      w: 1,
      h: 1,
      x_center: 0.6875,
      y_center: 0.8125
    },
    {
      w: 1,
      h: 1,
      x_center: 0.6875,
      y_center: 0.8125
    },
    {
      w: 1,
      h: 1,
      x_center: 0.6875,
      y_center: 0.8125
    },
    {
      w: 1,
      h: 1,
      x_center: 0.6875,
      y_center: 0.8125
    },
    {
      w: 1,
      h: 1,
      x_center: 0.8125,
      y_center: 0.8125
    },
    {
      w: 1,
      h: 1,
      x_center: 0.8125,
      y_center: 0.8125
    },
    {
      w: 1,
      h: 1,
      x_center: 0.8125,
      y_center: 0.8125
    },
    {
      w: 1,
      h: 1,
      x_center: 0.8125,
      y_center: 0.8125
    },
    {
      w: 1,
      h: 1,
      x_center: 0.8125,
      y_center: 0.8125
    },
    {
      w: 1,
      h: 1,
      x_center: 0.8125,
      y_center: 0.8125
    },
    {
      w: 1,
      h: 1,
      x_center: 0.9375,
      y_center: 0.8125
    },
    {
      w: 1,
      h: 1,
      x_center: 0.9375,
      y_center: 0.8125
    },
    {
      w: 1,
      h: 1,
      x_center: 0.9375,
      y_center: 0.8125
    },
    {
      w: 1,
      h: 1,
      x_center: 0.9375,
      y_center: 0.8125
    },
    {
      w: 1,
      h: 1,
      x_center: 0.9375,
      y_center: 0.8125
    },
    {
      w: 1,
      h: 1,
      x_center: 0.9375,
      y_center: 0.8125
    },
    {
      w: 1,
      h: 1,
      x_center: 0.0625,
      y_center: 0.9375
    },
    {
      w: 1,
      h: 1,
      x_center: 0.0625,
      y_center: 0.9375
    },
    {
      w: 1,
      h: 1,
      x_center: 0.0625,
      y_center: 0.9375
    },
    {
      w: 1,
      h: 1,
      x_center: 0.0625,
      y_center: 0.9375
    },
    {
      w: 1,
      h: 1,
      x_center: 0.0625,
      y_center: 0.9375
    },
    {
      w: 1,
      h: 1,
      x_center: 0.0625,
      y_center: 0.9375
    },
    {
      w: 1,
      h: 1,
      x_center: 0.1875,
      y_center: 0.9375
    },
    {
      w: 1,
      h: 1,
      x_center: 0.1875,
      y_center: 0.9375
    },
    {
      w: 1,
      h: 1,
      x_center: 0.1875,
      y_center: 0.9375
    },
    {
      w: 1,
      h: 1,
      x_center: 0.1875,
      y_center: 0.9375
    },
    {
      w: 1,
      h: 1,
      x_center: 0.1875,
      y_center: 0.9375
    },
    {
      w: 1,
      h: 1,
      x_center: 0.1875,
      y_center: 0.9375
    },
    {
      w: 1,
      h: 1,
      x_center: 0.3125,
      y_center: 0.9375
    },
    {
      w: 1,
      h: 1,
      x_center: 0.3125,
      y_center: 0.9375
    },
    {
      w: 1,
      h: 1,
      x_center: 0.3125,
      y_center: 0.9375
    },
    {
      w: 1,
      h: 1,
      x_center: 0.3125,
      y_center: 0.9375
    },
    {
      w: 1,
      h: 1,
      x_center: 0.3125,
      y_center: 0.9375
    },
    {
      w: 1,
      h: 1,
      x_center: 0.3125,
      y_center: 0.9375
    },
    {
      w: 1,
      h: 1,
      x_center: 0.4375,
      y_center: 0.9375
    },
    {
      w: 1,
      h: 1,
      x_center: 0.4375,
      y_center: 0.9375
    },
    {
      w: 1,
      h: 1,
      x_center: 0.4375,
      y_center: 0.9375
    },
    {
      w: 1,
      h: 1,
      x_center: 0.4375,
      y_center: 0.9375
    },
    {
      w: 1,
      h: 1,
      x_center: 0.4375,
      y_center: 0.9375
    },
    {
      w: 1,
      h: 1,
      x_center: 0.4375,
      y_center: 0.9375
    },
    {
      w: 1,
      h: 1,
      x_center: 0.5625,
      y_center: 0.9375
    },
    {
      w: 1,
      h: 1,
      x_center: 0.5625,
      y_center: 0.9375
    },
    {
      w: 1,
      h: 1,
      x_center: 0.5625,
      y_center: 0.9375
    },
    {
      w: 1,
      h: 1,
      x_center: 0.5625,
      y_center: 0.9375
    },
    {
      w: 1,
      h: 1,
      x_center: 0.5625,
      y_center: 0.9375
    },
    {
      w: 1,
      h: 1,
      x_center: 0.5625,
      y_center: 0.9375
    },
    {
      w: 1,
      h: 1,
      x_center: 0.6875,
      y_center: 0.9375
    },
    {
      w: 1,
      h: 1,
      x_center: 0.6875,
      y_center: 0.9375
    },
    {
      w: 1,
      h: 1,
      x_center: 0.6875,
      y_center: 0.9375
    },
    {
      w: 1,
      h: 1,
      x_center: 0.6875,
      y_center: 0.9375
    },
    {
      w: 1,
      h: 1,
      x_center: 0.6875,
      y_center: 0.9375
    },
    {
      w: 1,
      h: 1,
      x_center: 0.6875,
      y_center: 0.9375
    },
    {
      w: 1,
      h: 1,
      x_center: 0.8125,
      y_center: 0.9375
    },
    {
      w: 1,
      h: 1,
      x_center: 0.8125,
      y_center: 0.9375
    },
    {
      w: 1,
      h: 1,
      x_center: 0.8125,
      y_center: 0.9375
    },
    {
      w: 1,
      h: 1,
      x_center: 0.8125,
      y_center: 0.9375
    },
    {
      w: 1,
      h: 1,
      x_center: 0.8125,
      y_center: 0.9375
    },
    {
      w: 1,
      h: 1,
      x_center: 0.8125,
      y_center: 0.9375
    },
    {
      w: 1,
      h: 1,
      x_center: 0.9375,
      y_center: 0.9375
    },
    {
      w: 1,
      h: 1,
      x_center: 0.9375,
      y_center: 0.9375
    },
    {
      w: 1,
      h: 1,
      x_center: 0.9375,
      y_center: 0.9375
    },
    {
      w: 1,
      h: 1,
      x_center: 0.9375,
      y_center: 0.9375
    },
    {
      w: 1,
      h: 1,
      x_center: 0.9375,
      y_center: 0.9375
    },
    {
      w: 1,
      h: 1,
      x_center: 0.9375,
      y_center: 0.9375
    }
  ];
});
var require_handpose = __commonJS((exports) => {
  const handdetector = __toModule(require_handdetector());
  const pipeline = __toModule(require_handpipeline());
  const anchors = __toModule(require_anchors());
  /**
   * @license
   * Copyright 2020 Google LLC. All Rights Reserved.
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * https://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * =============================================================================
   */
  const MESH_ANNOTATIONS = {
    thumb: [1, 2, 3, 4],
    indexFinger: [5, 6, 7, 8],
    middleFinger: [9, 10, 11, 12],
    ringFinger: [13, 14, 15, 16],
    pinky: [17, 18, 19, 20],
    palmBase: [0]
  };
  class HandPose {
    constructor(pipe) {
      this.pipeline = pipe;
    }
    static getAnnotations() {
      return MESH_ANNOTATIONS;
    }
    async estimateHands(input, config2) {
      const predictions = await this.pipeline.estimateHands(input, config2);
      if (!predictions)
        return [];
      const hands = [];
      for (const prediction of predictions) {
        const annotations = {};
        if (prediction.landmarks) {
          for (const key of Object.keys(MESH_ANNOTATIONS)) {
            annotations[key] = MESH_ANNOTATIONS[key].map((index) => prediction.landmarks[index]);
          }
        }
        hands.push({
          confidence: prediction.confidence,
          box: prediction.box ? [
            prediction.box.topLeft[0],
            prediction.box.topLeft[1],
            prediction.box.bottomRight[0] - prediction.box.topLeft[0],
            prediction.box.bottomRight[1] - prediction.box.topLeft[1]
          ] : 0,
          landmarks: prediction.landmarks,
          annotations
        });
      }
      return hands;
    }
  }
  exports.HandPose = HandPose;
  async function load2(config2) {
    const [handDetectorModel, handPoseModel] = await Promise.all([
      loadGraphModel(config2.detector.modelPath, {fromTFHub: config2.detector.modelPath.includes("tfhub.dev")}),
      loadGraphModel(config2.skeleton.modelPath, {fromTFHub: config2.skeleton.modelPath.includes("tfhub.dev")})
    ]);
    const detector = new handdetector.HandDetector(handDetectorModel, config2.inputSize, anchors.anchors);
    const pipe = new pipeline.HandPipeline(detector, handPoseModel, config2.inputSize);
    const handpose2 = new HandPose(pipe);
    console.log(`Human: load model: ${config2.detector.modelPath.match(/\/(.*)\./)[1]}`);
    console.log(`Human: load model: ${config2.skeleton.modelPath.match(/\/(.*)\./)[1]}`);
    return handpose2;
  }
  exports.load = load2;
});
var require_gesture = __commonJS((exports) => {
  exports.body = (res) => {
    if (!res)
      return [];
    const gestures = [];
    for (const pose of res) {
      const leftWrist = pose.keypoints.find((a) => a.part === "leftWrist");
      const rightWrist = pose.keypoints.find((a) => a.part === "rightWrist");
      const nose = pose.keypoints.find((a) => a.part === "nose");
      if (nose && leftWrist && rightWrist && leftWrist.position.y < nose.position.y && rightWrist.position.y < nose.position.y)
        gestures.push("i give up");
      else if (nose && leftWrist && leftWrist.position.y < nose.position.y)
        gestures.push("raise left hand");
      else if (nose && rightWrist && rightWrist.position.y < nose.position.y)
        gestures.push("raise right hand");
      const leftShoulder = pose.keypoints.find((a) => a.part === "leftShoulder");
      const rightShoulder = pose.keypoints.find((a) => a.part === "rightShoulder");
      if (leftShoulder && rightShoulder)
        gestures.push(`leaning ${leftShoulder.position.y > rightShoulder.position.y ? "left" : "right"}`);
    }
    return gestures;
  };
  exports.face = (res) => {
    if (!res)
      return [];
    const gestures = [];
    for (const face2 of res) {
      if (face2.mesh && face2.mesh.length > 0) {
        const eyeFacing = face2.mesh[35][2] - face2.mesh[263][2];
        if (Math.abs(eyeFacing) < 10)
          gestures.push("facing camera");
        else
          gestures.push(`facing ${eyeFacing < 0 ? "right" : "left"}`);
        const openLeft = Math.abs(face2.mesh[374][1] - face2.mesh[386][1]) / Math.abs(face2.mesh[443][1] - face2.mesh[450][1]);
        if (openLeft < 0.2)
          gestures.push("blink left eye");
        const openRight = Math.abs(face2.mesh[145][1] - face2.mesh[159][1]) / Math.abs(face2.mesh[223][1] - face2.mesh[230][1]);
        if (openRight < 0.2)
          gestures.push("blink right eye");
        const mouthOpen = Math.min(100, 500 * Math.abs(face2.mesh[13][1] - face2.mesh[14][1]) / Math.abs(face2.mesh[10][1] - face2.mesh[152][1]));
        if (mouthOpen > 10)
          gestures.push(`mouth ${Math.trunc(mouthOpen)}% open`);
        const chinDepth = face2.mesh[152][2];
        if (Math.abs(chinDepth) > 10)
          gestures.push(`head ${chinDepth < 0 ? "up" : "down"}`);
      }
    }
    return gestures;
  };
  exports.hand = (res) => {
    if (!res)
      return [];
    const gestures = [];
    for (const hand2 of res) {
      const fingers = [];
      for (const [finger, pos] of Object.entries(hand2["annotations"])) {
        if (finger !== "palmBase")
          fingers.push({name: finger.toLowerCase(), position: pos[0]});
      }
      if (fingers && fingers.length > 0) {
        const closest = fingers.reduce((best, a) => best.position[2] < a.position[2] ? best : a);
        const highest = fingers.reduce((best, a) => best.position[1] < a.position[1] ? best : a);
        gestures.push(`${closest.name} forward ${highest.name} up`);
      }
    }
    return gestures;
  };
});
var require_imagefx = __commonJS((exports) => {
  const WebGLProgram = function(gl, vertexSource, fragmentSource) {
    const _collect = function(source, prefix, collection) {
      const r = new RegExp("\\b" + prefix + " \\w+ (\\w+)", "ig");
      source.replace(r, (match, name) => {
        collection[name] = 0;
        return match;
      });
    };
    const _compile = function(source, type) {
      const shader = gl.createShader(type);
      gl.shaderSource(shader, source);
      gl.compileShader(shader);
      if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
        throw new Error("Filter: GL compile failed", gl.getShaderInfoLog(shader));
      }
      return shader;
    };
    this.uniform = {};
    this.attribute = {};
    const _vsh = _compile(vertexSource, gl.VERTEX_SHADER);
    const _fsh = _compile(fragmentSource, gl.FRAGMENT_SHADER);
    this.id = gl.createProgram();
    gl.attachShader(this.id, _vsh);
    gl.attachShader(this.id, _fsh);
    gl.linkProgram(this.id);
    if (!gl.getProgramParameter(this.id, gl.LINK_STATUS)) {
      throw new Error("Filter: GL link failed", gl.getProgramInfoLog(this.id));
    }
    gl.useProgram(this.id);
    _collect(vertexSource, "attribute", this.attribute);
    for (const a in this.attribute) {
      this.attribute[a] = gl.getAttribLocation(this.id, a);
    }
    _collect(vertexSource, "uniform", this.uniform);
    _collect(fragmentSource, "uniform", this.uniform);
    for (const u in this.uniform) {
      this.uniform[u] = gl.getUniformLocation(this.id, u);
    }
  };
  const WebGLImageFilter = function(params) {
    if (!params)
      params = {};
    let _drawCount = 0;
    let _sourceTexture = null;
    let _lastInChain = false;
    let _currentFramebufferIndex = -1;
    let _tempFramebuffers = [null, null];
    let _filterChain = [];
    let _width = -1;
    let _height = -1;
    let _vertexBuffer = null;
    let _currentProgram = null;
    const _canvas = params.canvas || document.createElement("canvas");
    const _shaderProgramCache = {};
    const gl = _canvas.getContext("webgl");
    if (!gl)
      throw new Error("Filter: getContext() failed");
    this.addFilter = function(name) {
      const args = Array.prototype.slice.call(arguments, 1);
      const filter = _filter[name];
      _filterChain.push({func: filter, args});
    };
    this.reset = function() {
      _filterChain = [];
    };
    this.apply = function(image2) {
      _resize(image2.width, image2.height);
      _drawCount = 0;
      if (!_sourceTexture)
        _sourceTexture = gl.createTexture();
      gl.bindTexture(gl.TEXTURE_2D, _sourceTexture);
      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);
      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);
      gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, image2);
      if (_filterChain.length === 0) {
        _draw();
        return _canvas;
      }
      for (let i = 0; i < _filterChain.length; i++) {
        _lastInChain = i === _filterChain.length - 1;
        const f = _filterChain[i];
        f.func.apply(this, f.args || []);
      }
      return _canvas;
    };
    const _resize = function(width, height) {
      if (width === _width && height === _height) {
        return;
      }
      _canvas.width = width;
      _width = width;
      _canvas.height = height;
      _height = height;
      if (!_vertexBuffer) {
        const vertices = new Float32Array([
          -1,
          -1,
          0,
          1,
          1,
          -1,
          1,
          1,
          -1,
          1,
          0,
          0,
          -1,
          1,
          0,
          0,
          1,
          -1,
          1,
          1,
          1,
          1,
          1,
          0
        ]);
        _vertexBuffer = gl.createBuffer(), gl.bindBuffer(gl.ARRAY_BUFFER, _vertexBuffer);
        gl.bufferData(gl.ARRAY_BUFFER, vertices, gl.STATIC_DRAW);
        gl.pixelStorei(gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, true);
      }
      gl.viewport(0, 0, _width, _height);
      _tempFramebuffers = [null, null];
    };
    const _getTempFramebuffer = function(index) {
      _tempFramebuffers[index] = _tempFramebuffers[index] || _createFramebufferTexture(_width, _height);
      return _tempFramebuffers[index];
    };
    const _createFramebufferTexture = function(width, height) {
      const fbo = gl.createFramebuffer();
      gl.bindFramebuffer(gl.FRAMEBUFFER, fbo);
      const renderbuffer = gl.createRenderbuffer();
      gl.bindRenderbuffer(gl.RENDERBUFFER, renderbuffer);
      const texture = gl.createTexture();
      gl.bindTexture(gl.TEXTURE_2D, texture);
      gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, width, height, 0, gl.RGBA, gl.UNSIGNED_BYTE, null);
      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
      gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, texture, 0);
      gl.bindTexture(gl.TEXTURE_2D, null);
      gl.bindFramebuffer(gl.FRAMEBUFFER, null);
      return {fbo, texture};
    };
    const _draw = function(flags) {
      let source = null;
      let target = null;
      let flipY = false;
      if (_drawCount === 0) {
        source = _sourceTexture;
      } else {
        source = _getTempFramebuffer(_currentFramebufferIndex).texture;
      }
      _drawCount++;
      if (_lastInChain && !(flags & DRAW.INTERMEDIATE)) {
        target = null;
        flipY = _drawCount % 2 === 0;
      } else {
        _currentFramebufferIndex = (_currentFramebufferIndex + 1) % 2;
        target = _getTempFramebuffer(_currentFramebufferIndex).fbo;
      }
      gl.bindTexture(gl.TEXTURE_2D, source);
      gl.bindFramebuffer(gl.FRAMEBUFFER, target);
      gl.uniform1f(_currentProgram.uniform.flipY, flipY ? -1 : 1);
      gl.drawArrays(gl.TRIANGLES, 0, 6);
    };
    const _compileShader = function(fragmentSource) {
      if (_shaderProgramCache[fragmentSource]) {
        _currentProgram = _shaderProgramCache[fragmentSource];
        gl.useProgram(_currentProgram.id);
        return _currentProgram;
      }
      _currentProgram = new WebGLProgram(gl, SHADER.VERTEX_IDENTITY, fragmentSource);
      const floatSize = Float32Array.BYTES_PER_ELEMENT;
      const vertSize = 4 * floatSize;
      gl.enableVertexAttribArray(_currentProgram.attribute.pos);
      gl.vertexAttribPointer(_currentProgram.attribute.pos, 2, gl.FLOAT, false, vertSize, 0 * floatSize);
      gl.enableVertexAttribArray(_currentProgram.attribute.uv);
      gl.vertexAttribPointer(_currentProgram.attribute.uv, 2, gl.FLOAT, false, vertSize, 2 * floatSize);
      _shaderProgramCache[fragmentSource] = _currentProgram;
      return _currentProgram;
    };
    let DRAW = {INTERMEDIATE: 1};
    let SHADER = {};
    SHADER.VERTEX_IDENTITY = [
      "precision highp float;",
      "attribute vec2 pos;",
      "attribute vec2 uv;",
      "varying vec2 vUv;",
      "uniform float flipY;",
      "void main(void) {",
      "vUv = uv;",
      "gl_Position = vec4(pos.x, pos.y*flipY, 0.0, 1.);",
      "}"
    ].join("\n");
    SHADER.FRAGMENT_IDENTITY = [
      "precision highp float;",
      "varying vec2 vUv;",
      "uniform sampler2D texture;",
      "void main(void) {",
      "gl_FragColor = texture2D(texture, vUv);",
      "}"
    ].join("\n");
    let _filter = {};
    _filter.colorMatrix = function(matrix) {
      const m = new Float32Array(matrix);
      m[4] /= 255;
      m[9] /= 255;
      m[14] /= 255;
      m[19] /= 255;
      const shader = m[18] === 1 && m[3] === 0 && m[8] === 0 && m[13] === 0 && m[15] === 0 && m[16] === 0 && m[17] === 0 && m[19] === 0 ? _filter.colorMatrix.SHADER.WITHOUT_ALPHA : _filter.colorMatrix.SHADER.WITH_ALPHA;
      const program = _compileShader(shader);
      gl.uniform1fv(program.uniform.m, m);
      _draw();
    };
    _filter.colorMatrix.SHADER = {};
    _filter.colorMatrix.SHADER.WITH_ALPHA = [
      "precision highp float;",
      "varying vec2 vUv;",
      "uniform sampler2D texture;",
      "uniform float m[20];",
      "void main(void) {",
      "vec4 c = texture2D(texture, vUv);",
      "gl_FragColor.r = m[0] * c.r + m[1] * c.g + m[2] * c.b + m[3] * c.a + m[4];",
      "gl_FragColor.g = m[5] * c.r + m[6] * c.g + m[7] * c.b + m[8] * c.a + m[9];",
      "gl_FragColor.b = m[10] * c.r + m[11] * c.g + m[12] * c.b + m[13] * c.a + m[14];",
      "gl_FragColor.a = m[15] * c.r + m[16] * c.g + m[17] * c.b + m[18] * c.a + m[19];",
      "}"
    ].join("\n");
    _filter.colorMatrix.SHADER.WITHOUT_ALPHA = [
      "precision highp float;",
      "varying vec2 vUv;",
      "uniform sampler2D texture;",
      "uniform float m[20];",
      "void main(void) {",
      "vec4 c = texture2D(texture, vUv);",
      "gl_FragColor.r = m[0] * c.r + m[1] * c.g + m[2] * c.b + m[4];",
      "gl_FragColor.g = m[5] * c.r + m[6] * c.g + m[7] * c.b + m[9];",
      "gl_FragColor.b = m[10] * c.r + m[11] * c.g + m[12] * c.b + m[14];",
      "gl_FragColor.a = c.a;",
      "}"
    ].join("\n");
    _filter.brightness = function(brightness) {
      const b = (brightness || 0) + 1;
      _filter.colorMatrix([
        b,
        0,
        0,
        0,
        0,
        0,
        b,
        0,
        0,
        0,
        0,
        0,
        b,
        0,
        0,
        0,
        0,
        0,
        1,
        0
      ]);
    };
    _filter.saturation = function(amount) {
      const x = (amount || 0) * 2 / 3 + 1;
      const y = (x - 1) * -0.5;
      _filter.colorMatrix([
        x,
        y,
        y,
        0,
        0,
        y,
        x,
        y,
        0,
        0,
        y,
        y,
        x,
        0,
        0,
        0,
        0,
        0,
        1,
        0
      ]);
    };
    _filter.desaturate = function() {
      _filter.saturation(-1);
    };
    _filter.contrast = function(amount) {
      const v = (amount || 0) + 1;
      const o = -128 * (v - 1);
      _filter.colorMatrix([
        v,
        0,
        0,
        0,
        o,
        0,
        v,
        0,
        0,
        o,
        0,
        0,
        v,
        0,
        o,
        0,
        0,
        0,
        1,
        0
      ]);
    };
    _filter.negative = function() {
      _filter.contrast(-2);
    };
    _filter.hue = function(rotation) {
      rotation = (rotation || 0) / 180 * Math.PI;
      const cos = Math.cos(rotation);
      const sin = Math.sin(rotation);
      const lumR = 0.213;
      const lumG = 0.715;
      const lumB = 0.072;
      _filter.colorMatrix([
        lumR + cos * (1 - lumR) + sin * -lumR,
        lumG + cos * -lumG + sin * -lumG,
        lumB + cos * -lumB + sin * (1 - lumB),
        0,
        0,
        lumR + cos * -lumR + sin * 0.143,
        lumG + cos * (1 - lumG) + sin * 0.14,
        lumB + cos * -lumB + sin * -0.283,
        0,
        0,
        lumR + cos * -lumR + sin * -(1 - lumR),
        lumG + cos * -lumG + sin * lumG,
        lumB + cos * (1 - lumB) + sin * lumB,
        0,
        0,
        0,
        0,
        0,
        1,
        0
      ]);
    };
    _filter.desaturateLuminance = function() {
      _filter.colorMatrix([
        0.2764723,
        0.929708,
        0.0938197,
        0,
        -37.1,
        0.2764723,
        0.929708,
        0.0938197,
        0,
        -37.1,
        0.2764723,
        0.929708,
        0.0938197,
        0,
        -37.1,
        0,
        0,
        0,
        1,
        0
      ]);
    };
    _filter.sepia = function() {
      _filter.colorMatrix([
        0.393,
        0.7689999,
        0.18899999,
        0,
        0,
        0.349,
        0.6859999,
        0.16799999,
        0,
        0,
        0.272,
        0.5339999,
        0.13099999,
        0,
        0,
        0,
        0,
        0,
        1,
        0
      ]);
    };
    _filter.brownie = function() {
      _filter.colorMatrix([
        0.5997023498159715,
        0.34553243048391263,
        -0.2708298674538042,
        0,
        47.43192855600873,
        -0.037703249837783157,
        0.8609577587992641,
        0.15059552388459913,
        0,
        -36.96841498319127,
        0.24113635128153335,
        -0.07441037908422492,
        0.44972182064877153,
        0,
        -7.562075277591283,
        0,
        0,
        0,
        1,
        0
      ]);
    };
    _filter.vintagePinhole = function() {
      _filter.colorMatrix([
        0.6279345635605994,
        0.3202183420819367,
        -0.03965408211312453,
        0,
        9.651285835294123,
        0.02578397704808868,
        0.6441188644374771,
        0.03259127616149294,
        0,
        7.462829176470591,
        0.0466055556782719,
        -0.0851232987247891,
        0.5241648018700465,
        0,
        5.159190588235296,
        0,
        0,
        0,
        1,
        0
      ]);
    };
    _filter.kodachrome = function() {
      _filter.colorMatrix([
        1.1285582396593525,
        -0.3967382283601348,
        -0.03992559172921793,
        0,
        63.72958762196502,
        -0.16404339962244616,
        1.0835251566291304,
        -0.05498805115633132,
        0,
        24.732407896706203,
        -0.16786010706155763,
        -0.5603416277695248,
        1.6014850761964943,
        0,
        35.62982807460946,
        0,
        0,
        0,
        1,
        0
      ]);
    };
    _filter.technicolor = function() {
      _filter.colorMatrix([
        1.9125277891456083,
        -0.8545344976951645,
        -0.09155508482755585,
        0,
        11.793603434377337,
        -0.3087833385928097,
        1.7658908555458428,
        -0.10601743074722245,
        0,
        -70.35205161461398,
        -0.231103377548616,
        -0.7501899197440212,
        1.847597816108189,
        0,
        30.950940869491138,
        0,
        0,
        0,
        1,
        0
      ]);
    };
    _filter.polaroid = function() {
      _filter.colorMatrix([
        1.438,
        -0.062,
        -0.062,
        0,
        0,
        -0.122,
        1.378,
        -0.122,
        0,
        0,
        -0.016,
        -0.016,
        1.483,
        0,
        0,
        0,
        0,
        0,
        1,
        0
      ]);
    };
    _filter.shiftToBGR = function() {
      _filter.colorMatrix([
        0,
        0,
        1,
        0,
        0,
        0,
        1,
        0,
        0,
        0,
        1,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        1,
        0
      ]);
    };
    _filter.convolution = function(matrix) {
      const m = new Float32Array(matrix);
      const pixelSizeX = 1 / _width;
      const pixelSizeY = 1 / _height;
      const program = _compileShader(_filter.convolution.SHADER);
      gl.uniform1fv(program.uniform.m, m);
      gl.uniform2f(program.uniform.px, pixelSizeX, pixelSizeY);
      _draw();
    };
    _filter.convolution.SHADER = [
      "precision highp float;",
      "varying vec2 vUv;",
      "uniform sampler2D texture;",
      "uniform vec2 px;",
      "uniform float m[9];",
      "void main(void) {",
      "vec4 c11 = texture2D(texture, vUv - px);",
      "vec4 c12 = texture2D(texture, vec2(vUv.x, vUv.y - px.y));",
      "vec4 c13 = texture2D(texture, vec2(vUv.x + px.x, vUv.y - px.y));",
      "vec4 c21 = texture2D(texture, vec2(vUv.x - px.x, vUv.y) );",
      "vec4 c22 = texture2D(texture, vUv);",
      "vec4 c23 = texture2D(texture, vec2(vUv.x + px.x, vUv.y) );",
      "vec4 c31 = texture2D(texture, vec2(vUv.x - px.x, vUv.y + px.y) );",
      "vec4 c32 = texture2D(texture, vec2(vUv.x, vUv.y + px.y) );",
      "vec4 c33 = texture2D(texture, vUv + px );",
      "gl_FragColor = ",
      "c11 * m[0] + c12 * m[1] + c22 * m[2] +",
      "c21 * m[3] + c22 * m[4] + c23 * m[5] +",
      "c31 * m[6] + c32 * m[7] + c33 * m[8];",
      "gl_FragColor.a = c22.a;",
      "}"
    ].join("\n");
    _filter.detectEdges = function() {
      _filter.convolution.call(this, [
        0,
        1,
        0,
        1,
        -4,
        1,
        0,
        1,
        0
      ]);
    };
    _filter.sobelX = function() {
      _filter.convolution.call(this, [
        -1,
        0,
        1,
        -2,
        0,
        2,
        -1,
        0,
        1
      ]);
    };
    _filter.sobelY = function() {
      _filter.convolution.call(this, [
        -1,
        -2,
        -1,
        0,
        0,
        0,
        1,
        2,
        1
      ]);
    };
    _filter.sharpen = function(amount) {
      const a = amount || 1;
      _filter.convolution.call(this, [
        0,
        -1 * a,
        0,
        -1 * a,
        1 + 4 * a,
        -1 * a,
        0,
        -1 * a,
        0
      ]);
    };
    _filter.emboss = function(size) {
      const s = size || 1;
      _filter.convolution.call(this, [
        -2 * s,
        -1 * s,
        0,
        -1 * s,
        1,
        1 * s,
        0,
        1 * s,
        2 * s
      ]);
    };
    _filter.blur = function(size) {
      const blurSizeX = size / 7 / _width;
      const blurSizeY = size / 7 / _height;
      const program = _compileShader(_filter.blur.SHADER);
      gl.uniform2f(program.uniform.px, 0, blurSizeY);
      _draw(DRAW.INTERMEDIATE);
      gl.uniform2f(program.uniform.px, blurSizeX, 0);
      _draw();
    };
    _filter.blur.SHADER = [
      "precision highp float;",
      "varying vec2 vUv;",
      "uniform sampler2D texture;",
      "uniform vec2 px;",
      "void main(void) {",
      "gl_FragColor = vec4(0.0);",
      "gl_FragColor += texture2D(texture, vUv + vec2(-7.0*px.x, -7.0*px.y))*0.0044299121055113265;",
      "gl_FragColor += texture2D(texture, vUv + vec2(-6.0*px.x, -6.0*px.y))*0.00895781211794;",
      "gl_FragColor += texture2D(texture, vUv + vec2(-5.0*px.x, -5.0*px.y))*0.0215963866053;",
      "gl_FragColor += texture2D(texture, vUv + vec2(-4.0*px.x, -4.0*px.y))*0.0443683338718;",
      "gl_FragColor += texture2D(texture, vUv + vec2(-3.0*px.x, -3.0*px.y))*0.0776744219933;",
      "gl_FragColor += texture2D(texture, vUv + vec2(-2.0*px.x, -2.0*px.y))*0.115876621105;",
      "gl_FragColor += texture2D(texture, vUv + vec2(-1.0*px.x, -1.0*px.y))*0.147308056121;",
      "gl_FragColor += texture2D(texture, vUv                             )*0.159576912161;",
      "gl_FragColor += texture2D(texture, vUv + vec2( 1.0*px.x,  1.0*px.y))*0.147308056121;",
      "gl_FragColor += texture2D(texture, vUv + vec2( 2.0*px.x,  2.0*px.y))*0.115876621105;",
      "gl_FragColor += texture2D(texture, vUv + vec2( 3.0*px.x,  3.0*px.y))*0.0776744219933;",
      "gl_FragColor += texture2D(texture, vUv + vec2( 4.0*px.x,  4.0*px.y))*0.0443683338718;",
      "gl_FragColor += texture2D(texture, vUv + vec2( 5.0*px.x,  5.0*px.y))*0.0215963866053;",
      "gl_FragColor += texture2D(texture, vUv + vec2( 6.0*px.x,  6.0*px.y))*0.00895781211794;",
      "gl_FragColor += texture2D(texture, vUv + vec2( 7.0*px.x,  7.0*px.y))*0.0044299121055113265;",
      "}"
    ].join("\n");
    _filter.pixelate = function(size) {
      const blurSizeX = size / _width;
      const blurSizeY = size / _height;
      const program = _compileShader(_filter.pixelate.SHADER);
      gl.uniform2f(program.uniform.size, blurSizeX, blurSizeY);
      _draw();
    };
    _filter.pixelate.SHADER = [
      "precision highp float;",
      "varying vec2 vUv;",
      "uniform vec2 size;",
      "uniform sampler2D texture;",
      "vec2 pixelate(vec2 coord, vec2 size) {",
      "return floor( coord / size ) * size;",
      "}",
      "void main(void) {",
      "gl_FragColor = vec4(0.0);",
      "vec2 coord = pixelate(vUv, size);",
      "gl_FragColor += texture2D(texture, coord);",
      "}"
    ].join("\n");
  };
  exports.Canvas = WebGLImageFilter;
});
var require_image = __commonJS((exports) => {
  const fxImage = __toModule(require_imagefx());
  let inCanvas = null;
  let outCanvas = null;
  function process3(input, config2) {
    let tensor6;
    if (input instanceof tf.Tensor) {
      tensor6 = tf.clone(input);
    } else {
      const originalWidth = input.naturalWidth || input.videoWidth || input.width || input.shape && input.shape[1] > 0;
      const originalHeight = input.naturalHeight || input.videoHeight || input.height || input.shape && input.shape[2] > 0;
      let targetWidth = originalWidth;
      let targetHeight = originalHeight;
      if (config2.filter.width > 0)
        targetWidth = config2.filter.width;
      else if (config2.filter.height > 0)
        targetWidth = originalWidth * (config2.filter.height / originalHeight);
      if (config2.filter.height > 0)
        targetHeight = config2.filter.height;
      else if (config2.filter.width > 0)
        targetHeight = originalHeight * (config2.filter.width / originalWidth);
      if (!inCanvas || inCanvas.width !== targetWidth || inCanvas.height !== targetHeight) {
        inCanvas = typeof OffscreenCanvas !== "undefined" ? new OffscreenCanvas(targetWidth, targetHeight) : document.createElement("canvas");
        if (inCanvas.width !== targetWidth)
          inCanvas.width = targetWidth;
        if (inCanvas.height !== targetHeight)
          inCanvas.height = targetHeight;
      }
      const ctx = inCanvas.getContext("2d");
      if (input instanceof ImageData)
        ctx.putImageData(input, 0, 0);
      else
        ctx.drawImage(input, 0, 0, originalWidth, originalHeight, 0, 0, inCanvas.width, inCanvas.height);
      if (config2.filter.enabled) {
        if (!this.fx || !outCanvas || inCanvas.width !== outCanvas.width || inCanvas.height !== outCanvas.height) {
          outCanvas = typeof OffscreenCanvas !== "undefined" ? new OffscreenCanvas(inCanvas.width, inCanvas.height) : document.createElement("canvas");
          if (outCanvas.width !== inCanvas.width)
            outCanvas.width = inCanvas.width;
          if (outCanvas.height !== inCanvas.height)
            outCanvas.height = inCanvas.height;
          this.fx = tf.ENV.flags.IS_BROWSER ? new fxImage.Canvas({canvas: outCanvas}) : null;
        }
        this.fx.reset();
        this.fx.addFilter("brightness", config2.filter.brightness);
        if (config2.filter.contrast !== 0)
          this.fx.addFilter("contrast", config2.filter.contrast);
        if (config2.filter.sharpness !== 0)
          this.fx.addFilter("sharpen", config2.filter.sharpness);
        if (config2.filter.blur !== 0)
          this.fx.addFilter("blur", config2.filter.blur);
        if (config2.filter.saturation !== 0)
          this.fx.addFilter("saturation", config2.filter.saturation);
        if (config2.filter.hue !== 0)
          this.fx.addFilter("hue", config2.filter.hue);
        if (config2.filter.negative)
          this.fx.addFilter("negative");
        if (config2.filter.sepia)
          this.fx.addFilter("sepia");
        if (config2.filter.vintage)
          this.fx.addFilter("brownie");
        if (config2.filter.sepia)
          this.fx.addFilter("sepia");
        if (config2.filter.kodachrome)
          this.fx.addFilter("kodachrome");
        if (config2.filter.technicolor)
          this.fx.addFilter("technicolor");
        if (config2.filter.polaroid)
          this.fx.addFilter("polaroid");
        if (config2.filter.pixelate !== 0)
          this.fx.addFilter("pixelate", config2.filter.pixelate);
        this.fx.apply(inCanvas);
        const gl = false;
        if (gl) {
          const glBuffer = new Uint8Array(outCanvas.width * outCanvas.height * 4);
          const pixBuffer = new Uint8Array(outCanvas.width * outCanvas.height * 3);
          gl.readPixels(0, 0, outCanvas.width, outCanvas.height, gl.RGBA, gl.UNSIGNED_BYTE, glBuffer);
          let i = 0;
          for (let y = outCanvas.height - 1; y >= 0; y--) {
            for (let x = 0; x < outCanvas.width; x++) {
              const index = (x + y * outCanvas.width) * 4;
              pixBuffer[i++] = glBuffer[index + 0];
              pixBuffer[i++] = glBuffer[index + 1];
              pixBuffer[i++] = glBuffer[index + 2];
            }
          }
          outCanvas.data = pixBuffer;
        }
      } else {
        outCanvas = inCanvas;
      }
      let pixels;
      if (outCanvas.data) {
        const shape = [outCanvas.height, outCanvas.width, 3];
        pixels = tf.tensor3d(outCanvas.data, shape, "int32");
      } else if (config2.backend === "webgl" || outCanvas instanceof ImageData) {
        pixels = tf.browser.fromPixels(outCanvas);
      } else {
        const tempCanvas = typeof OffscreenCanvas !== "undefined" ? new OffscreenCanvas(targetWidth, targetHeight) : document.createElement("canvas");
        tempCanvas.width = targetWidth;
        tempCanvas.height = targetHeight;
        const tempCtx = tempCanvas.getContext("2d");
        tempCtx.drawImage(outCanvas, 0, 0);
        const data2 = tempCtx.getImageData(0, 0, targetWidth, targetHeight);
        pixels = tf.browser.fromPixels(data2);
      }
      const casted = pixels.toFloat();
      tensor6 = casted.expandDims(0);
      pixels.dispose();
      casted.dispose();
    }
    return {tensor: tensor6, canvas: config2.filter.return ? outCanvas : null};
  }
  exports.process = process3;
});
const tf = __toModule(require_tf_es2017());
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const EPSILON_FLOAT32 = 1e-7;
const EPSILON_FLOAT16 = 1e-4;
class DataStorage {
  constructor(backend2, dataMover) {
    this.backend = backend2;
    this.dataMover = dataMover;
    this.data = new WeakMap();
    this.dataIdsCount = 0;
  }
  get(dataId) {
    if (!this.data.has(dataId)) {
      this.dataMover.moveData(this.backend, dataId);
    }
    return this.data.get(dataId);
  }
  set(dataId, value) {
    this.dataIdsCount++;
    this.data.set(dataId, value);
  }
  has(dataId) {
    return this.data.has(dataId);
  }
  delete(dataId) {
    this.dataIdsCount--;
    return this.data.delete(dataId);
  }
  numDataIds() {
    return this.dataIdsCount;
  }
}
class KernelBackend {
  time(f) {
    return notYetImplemented("time");
  }
  read(dataId) {
    return notYetImplemented("read");
  }
  readSync(dataId) {
    return notYetImplemented("readSync");
  }
  numDataIds() {
    return notYetImplemented("numDataIds");
  }
  disposeData(dataId) {
    return notYetImplemented("disposeData");
  }
  write(values, shape, dtype) {
    return notYetImplemented("write");
  }
  move(dataId, values, shape, dtype) {
    return notYetImplemented("move");
  }
  memory() {
    return notYetImplemented("memory");
  }
  floatPrecision() {
    return notYetImplemented("floatPrecision");
  }
  epsilon() {
    return this.floatPrecision() === 32 ? EPSILON_FLOAT32 : EPSILON_FLOAT16;
  }
  batchMatMul(a, b, transposeA, transposeB) {
    return notYetImplemented("batchMatMul");
  }
  fusedBatchMatMul({a, b, transposeA, transposeB, bias, activation, preluActivationWeights}) {
    return notYetImplemented("fusedBatchMatMul");
  }
  slice(x, begin, size) {
    return notYetImplemented("slice");
  }
  stridedSlice(x, begin, end, strides) {
    return notYetImplemented("stridedSlice");
  }
  unstack(x, axis) {
    return notYetImplemented("unstack");
  }
  reverse(a, axis) {
    return notYetImplemented("reverse");
  }
  concat(tensors, axis) {
    return notYetImplemented("concat");
  }
  neg(a) {
    return notYetImplemented("neg");
  }
  add(a, b) {
    return notYetImplemented("add");
  }
  addN(tensors) {
    return notYetImplemented("addN");
  }
  subtract(a, b) {
    return notYetImplemented("subtract");
  }
  multiply(a, b) {
    return notYetImplemented("multiply");
  }
  realDivide(a, b) {
    return notYetImplemented("realDivide");
  }
  floorDiv(a, b) {
    return notYetImplemented("floorDiv");
  }
  sum(x, axes) {
    return notYetImplemented("sum");
  }
  prod(x, axes) {
    return notYetImplemented("prod");
  }
  unsortedSegmentSum(x, segmentIds, numSegments) {
    return notYetImplemented("unsortedSegmentSum");
  }
  argMin(x, axis) {
    return notYetImplemented("argMin");
  }
  argMax(x, axis) {
    return notYetImplemented("argMax");
  }
  equal(a, b) {
    return notYetImplemented("equal");
  }
  notEqual(a, b) {
    return notYetImplemented("notEqual");
  }
  less(a, b) {
    return notYetImplemented("less");
  }
  lessEqual(a, b) {
    return notYetImplemented("lessEqual");
  }
  greater(a, b) {
    return notYetImplemented("greater");
  }
  greaterEqual(a, b) {
    return notYetImplemented("greaterEqual");
  }
  logicalNot(a) {
    return notYetImplemented("logicalNot");
  }
  logicalAnd(a, b) {
    return notYetImplemented("logicalAnd");
  }
  logicalOr(a, b) {
    return notYetImplemented("logicalOr");
  }
  where(condition) {
    return notYetImplemented("where");
  }
  select(condition, a, b) {
    return notYetImplemented("select");
  }
  topk(x, k, sorted) {
    return notYetImplemented("topk");
  }
  min(x, axes) {
    return notYetImplemented("min");
  }
  minimum(a, b) {
    return notYetImplemented("minimum");
  }
  mod(a, b) {
    return notYetImplemented("mod");
  }
  max(x, axes) {
    return notYetImplemented("max");
  }
  maximum(a, b) {
    return notYetImplemented("maximum");
  }
  all(x, axes) {
    return notYetImplemented("all");
  }
  any(x, axes) {
    return notYetImplemented("any");
  }
  squaredDifference(a, b) {
    return notYetImplemented("squaredDifference");
  }
  ceil(x) {
    return notYetImplemented("ceil");
  }
  floor(x) {
    return notYetImplemented("floor");
  }
  round(x) {
    return notYetImplemented("round");
  }
  sign(x) {
    return notYetImplemented("sign");
  }
  isNaN(x) {
    return notYetImplemented("isNaN");
  }
  isInf(x) {
    return notYetImplemented("isInf");
  }
  isFinite(x) {
    return notYetImplemented("isFinite");
  }
  pow(a, b) {
    return notYetImplemented("pow");
  }
  exp(x) {
    return notYetImplemented("exp");
  }
  expm1(x) {
    return notYetImplemented("expm1");
  }
  softmax(x, dim) {
    return notYetImplemented("softmax");
  }
  log(x) {
    return notYetImplemented("log");
  }
  log1p(x) {
    return notYetImplemented("log1p");
  }
  sqrt(x) {
    return notYetImplemented("sqrt");
  }
  rsqrt(x) {
    return notYetImplemented("rsqrt");
  }
  square(x) {
    return notYetImplemented("square");
  }
  reciprocal(x) {
    return notYetImplemented("reciprocal");
  }
  relu(x) {
    return notYetImplemented("relu");
  }
  relu6(x) {
    return notYetImplemented("relu6");
  }
  prelu(x, a) {
    return notYetImplemented("prelu");
  }
  elu(x) {
    return notYetImplemented("elu");
  }
  eluDer(dy, y) {
    return notYetImplemented("eluDer");
  }
  selu(x) {
    return notYetImplemented("selu");
  }
  int(x) {
    return notYetImplemented("int");
  }
  clip(x, min2, max2) {
    return notYetImplemented("clip");
  }
  abs(x) {
    return notYetImplemented("abs");
  }
  complexAbs(x) {
    return notYetImplemented("complexAbs");
  }
  sigmoid(x) {
    return notYetImplemented("sigmoid");
  }
  softplus(x) {
    return notYetImplemented("softplus");
  }
  sin(x) {
    return notYetImplemented("sin");
  }
  cos(x) {
    return notYetImplemented("cos");
  }
  tan(x) {
    return notYetImplemented("tan");
  }
  asin(x) {
    return notYetImplemented("asin");
  }
  acos(x) {
    return notYetImplemented("acos");
  }
  atan(x) {
    return notYetImplemented("atan");
  }
  atan2(a, b) {
    return notYetImplemented("atan2");
  }
  sinh(x) {
    return notYetImplemented("sinh");
  }
  cosh(x) {
    return notYetImplemented("cosh");
  }
  tanh(x) {
    return notYetImplemented("tanh");
  }
  asinh(x) {
    return notYetImplemented("asinh");
  }
  acosh(x) {
    return notYetImplemented("acosh");
  }
  atanh(x) {
    return notYetImplemented("atanh");
  }
  erf(x) {
    return notYetImplemented("erf");
  }
  step(x, alpha) {
    return notYetImplemented("step");
  }
  fusedConv2d({input, filter, convInfo, bias, activation, preluActivationWeights}) {
    return notYetImplemented("fusedConv2d");
  }
  conv2d(x, filter, convInfo) {
    return notYetImplemented("conv2d");
  }
  conv2dDerInput(dy, filter, convInfo) {
    return notYetImplemented("conv2dDerInput");
  }
  conv2dDerFilter(x, dY, convInfo) {
    return notYetImplemented("conv2dDerFilter");
  }
  fusedDepthwiseConv2D({input, filter, convInfo, bias, activation, preluActivationWeights}) {
    return notYetImplemented("fusedDepthwiseConv2D");
  }
  depthwiseConv2D(input, filter, convInfo) {
    return notYetImplemented("depthwiseConv2D");
  }
  depthwiseConv2DDerInput(dy, filter, convInfo) {
    return notYetImplemented("depthwiseConv2DDerInput");
  }
  depthwiseConv2DDerFilter(x, dY, convInfo) {
    return notYetImplemented("depthwiseConv2DDerFilter");
  }
  conv3d(x, filter, convInfo) {
    return notYetImplemented("conv3d");
  }
  conv3dDerInput(dy, filter, convInfo) {
    return notYetImplemented("conv3dDerInput");
  }
  conv3dDerFilter(x, dY, convInfo) {
    return notYetImplemented("conv3dDerFilter");
  }
  maxPool(x, convInfo) {
    return notYetImplemented("maxPool");
  }
  maxPoolBackprop(dy, x, y, convInfo) {
    return notYetImplemented("maxPoolBackprop");
  }
  avgPool(x, convInfo) {
    return notYetImplemented("avgPool");
  }
  avgPoolBackprop(dy, x, convInfo) {
    return notYetImplemented("avgPoolBackprop");
  }
  avgPool3d(x, convInfo) {
    return notYetImplemented("avgPool3d");
  }
  avgPool3dBackprop(dy, x, convInfo) {
    return notYetImplemented("avgPool3dBackprop");
  }
  maxPool3d(x, convInfo) {
    return notYetImplemented("maxPool3d");
  }
  maxPool3dBackprop(dy, x, y, convInfo) {
    return notYetImplemented("maxPool3dBackprop");
  }
  reshape(x, shape) {
    return notYetImplemented("reshape");
  }
  cast(x, dtype) {
    return notYetImplemented("cast");
  }
  tile(x, reps) {
    return notYetImplemented("tile");
  }
  pad(x, paddings, constantValue) {
    return notYetImplemented("pad");
  }
  transpose(x, perm) {
    return notYetImplemented("transpose");
  }
  gather(x, indices, axis) {
    return notYetImplemented("gather");
  }
  gatherND(x, indices) {
    return notYetImplemented("gatherND");
  }
  scatterND(indices, updates, shape) {
    return notYetImplemented("scatterND");
  }
  batchToSpaceND(x, blockShape, crops) {
    return notYetImplemented("batchToSpaceND");
  }
  spaceToBatchND(x, blockShape, paddings) {
    return notYetImplemented("spaceToBatchND");
  }
  resizeBilinear(x, newHeight, newWidth, alignCorners) {
    return notYetImplemented("resizeBilinear");
  }
  resizeBilinearBackprop(dy, x, alignCorners) {
    return notYetImplemented("resizeBilinearBackprop");
  }
  resizeNearestNeighbor(x, newHEight, newWidth, alignCorners) {
    return notYetImplemented("resizeNearestNeighbor");
  }
  resizeNearestNeighborBackprop(dy, x, alignCorners) {
    return notYetImplemented("resizeNearestNeighborBackprop");
  }
  batchNorm(x, mean, variance, offset, scale, varianceEpsilon) {
    return notYetImplemented("batchNorm");
  }
  localResponseNormalization4D(x, radius, bias, alpha, beta) {
    return notYetImplemented("localResponseNormalization4D");
  }
  LRNGrad(dy, inputImage, outputImage, radius, bias, alpha, beta) {
    return notYetImplemented("LRNGrad");
  }
  multinomial(logits, normalized, numSamples, seed) {
    return notYetImplemented("multinomial");
  }
  oneHot(indices, depth, onValue, offValue) {
    return notYetImplemented("oneHot");
  }
  cumsum(x, axis, exclusive, reverse2) {
    return notYetImplemented("cumsum");
  }
  nonMaxSuppression(boxes, scores, maxOutputSize, iouThreshold, scoreThreshold) {
    return notYetImplemented("nonMaxSuppression");
  }
  fft(x) {
    return notYetImplemented("fft");
  }
  ifft(x) {
    return notYetImplemented("ifft");
  }
  complex(real, imag) {
    return notYetImplemented("complex");
  }
  real(input) {
    return notYetImplemented("real");
  }
  imag(input) {
    return notYetImplemented("imag");
  }
  cropAndResize(image2, boxes, boxIndex, cropSize, method, extrapolationValue) {
    return notYetImplemented("cropAndResize");
  }
  depthToSpace(x, blockSize, dataFormat) {
    return notYetImplemented("depthToSpace");
  }
  split(value, sizeSplits, axis) {
    return notYetImplemented("split");
  }
  sparseToDense(sparseIndices, sparseValues, outputShape, defaultValue) {
    return notYetImplemented("sparseToDense");
  }
  diag(x) {
    return notYetImplemented("diag");
  }
  fill(shape, value, dtype) {
    return notYetImplemented("fill");
  }
  onesLike(x) {
    return notYetImplemented("onesLike");
  }
  zerosLike(x) {
    return notYetImplemented("zerosLike");
  }
  linspace(start, stop, num) {
    return notYetImplemented("linspace");
  }
  dispose() {
    return notYetImplemented("dispose");
  }
}
function notYetImplemented(kernelName) {
  throw new Error(`'${kernelName}' not yet implemented or not found in the registry. This kernel may not be supported by the tfjs backend you have chosen`);
}
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function shuffle(array) {
  let counter = array.length;
  let temp = 0;
  let index = 0;
  while (counter > 0) {
    index = Math.random() * counter | 0;
    counter--;
    temp = array[counter];
    array[counter] = array[index];
    array[index] = temp;
  }
}
function clamp(min2, x, max2) {
  return Math.max(min2, Math.min(x, max2));
}
function nearestLargerEven(val) {
  return val % 2 === 0 ? val : val + 1;
}
function sum(arr) {
  let sum5 = 0;
  for (let i = 0; i < arr.length; i++) {
    sum5 += arr[i];
  }
  return sum5;
}
function randUniform(a, b) {
  const r = Math.random();
  return b * r + (1 - r) * a;
}
function distSquared(a, b) {
  let result = 0;
  for (let i = 0; i < a.length; i++) {
    const diff = Number(a[i]) - Number(b[i]);
    result += diff * diff;
  }
  return result;
}
function assert(expr, msg) {
  if (!expr) {
    throw new Error(typeof msg === "string" ? msg : msg());
  }
}
function assertShapesMatch(shapeA, shapeB, errorMessagePrefix = "") {
  assert(arraysEqual(shapeA, shapeB), () => errorMessagePrefix + ` Shapes ${shapeA} and ${shapeB} must match`);
}
function assertNonNull(a) {
  assert(a != null, () => `The input to the tensor constructor must be a non-null value.`);
}
function flatten(arr, result = [], skipTypedArray = false) {
  if (result == null) {
    result = [];
  }
  if (Array.isArray(arr) || isTypedArray(arr) && !skipTypedArray) {
    for (let i = 0; i < arr.length; ++i) {
      flatten(arr[i], result, skipTypedArray);
    }
  } else {
    result.push(arr);
  }
  return result;
}
function sizeFromShape(shape) {
  if (shape.length === 0) {
    return 1;
  }
  let size = shape[0];
  for (let i = 1; i < shape.length; i++) {
    size *= shape[i];
  }
  return size;
}
function isScalarShape(shape) {
  return shape.length === 0;
}
function arraysEqual(n1, n2) {
  if (n1 === n2) {
    return true;
  }
  if (n1 == null || n2 == null) {
    return false;
  }
  if (n1.length !== n2.length) {
    return false;
  }
  for (let i = 0; i < n1.length; i++) {
    if (n1[i] !== n2[i]) {
      return false;
    }
  }
  return true;
}
function isInt(a) {
  return a % 1 === 0;
}
function tanh(x) {
  if (Math.tanh != null) {
    return Math.tanh(x);
  }
  if (x === Infinity) {
    return 1;
  } else if (x === -Infinity) {
    return -1;
  } else {
    const e2x = Math.exp(2 * x);
    return (e2x - 1) / (e2x + 1);
  }
}
function sizeToSquarishShape(size) {
  const width = Math.ceil(Math.sqrt(size));
  return [width, Math.ceil(size / width)];
}
function createShuffledIndices(n) {
  const shuffledIndices = new Uint32Array(n);
  for (let i = 0; i < n; ++i) {
    shuffledIndices[i] = i;
  }
  shuffle(shuffledIndices);
  return shuffledIndices;
}
function rightPad(a, size) {
  if (size <= a.length) {
    return a;
  }
  return a + " ".repeat(size - a.length);
}
function repeatedTry(checkFn, delayFn = (counter) => 0, maxCounter) {
  return new Promise((resolve, reject) => {
    let tryCount = 0;
    const tryFn = () => {
      if (checkFn()) {
        resolve();
        return;
      }
      tryCount++;
      const nextBackoff = delayFn(tryCount);
      if (maxCounter != null && tryCount >= maxCounter) {
        reject();
        return;
      }
      setTimeout(tryFn, nextBackoff);
    };
    tryFn();
  });
}
function inferFromImplicitShape(shape, size) {
  let shapeProd = 1;
  let implicitIdx = -1;
  for (let i = 0; i < shape.length; ++i) {
    if (shape[i] >= 0) {
      shapeProd *= shape[i];
    } else if (shape[i] === -1) {
      if (implicitIdx !== -1) {
        throw Error(`Shapes can only have 1 implicit size. Found -1 at dim ${implicitIdx} and dim ${i}`);
      }
      implicitIdx = i;
    } else if (shape[i] < 0) {
      throw Error(`Shapes can not be < 0. Found ${shape[i]} at dim ${i}`);
    }
  }
  if (implicitIdx === -1) {
    if (size > 0 && size !== shapeProd) {
      throw Error(`Size(${size}) must match the product of shape ${shape}`);
    }
    return shape;
  }
  if (shapeProd === 0) {
    throw Error(`Cannot infer the missing size in [${shape}] when there are 0 elements`);
  }
  if (size % shapeProd !== 0) {
    throw Error(`The implicit shape can't be a fractional number. Got ${size} / ${shapeProd}`);
  }
  const newShape = shape.slice();
  newShape[implicitIdx] = size / shapeProd;
  return newShape;
}
function parseAxisParam(axis, shape) {
  const rank = shape.length;
  axis = axis == null ? shape.map((s, i) => i) : [].concat(axis);
  assert(axis.every((ax) => ax >= -rank && ax < rank), () => `All values in axis param must be in range [-${rank}, ${rank}) but got axis ${axis}`);
  assert(axis.every((ax) => isInt(ax)), () => `All values in axis param must be integers but got axis ${axis}`);
  return axis.map((a) => a < 0 ? rank + a : a);
}
function squeezeShape(shape, axis) {
  const newShape = [];
  const keptDims = [];
  const isEmptyArray = axis != null && Array.isArray(axis) && axis.length === 0;
  const axes = axis == null || isEmptyArray ? null : parseAxisParam(axis, shape).sort();
  let j = 0;
  for (let i = 0; i < shape.length; ++i) {
    if (axes != null) {
      if (axes[j] === i && shape[i] !== 1) {
        throw new Error(`Can't squeeze axis ${i} since its dim '${shape[i]}' is not 1`);
      }
      if ((axes[j] == null || axes[j] > i) && shape[i] === 1) {
        newShape.push(shape[i]);
        keptDims.push(i);
      }
      if (axes[j] <= i) {
        j++;
      }
    }
    if (shape[i] !== 1) {
      newShape.push(shape[i]);
      keptDims.push(i);
    }
  }
  return {newShape, keptDims};
}
function getTypedArrayFromDType(dtype, size) {
  let values = null;
  if (dtype == null || dtype === "float32") {
    values = new Float32Array(size);
  } else if (dtype === "int32") {
    values = new Int32Array(size);
  } else if (dtype === "bool") {
    values = new Uint8Array(size);
  } else {
    throw new Error(`Unknown data type ${dtype}`);
  }
  return values;
}
function getArrayFromDType(dtype, size) {
  let values = null;
  if (dtype == null || dtype === "float32") {
    values = new Float32Array(size);
  } else if (dtype === "int32") {
    values = new Int32Array(size);
  } else if (dtype === "bool") {
    values = new Uint8Array(size);
  } else if (dtype === "string") {
    values = new Array(size);
  } else {
    throw new Error(`Unknown data type ${dtype}`);
  }
  return values;
}
function checkConversionForErrors(vals, dtype) {
  for (let i = 0; i < vals.length; i++) {
    const num = vals[i];
    if (isNaN(num) || !isFinite(num)) {
      throw Error(`A tensor of type ${dtype} being uploaded contains ${num}.`);
    }
  }
}
function isValidDtype(dtype) {
  return dtype === "bool" || dtype === "complex64" || dtype === "float32" || dtype === "int32" || dtype === "string";
}
function hasEncodingLoss(oldType, newType) {
  if (newType === "complex64") {
    return false;
  }
  if (newType === "float32" && oldType !== "complex64") {
    return false;
  }
  if (newType === "int32" && oldType !== "float32" && oldType !== "complex64") {
    return false;
  }
  if (newType === "bool" && oldType === "bool") {
    return false;
  }
  return true;
}
function isTypedArray(a) {
  return a instanceof Float32Array || a instanceof Int32Array || a instanceof Uint8Array;
}
function bytesPerElement(dtype) {
  if (dtype === "float32" || dtype === "int32") {
    return 4;
  } else if (dtype === "complex64") {
    return 8;
  } else if (dtype === "bool") {
    return 1;
  } else {
    throw new Error(`Unknown dtype ${dtype}`);
  }
}
function bytesFromStringArray(arr) {
  if (arr == null) {
    return 0;
  }
  let bytes = 0;
  arr.forEach((x) => bytes += x.length);
  return bytes;
}
function isString(value) {
  return typeof value === "string" || value instanceof String;
}
function isBoolean(value) {
  return typeof value === "boolean";
}
function isNumber(value) {
  return typeof value === "number";
}
function inferDtype(values) {
  if (Array.isArray(values)) {
    return inferDtype(values[0]);
  }
  if (values instanceof Float32Array) {
    return "float32";
  } else if (values instanceof Int32Array || values instanceof Uint8Array) {
    return "int32";
  } else if (isNumber(values)) {
    return "float32";
  } else if (isString(values)) {
    return "string";
  } else if (isBoolean(values)) {
    return "bool";
  }
  return "float32";
}
function isFunction(f) {
  return !!(f && f.constructor && f.call && f.apply);
}
function nearestDivisor(size, start) {
  for (let i = start; i < size; ++i) {
    if (size % i === 0) {
      return i;
    }
  }
  return size;
}
function computeStrides(shape) {
  const rank = shape.length;
  if (rank < 2) {
    return [];
  }
  const strides = new Array(rank - 1);
  strides[rank - 2] = shape[rank - 1];
  for (let i = rank - 3; i >= 0; --i) {
    strides[i] = strides[i + 1] * shape[i + 1];
  }
  return strides;
}
function createNestedArray(offset, shape, a) {
  const ret = new Array();
  if (shape.length === 1) {
    const d = shape[0];
    for (let i = 0; i < d; i++) {
      ret[i] = a[offset + i];
    }
  } else {
    const d = shape[0];
    const rest = shape.slice(1);
    const len = rest.reduce((acc, c) => acc * c);
    for (let i = 0; i < d; i++) {
      ret[i] = createNestedArray(offset + i * len, rest, a);
    }
  }
  return ret;
}
function toNestedArray(shape, a) {
  if (shape.length === 0) {
    return a[0];
  }
  const size = shape.reduce((acc, c) => acc * c);
  if (size === 0) {
    return [];
  }
  if (size !== a.length) {
    throw new Error(`[${shape}] does not match the input size ${a.length}.`);
  }
  return createNestedArray(0, shape, a);
}
function makeOnesTypedArray(size, dtype) {
  const array = makeZerosTypedArray(size, dtype);
  for (let i = 0; i < array.length; i++) {
    array[i] = 1;
  }
  return array;
}
function makeZerosTypedArray(size, dtype) {
  if (dtype == null || dtype === "float32" || dtype === "complex64") {
    return new Float32Array(size);
  } else if (dtype === "int32") {
    return new Int32Array(size);
  } else if (dtype === "bool") {
    return new Uint8Array(size);
  } else {
    throw new Error(`Unknown data type ${dtype}`);
  }
}
function makeZerosNestedTypedArray(shape, dtype) {
  const size = shape.reduce((prev, curr) => prev * curr, 1);
  if (dtype == null || dtype === "float32") {
    return toNestedArray(shape, new Float32Array(size));
  } else if (dtype === "int32") {
    return toNestedArray(shape, new Int32Array(size));
  } else if (dtype === "bool") {
    return toNestedArray(shape, new Uint8Array(size));
  } else {
    throw new Error(`Unknown data type ${dtype}`);
  }
}
function assertNonNegativeIntegerDimensions(shape) {
  shape.forEach((dimSize) => {
    assert(Number.isInteger(dimSize) && dimSize >= 0, () => `Tensor must have a shape comprised of positive integers but got shape [${shape}].`);
  });
}
function locToIndex(locs, rank, strides) {
  if (rank === 0) {
    return 0;
  } else if (rank === 1) {
    return locs[0];
  }
  let index = locs[locs.length - 1];
  for (let i = 0; i < locs.length - 1; ++i) {
    index += strides[i] * locs[i];
  }
  return index;
}
function indexToLoc(index, rank, strides) {
  if (rank === 0) {
    return [];
  } else if (rank === 1) {
    return [index];
  }
  const locs = new Array(rank);
  for (let i = 0; i < locs.length - 1; ++i) {
    locs[i] = Math.floor(index / strides[i]);
    index -= locs[i] * strides[i];
  }
  locs[locs.length - 1] = index;
  return locs;
}
function isPromise(object) {
  return object && object.then && typeof object.then === "function";
}
/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const TENSORFLOWJS_FLAGS_PREFIX = "tfjsflags";
class Environment {
  constructor(global2) {
    this.global = global2;
    this.flags = {};
    this.flagRegistry = {};
    this.urlFlags = {};
    this.populateURLFlags();
  }
  setPlatform(platformName, platform) {
    if (this.platform != null) {
      console.warn(`Platform ${this.platformName} has already been set. Overwriting the platform with ${platform}.`);
    }
    this.platformName = platformName;
    this.platform = platform;
  }
  registerFlag(flagName, evaluationFn, setHook) {
    this.flagRegistry[flagName] = {evaluationFn, setHook};
    if (this.urlFlags[flagName] != null) {
      const flagValue = this.urlFlags[flagName];
      console.warn(`Setting feature override from URL ${flagName}: ${flagValue}.`);
      this.set(flagName, flagValue);
    }
  }
  async getAsync(flagName) {
    if (flagName in this.flags) {
      return this.flags[flagName];
    }
    this.flags[flagName] = await this.evaluateFlag(flagName);
    return this.flags[flagName];
  }
  get(flagName) {
    if (flagName in this.flags) {
      return this.flags[flagName];
    }
    const flagValue = this.evaluateFlag(flagName);
    if (isPromise(flagValue)) {
      throw new Error(`Flag ${flagName} cannot be synchronously evaluated. Please use getAsync() instead.`);
    }
    this.flags[flagName] = flagValue;
    return this.flags[flagName];
  }
  getNumber(flagName) {
    return this.get(flagName);
  }
  getBool(flagName) {
    return this.get(flagName);
  }
  getFlags() {
    return this.flags;
  }
  get features() {
    return this.flags;
  }
  set(flagName, value) {
    if (this.flagRegistry[flagName] == null) {
      throw new Error(`Cannot set flag ${flagName} as it has not been registered.`);
    }
    this.flags[flagName] = value;
    if (this.flagRegistry[flagName].setHook != null) {
      this.flagRegistry[flagName].setHook(value);
    }
  }
  evaluateFlag(flagName) {
    if (this.flagRegistry[flagName] == null) {
      throw new Error(`Cannot evaluate flag '${flagName}': no evaluation function found.`);
    }
    return this.flagRegistry[flagName].evaluationFn();
  }
  setFlags(flags) {
    this.flags = Object.assign({}, flags);
  }
  reset() {
    this.flags = {};
    this.urlFlags = {};
    this.populateURLFlags();
  }
  populateURLFlags() {
    if (typeof this.global === "undefined" || typeof this.global.location === "undefined" || typeof this.global.location.search === "undefined") {
      return;
    }
    const urlParams = getQueryParams(this.global.location.search);
    if (TENSORFLOWJS_FLAGS_PREFIX in urlParams) {
      const keyValues = urlParams[TENSORFLOWJS_FLAGS_PREFIX].split(",");
      keyValues.forEach((keyValue) => {
        const [key, value] = keyValue.split(":");
        this.urlFlags[key] = parseValue(key, value);
      });
    }
  }
}
function getQueryParams(queryString) {
  const params = {};
  queryString.replace(/[?&]([^=?&]+)(?:=([^&]*))?/g, (s, ...t) => {
    decodeParam(params, t[0], t[1]);
    return t.join("=");
  });
  return params;
}
function decodeParam(params, name, value) {
  params[decodeURIComponent(name)] = decodeURIComponent(value || "");
}
function parseValue(flagName, value) {
  value = value.toLowerCase();
  if (value === "true" || value === "false") {
    return value === "true";
  } else if (`${+value}` === value) {
    return +value;
  }
  throw new Error(`Could not parse value flag value ${value} for flag ${flagName}.`);
}
function env() {
  return ENV;
}
let ENV = null;
function setEnvironmentGlobal(environment6) {
  ENV = environment6;
}
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
let globalNameSpace;
function getGlobalNamespace() {
  if (globalNameSpace == null) {
    let ns;
    if (typeof window !== "undefined") {
      ns = window;
    } else if (typeof global !== "undefined") {
      ns = global;
    } else if (typeof process !== "undefined") {
      ns = process;
    } else if (typeof self !== "undefined") {
      ns = self;
    } else {
      throw new Error("Could not find a global object");
    }
    globalNameSpace = ns;
  }
  return globalNameSpace;
}
function getGlobalMap() {
  const ns = getGlobalNamespace();
  if (ns._tfGlobals == null) {
    ns._tfGlobals = new Map();
  }
  return ns._tfGlobals;
}
function getGlobal(key, init2) {
  const globalMap = getGlobalMap();
  if (globalMap.has(key)) {
    return globalMap.get(key);
  } else {
    const singleton = init2();
    globalMap.set(key, singleton);
    return globalMap.get(key);
  }
}
const Abs = "Abs";
const Add = "Add";
const AddN = "AddN";
const ArgMax = "ArgMax";
const AvgPool = "AvgPool";
const BatchMatMul = "BatchMatMul";
const Cast = "Cast";
const ClipByValue = "ClipByValue";
const Complex = "Complex";
const Concat = "Concat";
const Conv2D = "Conv2D";
const Conv2DBackpropInput = "Conv2DBackpropInput";
const Cos = "Cos";
const Cumsum = "Cumsum";
const CropAndResize = "CropAndResize";
const DepthToSpace = "DepthToSpace";
const DepthwiseConv2dNative = "DepthwiseConv2dNative";
const Div = "Div";
const Elu = "Elu";
const Equal = "Equal";
const Exp = "Exp";
const Fill = "Fill";
const FlipLeftRight = "FlipLeftRight";
const FloorDiv = "FloorDiv";
const FusedBatchNorm = "FusedBatchNorm";
const GatherV2 = "GatherV2";
const GatherNd = "GatherNd";
const Greater = "Greater";
const GreaterEqual = "GreaterEqual";
const Identity = "Identity";
const Less = "Less";
const LessEqual = "LessEqual";
const Log = "Log";
const LogicalAnd = "LogicalAnd";
const Max = "Max";
const Maximum = "Maximum";
const MaxPool = "MaxPool";
const Min = "Min";
const Minimum = "Minimum";
const Multiply = "Multiply";
const Negate = "Negate";
const NotEqual = "NotEqual";
const NonMaxSuppressionV3 = "NonMaxSuppressionV3";
const NonMaxSuppressionV4 = "NonMaxSuppressionV4";
const NonMaxSuppressionV5 = "NonMaxSuppressionV5";
const OnesLike = "OnesLike";
const OneHot = "OneHot";
const PadV2 = "PadV2";
const Pow = "Pow";
const Prelu = "Prelu";
const Relu = "Relu";
const Reshape = "Reshape";
const ResizeBilinear = "ResizeBilinear";
const Relu6 = "Relu6";
const Reverse = "Reverse";
const Rsqrt = "Rsqrt";
const ScatterNd = "ScatterNd";
const SelectV2 = "SelectV2";
const Slice = "Slice";
const Sin = "Sin";
const Sigmoid = "Sigmoid";
const Sqrt = "Sqrt";
const Sum = "Sum";
const SplitV = "SplitV";
const Softmax = "Softmax";
const SquaredDifference = "SquaredDifference";
const Square = "Square";
const Sub = "Sub";
const StridedSlice = "StridedSlice";
const Tanh = "Tanh";
const Tile = "Tile";
const Transpose = "Transpose";
const Unpack = "Unpack";
const ZerosLike = "ZerosLike";
const Step = "Step";
const RotateWithOffset = "RotateWithOffset";
const _FusedMatMul = "_FusedMatMul";
const FusedConv2D = "FusedConv2D";
const FusedDepthwiseConv2D = "FusedDepthwiseConv2D";
/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const kernelRegistry = getGlobal("kernelRegistry", () => new Map());
const gradRegistry = getGlobal("gradRegistry", () => new Map());
function getKernel(kernelName, backendName) {
  const key = makeKey(kernelName, backendName);
  return kernelRegistry.get(key);
}
function getGradient(kernelName) {
  return gradRegistry.get(kernelName);
}
function getKernelsForBackend(backendName) {
  const it = kernelRegistry.entries();
  const result = [];
  while (true) {
    const {done, value} = it.next();
    if (done) {
      break;
    }
    const [key, config2] = value;
    const [backend2] = key.split("_");
    if (backend2 === backendName) {
      result.push(config2);
    }
  }
  return result;
}
function registerKernel(config2) {
  const {kernelName, backendName} = config2;
  const key = makeKey(kernelName, backendName);
  if (kernelRegistry.has(key)) {
    console.warn(`The kernel '${kernelName}' for backend '${backendName}' is already registered`);
  }
  kernelRegistry.set(key, config2);
}
function makeKey(kernelName, backendName) {
  return `${backendName}_${kernelName}`;
}
const util_exports = {};
__export(util_exports, {
  arraysEqual: () => arraysEqual,
  assert: () => assert,
  assertNonNegativeIntegerDimensions: () => assertNonNegativeIntegerDimensions,
  assertNonNull: () => assertNonNull,
  assertShapesMatch: () => assertShapesMatch,
  bytesFromStringArray: () => bytesFromStringArray,
  bytesPerElement: () => bytesPerElement,
  checkConversionForErrors: () => checkConversionForErrors,
  clamp: () => clamp,
  computeStrides: () => computeStrides,
  createScalarValue: () => createScalarValue,
  createShuffledIndices: () => createShuffledIndices,
  decodeString: () => decodeString,
  distSquared: () => distSquared,
  encodeString: () => encodeString,
  fetch: () => fetch2,
  flatten: () => flatten,
  getArrayFromDType: () => getArrayFromDType,
  getTypedArrayFromDType: () => getTypedArrayFromDType,
  hasEncodingLoss: () => hasEncodingLoss,
  indexToLoc: () => indexToLoc,
  inferDtype: () => inferDtype,
  inferFromImplicitShape: () => inferFromImplicitShape,
  isBoolean: () => isBoolean,
  isFunction: () => isFunction,
  isInt: () => isInt,
  isNumber: () => isNumber,
  isPromise: () => isPromise,
  isScalarShape: () => isScalarShape,
  isString: () => isString,
  isTypedArray: () => isTypedArray,
  isValidDtype: () => isValidDtype,
  locToIndex: () => locToIndex,
  makeOnesTypedArray: () => makeOnesTypedArray,
  makeZerosNestedTypedArray: () => makeZerosNestedTypedArray,
  makeZerosTypedArray: () => makeZerosTypedArray,
  nearestDivisor: () => nearestDivisor,
  nearestLargerEven: () => nearestLargerEven,
  now: () => now,
  parseAxisParam: () => parseAxisParam,
  randUniform: () => randUniform,
  repeatedTry: () => repeatedTry,
  rightPad: () => rightPad,
  shuffle: () => shuffle,
  sizeFromShape: () => sizeFromShape,
  sizeToSquarishShape: () => sizeToSquarishShape,
  squeezeShape: () => squeezeShape,
  sum: () => sum,
  tanh: () => tanh,
  toNestedArray: () => toNestedArray,
  toTypedArray: () => toTypedArray
});
/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function createScalarValue(value, dtype) {
  if (dtype === "string") {
    return encodeString(value);
  }
  return toTypedArray([value], dtype);
}
function noConversionNeeded(a, dtype) {
  return a instanceof Float32Array && dtype === "float32" || a instanceof Int32Array && dtype === "int32" || a instanceof Uint8Array && dtype === "bool";
}
function toTypedArray(a, dtype) {
  if (dtype === "string") {
    throw new Error("Cannot convert a string[] to a TypedArray");
  }
  if (Array.isArray(a)) {
    a = flatten(a);
  }
  if (env().getBool("DEBUG")) {
    checkConversionForErrors(a, dtype);
  }
  if (noConversionNeeded(a, dtype)) {
    return a;
  }
  if (dtype == null || dtype === "float32" || dtype === "complex64") {
    return new Float32Array(a);
  } else if (dtype === "int32") {
    return new Int32Array(a);
  } else if (dtype === "bool") {
    const bool = new Uint8Array(a.length);
    for (let i = 0; i < bool.length; ++i) {
      if (Math.round(a[i]) !== 0) {
        bool[i] = 1;
      }
    }
    return bool;
  } else {
    throw new Error(`Unknown data type ${dtype}`);
  }
}
function now() {
  return env().platform.now();
}
function fetch2(path, requestInits) {
  return env().platform.fetch(path, requestInits);
}
function encodeString(s, encoding = "utf-8") {
  encoding = encoding || "utf-8";
  return env().platform.encode(s, encoding);
}
function decodeString(bytes, encoding = "utf-8") {
  encoding = encoding || "utf-8";
  return env().platform.decode(bytes, encoding);
}
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
class Profiler {
  constructor(backendTimer, logger) {
    this.backendTimer = backendTimer;
    this.logger = logger;
    if (logger == null) {
      this.logger = new Logger();
    }
  }
  profileKernel(kernelName, inputs, f) {
    let outputs;
    const holdResultWrapperFn = () => {
      outputs = f();
    };
    const timer = this.backendTimer.time(holdResultWrapperFn);
    for (let i = 0; i < outputs.length; i++) {
      const output = outputs[i];
      output.data().then((tensorVals) => {
        checkComputationForErrors(tensorVals, output.dtype, kernelName);
      });
    }
    const kernelProfile = {
      kernelName,
      outputs,
      inputs,
      timeMs: timer.then((timing) => timing.kernelMs),
      extraInfo: timer.then((timing) => timing.getExtraProfileInfo != null ? timing.getExtraProfileInfo() : "")
    };
    return kernelProfile;
  }
  logKernelProfile(kernelProfile) {
    const {kernelName, outputs, timeMs, inputs, extraInfo} = kernelProfile;
    outputs.forEach((result) => {
      Promise.all([result.data(), timeMs, extraInfo]).then((valueContainer) => {
        this.logger.logKernelProfile(kernelName, result, valueContainer[0], valueContainer[1], inputs, valueContainer[2]);
      });
    });
  }
}
function checkComputationForErrors(vals, dtype, kernelName) {
  if (dtype !== "float32") {
    return false;
  }
  for (let i = 0; i < vals.length; i++) {
    const num = vals[i];
    if (isNaN(num) || !isFinite(num)) {
      console.warn(`Found ${num} in the result of '${kernelName}'`);
      return true;
    }
  }
  return false;
}
class Logger {
  logKernelProfile(name, result, vals, timeMs, inputs, extraInfo) {
    const time = typeof timeMs === "number" ? rightPad(`${timeMs}ms`, 9) : timeMs["error"];
    const paddedName = rightPad(name, 25);
    const rank = result.rank;
    const size = result.size;
    const shape = rightPad(result.shape.toString(), 14);
    let inputShapesDescription = "";
    for (const name2 in inputs) {
      const input = inputs[name2];
      if (input != null) {
        const inputShape = input.shape || result.shape;
        const inputRank = inputShape.length;
        inputShapesDescription += `${name2}: ${inputRank}D ${inputRank > 0 ? inputShape : ""} `;
      }
    }
    console.log(`%c${paddedName}	%c${time}	%c${rank}D ${shape}	%c${size}	%c${inputShapesDescription}	%c${extraInfo}`, "font-weight:bold", "color:red", "color:blue", "color: orange", "color: green", "color: steelblue");
  }
}
/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function getFilteredNodesXToY(tape2, xs, y) {
  const tensorsFromX = {};
  const nodesFromX = {};
  for (let i = 0; i < xs.length; i++) {
    tensorsFromX[xs[i].id] = true;
  }
  for (let i = 0; i < tape2.length; i++) {
    const node = tape2[i];
    const nodeInputs = node.inputs;
    for (const inputName in nodeInputs) {
      const input = nodeInputs[inputName];
      let anyInputFromX = false;
      for (let j = 0; j < xs.length; j++) {
        if (tensorsFromX[input.id]) {
          node.outputs.forEach((output) => tensorsFromX[output.id] = true);
          anyInputFromX = true;
          nodesFromX[node.id] = true;
          break;
        }
      }
      if (anyInputFromX) {
        break;
      }
    }
  }
  const tensorsLeadToY = {};
  tensorsLeadToY[y.id] = true;
  const nodesToY = {};
  for (let i = tape2.length - 1; i >= 0; i--) {
    const node = tape2[i];
    const nodeInputs = node.inputs;
    for (let j = 0; j < node.outputs.length; j++) {
      if (tensorsLeadToY[node.outputs[j].id]) {
        for (const inputName in nodeInputs) {
          tensorsLeadToY[nodeInputs[inputName].id] = true;
          nodesToY[node.id] = true;
        }
        break;
      }
    }
  }
  const filteredTape = [];
  for (let i = 0; i < tape2.length; i++) {
    const node = tape2[i];
    if (nodesFromX[node.id] && nodesToY[node.id]) {
      const prunedInputs = {};
      for (const inputName in node.inputs) {
        const nodeInput = node.inputs[inputName];
        if (tensorsFromX[nodeInput.id]) {
          prunedInputs[inputName] = nodeInput;
        }
      }
      const prunedNode = Object.assign({}, node);
      prunedNode.inputs = prunedInputs;
      prunedNode.outputs = node.outputs;
      filteredTape.push(prunedNode);
    }
  }
  return filteredTape;
}
function backpropagateGradients(tensorAccumulatedGradientMap, filteredTape, tidy, add2) {
  for (let i = filteredTape.length - 1; i >= 0; i--) {
    const node = filteredTape[i];
    const dys = [];
    node.outputs.forEach((o) => {
      const gradTensor = tensorAccumulatedGradientMap[o.id];
      if (gradTensor != null) {
        dys.push(gradTensor);
      } else {
        dys.push(null);
      }
    });
    if (node.gradient == null) {
      throw new Error(`Cannot compute gradient: gradient function not found for ${node.kernelName}.`);
    }
    const inputGradients = node.gradient(dys);
    for (const inputName in node.inputs) {
      if (!(inputName in inputGradients)) {
        throw new Error(`Cannot backprop through input ${inputName}. Available gradients found: ${Object.keys(inputGradients)}.`);
      }
      const dx = tidy(() => inputGradients[inputName]());
      if (dx.dtype !== "float32") {
        throw new Error(`Error in gradient for op ${node.kernelName}. The gradient of input ${inputName} must have 'float32' dtype, but has '${dx.dtype}'`);
      }
      const x = node.inputs[inputName];
      if (!arraysEqual(dx.shape, x.shape)) {
        throw new Error(`Error in gradient for op ${node.kernelName}. The gradient of input '${inputName}' has shape '${dx.shape}', which does not match the shape of the input '${x.shape}'`);
      }
      if (tensorAccumulatedGradientMap[x.id] == null) {
        tensorAccumulatedGradientMap[x.id] = dx;
      } else {
        const curGradient = tensorAccumulatedGradientMap[x.id];
        tensorAccumulatedGradientMap[x.id] = add2(curGradient, dx);
        curGradient.dispose();
      }
    }
  }
}
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const FORMAT_LIMIT_NUM_VALS = 20;
const FORMAT_NUM_FIRST_LAST_VALS = 3;
const FORMAT_NUM_SIG_DIGITS = 7;
function tensorToString(vals, shape, dtype, verbose) {
  const strides = computeStrides(shape);
  const padPerCol = computeMaxSizePerColumn(vals, shape, dtype, strides);
  const rank = shape.length;
  const valsLines = subTensorToString(vals, shape, dtype, strides, padPerCol);
  const lines = ["Tensor"];
  if (verbose) {
    lines.push(`  dtype: ${dtype}`);
    lines.push(`  rank: ${rank}`);
    lines.push(`  shape: [${shape}]`);
    lines.push(`  values:`);
  }
  lines.push(valsLines.map((l) => "    " + l).join("\n"));
  return lines.join("\n");
}
function computeMaxSizePerColumn(vals, shape, dtype, strides) {
  const n = sizeFromShape(shape);
  const numCols = strides[strides.length - 1];
  const padPerCol = new Array(numCols).fill(0);
  const rank = shape.length;
  const valuesOrTuples = dtype === "complex64" ? createComplexTuples(vals) : vals;
  if (rank > 1) {
    for (let row = 0; row < n / numCols; row++) {
      const offset = row * numCols;
      for (let j = 0; j < numCols; j++) {
        padPerCol[j] = Math.max(padPerCol[j], valToString(valuesOrTuples[offset + j], 0, dtype).length);
      }
    }
  }
  return padPerCol;
}
function valToString(val, pad2, dtype) {
  let valStr;
  if (Array.isArray(val)) {
    valStr = `${parseFloat(val[0].toFixed(FORMAT_NUM_SIG_DIGITS))} + ${parseFloat(val[1].toFixed(FORMAT_NUM_SIG_DIGITS))}j`;
  } else if (isString(val)) {
    valStr = `'${val}'`;
  } else if (dtype === "bool") {
    valStr = boolNumToString(val);
  } else {
    valStr = parseFloat(val.toFixed(FORMAT_NUM_SIG_DIGITS)).toString();
  }
  return rightPad(valStr, pad2);
}
function boolNumToString(v) {
  return v === 0 ? "false" : "true";
}
function subTensorToString(vals, shape, dtype, strides, padPerCol, isLast = true) {
  const storagePerElement = dtype === "complex64" ? 2 : 1;
  const size = shape[0];
  const rank = shape.length;
  if (rank === 0) {
    if (dtype === "complex64") {
      const complexTuple = createComplexTuples(vals);
      return [valToString(complexTuple[0], 0, dtype)];
    }
    if (dtype === "bool") {
      return [boolNumToString(vals[0])];
    }
    return [vals[0].toString()];
  }
  if (rank === 1) {
    if (size > FORMAT_LIMIT_NUM_VALS) {
      const firstValsSize = FORMAT_NUM_FIRST_LAST_VALS * storagePerElement;
      let firstVals = Array.from(vals.slice(0, firstValsSize));
      let lastVals = Array.from(vals.slice((size - FORMAT_NUM_FIRST_LAST_VALS) * storagePerElement, size * storagePerElement));
      if (dtype === "complex64") {
        firstVals = createComplexTuples(firstVals);
        lastVals = createComplexTuples(lastVals);
      }
      return [
        "[" + firstVals.map((x, i) => valToString(x, padPerCol[i], dtype)).join(", ") + ", ..., " + lastVals.map((x, i) => valToString(x, padPerCol[size - FORMAT_NUM_FIRST_LAST_VALS + i], dtype)).join(", ") + "]"
      ];
    }
    const displayVals = dtype === "complex64" ? createComplexTuples(vals) : Array.from(vals);
    return [
      "[" + displayVals.map((x, i) => valToString(x, padPerCol[i], dtype)).join(", ") + "]"
    ];
  }
  const subshape = shape.slice(1);
  const substrides = strides.slice(1);
  const stride = strides[0] * storagePerElement;
  const lines = [];
  if (size > FORMAT_LIMIT_NUM_VALS) {
    for (let i = 0; i < FORMAT_NUM_FIRST_LAST_VALS; i++) {
      const start = i * stride;
      const end = start + stride;
      lines.push(...subTensorToString(vals.slice(start, end), subshape, dtype, substrides, padPerCol, false));
    }
    lines.push("...");
    for (let i = size - FORMAT_NUM_FIRST_LAST_VALS; i < size; i++) {
      const start = i * stride;
      const end = start + stride;
      lines.push(...subTensorToString(vals.slice(start, end), subshape, dtype, substrides, padPerCol, i === size - 1));
    }
  } else {
    for (let i = 0; i < size; i++) {
      const start = i * stride;
      const end = start + stride;
      lines.push(...subTensorToString(vals.slice(start, end), subshape, dtype, substrides, padPerCol, i === size - 1));
    }
  }
  const sep = rank === 2 ? "," : "";
  lines[0] = "[" + lines[0] + sep;
  for (let i = 1; i < lines.length - 1; i++) {
    lines[i] = " " + lines[i] + sep;
  }
  let newLineSep = ",\n";
  for (let i = 2; i < rank; i++) {
    newLineSep += "\n";
  }
  lines[lines.length - 1] = " " + lines[lines.length - 1] + "]" + (isLast ? "" : newLineSep);
  return lines;
}
function createComplexTuples(vals) {
  const complexTuples = [];
  for (let i = 0; i < vals.length; i += 2) {
    complexTuples.push([vals[i], vals[i + 1]]);
  }
  return complexTuples;
}
/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
class TensorBuffer {
  constructor(shape, dtype, values) {
    this.dtype = dtype;
    this.shape = shape.slice();
    this.size = sizeFromShape(shape);
    if (values != null) {
      const n = values.length;
      assert(n === this.size, () => `Length of values '${n}' does not match the size inferred by the shape '${this.size}'.`);
    }
    if (dtype === "complex64") {
      throw new Error(`complex64 dtype TensorBuffers are not supported. Please create a TensorBuffer for the real and imaginary parts separately and call tf.complex(real, imag).`);
    }
    this.values = values || getArrayFromDType(dtype, this.size);
    this.strides = computeStrides(shape);
  }
  set(value, ...locs) {
    if (locs.length === 0) {
      locs = [0];
    }
    assert(locs.length === this.rank, () => `The number of provided coordinates (${locs.length}) must match the rank (${this.rank})`);
    const index = this.locToIndex(locs);
    this.values[index] = value;
  }
  get(...locs) {
    if (locs.length === 0) {
      locs = [0];
    }
    let i = 0;
    for (const loc of locs) {
      if (loc < 0 || loc >= this.shape[i]) {
        const msg = `Requested out of range element at ${locs}.   Buffer shape=${this.shape}`;
        throw new Error(msg);
      }
      i++;
    }
    let index = locs[locs.length - 1];
    for (let i2 = 0; i2 < locs.length - 1; ++i2) {
      index += this.strides[i2] * locs[i2];
    }
    return this.values[index];
  }
  locToIndex(locs) {
    if (this.rank === 0) {
      return 0;
    } else if (this.rank === 1) {
      return locs[0];
    }
    let index = locs[locs.length - 1];
    for (let i = 0; i < locs.length - 1; ++i) {
      index += this.strides[i] * locs[i];
    }
    return index;
  }
  indexToLoc(index) {
    if (this.rank === 0) {
      return [];
    } else if (this.rank === 1) {
      return [index];
    }
    const locs = new Array(this.shape.length);
    for (let i = 0; i < locs.length - 1; ++i) {
      locs[i] = Math.floor(index / this.strides[i]);
      index -= locs[i] * this.strides[i];
    }
    locs[locs.length - 1] = index;
    return locs;
  }
  get rank() {
    return this.shape.length;
  }
  toTensor() {
    return trackerFn().makeTensor(this.values, this.shape, this.dtype);
  }
}
let trackerFn = null;
let opHandler = null;
let deprecationWarningFn = null;
function setTensorTracker(fn) {
  trackerFn = fn;
}
function setDeprecationWarningFn(fn) {
  deprecationWarningFn = fn;
}
class Tensor {
  constructor(shape, dtype, dataId, id) {
    this.kept = false;
    this.isDisposedInternal = false;
    this.shape = shape.slice();
    this.dtype = dtype || "float32";
    this.size = sizeFromShape(shape);
    this.strides = computeStrides(shape);
    this.dataId = dataId;
    this.id = id;
    this.rankType = this.rank < 5 ? this.rank.toString() : "higher";
  }
  get rank() {
    return this.shape.length;
  }
  async buffer() {
    const vals = await this.data();
    return opHandler.buffer(this.shape, this.dtype, vals);
  }
  bufferSync() {
    return opHandler.buffer(this.shape, this.dtype, this.dataSync());
  }
  async array() {
    const vals = await this.data();
    return toNestedArray(this.shape, vals);
  }
  arraySync() {
    return toNestedArray(this.shape, this.dataSync());
  }
  async data() {
    this.throwIfDisposed();
    const data2 = trackerFn().read(this.dataId);
    if (this.dtype === "string") {
      const bytes = await data2;
      try {
        return bytes.map((b) => decodeString(b));
      } catch (_a) {
        throw new Error("Failed to decode the string bytes into utf-8. To get the original bytes, call tensor.bytes().");
      }
    }
    return data2;
  }
  dataSync() {
    this.throwIfDisposed();
    const data2 = trackerFn().readSync(this.dataId);
    if (this.dtype === "string") {
      try {
        return data2.map((b) => decodeString(b));
      } catch (_a) {
        throw new Error("Failed to decode the string bytes into utf-8. To get the original bytes, call tensor.bytes().");
      }
    }
    return data2;
  }
  async bytes() {
    this.throwIfDisposed();
    const data2 = await trackerFn().read(this.dataId);
    if (this.dtype === "string") {
      return data2;
    } else {
      return new Uint8Array(data2.buffer);
    }
  }
  dispose() {
    if (this.isDisposed) {
      return;
    }
    trackerFn().disposeTensor(this);
    this.isDisposedInternal = true;
  }
  get isDisposed() {
    return this.isDisposedInternal;
  }
  throwIfDisposed() {
    if (this.isDisposed) {
      throw new Error(`Tensor is disposed.`);
    }
  }
  print(verbose = false) {
    return opHandler.print(this, verbose);
  }
  clone() {
    this.throwIfDisposed();
    return opHandler.clone(this);
  }
  toString(verbose = false) {
    const vals = this.dataSync();
    return tensorToString(vals, this.shape, this.dtype, verbose);
  }
  cast(dtype) {
    this.throwIfDisposed();
    return opHandler.cast(this, dtype);
  }
  variable(trainable = true, name, dtype) {
    this.throwIfDisposed();
    return trackerFn().makeVariable(this, trainable, name, dtype);
  }
}
Object.defineProperty(Tensor, Symbol.hasInstance, {
  value: (instance2) => {
    return !!instance2 && instance2.data != null && instance2.dataSync != null && instance2.throwIfDisposed != null;
  }
});
class Variable extends Tensor {
  constructor(initialValue, trainable, name, tensorId) {
    super(initialValue.shape, initialValue.dtype, initialValue.dataId, tensorId);
    this.trainable = trainable;
    this.name = name;
  }
  assign(newValue) {
    if (newValue.dtype !== this.dtype) {
      throw new Error(`dtype of the new value (${newValue.dtype}) and previous value (${this.dtype}) must match`);
    }
    if (!arraysEqual(newValue.shape, this.shape)) {
      throw new Error(`shape of the new value (${newValue.shape}) and previous value (${this.shape}) must match`);
    }
    trackerFn().disposeTensor(this);
    this.dataId = newValue.dataId;
    trackerFn().incRef(this, null);
  }
  dispose() {
    trackerFn().disposeVariable(this);
    this.isDisposedInternal = true;
  }
}
Object.defineProperty(Variable, Symbol.hasInstance, {
  value: (instance2) => {
    return instance2 instanceof Tensor && instance2.assign != null && instance2.assign instanceof Function;
  }
});
/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
var Rank;
(function(Rank2) {
  Rank2["R0"] = "R0";
  Rank2["R1"] = "R1";
  Rank2["R2"] = "R2";
  Rank2["R3"] = "R3";
  Rank2["R4"] = "R4";
  Rank2["R5"] = "R5";
  Rank2["R6"] = "R6";
})(Rank || (Rank = {}));
var UpcastInt32AndMap;
(function(UpcastInt32AndMap2) {
  UpcastInt32AndMap2["float32"] = "float32";
  UpcastInt32AndMap2["int32"] = "int32";
  UpcastInt32AndMap2["bool"] = "int32";
  UpcastInt32AndMap2["complex64"] = "complex64";
})(UpcastInt32AndMap || (UpcastInt32AndMap = {}));
var UpcastBoolAndMap;
(function(UpcastBoolAndMap2) {
  UpcastBoolAndMap2["float32"] = "float32";
  UpcastBoolAndMap2["int32"] = "int32";
  UpcastBoolAndMap2["bool"] = "bool";
  UpcastBoolAndMap2["complex64"] = "complex64";
})(UpcastBoolAndMap || (UpcastBoolAndMap = {}));
var UpcastFloat32AndMap;
(function(UpcastFloat32AndMap2) {
  UpcastFloat32AndMap2["float32"] = "float32";
  UpcastFloat32AndMap2["int32"] = "float32";
  UpcastFloat32AndMap2["bool"] = "float32";
  UpcastFloat32AndMap2["complex64"] = "complex64";
})(UpcastFloat32AndMap || (UpcastFloat32AndMap = {}));
var UpcastComplex64AndMap;
(function(UpcastComplex64AndMap2) {
  UpcastComplex64AndMap2["float32"] = "complex64";
  UpcastComplex64AndMap2["int32"] = "complex64";
  UpcastComplex64AndMap2["bool"] = "complex64";
  UpcastComplex64AndMap2["complex64"] = "complex64";
})(UpcastComplex64AndMap || (UpcastComplex64AndMap = {}));
const upcastTypeMap = {
  float32: UpcastFloat32AndMap,
  int32: UpcastInt32AndMap,
  bool: UpcastBoolAndMap,
  complex64: UpcastComplex64AndMap
};
function upcastType(typeA, typeB) {
  if (typeA === "string" || typeB === "string") {
    if (typeA === "string" && typeB === "string") {
      return "string";
    }
    throw new Error(`Can not upcast ${typeA} with ${typeB}`);
  }
  return upcastTypeMap[typeA][typeB];
}
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function makeTypesMatch(a, b) {
  if (a.dtype === b.dtype) {
    return [a, b];
  }
  const dtype = upcastType(a.dtype, b.dtype);
  return [a.cast(dtype), b.cast(dtype)];
}
function getTensorsInContainer(result) {
  const list = [];
  const seen = new Set();
  walkTensorContainer(result, list, seen);
  return list;
}
function walkTensorContainer(container, list, seen) {
  if (container == null) {
    return;
  }
  if (container instanceof Tensor) {
    list.push(container);
    return;
  }
  if (!isIterable(container)) {
    return;
  }
  const iterable = container;
  for (const k in iterable) {
    const val = iterable[k];
    if (!seen.has(val)) {
      seen.add(val);
      walkTensorContainer(val, list, seen);
    }
  }
}
function isIterable(obj) {
  return Array.isArray(obj) || typeof obj === "object";
}
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
class EngineState {
  constructor() {
    this.registeredVariables = {};
    this.nextTapeNodeId = 0;
    this.numBytes = 0;
    this.numTensors = 0;
    this.numStringTensors = 0;
    this.numDataBuffers = 0;
    this.gradientDepth = 0;
    this.kernelDepth = 0;
    this.scopeStack = [];
    this.numDataMovesStack = [];
    this.nextScopeId = 0;
    this.tensorInfo = new WeakMap();
    this.profiling = false;
    this.activeProfile = {newBytes: 0, newTensors: 0, peakBytes: 0, kernels: [], result: null};
  }
  dispose() {
    for (const variableName in this.registeredVariables) {
      this.registeredVariables[variableName].dispose();
    }
  }
}
class Engine {
  constructor(ENV3) {
    this.ENV = ENV3;
    this.registry = {};
    this.registryFactory = {};
    this.pendingBackendInitId = 0;
    this.state = new EngineState();
  }
  async ready() {
    if (this.pendingBackendInit != null) {
      return this.pendingBackendInit.then(() => {
      });
    }
    if (this.backendInstance != null) {
      return;
    }
    const sortedBackends = this.getSortedBackends();
    for (let i = 0; i < sortedBackends.length; i++) {
      const backendName = sortedBackends[i];
      const success = await this.initializeBackend(backendName).success;
      if (success) {
        await this.setBackend(backendName);
        return;
      }
    }
    throw new Error(`Could not initialize any backends, all backend initializations failed.`);
  }
  get backend() {
    if (this.pendingBackendInit != null) {
      throw new Error(`Backend '${this.backendName}' has not yet been initialized. Make sure to await tf.ready() or await tf.setBackend() before calling other methods`);
    }
    if (this.backendInstance == null) {
      const {name, asyncInit} = this.initializeBackendsAndReturnBest();
      if (asyncInit) {
        throw new Error(`The highest priority backend '${name}' has not yet been initialized. Make sure to await tf.ready() or await tf.setBackend() before calling other methods`);
      }
      this.setBackend(name);
    }
    return this.backendInstance;
  }
  backendNames() {
    return Object.keys(this.registryFactory);
  }
  findBackend(backendName) {
    if (!(backendName in this.registry)) {
      if (backendName in this.registryFactory) {
        const {asyncInit} = this.initializeBackend(backendName);
        if (asyncInit) {
          return null;
        }
      } else {
        return null;
      }
    }
    return this.registry[backendName];
  }
  findBackendFactory(backendName) {
    if (!(backendName in this.registryFactory)) {
      return null;
    }
    return this.registryFactory[backendName].factory;
  }
  registerBackend(backendName, factory, priority = 1) {
    if (backendName in this.registryFactory) {
      console.warn(`${backendName} backend was already registered. Reusing existing backend factory.`);
      return false;
    }
    this.registryFactory[backendName] = {factory, priority};
    return true;
  }
  async setBackend(backendName) {
    if (this.registryFactory[backendName] == null) {
      throw new Error(`Backend name '${backendName}' not found in registry`);
    }
    this.backendName = backendName;
    if (this.registry[backendName] == null) {
      this.backendInstance = null;
      const {success, asyncInit} = this.initializeBackend(backendName);
      const result = asyncInit ? await success : success;
      if (!result) {
        return false;
      }
    }
    this.backendInstance = this.registry[backendName];
    this.setupRegisteredKernels();
    this.profiler = new Profiler(this.backendInstance);
    return true;
  }
  setupRegisteredKernels() {
    const kernels = getKernelsForBackend(this.backendName);
    kernels.forEach((kernel) => {
      if (kernel.setupFunc != null) {
        kernel.setupFunc(this.backendInstance);
      }
    });
  }
  disposeRegisteredKernels(backendName) {
    const kernels = getKernelsForBackend(backendName);
    kernels.forEach((kernel) => {
      if (kernel.disposeFunc != null) {
        kernel.disposeFunc(this.registry[backendName]);
      }
    });
  }
  initializeBackend(backendName) {
    const registryFactoryEntry = this.registryFactory[backendName];
    if (registryFactoryEntry == null) {
      throw new Error(`Cannot initialize backend ${backendName}, no registration found.`);
    }
    try {
      const backend2 = registryFactoryEntry.factory();
      if (backend2 && !(backend2 instanceof KernelBackend) && typeof backend2.then === "function") {
        const promiseId = ++this.pendingBackendInitId;
        const success = backend2.then((backendInstance) => {
          if (promiseId < this.pendingBackendInitId) {
            return false;
          }
          this.registry[backendName] = backendInstance;
          this.pendingBackendInit = null;
          return true;
        }).catch((err) => {
          if (promiseId < this.pendingBackendInitId) {
            return false;
          }
          this.pendingBackendInit = null;
          console.warn(`Initialization of backend ${backendName} failed`);
          console.warn(err.stack || err.message);
          return false;
        });
        this.pendingBackendInit = success;
        return {success, asyncInit: true};
      } else {
        this.registry[backendName] = backend2;
        return {success: true, asyncInit: false};
      }
    } catch (err) {
      console.warn(`Initialization of backend ${backendName} failed`);
      console.warn(err.stack || err.message);
      return {success: false, asyncInit: false};
    }
  }
  removeBackend(backendName) {
    if (!(backendName in this.registryFactory)) {
      throw new Error(`${backendName} backend not found in registry`);
    }
    if (this.backendName === backendName && this.pendingBackendInit != null) {
      this.pendingBackendInitId++;
    }
    if (backendName in this.registry) {
      this.disposeRegisteredKernels(backendName);
      this.registry[backendName].dispose();
      delete this.registry[backendName];
    }
    delete this.registryFactory[backendName];
    if (this.backendName === backendName) {
      this.pendingBackendInit = null;
      this.backendName = null;
      this.backendInstance = null;
    }
  }
  getSortedBackends() {
    if (Object.keys(this.registryFactory).length === 0) {
      throw new Error("No backend found in registry.");
    }
    return Object.keys(this.registryFactory).sort((a, b) => {
      return this.registryFactory[b].priority - this.registryFactory[a].priority;
    });
  }
  initializeBackendsAndReturnBest() {
    const sortedBackends = this.getSortedBackends();
    for (let i = 0; i < sortedBackends.length; i++) {
      const backendName = sortedBackends[i];
      const {success, asyncInit} = this.initializeBackend(backendName);
      if (asyncInit || success) {
        return {name: backendName, asyncInit};
      }
    }
    throw new Error(`Could not initialize any backends, all backend initializations failed.`);
  }
  moveData(backend2, dataId) {
    const info = this.state.tensorInfo.get(dataId);
    const srcBackend = info.backend;
    const values = this.readSync(dataId);
    srcBackend.disposeData(dataId);
    info.backend = backend2;
    backend2.move(dataId, values, info.shape, info.dtype);
    if (this.shouldCheckForMemLeaks()) {
      this.state.numDataMovesStack[this.state.numDataMovesStack.length - 1]++;
    }
  }
  tidy(nameOrFn, fn) {
    let name = null;
    if (fn == null) {
      if (typeof nameOrFn !== "function") {
        throw new Error("Please provide a function to tidy()");
      }
      fn = nameOrFn;
    } else {
      if (typeof nameOrFn !== "string" && !(nameOrFn instanceof String)) {
        throw new Error("When calling with two arguments, the first argument to tidy() must be a string");
      }
      if (typeof fn !== "function") {
        throw new Error("When calling with two arguments, the 2nd argument to tidy() must be a function");
      }
      name = nameOrFn;
    }
    let result;
    return this.scopedRun(() => this.startScope(name), () => this.endScope(result), () => {
      result = fn();
      if (result instanceof Promise) {
        console.error("Cannot return a Promise inside of tidy.");
      }
      return result;
    });
  }
  scopedRun(start, end, f) {
    start();
    try {
      const res = f();
      end();
      return res;
    } catch (ex) {
      end();
      throw ex;
    }
  }
  nextTensorId() {
    return Engine.nextTensorId++;
  }
  nextVariableId() {
    return Engine.nextVariableId++;
  }
  clone(x) {
    const y = this.makeTensorFromDataId(x.dataId, x.shape, x.dtype);
    const inputs = {x};
    const grad = (dy) => ({
      x: () => {
        const dtype = "float32";
        const gradInputs = {x: dy};
        const attrs = {dtype};
        return ENGINE.runKernelFunc((backend2) => backend2.cast(dy, dtype), gradInputs, null, Cast, attrs);
      }
    });
    const saved = [];
    this.addTapeNode(this.state.activeScope.name, inputs, [y], grad, saved, {});
    return y;
  }
  runKernel(kernelName, inputs, attrs, inputsToSave, outputsToSave) {
    const forwardFunc = null;
    const backwardsFunc = null;
    return this.runKernelFunc(forwardFunc, inputs, backwardsFunc, kernelName, attrs, inputsToSave, outputsToSave);
  }
  shouldCheckForMemLeaks() {
    return this.ENV.getBool("IS_TEST");
  }
  checkKernelForMemLeak(kernelName, numDataIdsBefore, outInfos) {
    const numDataIdsAfter = this.backend.numDataIds();
    let numOutputDataIds = 0;
    outInfos.forEach((info) => {
      numOutputDataIds += info.dtype === "complex64" ? 3 : 1;
    });
    const numMoves = this.state.numDataMovesStack[this.state.numDataMovesStack.length - 1];
    const dataIdsLeaked = numDataIdsAfter - numDataIdsBefore - numOutputDataIds - numMoves;
    if (dataIdsLeaked > 0) {
      throw new Error(`Backend '${this.backendName}' has an internal memory leak (${dataIdsLeaked} data ids) after running '${kernelName}'`);
    }
  }
  runKernelFunc(forwardFunc, inputs, backwardsFunc, kernelName, attrs, inputsToSave, outputsToSave) {
    let outputs;
    let saved = [];
    const isTapeOn = this.isTapeOn();
    if (kernelName == null) {
      kernelName = this.state.activeScope != null ? this.state.activeScope.name : "";
    }
    const startingBytecount = this.state.numBytes;
    const startingNumTensors = this.state.numTensors;
    if (this.shouldCheckForMemLeaks()) {
      this.state.numDataMovesStack.push(0);
    }
    let kernelFunc3;
    const kernel = getKernel(kernelName, this.backendName);
    let out;
    if (kernel != null) {
      kernelFunc3 = () => {
        const numDataIdsBefore = this.backend.numDataIds();
        out = kernel.kernelFunc({inputs, attrs, backend: this.backend});
        const outInfos = Array.isArray(out) ? out : [out];
        if (this.shouldCheckForMemLeaks()) {
          this.checkKernelForMemLeak(kernelName, numDataIdsBefore, outInfos);
        }
        const outTensors = outInfos.map(({dataId, shape, dtype}) => this.makeTensorFromDataId(dataId, shape, dtype));
        if (isTapeOn) {
          let tensorsToSave = this.getTensorsForGradient(kernelName, inputs, outTensors);
          if (tensorsToSave == null) {
            if (outputsToSave == null) {
              outputsToSave = [];
            }
            const outsToSave = outTensors.filter((_, i) => outputsToSave[i]);
            tensorsToSave = (inputsToSave || []).slice().concat(outsToSave);
          }
          saved = this.saveTensorsForBackwardMode(tensorsToSave);
        }
        return outTensors;
      };
    } else {
      const saveFunc = (tensors) => {
        if (!isTapeOn) {
          return;
        }
        saved = tensors.map((tensor6) => this.keep(this.clone(tensor6)));
      };
      kernelFunc3 = () => {
        const numDataIdsBefore = this.backend.numDataIds();
        out = this.tidy(() => forwardFunc(this.backend, saveFunc));
        const outs = Array.isArray(out) ? out : [out];
        if (this.shouldCheckForMemLeaks()) {
          this.checkKernelForMemLeak(kernelName, numDataIdsBefore, outs);
        }
        return outs;
      };
    }
    let kernelProfile;
    this.scopedRun(() => this.state.kernelDepth++, () => this.state.kernelDepth--, () => {
      if (!this.ENV.getBool("DEBUG") && !this.state.profiling) {
        outputs = kernelFunc3();
      } else {
        kernelProfile = this.profiler.profileKernel(kernelName, inputs, () => kernelFunc3());
        if (this.ENV.getBool("DEBUG")) {
          this.profiler.logKernelProfile(kernelProfile);
        }
        outputs = kernelProfile.outputs;
      }
    });
    if (isTapeOn) {
      this.addTapeNode(kernelName, inputs, outputs, backwardsFunc, saved, attrs);
    }
    if (this.state.profiling) {
      this.state.activeProfile.kernels.push({
        name: kernelName,
        bytesAdded: this.state.numBytes - startingBytecount,
        totalBytesSnapshot: this.state.numBytes,
        tensorsAdded: this.state.numTensors - startingNumTensors,
        totalTensorsSnapshot: this.state.numTensors,
        inputShapes: Object.keys(inputs).map((key) => inputs[key] != null ? inputs[key].shape : null),
        outputShapes: outputs.map((item) => item.shape),
        kernelTimeMs: kernelProfile.timeMs,
        extraInfo: kernelProfile.extraInfo
      });
    }
    return Array.isArray(out) ? outputs : outputs[0];
  }
  saveTensorsForBackwardMode(tensors) {
    const saved = tensors.map((tensor6) => this.keep(this.clone(tensor6)));
    return saved;
  }
  getTensorsForGradient(kernelName, inputs, outputs) {
    const gradConfig = getGradient(kernelName);
    if (gradConfig != null) {
      const inputsToSave = gradConfig.inputsToSave || [];
      const outputsToSave = gradConfig.outputsToSave || [];
      let inputTensorsToSave;
      if (gradConfig.saveAllInputs) {
        assert(Array.isArray(inputs), () => "saveAllInputs is true, expected inputs to be an array.");
        inputTensorsToSave = Object.keys(inputs).map((key) => inputs[key]);
      } else {
        inputTensorsToSave = inputsToSave.map((inputName) => inputs[inputName]);
      }
      const outputTensorsToSave = outputs.filter((_, i) => outputsToSave[i]);
      return inputTensorsToSave.concat(outputTensorsToSave);
    }
    return null;
  }
  makeTensor(values, shape, dtype, backend2) {
    if (values == null) {
      throw new Error("Values passed to engine.makeTensor() are null");
    }
    dtype = dtype || "float32";
    backend2 = backend2 || this.backend;
    let backendVals = values;
    if (dtype === "string" && isString(values[0])) {
      backendVals = values.map((d) => encodeString(d));
    }
    const dataId = backend2.write(backendVals, shape, dtype);
    const t = new Tensor(shape, dtype, dataId, this.nextTensorId());
    this.incRef(t, backend2);
    if (dtype === "string") {
      const info = this.state.tensorInfo.get(dataId);
      const newBytes = bytesFromStringArray(backendVals);
      this.state.numBytes += newBytes - info.bytes;
      info.bytes = newBytes;
    }
    return t;
  }
  makeTensorFromDataId(dataId, shape, dtype, backend2) {
    dtype = dtype || "float32";
    const t = new Tensor(shape, dtype, dataId, this.nextTensorId());
    this.incRef(t, backend2);
    return t;
  }
  makeVariable(initialValue, trainable = true, name, dtype) {
    name = name || this.nextVariableId().toString();
    if (dtype != null && dtype !== initialValue.dtype) {
      initialValue = initialValue.cast(dtype);
    }
    const v = new Variable(initialValue, trainable, name, this.nextTensorId());
    if (this.state.registeredVariables[v.name] != null) {
      throw new Error(`Variable with name ${v.name} was already registered`);
    }
    this.state.registeredVariables[v.name] = v;
    this.incRef(v, this.backend);
    return v;
  }
  incRef(a, backend2) {
    const refCount = this.state.tensorInfo.has(a.dataId) ? this.state.tensorInfo.get(a.dataId).refCount : 0;
    this.state.numTensors++;
    if (a.dtype === "string") {
      this.state.numStringTensors++;
    }
    if (refCount === 0) {
      this.state.numDataBuffers++;
      let bytes = 0;
      if (a.dtype !== "complex64" && a.dtype !== "string") {
        bytes = a.size * bytesPerElement(a.dtype);
      }
      this.state.tensorInfo.set(a.dataId, {
        backend: backend2 || this.backend,
        dtype: a.dtype,
        shape: a.shape,
        bytes,
        refCount: 0
      });
      this.state.numBytes += bytes;
    }
    this.state.tensorInfo.get(a.dataId).refCount++;
    if (!(a instanceof Variable)) {
      this.track(a);
    }
  }
  disposeTensor(a) {
    if (!this.state.tensorInfo.has(a.dataId)) {
      return;
    }
    this.state.numTensors--;
    if (a.dtype === "string") {
      this.state.numStringTensors--;
    }
    const info = this.state.tensorInfo.get(a.dataId);
    const refCount = info.refCount;
    if (refCount <= 1) {
      if (a.dtype !== "complex64") {
        this.state.numBytes -= info.bytes;
      }
      this.state.numDataBuffers--;
      info.backend.disposeData(a.dataId);
      this.state.tensorInfo.delete(a.dataId);
    } else {
      this.state.tensorInfo.get(a.dataId).refCount--;
    }
  }
  disposeVariables() {
    for (const varName in this.state.registeredVariables) {
      const v = this.state.registeredVariables[varName];
      this.disposeVariable(v);
    }
  }
  disposeVariable(v) {
    this.disposeTensor(v);
    if (this.state.registeredVariables[v.name] != null) {
      delete this.state.registeredVariables[v.name];
    }
  }
  memory() {
    const info = this.backend.memory();
    info.numTensors = this.state.numTensors;
    info.numDataBuffers = this.state.numDataBuffers;
    info.numBytes = this.state.numBytes;
    if (this.state.numStringTensors > 0) {
      info.unreliable = true;
      if (info.reasons == null) {
        info.reasons = [];
      }
      info.reasons.push("Memory usage by string tensors is approximate (2 bytes per character)");
    }
    return info;
  }
  async profile(query) {
    this.state.profiling = true;
    const startBytes = this.state.numBytes;
    const startNumTensors = this.state.numTensors;
    this.state.activeProfile.kernels = [];
    this.state.activeProfile.result = await query();
    this.state.profiling = false;
    this.state.activeProfile.peakBytes = Math.max(...this.state.activeProfile.kernels.map((d) => d.totalBytesSnapshot));
    this.state.activeProfile.newBytes = this.state.numBytes - startBytes;
    this.state.activeProfile.newTensors = this.state.numTensors - startNumTensors;
    for (const kernel of this.state.activeProfile.kernels) {
      kernel.kernelTimeMs = await kernel.kernelTimeMs;
      kernel.extraInfo = await kernel.extraInfo;
    }
    return this.state.activeProfile;
  }
  isTapeOn() {
    return this.state.gradientDepth > 0 && this.state.kernelDepth === 0;
  }
  addTapeNode(kernelName, inputs, outputs, gradientsFunc, saved, attrs) {
    const tapeNode = {id: this.state.nextTapeNodeId++, kernelName, inputs, outputs, saved};
    const gradConfig = getGradient(kernelName);
    if (gradConfig != null) {
      gradientsFunc = gradConfig.gradFunc;
    }
    if (gradientsFunc != null) {
      tapeNode.gradient = (dys) => {
        dys = dys.map((dy, i) => {
          if (dy == null) {
            const output = outputs[i];
            const vals = makeZerosTypedArray(output.size, output.dtype);
            return this.makeTensor(vals, output.shape, output.dtype);
          }
          return dy;
        });
        return gradientsFunc(dys.length > 1 ? dys : dys[0], saved, attrs);
      };
    }
    this.state.activeTape.push(tapeNode);
  }
  keep(result) {
    result.kept = true;
    return result;
  }
  startTape() {
    if (this.state.gradientDepth === 0) {
      this.state.activeTape = [];
    }
    this.state.gradientDepth++;
  }
  endTape() {
    this.state.gradientDepth--;
  }
  startScope(name) {
    const scopeInfo = {
      track: [],
      name: "unnamed scope",
      id: this.state.nextScopeId++
    };
    if (name) {
      scopeInfo.name = name;
    }
    this.state.scopeStack.push(scopeInfo);
    this.state.activeScope = scopeInfo;
  }
  endScope(result) {
    const tensorsToTrackInParent = getTensorsInContainer(result);
    const tensorsToTrackInParentSet = new Set(tensorsToTrackInParent.map((t) => t.id));
    for (let i = 0; i < this.state.activeScope.track.length; i++) {
      const tensor6 = this.state.activeScope.track[i];
      if (!tensor6.kept && !tensorsToTrackInParentSet.has(tensor6.id)) {
        tensor6.dispose();
      }
    }
    const oldScope = this.state.scopeStack.pop();
    this.state.activeScope = this.state.scopeStack.length === 0 ? null : this.state.scopeStack[this.state.scopeStack.length - 1];
    tensorsToTrackInParent.forEach((tensor6) => {
      if (!tensor6.kept && tensor6.scopeId === oldScope.id) {
        this.track(tensor6);
      }
    });
  }
  gradients(f, xs, dy, allowNoGradients = false) {
    assert(xs.length > 0, () => "gradients() received an empty list of xs.");
    if (dy != null && dy.dtype !== "float32") {
      throw new Error(`dy must have 'float32' dtype, but has '${dy.dtype}'`);
    }
    const y = this.scopedRun(() => this.startTape(), () => this.endTape(), () => this.tidy("forward", f));
    assert(y instanceof Tensor, () => "The result y returned by f() must be a tensor.");
    const filteredTape = getFilteredNodesXToY(this.state.activeTape, xs, y);
    if (!allowNoGradients && filteredTape.length === 0 && xs.length > 0) {
      throw new Error("Cannot compute gradient of y=f(x) with respect to x. Make sure that the f you passed encloses all operations that lead from x to y.");
    }
    return this.tidy("backward", () => {
      const accumulatedGradientMap = {};
      accumulatedGradientMap[y.id] = dy == null ? ones(y.shape) : dy;
      backpropagateGradients(accumulatedGradientMap, filteredTape, (f2) => this.tidy(f2), add);
      const grads = xs.map((x) => accumulatedGradientMap[x.id]);
      if (this.state.gradientDepth === 0) {
        this.state.activeTape.forEach((node) => {
          for (const tensor6 of node.saved) {
            tensor6.dispose();
          }
        });
        this.state.activeTape = null;
      }
      return {value: y, grads};
    });
  }
  customGrad(f) {
    assert(isFunction(f), () => "The f passed in customGrad(f) must be a function.");
    return (...inputs) => {
      assert(inputs.every((t) => t instanceof Tensor), () => "The args passed in customGrad(f)(x1, x2,...) must all be tensors");
      let res;
      const inputMap = {};
      inputs.forEach((input, i) => {
        inputMap[i] = input;
      });
      return this.runKernelFunc((_, save) => {
        res = f(...[...inputs, save]);
        assert(res.value instanceof Tensor, () => "The function f passed in customGrad(f) must return an object where `obj.value` is a tensor");
        assert(isFunction(res.gradFunc), () => "The function f passed in customGrad(f) must return an object where `obj.gradFunc` is a function.");
        return res.value;
      }, inputMap, (dy, saved) => {
        const gradRes = res.gradFunc(dy, saved);
        const grads = Array.isArray(gradRes) ? gradRes : [gradRes];
        assert(grads.length === inputs.length, () => "The function f passed in customGrad(f) must return an object where `obj.gradFunc` is a function that returns the same number of tensors as inputs passed to f(...).");
        assert(grads.every((t) => t instanceof Tensor), () => "The function f passed in customGrad(f) must return an object where `obj.gradFunc` is a function that returns a list of only tensors.");
        const gradMap = {};
        grads.forEach((grad, i) => {
          gradMap[i] = () => grad;
        });
        return gradMap;
      });
    };
  }
  readSync(dataId) {
    const info = this.state.tensorInfo.get(dataId);
    return info.backend.readSync(dataId);
  }
  read(dataId) {
    const info = this.state.tensorInfo.get(dataId);
    return info.backend.read(dataId);
  }
  async time(query) {
    const start = now();
    const timingInfo = await this.backend.time(query);
    timingInfo.wallMs = now() - start;
    return timingInfo;
  }
  track(result) {
    if (this.state.activeScope != null) {
      result.scopeId = this.state.activeScope.id;
      this.state.activeScope.track.push(result);
    }
    return result;
  }
  get registeredVariables() {
    return this.state.registeredVariables;
  }
  reset() {
    this.pendingBackendInitId++;
    this.state.dispose();
    this.ENV.reset();
    this.state = new EngineState();
    for (const backendName in this.registry) {
      this.disposeRegisteredKernels(backendName);
      this.registry[backendName].dispose();
      delete this.registry[backendName];
    }
    this.backendName = null;
    this.backendInstance = null;
    this.pendingBackendInit = null;
  }
}
Engine.nextTensorId = 0;
Engine.nextVariableId = 0;
function ones(shape) {
  const values = makeOnesTypedArray(sizeFromShape(shape), "float32");
  return ENGINE.makeTensor(values, shape, "float32");
}
function getOrMakeEngine() {
  const ns = getGlobalNamespace();
  if (ns._tfengine == null) {
    const environment6 = new Environment(ns);
    ns._tfengine = new Engine(environment6);
  }
  setEnvironmentGlobal(ns._tfengine.ENV);
  setTensorTracker(() => ns._tfengine);
  return ns._tfengine;
}
const ENGINE = getOrMakeEngine();
function add(a, b) {
  const inputs = {a, b};
  return ENGINE.runKernelFunc((backend2, save) => {
    const res = backend2.add(a, b);
    save([a, b]);
    return res;
  }, inputs, null, Add);
}
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function inferShape(val, dtype) {
  let firstElem = val;
  if (isTypedArray(val)) {
    return dtype === "string" ? [] : [val.length];
  }
  if (!Array.isArray(val)) {
    return [];
  }
  const shape = [];
  while (Array.isArray(firstElem) || isTypedArray(firstElem) && dtype !== "string") {
    shape.push(firstElem.length);
    firstElem = firstElem[0];
  }
  if (Array.isArray(val) && env().getBool("TENSORLIKE_CHECK_SHAPE_CONSISTENCY")) {
    deepAssertShapeConsistency(val, shape, []);
  }
  return shape;
}
function deepAssertShapeConsistency(val, shape, indices) {
  indices = indices || [];
  if (!Array.isArray(val) && !isTypedArray(val)) {
    assert(shape.length === 0, () => `Element arr[${indices.join("][")}] is a primitive, but should be an array/TypedArray of ${shape[0]} elements`);
    return;
  }
  assert(shape.length > 0, () => `Element arr[${indices.join("][")}] should be a primitive, but is an array of ${val.length} elements`);
  assert(val.length === shape[0], () => `Element arr[${indices.join("][")}] should have ${shape[0]} elements, but has ${val.length} elements`);
  const subShape = shape.slice(1);
  for (let i = 0; i < val.length; ++i) {
    deepAssertShapeConsistency(val[i], subShape, indices.concat(i));
  }
}
function assertDtype(expectedDtype, actualDType, argName, functionName) {
  if (expectedDtype == null) {
    return;
  }
  if (expectedDtype !== "numeric" && expectedDtype !== actualDType || expectedDtype === "numeric" && actualDType === "string") {
    throw new Error(`Argument '${argName}' passed to '${functionName}' must be ${expectedDtype} tensor, but got ${actualDType} tensor`);
  }
}
function convertToTensor(x, argName, functionName, parseAsDtype = "numeric") {
  if (x instanceof Tensor) {
    assertDtype(parseAsDtype, x.dtype, argName, functionName);
    return x;
  }
  let inferredDtype = inferDtype(x);
  if (inferredDtype !== "string" && ["bool", "int32", "float32"].indexOf(parseAsDtype) >= 0) {
    inferredDtype = parseAsDtype;
  }
  assertDtype(parseAsDtype, inferredDtype, argName, functionName);
  if (x == null || !isTypedArray(x) && !Array.isArray(x) && typeof x !== "number" && typeof x !== "boolean" && typeof x !== "string") {
    const type = x == null ? "null" : x.constructor.name;
    throw new Error(`Argument '${argName}' passed to '${functionName}' must be a Tensor or TensorLike, but got '${type}'`);
  }
  const inferredShape = inferShape(x, inferredDtype);
  if (!isTypedArray(x) && !Array.isArray(x)) {
    x = [x];
  }
  const skipTypedArray = true;
  const values = inferredDtype !== "string" ? toTypedArray(x, inferredDtype) : flatten(x, [], skipTypedArray);
  return ENGINE.makeTensor(values, inferredShape, inferredDtype);
}
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const OP_SCOPE_SUFFIX = "__op";
function op(f) {
  const keys = Object.keys(f);
  if (keys.length !== 1) {
    throw new Error(`Please provide an object with a single key (operation name) mapping to a function. Got an object with ${keys.length} keys.`);
  }
  let opName = keys[0];
  const fn = f[opName];
  if (opName.endsWith("_")) {
    opName = opName.substring(0, opName.length - 1);
  }
  opName = opName + OP_SCOPE_SUFFIX;
  const f2 = (...args) => {
    ENGINE.startScope(opName);
    try {
      const result = fn(...args);
      if (isPromise(result)) {
        console.error("Cannot return a Promise inside of tidy.");
      }
      ENGINE.endScope(result);
      return result;
    } catch (ex) {
      ENGINE.endScope(null);
      throw ex;
    }
  };
  Object.defineProperty(f2, "name", {value: opName, configurable: true});
  return f2;
}
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function complex_(real, imag) {
  const $real = convertToTensor(real, "real", "complex");
  const $imag = convertToTensor(imag, "imag", "complex");
  assertShapesMatch($real.shape, $imag.shape, `real and imag shapes, ${$real.shape} and ${$imag.shape}, must match in call to tf.complex().`);
  const forward = (backend2) => {
    return backend2.complex($real, $imag);
  };
  const inputs = {real: $real, imag: $imag};
  return ENGINE.runKernelFunc(forward, inputs, null, Complex);
}
const complex = op({complex_});
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function makeTensor(values, shape, inferredShape, dtype) {
  if (dtype == null) {
    dtype = inferDtype(values);
  }
  if (dtype === "complex64") {
    throw new Error(`Cannot construct a complex64 tensor directly. Please use tf.complex(real, imag).`);
  }
  if (!isTypedArray(values) && !Array.isArray(values) && typeof values !== "number" && typeof values !== "boolean" && typeof values !== "string") {
    throw new Error("values passed to tensor(values) must be a number/boolean/string or an array of numbers/booleans/strings, or a TypedArray");
  }
  if (shape != null) {
    assertNonNegativeIntegerDimensions(shape);
    const providedSize = sizeFromShape(shape);
    const inferredSize = sizeFromShape(inferredShape);
    assert(providedSize === inferredSize, () => `Based on the provided shape, [${shape}], the tensor should have ${providedSize} values but has ${inferredSize}`);
    for (let i = 0; i < inferredShape.length; ++i) {
      const inferred = inferredShape[i];
      const flatDimsDontMatch = i === inferredShape.length - 1 ? inferred !== sizeFromShape(shape.slice(i)) : true;
      assert(inferredShape[i] === shape[i] || !flatDimsDontMatch, () => `Error creating a new Tensor. Inferred shape (${inferredShape}) does not match the provided shape (${shape}). `);
    }
  }
  if (!isTypedArray(values) && !Array.isArray(values)) {
    values = [values];
  }
  shape = shape || inferredShape;
  values = dtype !== "string" ? toTypedArray(values, dtype) : flatten(values, [], true);
  return ENGINE.makeTensor(values, shape, dtype);
}
/**
 * @license
 * Copyright 2020 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function buffer(shape, dtype = "float32", values) {
  dtype = dtype || "float32";
  assertNonNegativeIntegerDimensions(shape);
  return new TensorBuffer(shape, dtype, values);
}
/**
 * @license
 * Copyright 2020 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function cast_(x, dtype) {
  const $x = convertToTensor(x, "x", "cast");
  if (!isValidDtype(dtype)) {
    throw new Error(`Failed to cast to unknown dtype ${dtype}`);
  }
  if (dtype === "string" && $x.dtype !== "string" || dtype !== "string" && $x.dtype === "string") {
    throw new Error("Only strings can be casted to strings");
  }
  const inputs = {x: $x};
  const attrs = {dtype};
  return ENGINE.runKernelFunc((backend2) => backend2.cast($x, dtype), inputs, null, Cast, attrs);
}
const cast = op({cast_});
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function reshape_(x, shape) {
  const $x = convertToTensor(x, "x", "reshape", null);
  const inputs = {x: $x};
  const attrs = {shape};
  const forward = (backend2, save) => {
    shape = inferFromImplicitShape(shape, $x.size);
    assert($x.size === sizeFromShape(shape), () => "new shape and old shape must have the same number of elements.");
    save([$x]);
    return backend2.reshape($x, shape);
  };
  return ENGINE.runKernelFunc(forward, inputs, null, Reshape, attrs);
}
const reshape = op({reshape_});
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function transpose_(x, perm) {
  const $x = convertToTensor(x, "x", "transpose");
  if (perm == null) {
    perm = $x.shape.map((s, i) => i).reverse();
  }
  assert($x.rank === perm.length, () => `Error in transpose: rank of input ${$x.rank} must match length of perm ${perm}.`);
  perm.forEach((axis) => {
    assert(axis >= 0 && axis < $x.rank, () => `All entries in 'perm' must be between 0 and ${$x.rank - 1} but got ${perm}`);
  });
  if ($x.rank <= 1) {
    return $x.clone();
  }
  const inputs = {x: $x};
  const attrs = {perm};
  return ENGINE.runKernelFunc((backend2) => backend2.transpose($x, perm), inputs, null, Transpose, attrs);
}
const transpose = op({transpose_});
const gather_nd_util_exports = {};
__export(gather_nd_util_exports, {
  prepareAndValidate: () => prepareAndValidate
});
function prepareAndValidate(tensor6, indices) {
  if (tensor6.rank < 1) {
    throw new Error(`tf.gatherND() expects the input to be rank 1 or higher, but the rank was ${tensor6.rank}.`);
  }
  if (indices.rank < 1) {
    throw new Error(`tf.gatherND() expects the indices to be rank 1 or higher, but the rank was ${indices.rank}.`);
  }
  if (indices.dtype !== "int32") {
    throw new Error(`tf.gatherND() expects the indices to be int32 type, but the dtype was ${indices.dtype}.`);
  }
  if (indices.shape[indices.rank - 1] > tensor6.rank) {
    throw new Error(`index innermost dimension length must be <= tensor rank; saw: ${indices.shape[indices.rank - 1]} vs. ${tensor6.rank}`);
  }
  if (tensor6.size === 0) {
    throw new Error(`Requested more than 0 entries, but input is empty. Input shape: ${tensor6.shape}.`);
  }
  const indicesShape = indices.shape;
  const sliceRank = indicesShape[indicesShape.length - 1];
  let nResult = 1;
  for (let i = 0; i < indicesShape.length - 1; ++i) {
    nResult *= indicesShape[i];
  }
  const inputShape = tensor6.shape;
  const resultShape = indicesShape.slice();
  resultShape.pop();
  let sliceSize = 1;
  for (let i = sliceRank; i < tensor6.rank; ++i) {
    sliceSize *= inputShape[i];
    resultShape.push(inputShape[i]);
  }
  const strides = [
    ...computeStrides(tensor6.shape).map((stride) => stride / sliceSize),
    1
  ].slice(0, sliceRank);
  return [resultShape, nResult, sliceSize, strides];
}
const scatter_nd_util_exports = {};
__export(scatter_nd_util_exports, {
  calculateShapes: () => calculateShapes,
  validateInput: () => validateInput,
  validateUpdateShape: () => validateUpdateShape
});
function validateUpdateShape(shape, indices, updates) {
  const sliceDim = indices.rank > 1 ? indices.shape[indices.rank - 1] : 1;
  const batchDim = indices.rank > 1 ? indices.rank - 1 : 1;
  const shapeError = `Must have updates.shape = indices.shape[:batchDim] + shape[sliceDim:], got updates.shape: ${updates.shape}, indices.shape: ${indices.shape}, shape: ${shape}, sliceDim: ${sliceDim}, and batchDim: ${batchDim}.`;
  if (updates.rank < batchDim) {
    throw new Error(shapeError + ` update.rank < ${batchDim}. `);
  }
  if (shape.length < sliceDim + (updates.rank - batchDim)) {
    throw new Error(shapeError + ` Output shape length < ${sliceDim + (updates.rank - batchDim)}`);
  }
  if (updates.rank !== batchDim + shape.length - sliceDim) {
    throw new Error(shapeError + ` update.rank != ${batchDim + shape.length - sliceDim}`);
  }
  for (let d = 0; d < batchDim; ++d) {
    if (updates.shape[d] !== indices.shape[d]) {
      throw new Error(shapeError + ` updates.shape[${d}] (${updates.shape[d]}) != indices.shape[${d}] (${indices.shape[d]}).`);
    }
  }
  for (let d = 0; d < updates.rank - batchDim; ++d) {
    if (updates.shape[d + batchDim] !== shape[d + sliceDim]) {
      throw new Error(shapeError + ` updates.shape[${d + batchDim}] (${updates.shape[d + batchDim]}) != shape[${d + batchDim}] (${shape[d + batchDim]})`);
    }
  }
}
function validateInput(updates, indices, shape) {
  if (indices.rank < 1) {
    throw new Error(`tf.scatterND() expects the indices to be rank 1 or higher, but the rank was ${indices.rank}.`);
  }
  if (updates.rank < 1) {
    throw new Error(`tf.scatterND() expects the updates to be rank 1 or higher, but the rank was ${updates.rank}.`);
  }
  if (indices.dtype !== "int32") {
    throw new Error(`The dtype of 'indices' should be int32, but got dtype: ${indices.dtype}`);
  }
  if (shape.length < 1) {
    throw new Error(`Output rank must be greater or equal to 1, but got shape: ${shape}`);
  }
  if (shape.length === 0) {
    if (indices.size === 0) {
      throw new Error(`Indices specified for empty output. indices shape: ${indices.shape}`);
    }
    if (updates.size === 0) {
      throw new Error(`Updates specified for empty output. updates shape: ${updates.shape}`);
    }
  }
  validateUpdateShape(shape, indices, updates);
}
function calculateShapes(updates, indices, shape) {
  const indicesRank = indices.shape.length;
  const sliceRank = indicesRank > 1 ? indices.shape[indicesRank - 1] : 1;
  const totalNd = shape.length;
  let sliceSize = 1;
  for (let i = sliceRank; i < totalNd; ++i) {
    sliceSize *= shape[i];
  }
  const safeSliceDim = sliceRank < 1 ? 1 : sliceRank;
  const numUpdates = sizeFromShape(indices.shape) / safeSliceDim;
  const strides = [...computeStrides(shape.slice(0, sliceRank)), 1];
  const outputSize = sizeFromShape(shape);
  return {sliceRank, numUpdates, sliceSize, strides, outputSize};
}
const slice_util_exports = {};
__export(slice_util_exports, {
  assertParamsValid: () => assertParamsValid,
  computeFlatOffset: () => computeFlatOffset,
  computeOutShape: () => computeOutShape,
  getNormalizedAxes: () => getNormalizedAxes,
  isSliceContinous: () => isSliceContinous,
  maskToAxes: () => maskToAxes,
  parseSliceParams: () => parseSliceParams,
  startForAxis: () => startForAxis,
  startIndicesWithElidedDims: () => startIndicesWithElidedDims,
  stopForAxis: () => stopForAxis,
  stopIndicesWithElidedDims: () => stopIndicesWithElidedDims,
  stridesForAxis: () => stridesForAxis,
  stridesWithElidedDims: () => stridesWithElidedDims
});
/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function assertParamsValid(input, begin, size) {
  const inputRank = input.shape.length;
  assert(inputRank === begin.length, () => `Error in slice${inputRank}D: Length of begin ${begin} must match the rank of the array (${inputRank}).`);
  assert(inputRank === size.length, () => `Error in slice${inputRank}D: Length of size ${size} must match the rank of the array (${inputRank}).`);
  for (let i = 0; i < inputRank; ++i) {
    assert(begin[i] + size[i] <= input.shape[i], () => `Error in slice${inputRank}D: begin[${i}] + size[${i}] (${begin[i] + size[i]}) would overflow input.shape[${i}] (${input.shape[i]})`);
  }
}
function maskToAxes(mask) {
  const axes = [];
  let axis = 0;
  while (mask > 0) {
    if (mask & 1) {
      axes.push(axis);
    }
    mask /= 2;
    axis++;
  }
  return axes;
}
function computeOutShape(begin, end, strides) {
  const size = [];
  for (let axis = 0; axis < begin.length; axis++) {
    size[axis] = Math.ceil((end[axis] - begin[axis]) / strides[axis]);
  }
  return size;
}
function stridesWithElidedDims(strides, ellipsisInsertionIndex, numElidedAxes, inputShape) {
  const newStrides = [...strides];
  for (let i = newStrides.length; i < inputShape.length; i++) {
    newStrides.push(1);
  }
  for (let i = 0; i < numElidedAxes; i++) {
    if (i === 0) {
      newStrides[ellipsisInsertionIndex] = 1;
    } else {
      newStrides.splice(ellipsisInsertionIndex, 0, 1);
      newStrides.pop();
    }
  }
  return newStrides;
}
function unnormalizeAxis(ellipsisInsertionIndex, numElidedAxes, normalizedAxis) {
  if (normalizedAxis <= ellipsisInsertionIndex) {
    return normalizedAxis;
  }
  return normalizedAxis - (numElidedAxes - 1);
}
function getElidedAxes(numElidedAxes, ellipsisInsertionIndex) {
  const elidedAxes = [];
  for (let i = 0; i < numElidedAxes; i++) {
    elidedAxes.push(ellipsisInsertionIndex + i);
  }
  return elidedAxes;
}
function getNormalizedAxes(inputShape, ellipsisAxes, numInterpolatedAxes, begin, end, strides, beginMask, endMask, ellipsisMask) {
  const inputRank = inputShape.length;
  let normalizedBegin = new Array(inputRank), normalizedEnd = new Array(inputRank), normalizedStrides = new Array(inputRank);
  if (ellipsisAxes.length && numInterpolatedAxes > 0) {
    const fullIndex = ellipsisAxes[0];
    const numElidedAxes = numInterpolatedAxes + 1;
    normalizedBegin = startIndicesWithElidedDims(beginMask, fullIndex, numElidedAxes, begin, inputShape);
    normalizedEnd = stopIndicesWithElidedDims(endMask, fullIndex, numElidedAxes, end, inputShape);
    normalizedStrides = stridesWithElidedDims(strides, fullIndex, numElidedAxes, inputShape);
  } else {
    for (let axis = 0; axis < inputRank; axis++) {
      normalizedBegin[axis] = startForAxis(beginMask, begin, strides, inputShape, axis, ellipsisMask);
      normalizedEnd[axis] = stopForAxis(endMask, end, strides, inputShape, axis, ellipsisMask);
      normalizedStrides[axis] = stridesForAxis(strides, axis, ellipsisMask);
    }
  }
  return {
    begin: normalizedBegin,
    end: normalizedEnd,
    strides: normalizedStrides
  };
}
function startIndicesWithElidedDims(beginMask, ellipsisInsertionIndex, numElidedAxes, originalBegin, inputShape) {
  const newIndices = [...inputShape];
  const elidedAxes = getElidedAxes(numElidedAxes, ellipsisInsertionIndex);
  for (let axis = 0; axis < newIndices.length; axis++) {
    if (elidedAxes.indexOf(axis) > -1) {
      newIndices[axis] = 0;
    } else {
      const originalAxis = unnormalizeAxis(ellipsisInsertionIndex, numElidedAxes, axis);
      let originalValue = originalBegin[originalAxis];
      if (beginMask & 1 << originalAxis) {
        originalValue = 0;
      }
      newIndices[axis] = originalValue;
    }
  }
  return newIndices;
}
function stopIndicesWithElidedDims(endMask, ellipsisInsertionIndex, numElidedAxes, originalEnd, inputShape) {
  const newIndices = [...inputShape];
  const elidedAxes = getElidedAxes(numElidedAxes, ellipsisInsertionIndex);
  for (let axis = 0; axis < newIndices.length; axis++) {
    if (elidedAxes.indexOf(axis) > -1) {
      newIndices[axis] = Number.MAX_SAFE_INTEGER;
    } else {
      const originalAxis = unnormalizeAxis(ellipsisInsertionIndex, numElidedAxes, axis);
      let originalValue = originalEnd[originalAxis];
      if (endMask & 1 << originalAxis) {
        originalValue = Number.MAX_SAFE_INTEGER;
      }
      newIndices[axis] = originalValue;
    }
  }
  for (let i = 0; i < newIndices.length; i++) {
    const axisSize = inputShape[i];
    if (newIndices[i] < 0) {
      newIndices[i] += axisSize;
    }
    newIndices[i] = clamp(0, newIndices[i], inputShape[i]);
  }
  return newIndices;
}
function stridesForAxis(strides, axis, ellipsisMask) {
  let stride = strides[axis];
  if (ellipsisMask & 1 << axis || stride == null) {
    stride = 1;
  }
  return stride;
}
function startForAxis(beginMask, startIndices, strides, inputShape, axis, ellipsisMask) {
  let start = startIndices[axis];
  const stride = strides[axis] || 1;
  if (beginMask & 1 << axis || ellipsisMask & 1 << axis || start == null) {
    if (stride > 0) {
      start = Number.MIN_SAFE_INTEGER;
    } else {
      start = Number.MAX_SAFE_INTEGER;
    }
  }
  const axisSize = inputShape[axis];
  if (start < 0) {
    start += axisSize;
  }
  start = clamp(0, start, axisSize - 1);
  return start;
}
function stopForAxis(endMask, stopIndices, strides, inputShape, axis, ellipsisMask) {
  let stop = stopIndices[axis];
  const stride = strides[axis] || 1;
  if (endMask & 1 << axis || ellipsisMask & 1 << axis || stop == null) {
    if (stride > 0) {
      stop = Number.MAX_SAFE_INTEGER;
    } else {
      stop = Number.MIN_SAFE_INTEGER;
    }
  }
  const axisSize = inputShape[axis];
  if (stop < 0) {
    stop += axisSize;
  }
  if (stride > 0) {
    stop = clamp(0, stop, axisSize);
  } else {
    stop = clamp(-1, stop, axisSize - 1);
  }
  return stop;
}
function isSliceContinous(shape, begin, size) {
  let firstNonOneAxis = size.length;
  for (let i = 0; i < size.length; i++) {
    if (size[i] > 1) {
      firstNonOneAxis = i;
      break;
    }
  }
  for (let i = firstNonOneAxis + 1; i < size.length; i++) {
    if (begin[i] > 0 || size[i] !== shape[i]) {
      return false;
    }
  }
  return true;
}
function computeFlatOffset(begin, strides) {
  let flatOffset = begin.length > 0 ? begin[begin.length - 1] : 1;
  for (let i = 0; i < begin.length - 1; i++) {
    flatOffset += begin[i] * strides[i];
  }
  return flatOffset;
}
function parseSliceParams(x, begin, size) {
  let begin_;
  const xRank = x.shape.length;
  if (typeof begin === "number") {
    begin_ = [begin, ...new Array(xRank - 1).fill(0)];
  } else if (begin.length < xRank) {
    begin_ = begin.concat(new Array(xRank - begin.length).fill(0));
  } else {
    begin_ = begin.slice();
  }
  begin_.forEach((d) => {
    assert(d !== -1, () => "slice() does not support negative begin indexing.");
  });
  let size_;
  if (size == null) {
    size_ = new Array(xRank).fill(-1);
  } else if (typeof size === "number") {
    size_ = [size, ...new Array(xRank - 1).fill(-1)];
  } else if (size.length < xRank) {
    size_ = size.concat(new Array(xRank - size.length).fill(-1));
  } else {
    size_ = size;
  }
  size_ = size_.map((d, i) => {
    if (d >= 0) {
      return d;
    } else {
      assert(d === -1, () => `Negative size values should be exactly -1 but got ${d} for the slice() size at index ${i}.`);
      return x.shape[i] - begin_[i];
    }
  });
  return [begin_, size_];
}
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function deprecationWarn(msg) {
  if (env().getBool("DEPRECATION_WARNINGS_ENABLED")) {
    console.warn(msg + " You can disable deprecation warnings with tf.disableDeprecationWarnings().");
  }
}
setDeprecationWarningFn(deprecationWarn);
function engine9() {
  return ENGINE;
}
function registerBackend(name, factory, priority = 1) {
  return ENGINE.registerBackend(name, factory, priority);
}
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function mul_(a, b) {
  let $a = convertToTensor(a, "a", "mul");
  let $b = convertToTensor(b, "b", "mul");
  [$a, $b] = makeTypesMatch($a, $b);
  const forward = (backend2, save) => {
    const res = backend2.multiply($a, $b);
    save([$a, $b]);
    return res;
  };
  const inputs = {a: $a, b: $b};
  return ENGINE.runKernelFunc(forward, inputs, null, Multiply);
}
const mul = op({mul_});
/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function axesAreInnerMostDims(axes, rank) {
  for (let i = 0; i < axes.length; ++i) {
    if (axes[axes.length - i - 1] !== rank - 1 - i) {
      return false;
    }
  }
  return true;
}
function combineLocations(outputLoc, reduceLoc, axes) {
  const rank = outputLoc.length + reduceLoc.length;
  const loc = [];
  let outIdx = 0;
  let reduceIdx = 0;
  for (let dim = 0; dim < rank; dim++) {
    if (axes.indexOf(dim) === -1) {
      loc.push(outputLoc[outIdx++]);
    } else {
      loc.push(reduceLoc[reduceIdx++]);
    }
  }
  return loc;
}
function computeOutAndReduceShapes(aShape, axes) {
  const outShape = [];
  const rank = aShape.length;
  for (let dim = 0; dim < rank; dim++) {
    if (axes.indexOf(dim) === -1) {
      outShape.push(aShape[dim]);
    }
  }
  const reduceShape = axes.map((dim) => aShape[dim]);
  return [outShape, reduceShape];
}
function expandShapeToKeepDim(shape, axes) {
  const reduceSubShape = axes.map((x) => 1);
  return combineLocations(shape, reduceSubShape, axes);
}
function assertAxesAreInnerMostDims(msg, axes, rank) {
  assert(axesAreInnerMostDims(axes, rank), () => `${msg} supports only inner-most axes for now. Got axes ${axes} and rank-${rank} input.`);
}
function getAxesPermutation(axes, rank) {
  if (axesAreInnerMostDims(axes, rank)) {
    return null;
  }
  const result = [];
  for (let i = 0; i < rank; ++i) {
    if (axes.indexOf(i) === -1) {
      result.push(i);
    }
  }
  axes.forEach((axis) => result.push(axis));
  return result;
}
function getUndoAxesPermutation(axes) {
  return axes.map((axis, i) => [i, axis]).sort((a, b) => a[1] - b[1]).map((x) => x[0]);
}
function getInnerMostAxes(numAxes, rank) {
  const res = [];
  for (let i = rank - numAxes; i < rank; ++i) {
    res.push(i);
  }
  return res;
}
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function computeDilation2DInfo(inputShape, filterShape, strides, pad2, dataFormat = "NHWC", dilations) {
  const inputChannels = inputShape[3];
  const $filterShape = [...filterShape, inputChannels];
  const $dataFormat = convertConv2DDataFormat(dataFormat);
  return computeConv2DInfo(inputShape, $filterShape, strides, dilations, pad2, null, null, $dataFormat);
}
function computePool2DInfo(inShape, filterSize, strides, dilations, pad2, roundingMode, dataFormat = "channelsLast") {
  const [filterHeight, filterWidth] = parseTupleParam(filterSize);
  let filterShape;
  if (dataFormat === "channelsLast") {
    filterShape = [filterHeight, filterWidth, inShape[3], inShape[3]];
  } else if (dataFormat === "channelsFirst") {
    filterShape = [filterHeight, filterWidth, inShape[1], inShape[1]];
  } else {
    throw new Error(`Unknown dataFormat ${dataFormat}`);
  }
  return computeConv2DInfo(inShape, filterShape, strides, dilations, pad2, roundingMode, false, dataFormat);
}
function computePool3DInfo(inShape, filterSize, strides, dilations, pad2, roundingMode, dataFormat = "NDHWC") {
  const [filterDepth, filterHeight, filterWidth] = parse3TupleParam(filterSize);
  let filterShape;
  let $dataFormat;
  if (dataFormat === "NDHWC") {
    $dataFormat = "channelsLast";
    filterShape = [filterDepth, filterHeight, filterWidth, inShape[4], inShape[4]];
  } else if (dataFormat === "NCDHW") {
    $dataFormat = "channelsFirst";
    filterShape = [filterDepth, filterHeight, filterWidth, inShape[1], inShape[1]];
  } else {
    throw new Error(`Unknown dataFormat ${dataFormat}`);
  }
  return computeConv3DInfo(inShape, filterShape, strides, dilations, pad2, false, $dataFormat, roundingMode);
}
function computeConv2DInfo(inShape, filterShape, strides, dilations, pad2, roundingMode, depthwise = false, dataFormat = "channelsLast") {
  let [batchSize, inHeight, inWidth, inChannels] = [-1, -1, -1, -1];
  if (dataFormat === "channelsLast") {
    [batchSize, inHeight, inWidth, inChannels] = inShape;
  } else if (dataFormat === "channelsFirst") {
    [batchSize, inChannels, inHeight, inWidth] = inShape;
  } else {
    throw new Error(`Unknown dataFormat ${dataFormat}`);
  }
  const [filterHeight, filterWidth, , filterChannels] = filterShape;
  const [strideHeight, strideWidth] = parseTupleParam(strides);
  const [dilationHeight, dilationWidth] = parseTupleParam(dilations);
  const effectiveFilterHeight = getEffectiveFilterSize(filterHeight, dilationHeight);
  const effectiveFilterWidth = getEffectiveFilterSize(filterWidth, dilationWidth);
  const {padInfo, outHeight, outWidth} = getPadAndOutInfo(pad2, inHeight, inWidth, strideHeight, strideWidth, effectiveFilterHeight, effectiveFilterWidth, roundingMode, dataFormat);
  const outChannels = depthwise ? filterChannels * inChannels : filterChannels;
  let outShape;
  if (dataFormat === "channelsFirst") {
    outShape = [batchSize, outChannels, outHeight, outWidth];
  } else if (dataFormat === "channelsLast") {
    outShape = [batchSize, outHeight, outWidth, outChannels];
  }
  return {
    batchSize,
    dataFormat,
    inHeight,
    inWidth,
    inChannels,
    outHeight,
    outWidth,
    outChannels,
    padInfo,
    strideHeight,
    strideWidth,
    filterHeight,
    filterWidth,
    effectiveFilterHeight,
    effectiveFilterWidth,
    dilationHeight,
    dilationWidth,
    inShape,
    outShape,
    filterShape
  };
}
function computeConv3DInfo(inShape, filterShape, strides, dilations, pad2, depthwise = false, dataFormat = "channelsLast", roundingMode) {
  let [batchSize, inDepth, inHeight, inWidth, inChannels] = [-1, -1, -1, -1, -1];
  if (dataFormat === "channelsLast") {
    [batchSize, inDepth, inHeight, inWidth, inChannels] = inShape;
  } else if (dataFormat === "channelsFirst") {
    [batchSize, inChannels, inDepth, inHeight, inWidth] = inShape;
  } else {
    throw new Error(`Unknown dataFormat ${dataFormat}`);
  }
  const [filterDepth, filterHeight, filterWidth, , filterChannels] = filterShape;
  const [strideDepth, strideHeight, strideWidth] = parse3TupleParam(strides);
  const [dilationDepth, dilationHeight, dilationWidth] = parse3TupleParam(dilations);
  const effectiveFilterDepth = getEffectiveFilterSize(filterDepth, dilationDepth);
  const effectiveFilterHeight = getEffectiveFilterSize(filterHeight, dilationHeight);
  const effectiveFilterWidth = getEffectiveFilterSize(filterWidth, dilationWidth);
  const {padInfo, outDepth, outHeight, outWidth} = get3DPadAndOutInfo(pad2, inDepth, inHeight, inWidth, strideDepth, strideHeight, strideWidth, effectiveFilterDepth, effectiveFilterHeight, effectiveFilterWidth, roundingMode);
  const outChannels = depthwise ? filterChannels * inChannels : filterChannels;
  let outShape;
  if (dataFormat === "channelsFirst") {
    outShape = [batchSize, outChannels, outDepth, outHeight, outWidth];
  } else if (dataFormat === "channelsLast") {
    outShape = [batchSize, outDepth, outHeight, outWidth, outChannels];
  }
  return {
    batchSize,
    dataFormat,
    inDepth,
    inHeight,
    inWidth,
    inChannels,
    outDepth,
    outHeight,
    outWidth,
    outChannels,
    padInfo,
    strideDepth,
    strideHeight,
    strideWidth,
    filterDepth,
    filterHeight,
    filterWidth,
    effectiveFilterDepth,
    effectiveFilterHeight,
    effectiveFilterWidth,
    dilationDepth,
    dilationHeight,
    dilationWidth,
    inShape,
    outShape,
    filterShape
  };
}
function computeOutputShape2D(inShape, fieldSize, stride, zeroPad, roundingMode) {
  if (zeroPad == null) {
    zeroPad = computeDefaultPad(inShape, fieldSize, stride);
  }
  const inputRows = inShape[0];
  const inputCols = inShape[1];
  const outputRows = conditionalRound((inputRows - fieldSize + 2 * zeroPad) / stride + 1, roundingMode);
  assert(isInt(outputRows), () => `The output # of rows (${outputRows}) must be an integer. Change the stride and/or zero pad parameters`);
  const outputCols = conditionalRound((inputCols - fieldSize + 2 * zeroPad) / stride + 1, roundingMode);
  assert(isInt(outputCols), () => `The output # of columns (${outputCols}) must be an integer. Change the stride and/or zero pad parameters`);
  return [outputRows, outputCols];
}
function computeOutputShape4D(inShape, fieldSize, outChannels, stride, zeroPad, roundingMode) {
  if (zeroPad == null) {
    zeroPad = computeDefaultPad(inShape, fieldSize, stride);
  }
  const inputDepth = inShape[0];
  const inputRows = inShape[1];
  const inputCols = inShape[2];
  const outputDepths = conditionalRound((inputDepth - fieldSize + 2 * zeroPad) / stride + 1, roundingMode);
  assert(isInt(outputDepths), () => `The output # of depths (${outputDepths}) must be an integer. Change the stride and/or zero pad parameters`);
  const outputRows = conditionalRound((inputRows - fieldSize + 2 * zeroPad) / stride + 1, roundingMode);
  assert(isInt(outputRows), () => `The output # of rows (${outputRows}) must be an integer. Change the stride and/or zero pad parameters`);
  const outputCols = conditionalRound((inputCols - fieldSize + 2 * zeroPad) / stride + 1, roundingMode);
  assert(isInt(outputCols), () => `The output # of columns (${outputCols}) must be an integer. Change the stride and/or zero pad parameters`);
  return [outputDepths, outputRows, outputCols, outChannels];
}
function computeDefaultPad(inputShape, fieldSize, stride, dilation = 1) {
  const effectiveFieldSize = getEffectiveFilterSize(fieldSize, dilation);
  return Math.floor((inputShape[0] * (stride - 1) - stride + effectiveFieldSize) / 2);
}
function parseTupleParam(param) {
  if (typeof param === "number") {
    return [param, param, param];
  }
  if (param.length === 2) {
    return [param[0], param[1], 1];
  }
  return param;
}
function parse3TupleParam(param) {
  return typeof param === "number" ? [param, param, param] : param;
}
function getEffectiveFilterSize(filterSize, dilation) {
  if (dilation <= 1) {
    return filterSize;
  }
  return filterSize + (filterSize - 1) * (dilation - 1);
}
function getPadAndOutInfo(pad2, inHeight, inWidth, strideHeight, strideWidth, filterHeight, filterWidth, roundingMode, dataFormat) {
  let padInfo;
  let outHeight;
  let outWidth;
  if (typeof pad2 === "number") {
    const padType = pad2 === 0 ? "VALID" : "NUMBER";
    padInfo = {top: pad2, bottom: pad2, left: pad2, right: pad2, type: padType};
    const outShape = computeOutputShape2D([inHeight, inWidth], filterHeight, strideHeight, pad2, roundingMode);
    outHeight = outShape[0];
    outWidth = outShape[1];
  } else if (pad2 === "same") {
    outHeight = Math.ceil(inHeight / strideHeight);
    outWidth = Math.ceil(inWidth / strideWidth);
    const padAlongHeight = Math.max(0, (outHeight - 1) * strideHeight + filterHeight - inHeight);
    const padAlongWidth = Math.max(0, (outWidth - 1) * strideWidth + filterWidth - inWidth);
    const top = Math.floor(padAlongHeight / 2);
    const bottom = padAlongHeight - top;
    const left = Math.floor(padAlongWidth / 2);
    const right = padAlongWidth - left;
    padInfo = {top, bottom, left, right, type: "SAME"};
  } else if (pad2 === "valid") {
    padInfo = {top: 0, bottom: 0, left: 0, right: 0, type: "VALID"};
    outHeight = Math.ceil((inHeight - filterHeight + 1) / strideHeight);
    outWidth = Math.ceil((inWidth - filterWidth + 1) / strideWidth);
  } else if (typeof pad2 === "object") {
    const top = dataFormat === "channelsLast" ? pad2[1][0] : pad2[2][0];
    const bottom = dataFormat === "channelsLast" ? pad2[1][1] : pad2[2][1];
    const left = dataFormat === "channelsLast" ? pad2[2][0] : pad2[3][0];
    const right = dataFormat === "channelsLast" ? pad2[2][1] : pad2[3][1];
    const padType = top === 0 && bottom === 0 && left === 0 && right === 0 ? "VALID" : "EXPLICIT";
    padInfo = {top, bottom, left, right, type: padType};
    outHeight = conditionalRound((inHeight - filterHeight + top + bottom) / strideHeight + 1, roundingMode);
    outWidth = conditionalRound((inWidth - filterWidth + left + right) / strideWidth + 1, roundingMode);
  } else {
    throw Error(`Unknown padding parameter: ${pad2}`);
  }
  return {padInfo, outHeight, outWidth};
}
function get3DPadAndOutInfo(pad2, inDepth, inHeight, inWidth, strideDepth, strideHeight, strideWidth, filterDepth, filterHeight, filterWidth, roundingMode) {
  let padInfo;
  let outDepth;
  let outHeight;
  let outWidth;
  if (typeof pad2 === "number") {
    const padType = pad2 === 0 ? "VALID" : "NUMBER";
    padInfo = {
      top: pad2,
      bottom: pad2,
      left: pad2,
      right: pad2,
      front: pad2,
      back: pad2,
      type: padType
    };
    const outShape = computeOutputShape4D([inDepth, inHeight, inWidth, 1], filterDepth, 1, strideDepth, pad2, roundingMode);
    outDepth = outShape[0];
    outHeight = outShape[1];
    outWidth = outShape[2];
  } else if (pad2 === "same") {
    outDepth = Math.ceil(inDepth / strideDepth);
    outHeight = Math.ceil(inHeight / strideHeight);
    outWidth = Math.ceil(inWidth / strideWidth);
    const padAlongDepth = (outDepth - 1) * strideDepth + filterDepth - inDepth;
    const padAlongHeight = (outHeight - 1) * strideHeight + filterHeight - inHeight;
    const padAlongWidth = (outWidth - 1) * strideWidth + filterWidth - inWidth;
    const front = Math.floor(padAlongDepth / 2);
    const back = padAlongDepth - front;
    const top = Math.floor(padAlongHeight / 2);
    const bottom = padAlongHeight - top;
    const left = Math.floor(padAlongWidth / 2);
    const right = padAlongWidth - left;
    padInfo = {top, bottom, left, right, front, back, type: "SAME"};
  } else if (pad2 === "valid") {
    padInfo = {
      top: 0,
      bottom: 0,
      left: 0,
      right: 0,
      front: 0,
      back: 0,
      type: "VALID"
    };
    outDepth = Math.ceil((inDepth - filterDepth + 1) / strideDepth);
    outHeight = Math.ceil((inHeight - filterHeight + 1) / strideHeight);
    outWidth = Math.ceil((inWidth - filterWidth + 1) / strideWidth);
  } else {
    throw Error(`Unknown padding parameter: ${pad2}`);
  }
  return {padInfo, outDepth, outHeight, outWidth};
}
function conditionalRound(value, roundingMode) {
  if (!roundingMode) {
    return value;
  }
  switch (roundingMode) {
    case "round":
      return Math.round(value);
    case "ceil":
      return Math.ceil(value);
    case "floor":
      return Math.floor(value);
    default:
      throw new Error(`Unknown roundingMode ${roundingMode}`);
  }
}
function tupleValuesAreOne(param) {
  const [dimA, dimB, dimC] = parseTupleParam(param);
  return dimA === 1 && dimB === 1 && dimC === 1;
}
function eitherStridesOrDilationsAreOne(strides, dilations) {
  return tupleValuesAreOne(strides) || tupleValuesAreOne(dilations);
}
function convertConv2DDataFormat(dataFormat) {
  if (dataFormat === "NHWC") {
    return "channelsLast";
  } else if (dataFormat === "NCHW") {
    return "channelsFirst";
  } else {
    throw new Error(`Unknown dataFormat ${dataFormat}`);
  }
}
/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function assertParamsConsistent(shapes, axis) {
  const rank = shapes[0].length;
  shapes.forEach((shape, i) => {
    assert(shape.length === rank, () => `Error in concat${rank}D: rank of tensors[${i}] must be the same as the rank of the rest (${rank})`);
  });
  assert(axis >= 0 && axis < rank, () => `Error in concat${rank}D: axis must be between 0 and ${rank - 1}.`);
  const firstShape = shapes[0];
  shapes.forEach((shape, i) => {
    for (let r = 0; r < rank; r++) {
      assert(r === axis || shape[r] === firstShape[r], () => `Error in concat${rank}D: Shape of tensors[${i}] (${shape}) does not match the shape of the rest (${firstShape}) along the non-concatenated axis ${i}.`);
    }
  });
}
function computeOutShape2(shapes, axis) {
  const outputShape = shapes[0].slice();
  for (let i = 1; i < shapes.length; i++) {
    outputShape[axis] += shapes[i][axis];
  }
  return outputShape;
}
/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function getBroadcastDims(inShape, outShape) {
  const inRank = inShape.length;
  const dims = [];
  for (let i = 0; i < inRank; i++) {
    const dim = inRank - 1 - i;
    const a = inShape[dim] || 1;
    const b = outShape[outShape.length - 1 - i] || 1;
    if (b > 1 && a === 1) {
      dims.unshift(dim);
    }
  }
  return dims;
}
function getReductionAxes(inShape, outShape) {
  const result = [];
  for (let i = 0; i < outShape.length; i++) {
    const inDim = inShape[inShape.length - i - 1];
    const outAxis = outShape.length - i - 1;
    const outDim = outShape[outAxis];
    if (inDim == null || inDim === 1 && outDim > 1) {
      result.unshift(outAxis);
    }
  }
  return result;
}
function assertAndGetBroadcastShape(shapeA, shapeB) {
  const result = [];
  const l = Math.max(shapeA.length, shapeB.length);
  for (let i = 0; i < l; i++) {
    let a = shapeA[shapeA.length - i - 1];
    if (a == null) {
      a = 1;
    }
    let b = shapeB[shapeB.length - i - 1];
    if (b == null) {
      b = 1;
    }
    if (a === 1) {
      result.unshift(b);
    } else if (b === 1) {
      result.unshift(a);
    } else if (a !== b) {
      const errMsg = `Operands could not be broadcast together with shapes ${shapeA} and ${shapeB}.`;
      throw Error(errMsg);
    } else {
      result.unshift(a);
    }
  }
  return result;
}
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function elu_(x) {
  const $x = convertToTensor(x, "x", "elu");
  const forward = (backend2, save) => {
    const y = backend2.elu($x);
    save([y]);
    return y;
  };
  const inputs = {x: $x};
  return ENGINE.runKernelFunc(forward, inputs, null, Elu);
}
const elu = op({elu_});
const segment_util_exports = {};
__export(segment_util_exports, {
  collectGatherOpShapeInfo: () => collectGatherOpShapeInfo,
  computeOutShape: () => computeOutShape3,
  segOpComputeOptimalWindowSize: () => segOpComputeOptimalWindowSize
});
/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const PARALLELIZE_THRESHOLD = 30;
function computeOptimalWindowSize(inSize) {
  if (inSize <= PARALLELIZE_THRESHOLD) {
    return inSize;
  }
  return nearestDivisor(inSize, Math.floor(Math.sqrt(inSize)));
}
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function segOpComputeOptimalWindowSize(inSize, numSegments) {
  let done = false;
  let res;
  if (inSize <= PARALLELIZE_THRESHOLD) {
    res = inSize;
    done = true;
  } else {
    res = nearestDivisor(inSize, Math.floor(Math.sqrt(inSize)));
  }
  while (!done) {
    if (res > numSegments || res === inSize) {
      done = true;
    } else {
      res = nearestDivisor(inSize, res + 1);
    }
  }
  return res;
}
function computeOutShape3(aShape, axis, numSegments) {
  const outShape = [];
  const rank = aShape.length;
  for (let dim = 0; dim < rank; dim++) {
    if (dim !== axis) {
      outShape.push(aShape[dim]);
    } else {
      outShape.push(numSegments);
    }
  }
  return outShape;
}
function collectGatherOpShapeInfo(x, indices, axis) {
  const dimSize = x.shape[axis];
  const outputShape = [];
  let batchSize = 1;
  let sliceSize = 1;
  for (let i = 0; i < axis; i++) {
    outputShape.push(x.shape[i]);
    batchSize *= x.shape[i];
  }
  for (let i = 0; i < indices.rank; i++) {
    outputShape.push(indices.shape[i]);
  }
  for (let i = axis + 1; i < x.rank; i++) {
    outputShape.push(x.shape[i]);
    sliceSize *= x.shape[i];
  }
  return {batchSize, sliceSize, dimSize, outputShape};
}
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function scalar(value, dtype) {
  if ((isTypedArray(value) && dtype !== "string" || Array.isArray(value)) && dtype !== "complex64") {
    throw new Error("Error creating a new Scalar: value must be a primitive (number|boolean|string)");
  }
  if (dtype === "string" && isTypedArray(value) && !(value instanceof Uint8Array)) {
    throw new Error("When making a scalar from encoded string, the value must be `Uint8Array`.");
  }
  const shape = [];
  const inferredShape = [];
  return makeTensor(value, shape, inferredShape, dtype);
}
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function sum_(x, axis = null, keepDims = false) {
  let $x = convertToTensor(x, "x", "sum");
  if ($x.dtype === "bool") {
    $x = cast($x, "int32");
  }
  const forward = (backend2, save) => {
    save([$x]);
    const axes = parseAxisParam(axis, $x.shape);
    const permutation = getAxesPermutation(axes, $x.rank);
    let reductionAxes = axes;
    let permutedX = $x;
    if (permutation != null) {
      permutedX = transpose($x, permutation);
      reductionAxes = getInnerMostAxes(reductionAxes.length, $x.rank);
    }
    let value = backend2.sum(permutedX, reductionAxes);
    if (keepDims) {
      const newShape = expandShapeToKeepDim(value.shape, axes);
      value = reshape(value, newShape);
    }
    return value;
  };
  const inputs = {x: $x};
  const attrs = {axis, keepDims};
  return ENGINE.runKernelFunc(forward, inputs, null, Sum, attrs);
}
const sum2 = op({sum_});
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function zeros(shape, dtype = "float32") {
  if (dtype === "complex64") {
    const real = zeros(shape, "float32");
    const imag = zeros(shape, "float32");
    return complex(real, imag);
  }
  const values = makeZerosTypedArray(sizeFromShape(shape), dtype);
  return ENGINE.makeTensor(values, shape, dtype);
}
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function prelu_(x, alpha) {
  const $x = convertToTensor(x, "x", "prelu");
  const $alpha = convertToTensor(alpha, "alpha", "prelu");
  const forward = (backend2, save) => {
    const res = backend2.prelu($x, $alpha);
    save([$x, $alpha]);
    return res;
  };
  const inputs = {x: $x, alpha: $alpha};
  return ENGINE.runKernelFunc(forward, inputs, null, Prelu);
}
const prelu = op({prelu_});
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function tensor1d(values, dtype) {
  assertNonNull(values);
  const inferredShape = inferShape(values, dtype);
  if (inferredShape.length !== 1) {
    throw new Error("tensor1d() requires values to be a flat/TypedArray");
  }
  const shape = null;
  return makeTensor(values, shape, inferredShape, dtype);
}
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function relu_(x) {
  const $x = convertToTensor(x, "x", "relu");
  const forward = (backend2, save) => {
    save([$x]);
    if ($x.dtype === "bool") {
      return cast($x, "int32");
    }
    return backend2.relu($x);
  };
  const inputs = {x: $x};
  return ENGINE.runKernelFunc(forward, inputs, null, Relu);
}
const relu = op({relu_});
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function relu6_(x) {
  const $x = convertToTensor(x, "x", "relu6");
  const forward = (backend2, save) => {
    save([$x]);
    if ($x.dtype === "bool") {
      return cast($x, "int32");
    }
    return backend2.relu6($x);
  };
  const inputs = {x: $x};
  return ENGINE.runKernelFunc(forward, inputs, null, Relu6);
}
const relu6 = op({relu6_});
function prepareSplitSize(x, numOrSizeSplits, axis = 0) {
  let splitSizes = [];
  if (typeof numOrSizeSplits === "number") {
    assert(x.shape[axis] % numOrSizeSplits === 0, () => "Number of splits must evenly divide the axis.");
    splitSizes = new Array(numOrSizeSplits).fill(x.shape[axis] / numOrSizeSplits);
  } else {
    const numOfNegs = numOrSizeSplits.reduce((count, value) => {
      if (value === -1) {
        count += 1;
      }
      return count;
    }, 0);
    assert(numOfNegs <= 1, () => "There should be only one negative value in split array.");
    const negIndex = numOrSizeSplits.indexOf(-1);
    if (negIndex !== -1) {
      const total = numOrSizeSplits.reduce((a, b) => b > 0 ? a + b : a);
      numOrSizeSplits[negIndex] = x.shape[axis] - total;
    }
    assert(x.shape[axis] === numOrSizeSplits.reduce((a, b) => a + b), () => "The sum of sizes must match the size of the axis dimension.");
    splitSizes = numOrSizeSplits;
  }
  return splitSizes;
}
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function step_(x, alpha = 0) {
  const $x = convertToTensor(x, "x", "step");
  const inputs = {x: $x};
  const attrs = {alpha};
  return ENGINE.runKernelFunc((backend2) => backend2.step($x, alpha), inputs, null, Step, attrs);
}
const step = op({step_});
/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function getFusedDyActivation(dy, y, activation) {
  if (activation == null || activation === "linear") {
    return dy;
  }
  if (activation === "relu") {
    return mul(dy, step(y));
  }
  throw new Error(`Cannot compute gradient for fused activation ${activation}.`);
}
function getFusedBiasGradient(bias, dyActivation) {
  let res = dyActivation;
  const reduceAxes = getReductionAxes(bias.shape, dyActivation.shape);
  if (reduceAxes.length > 0) {
    res = sum2(res, reduceAxes);
  }
  return reshape(res, bias.shape);
}
function applyActivation(x, activation, preluActivationWeights) {
  if (activation === "linear") {
    return x;
  } else if (activation === "relu") {
    return relu(x);
  } else if (activation === "elu") {
    return elu(x);
  } else if (activation === "relu6") {
    return relu6(x);
  } else if (activation === "prelu") {
    return prelu(x, preluActivationWeights);
  }
  throw new Error(`Unknown fused activation ${activation}.`);
}
const shouldFuse = (gradientDepth, activation) => {
  const gradientMode = gradientDepth > 0;
  return !gradientMode || activation === "linear";
};
const backend_util_exports = {};
__export(backend_util_exports, {
  ERF_A1: () => ERF_A1,
  ERF_A2: () => ERF_A2,
  ERF_A3: () => ERF_A3,
  ERF_A4: () => ERF_A4,
  ERF_A5: () => ERF_A5,
  ERF_P: () => ERF_P,
  PARALLELIZE_THRESHOLD: () => PARALLELIZE_THRESHOLD,
  SELU_SCALE: () => SELU_SCALE,
  SELU_SCALEALPHA: () => SELU_SCALEALPHA,
  applyActivation: () => applyActivation,
  assertAndGetBroadcastShape: () => assertAndGetBroadcastShape,
  assertAxesAreInnerMostDims: () => assertAxesAreInnerMostDims,
  assertParamsConsistent: () => assertParamsConsistent,
  assignToTypedArray: () => assignToTypedArray,
  axesAreInnerMostDims: () => axesAreInnerMostDims,
  calculateShapes: () => calculateShapes,
  castTensor: () => castTensor,
  combineLocations: () => combineLocations,
  complexWithEvenIndex: () => complexWithEvenIndex,
  complexWithOddIndex: () => complexWithOddIndex,
  computeConv2DInfo: () => computeConv2DInfo,
  computeConv3DInfo: () => computeConv3DInfo,
  computeDefaultPad: () => computeDefaultPad,
  computeDilation2DInfo: () => computeDilation2DInfo,
  computeOptimalWindowSize: () => computeOptimalWindowSize,
  computeOutAndReduceShapes: () => computeOutAndReduceShapes,
  computeOutShape: () => computeOutShape2,
  computePool2DInfo: () => computePool2DInfo,
  computePool3DInfo: () => computePool3DInfo,
  convertConv2DDataFormat: () => convertConv2DDataFormat,
  eitherStridesOrDilationsAreOne: () => eitherStridesOrDilationsAreOne,
  expandShapeToKeepDim: () => expandShapeToKeepDim,
  exponent: () => exponent,
  exponents: () => exponents,
  getAxesPermutation: () => getAxesPermutation,
  getBroadcastDims: () => getBroadcastDims,
  getComplexWithIndex: () => getComplexWithIndex,
  getFusedBiasGradient: () => getFusedBiasGradient,
  getFusedDyActivation: () => getFusedDyActivation,
  getImageCenter: () => getImageCenter,
  getInnerMostAxes: () => getInnerMostAxes,
  getPermuted: () => getPermuted,
  getReductionAxes: () => getReductionAxes,
  getReshaped: () => getReshaped,
  getReshapedPermuted: () => getReshapedPermuted,
  getSliceBeginCoords: () => getSliceBeginCoords,
  getSliceSize: () => getSliceSize,
  getUndoAxesPermutation: () => getUndoAxesPermutation,
  linspaceImpl: () => linspaceImpl,
  log: () => log,
  mergeRealAndImagArrays: () => mergeRealAndImagArrays,
  prepareAndValidate: () => prepareAndValidate,
  prepareSplitSize: () => prepareSplitSize,
  reshapeTensor: () => reshapeTensor,
  segment_util: () => segment_util_exports,
  shouldFuse: () => shouldFuse,
  slice_util: () => slice_util_exports,
  splitRealAndImagArrays: () => splitRealAndImagArrays,
  tupleValuesAreOne: () => tupleValuesAreOne,
  upcastType: () => upcastType,
  validateInput: () => validateInput,
  validateUpdateShape: () => validateUpdateShape,
  warn: () => warn
});
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function getImageCenter(center, imageHeight, imageWidth) {
  const centerX = imageWidth * (typeof center === "number" ? center : center[0]);
  const centerY = imageHeight * (typeof center === "number" ? center : center[1]);
  return [centerX, centerY];
}
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function getReshaped(inputShape, blockShape, prod, batchToSpace = true) {
  let reshaped = [];
  if (batchToSpace) {
    reshaped = reshaped.concat(blockShape.slice(0));
    reshaped.push(inputShape[0] / prod);
    reshaped = reshaped.concat(inputShape.slice(1));
  } else {
    reshaped = reshaped.concat(inputShape[0]);
    const spatialLength = blockShape.length;
    for (let i = 0; i < spatialLength; ++i) {
      reshaped = reshaped.concat([inputShape[i + 1] / blockShape[i], blockShape[i]]);
    }
    reshaped = reshaped.concat(inputShape.slice(spatialLength + 1));
  }
  return reshaped;
}
function getPermuted(reshapedRank, blockShapeRank, batchToSpace = true) {
  const permuted = [];
  if (batchToSpace) {
    permuted.push(blockShapeRank);
    for (let i = blockShapeRank + 1; i < reshapedRank; ++i) {
      if (i <= 2 * blockShapeRank) {
        permuted.push(i);
        permuted.push(i - (blockShapeRank + 1));
      } else {
        permuted.push(i);
      }
    }
  } else {
    const permutedBeforeBatch = [];
    const permutedAfterBatch = [];
    for (let i = 1; i < reshapedRank; ++i) {
      if (i >= blockShapeRank * 2 + 1 || i % 2 === 1) {
        permutedAfterBatch.push(i);
      } else {
        permutedBeforeBatch.push(i);
      }
    }
    permuted.push(...permutedBeforeBatch);
    permuted.push(0);
    permuted.push(...permutedAfterBatch);
  }
  return permuted;
}
function getReshapedPermuted(inputShape, blockShape, prod, batchToSpace = true) {
  const reshapedPermuted = [];
  if (batchToSpace) {
    reshapedPermuted.push(inputShape[0] / prod);
  } else {
    reshapedPermuted.push(inputShape[0] * prod);
  }
  for (let i = 1; i < inputShape.length; ++i) {
    if (i <= blockShape.length) {
      if (batchToSpace) {
        reshapedPermuted.push(blockShape[i - 1] * inputShape[i]);
      } else {
        reshapedPermuted.push(inputShape[i] / blockShape[i - 1]);
      }
    } else {
      reshapedPermuted.push(inputShape[i]);
    }
  }
  return reshapedPermuted;
}
function getSliceBeginCoords(crops, blockShape) {
  const sliceBeginCoords = [0];
  for (let i = 0; i < blockShape; ++i) {
    sliceBeginCoords.push(crops[i][0]);
  }
  return sliceBeginCoords;
}
function getSliceSize(uncroppedShape, crops, blockShape) {
  const sliceSize = uncroppedShape.slice(0, 1);
  for (let i = 0; i < blockShape; ++i) {
    sliceSize.push(uncroppedShape[i + 1] - crops[i][0] - crops[i][1]);
  }
  return sliceSize;
}
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const SELU_SCALEALPHA = 1.7580993408473768;
const SELU_SCALE = 1.0507009873554805;
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const ERF_P = 0.3275911;
const ERF_A1 = 0.254829592;
const ERF_A2 = -0.284496736;
const ERF_A3 = 1.421413741;
const ERF_A4 = -1.453152027;
const ERF_A5 = 1.061405429;
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function warn(...msg) {
  if (!env().getBool("IS_TEST")) {
    console.warn(...msg);
  }
}
function log(...msg) {
  if (!env().getBool("IS_TEST")) {
    console.log(...msg);
  }
}
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function mergeRealAndImagArrays(real, imag) {
  if (real.length !== imag.length) {
    throw new Error(`Cannot merge real and imag arrays of different lengths. real:${real.length}, imag: ${imag.length}.`);
  }
  const result = new Float32Array(real.length * 2);
  for (let i = 0; i < result.length; i += 2) {
    result[i] = real[i / 2];
    result[i + 1] = imag[i / 2];
  }
  return result;
}
function splitRealAndImagArrays(complex3) {
  const real = new Float32Array(complex3.length / 2);
  const imag = new Float32Array(complex3.length / 2);
  for (let i = 0; i < complex3.length; i += 2) {
    real[i / 2] = complex3[i];
    imag[i / 2] = complex3[i + 1];
  }
  return {real, imag};
}
function complexWithEvenIndex(complex3) {
  const len = Math.ceil(complex3.length / 4);
  const real = new Float32Array(len);
  const imag = new Float32Array(len);
  for (let i = 0; i < complex3.length; i += 4) {
    real[Math.floor(i / 4)] = complex3[i];
    imag[Math.floor(i / 4)] = complex3[i + 1];
  }
  return {real, imag};
}
function complexWithOddIndex(complex3) {
  const len = Math.floor(complex3.length / 4);
  const real = new Float32Array(len);
  const imag = new Float32Array(len);
  for (let i = 2; i < complex3.length; i += 4) {
    real[Math.floor(i / 4)] = complex3[i];
    imag[Math.floor(i / 4)] = complex3[i + 1];
  }
  return {real, imag};
}
function getComplexWithIndex(complex3, index) {
  const real = complex3[index * 2];
  const imag = complex3[index * 2 + 1];
  return {real, imag};
}
function assignToTypedArray(data2, real, imag, index) {
  data2[index * 2] = real;
  data2[index * 2 + 1] = imag;
}
function exponents(n, inverse) {
  const real = new Float32Array(n / 2);
  const imag = new Float32Array(n / 2);
  for (let i = 0; i < Math.ceil(n / 2); i++) {
    const x = (inverse ? 2 : -2) * Math.PI * (i / n);
    real[i] = Math.cos(x);
    imag[i] = Math.sin(x);
  }
  return {real, imag};
}
function exponent(k, n, inverse) {
  const x = (inverse ? 2 : -2) * Math.PI * (k / n);
  const real = Math.cos(x);
  const imag = Math.sin(x);
  return {real, imag};
}
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function castTensor(x, dtype, backend2) {
  if (dtype === "complex64") {
    if (x.dtype === "complex64") {
      return x.clone();
    }
    const zerosTensor = zeros(x.shape);
    const floatX = cast(x, "float32");
    const result = backend2.complex(floatX, zerosTensor);
    zerosTensor.dispose();
    floatX.dispose();
    return result;
  }
  if (!hasEncodingLoss(x.dtype, dtype)) {
    return ENGINE.makeTensorFromDataId(x.dataId, x.shape, dtype);
  }
  if (x.dtype === "complex64") {
    const real = backend2.real(x);
    const result = cast(real, dtype);
    real.dispose();
    return result;
  }
  if (dtype === "int32") {
    return backend2.int(x);
  } else if (dtype === "bool") {
    const zero = scalar(0, x.dtype);
    const result = backend2.notEqual(x, zero);
    zero.dispose();
    return result;
  } else {
    throw new Error(`Error in Cast: failed to cast ${x.dtype} to ${dtype}`);
  }
}
function reshapeTensor(x, shape) {
  return ENGINE.makeTensorFromDataId(x.dataId, shape, x.dtype);
}
function linspaceImpl(start, stop, num) {
  const step3 = (stop - start) / (num - 1);
  const values = makeZerosTypedArray(num, "float32");
  values[0] = start;
  for (let i = 1; i < values.length; i++) {
    values[i] = values[i - 1] + step3;
  }
  return tensor1d(values, "float32");
}
/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
var CppDType;
(function(CppDType2) {
  CppDType2[CppDType2["float32"] = 0] = "float32";
  CppDType2[CppDType2["int32"] = 1] = "int32";
  CppDType2[CppDType2["bool"] = 2] = "bool";
  CppDType2[CppDType2["string"] = 3] = "string";
  CppDType2[CppDType2["complex64"] = 4] = "complex64";
})(CppDType || (CppDType = {}));
var FusableActivation;
(function(FusableActivation2) {
  FusableActivation2[FusableActivation2["linear"] = 0] = "linear";
  FusableActivation2[FusableActivation2["relu"] = 1] = "relu";
  FusableActivation2[FusableActivation2["relu6"] = 2] = "relu6";
  FusableActivation2[FusableActivation2["prelu"] = 3] = "prelu";
})(FusableActivation || (FusableActivation = {}));
/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
let wasmFusedMatMul;
function setup(backend2) {
  wasmFusedMatMul = backend2.wasm.cwrap(_FusedMatMul, null, [
    "number",
    "array",
    "number",
    "number",
    "array",
    "number",
    "number",
    "number",
    "number",
    "number",
    "number",
    "number"
  ]);
}
function fusedBatchMatMul(args) {
  const {inputs, backend: backend2, attrs} = args;
  const {a, b, bias, preluActivationWeights} = inputs;
  if (a.dtype !== "float32" || b.dtype !== "float32") {
    throw new Error(`_FusedMatMul for non non-float32 tensors not yet supported.`);
  }
  const {transposeA, transposeB, activation} = attrs;
  const aId = backend2.dataIdMap.get(a.dataId).id;
  const bId = backend2.dataIdMap.get(b.dataId).id;
  let biasId = 0;
  if (bias != null) {
    const biasData = backend2.dataIdMap.get(bias.dataId);
    if (biasData.shape.length !== 1) {
      throw new Error(`_FusedMatMul only supports rank-1 bias but got rank ${biasData.shape.length}.`);
    }
    biasId = biasData.id;
  }
  const preluActivationWeightsId = preluActivationWeights == null ? 0 : backend2.dataIdMap.get(preluActivationWeights.dataId).id;
  const fusedActivation = FusableActivation[activation];
  if (fusedActivation == null) {
    throw new Error(`${activation} activation not yet supported for FusedConv2D in the wasm backend.`);
  }
  const leftDim = transposeA ? a.shape[2] : a.shape[1];
  const rightDim = transposeB ? b.shape[1] : b.shape[2];
  const batchDim = a.shape[0];
  const out = backend2.makeOutput([batchDim, leftDim, rightDim], a.dtype);
  const outId = backend2.dataIdMap.get(out.dataId).id;
  const aShapeBytes = new Uint8Array(new Int32Array(a.shape).buffer);
  const bShapeBytes = new Uint8Array(new Int32Array(b.shape).buffer);
  wasmFusedMatMul(aId, aShapeBytes, a.shape.length, bId, bShapeBytes, b.shape.length, transposeA, transposeB, fusedActivation, biasId, preluActivationWeightsId, outId);
  return out;
}
const fusedMatMulConfig = {
  kernelName: _FusedMatMul,
  backendName: "wasm",
  setupFunc: setup,
  kernelFunc: fusedBatchMatMul
};
/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function createUnaryKernelConfig(kernelName) {
  let wasmFunc8;
  function setupFunc2(backend2) {
    wasmFunc8 = backend2.wasm.cwrap(kernelName, null, ["number", "number"]);
  }
  function kernelFunc3(args) {
    const {backend: backend2, inputs: {x}} = args;
    const xId = backend2.dataIdMap.get(x.dataId).id;
    const out = backend2.makeOutput(x.shape, x.dtype);
    const outId = backend2.dataIdMap.get(out.dataId).id;
    if (util_exports.sizeFromShape(out.shape) === 0) {
      return out;
    }
    wasmFunc8(xId, outId);
    return out;
  }
  return {kernelName, backendName: "wasm", setupFunc: setupFunc2, kernelFunc: kernelFunc3};
}
/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const absConfig = createUnaryKernelConfig(Abs);
/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function createBinaryKernelConfig(kernelName, supportsFullBroadcast17, dtype) {
  let wasmFunc8;
  function setupFunc2(backend2) {
    wasmFunc8 = backend2.wasm.cwrap(kernelName, null, [
      "number",
      "array",
      "number",
      "number",
      "array",
      "number",
      "number",
      "number"
    ]);
  }
  function kernelFunc3(args) {
    const {backend: backend2, inputs} = args;
    const {a, b} = inputs;
    const aId = backend2.dataIdMap.get(a.dataId).id;
    const bId = backend2.dataIdMap.get(b.dataId).id;
    const outputType = dtype != null ? dtype : a.dtype;
    const newShape = backend_util_exports.assertAndGetBroadcastShape(a.shape, b.shape);
    const out = backend2.makeOutput(newShape, outputType);
    if (util_exports.sizeFromShape(newShape) === 0) {
      return out;
    }
    const aShapeBytes = new Uint8Array(new Int32Array(a.shape).buffer);
    const bShapeBytes = new Uint8Array(new Int32Array(b.shape).buffer);
    const outId = backend2.dataIdMap.get(out.dataId).id;
    const kernelFunc4 = () => wasmFunc8(aId, aShapeBytes, a.shape.length, bId, bShapeBytes, b.shape.length, CppDType[a.dtype], outId);
    if (supportsFullBroadcast17 && a.dtype === "float32") {
      kernelFunc4();
      return out;
    }
    const aBroadcastDims = backend_util_exports.getBroadcastDims(a.shape, newShape);
    const bBroadcastDims = backend_util_exports.getBroadcastDims(b.shape, newShape);
    const loopsOverAllOfA = aBroadcastDims.every((v, i) => v === i);
    const loopsOverAllOfB = bBroadcastDims.every((v, i) => v === i);
    if (loopsOverAllOfA && loopsOverAllOfB) {
      kernelFunc4();
      return out;
    } else {
      throw new Error(`Broadcasting along outer dims is not yet supported for ${a.dtype} ${kernelName}.`);
    }
  }
  return {kernelName, backendName: "wasm", setupFunc: setupFunc2, kernelFunc: kernelFunc3};
}
/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const supportsFullBroadcast = true;
const addConfig = createBinaryKernelConfig(Add, supportsFullBroadcast);
/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
let wasmFunc;
function setupFunc(backend2) {
  wasmFunc = backend2.wasm.cwrap(AddN, null, [
    "array",
    "number",
    "number",
    "number"
  ]);
}
function addn(args) {
  const {inputs, backend: backend2} = args;
  const out = backend2.makeOutput(inputs[0].shape, inputs[0].dtype);
  if (util_exports.sizeFromShape(out.shape) === 0) {
    return out;
  }
  const inputIds = inputs.map((x) => backend2.dataIdMap.get(x.dataId).id);
  const inputIdsBytes = new Uint8Array(new Int32Array(inputIds).buffer);
  const outId = backend2.dataIdMap.get(out.dataId).id;
  wasmFunc(inputIdsBytes, inputIds.length, CppDType[out.dtype], outId);
  return out;
}
const addNConfig = {
  kernelName: AddN,
  backendName: "wasm",
  setupFunc,
  kernelFunc: addn
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function identity(args) {
  const {inputs: {x}, backend: backend2} = args;
  const out = backend2.makeOutput(x.shape, x.dtype);
  const inVals = backend2.typedArrayFromHeap(x);
  const outVals = backend2.typedArrayFromHeap(out);
  outVals.set(inVals);
  return out;
}
const identityConfig = {
  kernelName: Identity,
  backendName: "wasm",
  kernelFunc: identity
};
/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
let wasmTranspose;
function setup2(backend2) {
  wasmTranspose = backend2.wasm.cwrap(Transpose, null, [
    "number",
    "array",
    "number",
    "number",
    "number",
    "array",
    "number"
  ]);
}
function transpose3(args) {
  const {inputs, backend: backend2, attrs} = args;
  const [reducedShape, perm] = removeOneSizeDims(inputs.x.shape, attrs.perm);
  let permIsNoOp = true;
  for (let i = 0; i < perm.length; i++) {
    if (perm[i] !== i) {
      permIsNoOp = false;
    }
  }
  const outShape = computeOutShape4(inputs.x.shape, attrs.perm);
  const x = {
    dataId: inputs.x.dataId,
    shape: reducedShape,
    dtype: inputs.x.dtype
  };
  if (permIsNoOp) {
    const cloned = identity({inputs, backend: backend2});
    cloned.shape = outShape;
    return cloned;
  }
  const out = backend2.makeOutput(outShape, x.dtype);
  const xId = backend2.dataIdMap.get(x.dataId).id;
  const outId = backend2.dataIdMap.get(out.dataId).id;
  const permBytes = new Uint8Array(new Int32Array(perm).buffer);
  const xShapeBytes = new Uint8Array(new Int32Array(x.shape).buffer);
  wasmTranspose(xId, xShapeBytes, x.shape.length, CppDType[x.dtype], outId, permBytes, perm.length);
  return out;
}
function computeOutShape4(inShape, perm) {
  const outShape = new Array(inShape.length);
  for (let i = 0; i < outShape.length; i++) {
    outShape[i] = inShape[perm[i]];
  }
  return outShape;
}
function removeOneSizeDims(shape, perm) {
  const newShape = [];
  const newPerm = [];
  for (let i = 0; i < shape.length; ++i) {
    if (shape[i] !== 1) {
      newShape.push(shape[i]);
    }
    if (shape[perm[i]] !== 1) {
      newPerm.push(perm[i]);
    }
  }
  for (let i = 0; i < newPerm.length; ++i) {
    let minValIdx = -1;
    for (let j = 0; j < newPerm.length; ++j) {
      if (newPerm[j] >= i && (minValIdx === -1 || newPerm[minValIdx] > newPerm[j])) {
        minValIdx = j;
      }
    }
    newPerm[minValIdx] = i;
  }
  return [newShape, newPerm];
}
const transposeConfig = {
  kernelName: Transpose,
  backendName: "wasm",
  kernelFunc: transpose3,
  setupFunc: setup2
};
/**
 * @license
 * Copyright 2020 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function permuteAxesAndTranspose(x, axis, backend2) {
  const xShape = x.shape;
  const xRank = x.shape.length;
  const originalAxes = util_exports.parseAxisParam(axis, xShape);
  let axes = originalAxes;
  const permutedAxes = backend_util_exports.getAxesPermutation(axes, xRank);
  let xTransposed = null;
  let inputWasTransposed = false;
  if (permutedAxes != null) {
    const newShape = new Array(xRank);
    for (let i = 0; i < newShape.length; i++) {
      newShape[i] = xShape[permutedAxes[i]];
    }
    axes = backend_util_exports.getInnerMostAxes(axes.length, xRank);
    xTransposed = transpose3({inputs: {x}, attrs: {perm: permutedAxes}, backend: backend2});
    const xId = backend2.dataIdMap.get(x.dataId).id;
    const transposedId = backend2.dataIdMap.get(xTransposed.dataId).id;
    if (transposedId !== xId) {
      inputWasTransposed = true;
    }
  }
  return {transposed: xTransposed, originalAxes, axes, inputWasTransposed};
}
/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
let wasmFunc2;
function setup3(backend2) {
  wasmFunc2 = backend2.wasm.cwrap(ArgMax, null, [
    "number",
    "number",
    "number",
    "number",
    "number"
  ]);
}
function argmax(args) {
  const {backend: backend2, inputs, attrs} = args;
  const {axis} = attrs;
  const {x} = inputs;
  const xId = backend2.dataIdMap.get(x.dataId).id;
  let inputId = xId;
  let input = x;
  const {transposed, axes, inputWasTransposed} = permuteAxesAndTranspose(x, axis, backend2);
  if (inputWasTransposed) {
    const transposedId = backend2.dataIdMap.get(transposed.dataId).id;
    if (transposedId !== xId) {
      input = transposed;
      inputId = transposedId;
    }
  }
  const outShape = input.shape.slice(0, -1);
  const out = backend2.makeOutput(outShape, "int32");
  const outId = backend2.dataIdMap.get(out.dataId).id;
  const outerSize = util_exports.sizeFromShape(out.shape);
  const innerSize = input.shape[axes[0]];
  wasmFunc2(inputId, CppDType[input.dtype], outerSize, innerSize, outId);
  if (inputWasTransposed) {
    backend2.disposeData(transposed.dataId);
  }
  return out;
}
const argMaxConfig = {
  kernelName: ArgMax,
  backendName: "wasm",
  kernelFunc: argmax,
  setupFunc: setup3
};
/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
let wasmAvgPool;
function setup4(backend2) {
  wasmAvgPool = backend2.wasm.cwrap(AvgPool, null, [
    "number",
    "number",
    "number",
    "number",
    "number",
    "number",
    "number",
    "number",
    "number",
    "number",
    "number",
    "number",
    "number",
    "number"
  ]);
}
function avgPool(args) {
  const {inputs, attrs, backend: backend2} = args;
  const x = inputs.x;
  const xId = backend2.dataIdMap.get(x.dataId).id;
  const {filterSize, strides, pad: pad2, dimRoundingMode} = attrs;
  const convInfo = backend_util_exports.computePool2DInfo(x.shape, filterSize, strides, 1, pad2, dimRoundingMode);
  const filterHeight = convInfo.filterHeight;
  const filterWidth = convInfo.filterWidth;
  const padTop = convInfo.padInfo.top;
  const padRight = convInfo.padInfo.right;
  const padBottom = convInfo.padInfo.bottom;
  const padLeft = convInfo.padInfo.left;
  const strideHeight = convInfo.strideHeight;
  const strideWidth = convInfo.strideWidth;
  const channels = convInfo.inChannels;
  if (convInfo.dataFormat !== "channelsLast") {
    throw new Error(`wasm backend does not support dataFormat:'${convInfo.dataFormat}'. Please use 'channelsLast'.`);
  }
  if (convInfo.dilationWidth !== 1 || convInfo.dilationHeight !== 1) {
    throw new Error(`was backend only supports average pooling with dilation = [1, 1], got [${convInfo.dilationHeight}, ${convInfo.dilationWidth}].`);
  }
  const out = backend2.makeOutput(convInfo.outShape, "float32");
  const outId = backend2.dataIdMap.get(out.dataId).id;
  wasmAvgPool(xId, x.shape[0], x.shape[1], x.shape[2], filterHeight, filterWidth, padTop, padRight, padBottom, padLeft, strideHeight, strideWidth, channels, outId);
  return out;
}
const avgPoolConfig = {
  kernelName: AvgPool,
  backendName: "wasm",
  setupFunc: setup4,
  kernelFunc: avgPool
};
/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function reshape4(args) {
  const {inputs, attrs} = args;
  const {x} = inputs;
  const {shape} = attrs;
  const xSize = util_exports.sizeFromShape(x.shape);
  const $shape = util_exports.inferFromImplicitShape(shape, xSize);
  util_exports.assert(xSize === util_exports.sizeFromShape($shape), () => `new shape: ${$shape}, old shape: ${x.shape}. New shape and old shape must have the same number of elements.`);
  return {dataId: x.dataId, shape: $shape, dtype: x.dtype};
}
const reshapeConfig = {
  kernelName: Reshape,
  backendName: "wasm",
  kernelFunc: reshape4
};
/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
let wasmBatchMatMul;
function setup5(backend2) {
  wasmBatchMatMul = backend2.wasm.cwrap(BatchMatMul, null, [
    "number",
    "array",
    "number",
    "number",
    "array",
    "number",
    "number",
    "number",
    "number"
  ]);
}
function batchMatMul(args) {
  const {inputs, backend: backend2, attrs} = args;
  const {a, b} = inputs;
  const {transposeA, transposeB} = attrs;
  if (a.dtype !== "float32" || b.dtype !== "float32") {
    throw new Error(`BatchMatMul for non non-float32 tensors not yet supported.`);
  }
  const aRank = a.shape.length;
  const bRank = b.shape.length;
  const innerShapeA = transposeA ? a.shape[aRank - 2] : a.shape[aRank - 1];
  const innerShapeB = transposeB ? b.shape[bRank - 1] : b.shape[bRank - 2];
  const outerShapeA = transposeA ? a.shape[aRank - 1] : a.shape[aRank - 2];
  const outerShapeB = transposeB ? b.shape[bRank - 2] : b.shape[bRank - 1];
  const outerDimsA = a.shape.slice(0, -2);
  const outerDimsB = b.shape.slice(0, -2);
  const batchDimA = util_exports.sizeFromShape(outerDimsA);
  const batchDimB = util_exports.sizeFromShape(outerDimsB);
  const batchDimsCompatible = batchDimA === batchDimB || batchDimA === 1 || batchDimB === 1;
  util_exports.assert(aRank >= 2 && bRank >= 2 && batchDimsCompatible, () => `Error in matMul: the input batch dimensions must either be the same or at least one input batch dimension must be 1. Got input batch dimensions of (${outerDimsA}) and (${outerDimsB}).`);
  const outShapeOuterDims = batchDimA > batchDimB ? a.shape.slice(0, -2) : b.shape.slice(0, -2);
  const outShape = outShapeOuterDims.concat([outerShapeA, outerShapeB]);
  util_exports.assert(innerShapeA === innerShapeB, () => `Error in matMul: inner shapes (${innerShapeA}) and (${innerShapeB}) of Tensors with shapes ${a.shape} and ${b.shape} and transposeA=${transposeA} and transposeB=${transposeB} must match.`);
  const a3dShape = transposeA ? [batchDimA, innerShapeA, outerShapeA] : [batchDimA, outerShapeA, innerShapeA];
  const b3dShape = transposeB ? [batchDimB, outerShapeB, innerShapeB] : [batchDimB, innerShapeB, outerShapeB];
  const a3d = reshape4({inputs: {x: a}, backend: backend2, attrs: {shape: a3dShape}});
  const b3d = reshape4({inputs: {x: b}, backend: backend2, attrs: {shape: b3dShape}});
  const a3dId = backend2.dataIdMap.get(a3d.dataId).id;
  const b3dId = backend2.dataIdMap.get(b3d.dataId).id;
  const leftDim = transposeA ? a3d.shape[2] : a3d.shape[1];
  const rightDim = transposeB ? b3d.shape[1] : b3d.shape[2];
  const batchDim = Math.max(batchDimA, batchDimB);
  const out = backend2.makeOutput([batchDim, leftDim, rightDim], a3d.dtype);
  const outId = backend2.dataIdMap.get(out.dataId).id;
  const aShapeBytes = new Uint8Array(new Int32Array(a3d.shape).buffer);
  const bShapeBytes = new Uint8Array(new Int32Array(b3d.shape).buffer);
  wasmBatchMatMul(a3dId, aShapeBytes, a3d.shape.length, b3dId, bShapeBytes, b3d.shape.length, transposeA, transposeB, outId);
  out.shape = outShape;
  return out;
}
const batchMatMulConfig = {
  kernelName: BatchMatMul,
  backendName: "wasm",
  setupFunc: setup5,
  kernelFunc: batchMatMul
};
/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function cast6(args) {
  const {inputs: {x}, attrs: {dtype}, backend: backend2} = args;
  const out = backend2.makeOutput(x.shape, dtype);
  const inVals = backend2.typedArrayFromHeap(x);
  const outVals = backend2.typedArrayFromHeap(out);
  outVals.set(inVals);
  return out;
}
const castConfig = {
  kernelName: Cast,
  backendName: "wasm",
  kernelFunc: cast6
};
/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
let wasmClip;
function setup6(backend2) {
  wasmClip = backend2.wasm.cwrap(ClipByValue, null, [
    "number",
    "number",
    "number",
    "number"
  ]);
}
function clip(args) {
  const {inputs, backend: backend2, attrs} = args;
  const {x} = inputs;
  const {clipValueMin, clipValueMax} = attrs;
  const xId = backend2.dataIdMap.get(x.dataId).id;
  const out = backend2.makeOutput(x.shape, x.dtype);
  const outId = backend2.dataIdMap.get(out.dataId).id;
  wasmClip(xId, clipValueMin, clipValueMax, outId);
  return out;
}
const clipByValueConfig = {
  kernelName: ClipByValue,
  backendName: "wasm",
  setupFunc: setup6,
  kernelFunc: clip
};
/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function concat(args) {
  const {inputs, backend: backend2} = args;
  const axis = util_exports.parseAxisParam(args.attrs.axis, inputs[0].shape)[0];
  const outShape = backend_util_exports.computeOutShape(inputs.map((t) => t.shape), axis);
  const out = backend2.makeOutput(outShape, inputs[0].dtype);
  if (util_exports.sizeFromShape(outShape) === 0) {
    return out;
  }
  const $inputs = inputs.filter((t) => util_exports.sizeFromShape(t.shape) > 0);
  if ($inputs.length === 1) {
    return $inputs[0];
  }
  const shapes = $inputs.map((t) => t.shape);
  backend_util_exports.assertParamsConsistent(shapes, axis);
  const batchDim = util_exports.sizeFromShape($inputs[0].shape.slice(0, axis));
  let sumInnerDims = 0;
  const innerDims = $inputs.map((input) => {
    const innerDim = util_exports.sizeFromShape(input.shape.slice(axis));
    sumInnerDims += innerDim;
    return innerDim;
  });
  const inVals = $inputs.map((input) => backend2.typedArrayFromHeap(input));
  const outVals = backend2.typedArrayFromHeap(out);
  for (let b = 0; b < batchDim; b++) {
    let outOffset = b * sumInnerDims;
    for (let i = 0; i < inVals.length; i++) {
      const innerDim = innerDims[i];
      const inOffset = b * innerDim;
      const vals = inVals[i].subarray(inOffset, inOffset + innerDim);
      outVals.set(vals, outOffset);
      outOffset += innerDim;
    }
  }
  return out;
}
const concatConfig = {
  kernelName: Concat,
  backendName: "wasm",
  kernelFunc: concat
};
/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
let wasmConv2d;
function setup7(backend2) {
  wasmConv2d = backend2.wasm.cwrap(Conv2D, null, [
    "number",
    "number",
    "number",
    "number",
    "number",
    "number",
    "number",
    "number",
    "number",
    "number",
    "number",
    "number",
    "number",
    "number",
    "number",
    "number",
    "number",
    "number",
    "number"
  ]);
}
function conv2d(args) {
  const {inputs, attrs, backend: backend2} = args;
  const {x, filter} = inputs;
  const xId = backend2.dataIdMap.get(x.dataId).id;
  const filterId = backend2.dataIdMap.get(filter.dataId).id;
  const {strides, dilations, pad: pad2, dimRoundingMode, dataFormat} = attrs;
  const $dataFormat = backend_util_exports.convertConv2DDataFormat(dataFormat);
  const convInfo = backend_util_exports.computeConv2DInfo(x.shape, filter.shape, strides, dilations, pad2, dimRoundingMode, false, $dataFormat);
  const filterHeight = convInfo.filterHeight;
  const filterWidth = convInfo.filterWidth;
  const padTop = convInfo.padInfo.top;
  const padRight = convInfo.padInfo.right;
  const padBottom = convInfo.padInfo.bottom;
  const padLeft = convInfo.padInfo.left;
  const dilationHeight = convInfo.dilationHeight;
  const dilationWidth = convInfo.dilationWidth;
  const strideHeight = convInfo.strideHeight;
  const strideWidth = convInfo.strideWidth;
  const inputChannels = convInfo.inChannels;
  const outputChannels = convInfo.outChannels;
  const isSamePad = convInfo.padInfo.type === "SAME" ? 1 : 0;
  if (convInfo.dataFormat !== "channelsLast") {
    throw new Error(`wasm backend Conv2D does not support dataFormat:'${convInfo.dataFormat}'. Please use 'channelsLast'.`);
  }
  const out = backend2.makeOutput(convInfo.outShape, "float32");
  const outId = backend2.dataIdMap.get(out.dataId).id;
  wasmConv2d(xId, x.shape[0], x.shape[1], x.shape[2], filterId, filterHeight, filterWidth, padTop, padRight, padBottom, padLeft, isSamePad, dilationHeight, dilationWidth, strideHeight, strideWidth, inputChannels, outputChannels, outId);
  return out;
}
const conv2DConfig = {
  kernelName: Conv2D,
  backendName: "wasm",
  setupFunc: setup7,
  kernelFunc: conv2d
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
let wasmConv2DBackpropInput;
function setup8(backend2) {
  wasmConv2DBackpropInput = backend2.wasm.cwrap(Conv2DBackpropInput, null, [
    "number",
    "number",
    "number",
    "number",
    "number",
    "number",
    "number",
    "number",
    "number",
    "number",
    "number",
    "number",
    "number",
    "number",
    "number",
    "number",
    "number",
    "number",
    "number",
    "number",
    "number",
    "number",
    "number",
    "number",
    "number",
    "number",
    "number"
  ]);
}
function conv2DBackpropInput(args) {
  const {backend: backend2, inputs, attrs} = args;
  const {dy, filter} = inputs;
  const {strides, pad: pad2, dataFormat, dimRoundingMode, inputShape} = attrs;
  const dilations = 1;
  const $dataFormat = backend_util_exports.convertConv2DDataFormat(dataFormat);
  const convInfo = backend_util_exports.computeConv2DInfo(inputShape, filter.shape, strides, dilations, pad2, dimRoundingMode, false, $dataFormat);
  const {batchSize, filterHeight, filterWidth, inChannels, inHeight, inWidth, outChannels, outHeight, outWidth, strideHeight, strideWidth} = convInfo;
  const topPad = filterHeight - 1 - convInfo.padInfo.top;
  const leftPad = filterWidth - 1 - convInfo.padInfo.left;
  const isChannelsLast = convInfo.dataFormat === "channelsLast";
  const dxStrides = util_exports.computeStrides(convInfo.inShape);
  const dyStrides = util_exports.computeStrides(dy.shape);
  const [fltS0, fltS1, fltS2] = util_exports.computeStrides(filter.shape);
  const xBatchStride = dxStrides[0];
  const xRowStride = isChannelsLast ? dxStrides[1] : dxStrides[2];
  const xColStride = isChannelsLast ? dxStrides[2] : 1;
  const xChannelStride = isChannelsLast ? 1 : dxStrides[1];
  const yBatchStride = dyStrides[0];
  const yRowStride = isChannelsLast ? dyStrides[1] : dyStrides[2];
  const yColStride = isChannelsLast ? dyStrides[2] : 1;
  const yChannelStride = isChannelsLast ? 1 : dyStrides[1];
  const out = backend2.makeOutput(convInfo.inShape, "float32");
  const outId = backend2.dataIdMap.get(out.dataId).id;
  const dyId = backend2.dataIdMap.get(dy.dataId).id;
  const filterId = backend2.dataIdMap.get(filter.dataId).id;
  wasmConv2DBackpropInput(dyId, filterId, batchSize, filterHeight, filterWidth, inHeight, inWidth, inChannels, outHeight, outWidth, outChannels, strideHeight, strideWidth, topPad, leftPad, fltS0, fltS1, fltS2, xBatchStride, xRowStride, xColStride, xChannelStride, yBatchStride, yRowStride, yColStride, yChannelStride, outId);
  return out;
}
const conv2DBackpropInputConfig = {
  kernelName: Conv2DBackpropInput,
  backendName: "wasm",
  setupFunc: setup8,
  kernelFunc: conv2DBackpropInput
};
/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const cosConfig = createUnaryKernelConfig(Cos);
/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
var InterpolationMethod;
(function(InterpolationMethod2) {
  InterpolationMethod2[InterpolationMethod2["bilinear"] = 0] = "bilinear";
  InterpolationMethod2[InterpolationMethod2["nearest"] = 1] = "nearest";
})(InterpolationMethod || (InterpolationMethod = {}));
let wasmCropAndResize;
function setup9(backend2) {
  wasmCropAndResize = backend2.wasm.cwrap(CropAndResize, null, [
    "number",
    "number",
    "number",
    "number",
    "array",
    "number",
    "number",
    "number",
    "number",
    "number"
  ]);
}
function cropAndResize(args) {
  const {backend: backend2, inputs, attrs} = args;
  const {method, extrapolationValue, cropSize} = attrs;
  const {image: image2, boxes, boxInd} = inputs;
  const numBoxes = boxes.shape[0];
  const [cropHeight, cropWidth] = cropSize;
  const outShape = [numBoxes, cropHeight, cropWidth, image2.shape[3]];
  let imagesData = backend2.dataIdMap.get(image2.dataId);
  let castedData;
  if (image2.dtype !== "float32") {
    castedData = cast6({backend: backend2, inputs: {x: image2}, attrs: {dtype: "float32"}});
    imagesData = backend2.dataIdMap.get(castedData.dataId);
  }
  const imagesId = imagesData.id;
  const boxesId = backend2.dataIdMap.get(boxes.dataId).id;
  const boxIndId = backend2.dataIdMap.get(boxInd.dataId).id;
  const out = backend2.makeOutput(outShape, "float32");
  const outId = backend2.dataIdMap.get(out.dataId).id;
  const imagesShapeBytes = new Uint8Array(new Int32Array(image2.shape).buffer);
  wasmCropAndResize(imagesId, boxesId, boxIndId, numBoxes, imagesShapeBytes, cropHeight, cropWidth, InterpolationMethod[method], extrapolationValue, outId);
  if (castedData != null) {
    backend2.disposeData(castedData.dataId);
  }
  return out;
}
const cropAndResizeConfig = {
  kernelName: CropAndResize,
  backendName: "wasm",
  setupFunc: setup9,
  kernelFunc: cropAndResize
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
let wasmCumsum;
function setup10(backend2) {
  wasmCumsum = backend2.wasm.cwrap(Cumsum, null, [
    "number",
    "number",
    "number",
    "number",
    "number",
    "number"
  ]);
}
function cumsum(args) {
  const {inputs, backend: backend2, attrs} = args;
  const {x} = inputs;
  const {axis, exclusive, reverse: reverse2} = attrs;
  const xRank = x.shape.length;
  util_exports.assert(x.dtype === "float32" || x.dtype === "int32", () => `cumsum does not support ${x.dtype} tensors in the WASM backend`);
  const permutation = backend_util_exports.getAxesPermutation([axis], xRank);
  let permutedX = x;
  if (permutation !== null) {
    permutedX = transpose3({inputs: {x}, attrs: {perm: permutation}, backend: backend2});
  }
  const permutedAxis = backend_util_exports.getInnerMostAxes(1, xRank)[0];
  backend_util_exports.assertAxesAreInnerMostDims("cumsum", [permutedAxis], xRank);
  const permutedOut = backend2.makeOutput(permutedX.shape, permutedX.dtype);
  const finalDim = permutedX.shape[permutedAxis];
  const permutedXId = backend2.dataIdMap.get(permutedX.dataId).id;
  const permutedOutId = backend2.dataIdMap.get(permutedOut.dataId).id;
  wasmCumsum(permutedXId, exclusive ? 1 : 0, reverse2 ? 1 : 0, finalDim, permutedOutId, CppDType[x.dtype]);
  let out = permutedOut;
  if (permutation !== null) {
    const undoPermutation = backend_util_exports.getUndoAxesPermutation(permutation);
    out = transpose3({inputs: {x: permutedOut}, attrs: {perm: undoPermutation}, backend: backend2});
    backend2.disposeData(permutedX.dataId);
    backend2.disposeData(permutedOut.dataId);
  }
  return out;
}
const cumsumConfig = {
  kernelName: Cumsum,
  backendName: "wasm",
  setupFunc: setup10,
  kernelFunc: cumsum
};
/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
let wasmDepthToSpace;
function setup11(backend2) {
  wasmDepthToSpace = backend2.wasm.cwrap(DepthToSpace, null, [
    "number",
    "number",
    "number",
    "array",
    "number",
    "array",
    "array",
    "number",
    "number"
  ]);
}
function depthToSpace(args) {
  const {backend: backend2, inputs, attrs} = args;
  const {x} = inputs;
  const {blockSize, dataFormat} = attrs;
  util_exports.assert(blockSize > 1, () => `blockSize should be > 1 for depthToSpace, but was: ${blockSize}`);
  const batchSize = x.shape[0];
  const inputHeight = dataFormat === "NHWC" ? x.shape[1] : x.shape[2];
  const inputWidth = dataFormat === "NHWC" ? x.shape[2] : x.shape[3];
  const inputDepth = dataFormat === "NHWC" ? x.shape[3] : x.shape[1];
  const outputHeight = inputHeight * blockSize;
  const outputWidth = inputWidth * blockSize;
  const outputDepth = inputDepth / (blockSize * blockSize);
  const outputShape = dataFormat === "NHWC" ? [batchSize, outputHeight, outputWidth, outputDepth] : [batchSize, outputDepth, outputHeight, outputWidth];
  const out = backend2.makeOutput(outputShape, "float32");
  const xData = backend2.dataIdMap.get(x.dataId);
  const xId = xData.id;
  const xStridesBytes = new Uint8Array(new Int32Array(util_exports.computeStrides(x.shape)).buffer);
  const outputShapeBytes = new Uint8Array(new Int32Array(outputShape).buffer);
  const outStridesBytes = new Uint8Array(new Int32Array(util_exports.computeStrides(outputShape)).buffer);
  const outId = backend2.dataIdMap.get(out.dataId).id;
  const channelsLast = dataFormat === "NHWC" ? 1 : 0;
  wasmDepthToSpace(xId, blockSize, channelsLast, xStridesBytes, x.shape.length - 1, outputShapeBytes, outStridesBytes, outputShape.length, outId);
  return out;
}
const depthToSpaceConfig = {
  kernelName: DepthToSpace,
  backendName: "wasm",
  setupFunc: setup11,
  kernelFunc: depthToSpace
};
/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
let wasmDepthwiseConv2d;
function setup12(backend2) {
  wasmDepthwiseConv2d = backend2.wasm.cwrap(DepthwiseConv2dNative, null, [
    "number",
    "number",
    "number",
    "number",
    "number",
    "number",
    "number",
    "number",
    "number",
    "number",
    "number",
    "number",
    "number",
    "number",
    "number",
    "number",
    "number",
    "number",
    "number"
  ]);
}
function depthwiseConv2d(args) {
  const {inputs, attrs, backend: backend2} = args;
  const {x, filter} = inputs;
  const xId = backend2.dataIdMap.get(x.dataId).id;
  const filterId = backend2.dataIdMap.get(filter.dataId).id;
  const {strides, dilations, pad: pad2, dimRoundingMode} = attrs;
  const $dilations = dilations == null ? [1, 1] : dilations;
  const convInfo = backend_util_exports.computeConv2DInfo(x.shape, filter.shape, strides, $dilations, pad2, dimRoundingMode, true);
  const filterHeight = convInfo.filterHeight;
  const filterWidth = convInfo.filterWidth;
  const padTop = convInfo.padInfo.top;
  const padRight = convInfo.padInfo.right;
  const padBottom = convInfo.padInfo.bottom;
  const padLeft = convInfo.padInfo.left;
  const dilationHeight = convInfo.dilationHeight;
  const dilationWidth = convInfo.dilationWidth;
  const strideHeight = convInfo.strideHeight;
  const strideWidth = convInfo.strideWidth;
  const inputChannels = convInfo.inChannels;
  const outputChannels = convInfo.outChannels;
  const isSamePad = convInfo.padInfo.type === "SAME" ? 1 : 0;
  if (convInfo.dataFormat !== "channelsLast") {
    throw new Error(`wasm backend DepthwiseConv2dNative does not support dataFormat:'${convInfo.dataFormat}'. Please use 'channelsLast'.`);
  }
  const out = backend2.makeOutput(convInfo.outShape, "float32");
  const outId = backend2.dataIdMap.get(out.dataId).id;
  wasmDepthwiseConv2d(xId, x.shape[0], x.shape[1], x.shape[2], filterId, filterHeight, filterWidth, padTop, padRight, padBottom, padLeft, isSamePad, dilationHeight, dilationWidth, strideHeight, strideWidth, inputChannels, outputChannels, outId);
  return out;
}
const depthwiseConv2dNativeConfig = {
  kernelName: DepthwiseConv2dNative,
  backendName: "wasm",
  setupFunc: setup12,
  kernelFunc: depthwiseConv2d
};
/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const supportsFullBroadcast2 = true;
const divConfig = createBinaryKernelConfig(Div, supportsFullBroadcast2);
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const supportsFullBroadcast3 = false;
const equalConfig = createBinaryKernelConfig(Equal, supportsFullBroadcast3, "bool");
/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const expConfig = createUnaryKernelConfig(Exp);
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function fill(args) {
  const {attrs: {shape, value, dtype}, backend: backend2} = args;
  const out = backend2.makeOutput(shape, dtype);
  const outVals = backend2.typedArrayFromHeap(out);
  outVals.fill(value);
  return out;
}
const fillConfig = {
  kernelName: Fill,
  backendName: "wasm",
  kernelFunc: fill
};
/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
let wasmFlipLeftRight;
function setup13(backend2) {
  wasmFlipLeftRight = backend2.wasm.cwrap(FlipLeftRight, null, [
    "number",
    "number",
    "number",
    "number",
    "number",
    "number"
  ]);
}
function flipLeftRight(args) {
  const {inputs, backend: backend2} = args;
  const {image: image2} = inputs;
  const out = backend2.makeOutput(image2.shape, image2.dtype);
  const imageId = backend2.dataIdMap.get(image2.dataId).id;
  const outId = backend2.dataIdMap.get(out.dataId).id;
  const [batch, imageHeight, imageWidth, numChannels] = image2.shape;
  wasmFlipLeftRight(imageId, batch, imageHeight, imageWidth, numChannels, outId);
  return out;
}
const flipLeftRightConfig = {
  kernelName: FlipLeftRight,
  backendName: "wasm",
  kernelFunc: flipLeftRight,
  setupFunc: setup13
};
/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const supportsFullBroadcast4 = false;
const floorDivConfig = createBinaryKernelConfig(FloorDiv, supportsFullBroadcast4);
/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
let wasmBatchNorm;
function setup14(backend2) {
  wasmBatchNorm = backend2.wasm.cwrap(FusedBatchNorm, null, ["number", "number", "number", "number", "number", "number", "number"]);
}
function fusedBatchNorm(args) {
  const {backend: backend2, inputs, attrs} = args;
  const {varianceEpsilon} = attrs;
  const {x, mean, variance, offset, scale} = inputs;
  const xId = backend2.dataIdMap.get(x.dataId).id;
  const meanId = backend2.dataIdMap.get(mean.dataId).id;
  const varianceId = backend2.dataIdMap.get(variance.dataId).id;
  const offsetId = offset != null ? backend2.dataIdMap.get(offset.dataId).id : 0;
  const scaleId = scale != null ? backend2.dataIdMap.get(scale.dataId).id : 0;
  const out = backend2.makeOutput(x.shape, x.dtype);
  if (util_exports.sizeFromShape(x.shape) === 0) {
    return out;
  }
  const outId = backend2.dataIdMap.get(out.dataId).id;
  wasmBatchNorm(xId, meanId, varianceId, offsetId, scaleId, varianceEpsilon, outId);
  return out;
}
const fusedBatchNormConfig = {
  kernelName: FusedBatchNorm,
  backendName: "wasm",
  setupFunc: setup14,
  kernelFunc: fusedBatchNorm
};
/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
let wasmFusedConv2d;
function setup15(backend2) {
  wasmFusedConv2d = backend2.wasm.cwrap(FusedConv2D, null, [
    "number",
    "number",
    "number",
    "number",
    "number",
    "number",
    "number",
    "number",
    "number",
    "number",
    "number",
    "number",
    "number",
    "number",
    "number",
    "number",
    "number",
    "number",
    "number",
    "number",
    "number",
    "number"
  ]);
}
function fusedConv2d(args) {
  const {inputs, attrs, backend: backend2} = args;
  const {x, filter, bias, preluActivationWeights} = inputs;
  const {strides, pad: pad2, dilations, dataFormat, dimRoundingMode, activation} = attrs;
  const convInfo = backend_util_exports.computeConv2DInfo(x.shape, filter.shape, strides, dilations, pad2, dimRoundingMode);
  const fusedActivation = FusableActivation[activation];
  if (fusedActivation == null) {
    throw new Error(`${activation} activation not yet supported for FusedConv2D in the wasm backend.`);
  }
  const xId = backend2.dataIdMap.get(x.dataId).id;
  const filterId = backend2.dataIdMap.get(filter.dataId).id;
  const outputChannels = convInfo.outChannels;
  let biasId = 0;
  if (bias != null) {
    const biasData = backend2.dataIdMap.get(bias.dataId);
    if (biasData.shape.length !== 1) {
      throw new Error(`FusedConv2D only supports rank-1 bias but got rank ${biasData.shape.length}.`);
    }
    if (biasData.shape[0] !== outputChannels) {
      throw new Error(`FusedConv2D bias shape (${biasData.shape}) does not match the number of output channels (${outputChannels})`);
    }
    biasId = biasData.id;
  }
  const filterHeight = convInfo.filterHeight;
  const filterWidth = convInfo.filterWidth;
  const padTop = convInfo.padInfo.top;
  const padRight = convInfo.padInfo.right;
  const padBottom = convInfo.padInfo.bottom;
  const padLeft = convInfo.padInfo.left;
  const dilationHeight = convInfo.dilationHeight;
  const dilationWidth = convInfo.dilationWidth;
  const strideHeight = convInfo.strideHeight;
  const strideWidth = convInfo.strideWidth;
  const inputChannels = convInfo.inChannels;
  const isSamePad = convInfo.padInfo.type === "SAME" ? 1 : 0;
  const batchSize = convInfo.batchSize;
  const inHeight = convInfo.inHeight;
  const inWidth = convInfo.inWidth;
  if (dataFormat !== "NHWC") {
    throw new Error(`wasm backend FusedConv2D does not support dataFormat:'${dataFormat}'. Please use 'NHWC'.`);
  }
  const out = backend2.makeOutput(convInfo.outShape, "float32");
  const outId = backend2.dataIdMap.get(out.dataId).id;
  const preluActivationWeightsId = preluActivationWeights == null ? 0 : backend2.dataIdMap.get(preluActivationWeights.dataId).id;
  wasmFusedConv2d(xId, batchSize, inHeight, inWidth, filterId, filterHeight, filterWidth, biasId, padTop, padRight, padBottom, padLeft, isSamePad, dilationHeight, dilationWidth, strideHeight, strideWidth, inputChannels, outputChannels, fusedActivation, preluActivationWeightsId, outId);
  return out;
}
const fusedConv2DConfig = {
  kernelName: FusedConv2D,
  backendName: "wasm",
  setupFunc: setup15,
  kernelFunc: fusedConv2d
};
/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
let wasmFusedDepthwiseConv2d;
function setup16(backend2) {
  wasmFusedDepthwiseConv2d = backend2.wasm.cwrap(FusedDepthwiseConv2D, null, [
    "number",
    "number",
    "number",
    "number",
    "number",
    "number",
    "number",
    "number",
    "number",
    "number",
    "number",
    "number",
    "number",
    "number",
    "number",
    "number",
    "number",
    "number",
    "number",
    "number",
    "number",
    "number"
  ]);
}
function fusedDepthwiseConv2d(args) {
  const {inputs, attrs, backend: backend2} = args;
  const {x, filter, bias, preluActivationWeights} = inputs;
  const {strides, pad: pad2, dilations, dataFormat, dimRoundingMode, activation} = attrs;
  const convInfo = backend_util_exports.computeConv2DInfo(x.shape, filter.shape, strides, dilations, pad2, dimRoundingMode, true);
  const fusedActivation = FusableActivation[activation];
  if (fusedActivation == null) {
    throw new Error(`${activation} activation not yet supported for FusedDepthwiseConv2D in the wasm backend.`);
  }
  const xId = backend2.dataIdMap.get(x.dataId).id;
  const filterId = backend2.dataIdMap.get(filter.dataId).id;
  const outputChannels = convInfo.outChannels;
  let biasId = 0;
  if (bias != null) {
    const biasData = backend2.dataIdMap.get(bias.dataId);
    if (biasData.shape.length !== 1) {
      throw new Error(`FusedDepthwiseConv2D only supports rank-1 bias but got rank ${biasData.shape.length}.`);
    }
    if (biasData.shape[0] !== outputChannels) {
      throw new Error(`FusedDepthwiseConv2D bias shape (${biasData.shape}) does not match the number of output channels (${outputChannels})`);
    }
    biasId = biasData.id;
  }
  const filterHeight = convInfo.filterHeight;
  const filterWidth = convInfo.filterWidth;
  const padTop = convInfo.padInfo.top;
  const padRight = convInfo.padInfo.right;
  const padBottom = convInfo.padInfo.bottom;
  const padLeft = convInfo.padInfo.left;
  const dilationHeight = convInfo.dilationHeight;
  const dilationWidth = convInfo.dilationWidth;
  const strideHeight = convInfo.strideHeight;
  const strideWidth = convInfo.strideWidth;
  const inputChannels = convInfo.inChannels;
  const isSamePad = convInfo.padInfo.type === "SAME" ? 1 : 0;
  const batchSize = convInfo.batchSize;
  const inHeight = convInfo.inHeight;
  const inWidth = convInfo.inWidth;
  if (dataFormat !== "NHWC") {
    throw new Error(`wasm backend FusedDepthwiseConv2D does not support dataFormat:'${dataFormat}'. Please use 'NHWC'.`);
  }
  const out = backend2.makeOutput(convInfo.outShape, "float32");
  const outId = backend2.dataIdMap.get(out.dataId).id;
  const preluActivationWeightsId = preluActivationWeights == null ? 0 : backend2.dataIdMap.get(preluActivationWeights.dataId).id;
  wasmFusedDepthwiseConv2d(xId, batchSize, inHeight, inWidth, filterId, filterHeight, filterWidth, biasId, padTop, padRight, padBottom, padLeft, isSamePad, dilationHeight, dilationWidth, strideHeight, strideWidth, inputChannels, outputChannels, fusedActivation, preluActivationWeightsId, outId);
  return out;
}
const fusedDepthwiseConv2DConfig = {
  kernelName: FusedDepthwiseConv2D,
  backendName: "wasm",
  setupFunc: setup16,
  kernelFunc: fusedDepthwiseConv2d
};
/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
let wasmGatherNd;
function setup17(backend2) {
  wasmGatherNd = backend2.wasm.cwrap(GatherNd, null, [
    "number",
    "number",
    "number",
    "number",
    "number",
    "number",
    "array",
    "number"
  ]);
}
function gatherNd(args) {
  const {backend: backend2, inputs} = args;
  const {params, indices} = inputs;
  const [resultShape, numSlices, sliceSize, strides] = gather_nd_util_exports.prepareAndValidate(params, indices);
  const out = backend2.makeOutput(resultShape, params.dtype);
  if (numSlices === 0) {
    return out;
  }
  const indicesShape = indices.shape;
  const sliceRank = indicesShape[indicesShape.length - 1];
  const xData = backend2.dataIdMap.get(params.dataId);
  const xId = xData.id;
  const indicesData = backend2.dataIdMap.get(indices.dataId);
  const indicesId = indicesData.id;
  const stridesBytes = new Uint8Array(new Int32Array(strides).buffer);
  const outId = backend2.dataIdMap.get(out.dataId).id;
  wasmGatherNd(xId, CppDType[params.dtype], indicesId, numSlices, sliceRank, sliceSize, stridesBytes, outId);
  return out;
}
const gatherNdConfig = {
  kernelName: GatherNd,
  backendName: "wasm",
  setupFunc: setup17,
  kernelFunc: gatherNd
};
/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
let wasmGather;
function setup18(backend2) {
  wasmGather = backend2.wasm.cwrap("Gather", null, [
    "number",
    "number",
    "array",
    "number",
    "number",
    "number",
    "array",
    "number"
  ]);
}
function gatherV2(args) {
  const {backend: backend2, inputs, attrs} = args;
  const {x, indices} = inputs;
  const {axis} = attrs;
  const newShape = x.shape.slice();
  newShape[axis] = util_exports.sizeFromShape(indices.shape);
  const stridesSize = x.shape.length - 1;
  const out = backend2.makeOutput(newShape, x.dtype);
  if (util_exports.sizeFromShape(x.shape) === 0) {
    return out;
  }
  const xData = backend2.dataIdMap.get(x.dataId);
  const xId = xData.id;
  const indicesData = backend2.dataIdMap.get(indices.dataId);
  const indicesId = indicesData.id;
  const outId = backend2.dataIdMap.get(out.dataId).id;
  const xStridesBytes = new Uint8Array(new Int32Array(util_exports.computeStrides(x.shape)).buffer);
  const outStridesBytes = new Uint8Array(new Int32Array(util_exports.computeStrides(newShape)).buffer);
  wasmGather(xId, CppDType[x.dtype], xStridesBytes, stridesSize, indicesId, axis, outStridesBytes, outId);
  const parsedAxis = util_exports.parseAxisParam(axis, x.shape)[0];
  const shapeInfo = backend_util_exports.segment_util.collectGatherOpShapeInfo(x, indices, parsedAxis);
  out.shape = shapeInfo.outputShape;
  return out;
}
const gatherV2Config = {
  kernelName: GatherV2,
  backendName: "wasm",
  setupFunc: setup18,
  kernelFunc: gatherV2
};
/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const supportsFullBroadcast5 = false;
const greaterConfig = createBinaryKernelConfig(Greater, supportsFullBroadcast5, "bool");
/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const supportsFullBroadcast6 = false;
const greaterEqualConfig = createBinaryKernelConfig(GreaterEqual, supportsFullBroadcast6, "bool");
/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const supportsFullBroadcast7 = false;
const lessConfig = createBinaryKernelConfig(Less, supportsFullBroadcast7, "bool");
/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const supportsFullBroadcast8 = false;
const lessEqualConfig = createBinaryKernelConfig(LessEqual, supportsFullBroadcast8, "bool");
/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const logConfig = createUnaryKernelConfig(Log);
/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const supportsFullBroadcast9 = false;
const logicalAndConfig = createBinaryKernelConfig(LogicalAnd, supportsFullBroadcast9, "bool");
/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
let wasmMax;
function setup19(backend2) {
  wasmMax = backend2.wasm.cwrap(Max, null, ["number, number, number"]);
}
function max(args) {
  const {backend: backend2, inputs, attrs} = args;
  const {reductionIndices: axis, keepDims} = attrs;
  const {x} = inputs;
  const xId = backend2.dataIdMap.get(x.dataId).id;
  let inputId = xId;
  let input = x;
  const {transposed, axes, originalAxes, inputWasTransposed} = permuteAxesAndTranspose(x, axis, backend2);
  if (inputWasTransposed) {
    const transposedId = backend2.dataIdMap.get(transposed.dataId).id;
    input = transposed;
    inputId = transposedId;
  }
  const inputRank = input.shape.length;
  backend_util_exports.assertAxesAreInnerMostDims("max", axes, inputRank);
  const [outShape, reduceShape] = backend_util_exports.computeOutAndReduceShapes(input.shape, axes);
  const reduceSize = util_exports.sizeFromShape(reduceShape);
  const out = backend2.makeOutput(outShape, x.dtype);
  if (util_exports.sizeFromShape(input.shape) !== 0) {
    const outId = backend2.dataIdMap.get(out.dataId).id;
    wasmMax(inputId, reduceSize, outId);
  }
  if (inputWasTransposed) {
    backend2.disposeData(transposed.dataId);
  }
  if (keepDims) {
    const newShape = backend_util_exports.expandShapeToKeepDim(out.shape, originalAxes);
    out.shape = newShape;
  }
  return out;
}
const maxConfig = {
  kernelName: Max,
  backendName: "wasm",
  setupFunc: setup19,
  kernelFunc: max
};
/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const supportsFullBroadcast10 = false;
const maximumConfig = createBinaryKernelConfig(Maximum, supportsFullBroadcast10);
/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
let wasmMaxPool;
function setup20(backend2) {
  wasmMaxPool = backend2.wasm.cwrap(MaxPool, null, [
    "number",
    "number",
    "number",
    "number",
    "number",
    "number",
    "number",
    "number",
    "number",
    "number",
    "number",
    "number",
    "number",
    "number",
    "number",
    "number",
    "number"
  ]);
}
function maxPool(args) {
  const {inputs, attrs, backend: backend2} = args;
  const x = inputs.x;
  const xId = backend2.dataIdMap.get(x.dataId).id;
  const {filterSize, strides, pad: pad2, dimRoundingMode} = attrs;
  const convInfo = backend_util_exports.computePool2DInfo(x.shape, filterSize, strides, 1, pad2, dimRoundingMode);
  const filterHeight = convInfo.filterHeight;
  const filterWidth = convInfo.filterWidth;
  const padTop = convInfo.padInfo.top;
  const padRight = convInfo.padInfo.right;
  const padBottom = convInfo.padInfo.bottom;
  const padLeft = convInfo.padInfo.left;
  const dilationHeight = convInfo.dilationHeight;
  const dilationWidth = convInfo.dilationWidth;
  const strideHeight = convInfo.strideHeight;
  const strideWidth = convInfo.strideWidth;
  const inputChannels = convInfo.inChannels;
  const outputChannels = convInfo.outChannels;
  if (convInfo.dataFormat !== "channelsLast") {
    throw new Error(`wasm backend does not support dataFormat:'${convInfo.dataFormat}'. Please use 'channelsLast'.`);
  }
  const out = backend2.makeOutput(convInfo.outShape, "float32");
  const outId = backend2.dataIdMap.get(out.dataId).id;
  wasmMaxPool(xId, x.shape[0], x.shape[1], x.shape[2], filterHeight, filterWidth, padTop, padRight, padBottom, padLeft, dilationHeight, dilationWidth, strideHeight, strideWidth, inputChannels, outputChannels, outId);
  return out;
}
const maxPoolConfig = {
  kernelName: MaxPool,
  backendName: "wasm",
  setupFunc: setup20,
  kernelFunc: maxPool
};
/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
let wasmMin;
function setup21(backend2) {
  wasmMin = backend2.wasm.cwrap(Min, null, ["number, number, number"]);
}
function min(args) {
  const {backend: backend2, inputs, attrs} = args;
  const {axis, keepDims} = attrs;
  const {x} = inputs;
  const xId = backend2.dataIdMap.get(x.dataId).id;
  let inputId = xId;
  let input = x;
  const {transposed, axes, originalAxes, inputWasTransposed} = permuteAxesAndTranspose(x, axis, backend2);
  if (inputWasTransposed) {
    const transposedId = backend2.dataIdMap.get(transposed.dataId).id;
    if (transposedId !== xId) {
      input = transposed;
      inputId = transposedId;
    }
  }
  const inputRank = input.shape.length;
  backend_util_exports.assertAxesAreInnerMostDims("min", axes, inputRank);
  const [outShape, reduceShape] = backend_util_exports.computeOutAndReduceShapes(input.shape, axes);
  const reduceSize = util_exports.sizeFromShape(reduceShape);
  const out = backend2.makeOutput(outShape, input.dtype);
  if (util_exports.sizeFromShape(input.shape) !== 0) {
    const outId = backend2.dataIdMap.get(out.dataId).id;
    wasmMin(inputId, reduceSize, outId);
  }
  if (inputWasTransposed) {
    backend2.disposeData(transposed.dataId);
  }
  if (keepDims) {
    const newShape = backend_util_exports.expandShapeToKeepDim(out.shape, originalAxes);
    out.shape = newShape;
  }
  return out;
}
const minConfig = {
  kernelName: Min,
  backendName: "wasm",
  setupFunc: setup21,
  kernelFunc: min
};
/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const supportsFullBroadcast11 = false;
const minimumConfig = createBinaryKernelConfig(Minimum, supportsFullBroadcast11);
/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const supportsFullBroadcast12 = true;
const multiplyConfig = createBinaryKernelConfig(Multiply, supportsFullBroadcast12);
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const negateConfig = createUnaryKernelConfig(Negate);
/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function parseResultStruct(backend2, resOffset) {
  const result = new Int32Array(backend2.wasm.HEAPU8.buffer, resOffset, 4);
  const pSelectedIndices = result[0];
  const selectedSize = result[1];
  const pSelectedScores = result[2];
  const pValidOutputs = result[3];
  backend2.wasm._free(resOffset);
  return {pSelectedIndices, selectedSize, pSelectedScores, pValidOutputs};
}
/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
let wasmFunc3;
function setup22(backend2) {
  wasmFunc3 = backend2.wasm.cwrap(NonMaxSuppressionV3, "number", [
    "number",
    "number",
    "number",
    "number",
    "number"
  ]);
}
function kernelFunc(args) {
  const {backend: backend2, inputs, attrs} = args;
  const {iouThreshold, maxOutputSize, scoreThreshold} = attrs;
  const {boxes, scores} = inputs;
  const boxesId = backend2.dataIdMap.get(boxes.dataId).id;
  const scoresId = backend2.dataIdMap.get(scores.dataId).id;
  const resOffset = wasmFunc3(boxesId, scoresId, maxOutputSize, iouThreshold, scoreThreshold);
  const {pSelectedIndices, selectedSize, pSelectedScores, pValidOutputs} = parseResultStruct(backend2, resOffset);
  backend2.wasm._free(pSelectedScores);
  backend2.wasm._free(pValidOutputs);
  const selectedIndicesTensor = backend2.makeOutput([selectedSize], "int32", pSelectedIndices);
  return selectedIndicesTensor;
}
const nonMaxSuppressionV3Config = {
  kernelName: NonMaxSuppressionV3,
  backendName: "wasm",
  setupFunc: setup22,
  kernelFunc
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
let wasmFunc4;
function setup23(backend2) {
  wasmFunc4 = backend2.wasm.cwrap(NonMaxSuppressionV4, "number", [
    "number",
    "number",
    "number",
    "number",
    "number",
    "bool"
  ]);
}
function nonMaxSuppressionV4(args) {
  const {backend: backend2, inputs, attrs} = args;
  const {iouThreshold, maxOutputSize, scoreThreshold, padToMaxOutputSize} = attrs;
  const {boxes, scores} = inputs;
  const boxesId = backend2.dataIdMap.get(boxes.dataId).id;
  const scoresId = backend2.dataIdMap.get(scores.dataId).id;
  const resOffset = wasmFunc4(boxesId, scoresId, maxOutputSize, iouThreshold, scoreThreshold, padToMaxOutputSize);
  const {pSelectedIndices, selectedSize, pSelectedScores, pValidOutputs} = parseResultStruct(backend2, resOffset);
  backend2.wasm._free(pSelectedScores);
  const selectedIndicesTensor = backend2.makeOutput([selectedSize], "int32", pSelectedIndices);
  const validOutputsTensor = backend2.makeOutput([], "int32", pValidOutputs);
  return [selectedIndicesTensor, validOutputsTensor];
}
const nonMaxSuppressionV4Config = {
  kernelName: NonMaxSuppressionV4,
  backendName: "wasm",
  setupFunc: setup23,
  kernelFunc: nonMaxSuppressionV4
};
/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
let wasmFunc5;
function setup24(backend2) {
  wasmFunc5 = backend2.wasm.cwrap(NonMaxSuppressionV5, "number", [
    "number",
    "number",
    "number",
    "number",
    "number",
    "number"
  ]);
}
function kernelFunc2(args) {
  const {backend: backend2, inputs, attrs} = args;
  const {iouThreshold, maxOutputSize, scoreThreshold, softNmsSigma} = attrs;
  const {boxes, scores} = inputs;
  const boxesId = backend2.dataIdMap.get(boxes.dataId).id;
  const scoresId = backend2.dataIdMap.get(scores.dataId).id;
  const resOffset = wasmFunc5(boxesId, scoresId, maxOutputSize, iouThreshold, scoreThreshold, softNmsSigma);
  const {pSelectedIndices, selectedSize, pSelectedScores, pValidOutputs} = parseResultStruct(backend2, resOffset);
  backend2.wasm._free(pValidOutputs);
  const selectedIndicesTensor = backend2.makeOutput([selectedSize], "int32", pSelectedIndices);
  const selectedScoresTensor = backend2.makeOutput([selectedSize], "float32", pSelectedScores);
  return [selectedIndicesTensor, selectedScoresTensor];
}
const nonMaxSuppressionV5Config = {
  kernelName: NonMaxSuppressionV5,
  backendName: "wasm",
  setupFunc: setup24,
  kernelFunc: kernelFunc2
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const supportsFullBroadcast13 = false;
const notEqualConfig = createBinaryKernelConfig(NotEqual, supportsFullBroadcast13, "bool");
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
let wasmOneHot;
function setup25(backend2) {
  wasmOneHot = backend2.wasm.cwrap(OneHot, null, [
    "number",
    "number",
    "number",
    "number",
    "number"
  ]);
}
function oneHot(args) {
  const {inputs, backend: backend2, attrs} = args;
  const {indices} = inputs;
  const {depth, onValue, offValue} = attrs;
  const out = backend2.makeOutput([...indices.shape, depth], "int32");
  const outId = backend2.dataIdMap.get(out.dataId).id;
  const indicesData = backend2.dataIdMap.get(indices.dataId);
  const indicesId = indicesData.id;
  wasmOneHot(indicesId, depth, onValue, offValue, outId);
  return out;
}
const oneHotConfig = {
  kernelName: OneHot,
  backendName: "wasm",
  setupFunc: setup25,
  kernelFunc: oneHot
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function onesLike(args) {
  const {inputs: {x}, backend: backend2} = args;
  const out = backend2.makeOutput(x.shape, x.dtype);
  const outVals = backend2.typedArrayFromHeap(out);
  outVals.fill(1);
  return out;
}
const onesLikeConfig = {
  kernelName: OnesLike,
  backendName: "wasm",
  kernelFunc: onesLike
};
/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
let wasmPadV2;
function setup26(backend2) {
  wasmPadV2 = backend2.wasm.cwrap(PadV2, null, [
    "number",
    "array",
    "number",
    "number",
    "array",
    "array",
    "number",
    "number"
  ]);
}
function pad(args) {
  const {inputs: {x}, backend: backend2, attrs: {paddings, constantValue}} = args;
  const outShape = paddings.map((p, i) => p[0] + x.shape[i] + p[1]);
  const xId = backend2.dataIdMap.get(x.dataId).id;
  const out = backend2.makeOutput(outShape, x.dtype);
  const outId = backend2.dataIdMap.get(out.dataId).id;
  const xShapeBytes = new Uint8Array(new Int32Array(x.shape).buffer);
  const prePaddingsFlat = paddings.map((padTuple) => padTuple[0]);
  const postPaddingsFlat = paddings.map((padTuple) => padTuple[1]);
  const prePaddingsBytes = new Uint8Array(new Int32Array(prePaddingsFlat).buffer);
  const postPaddingsBytes = new Uint8Array(new Int32Array(postPaddingsFlat).buffer);
  wasmPadV2(xId, xShapeBytes, x.shape.length, CppDType[x.dtype], prePaddingsBytes, postPaddingsBytes, constantValue, outId);
  return out;
}
const padV2Config = {
  kernelName: PadV2,
  backendName: "wasm",
  kernelFunc: pad,
  setupFunc: setup26
};
/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const supportsFullBroadcast14 = false;
const powConfig = createBinaryKernelConfig(Pow, supportsFullBroadcast14);
/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
let wasmPrelu;
function setup27(backend2) {
  wasmPrelu = backend2.wasm.cwrap(Prelu, null, [
    "number",
    "number",
    "number"
  ]);
}
function prelu3(args) {
  const {inputs, backend: backend2} = args;
  const {x, alpha} = inputs;
  const xId = backend2.dataIdMap.get(x.dataId).id;
  const weightsId = backend2.dataIdMap.get(alpha.dataId).id;
  const out = backend2.makeOutput(x.shape, "float32");
  const outId = backend2.dataIdMap.get(out.dataId).id;
  wasmPrelu(xId, weightsId, outId);
  return out;
}
const preluConfig = {
  kernelName: Prelu,
  backendName: "wasm",
  setupFunc: setup27,
  kernelFunc: prelu3
};
/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const reluConfig = createUnaryKernelConfig(Relu);
/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const relu6Config = createUnaryKernelConfig(Relu6);
/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
let wasmResizeBilinear;
function setup28(backend2) {
  wasmResizeBilinear = backend2.wasm.cwrap(ResizeBilinear, null, [
    "number",
    "number",
    "number",
    "number",
    "number",
    "number",
    "number",
    "number",
    "number"
  ]);
}
function resizeBilinear(args) {
  const {backend: backend2, inputs, attrs} = args;
  const {images} = inputs;
  const {alignCorners, size} = attrs;
  const [newHeight, newWidth] = size;
  const [batch, oldHeight, oldWidth, numChannels] = images.shape;
  const outShape = [batch, newHeight, newWidth, numChannels];
  let xData = backend2.dataIdMap.get(images.dataId);
  let castedData;
  if (xData.dtype !== "float32") {
    castedData = cast6({backend: backend2, inputs: {x: images}, attrs: {dtype: "float32"}});
    xData = backend2.dataIdMap.get(castedData.dataId);
  }
  const xId = xData.id;
  const out = backend2.makeOutput(outShape, "float32");
  if (util_exports.sizeFromShape(images.shape) === 0) {
    return out;
  }
  const outId = backend2.dataIdMap.get(out.dataId).id;
  wasmResizeBilinear(xId, batch, oldHeight, oldWidth, numChannels, newHeight, newWidth, alignCorners ? 1 : 0, outId);
  if (castedData != null) {
    backend2.disposeData(castedData.dataId);
  }
  return out;
}
const resizeBilinearConfig = {
  kernelName: ResizeBilinear,
  backendName: "wasm",
  setupFunc: setup28,
  kernelFunc: resizeBilinear
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
let wasmReverse;
function setup29(backend2) {
  wasmReverse = backend2.wasm.cwrap(Reverse, null, [
    "number",
    "array",
    "number",
    "array",
    "number",
    "number"
  ]);
}
function reverse(args) {
  const {inputs, backend: backend2, attrs} = args;
  const {x} = inputs;
  const {dims} = attrs;
  const axes = util_exports.parseAxisParam(dims, x.shape);
  if (x.shape.length === 0) {
    return identity({inputs: {x}, backend: backend2});
  }
  const out = backend2.makeOutput(x.shape, x.dtype);
  const xId = backend2.dataIdMap.get(x.dataId).id;
  const outId = backend2.dataIdMap.get(out.dataId).id;
  const axesBytes = new Uint8Array(new Int32Array(axes).buffer);
  const outShapeBytes = new Uint8Array(new Int32Array(x.shape).buffer);
  wasmReverse(xId, axesBytes, axes.length, outShapeBytes, x.shape.length, outId);
  return reshape4({inputs: {x: out}, attrs: {shape: x.shape}, backend: backend2});
}
const reverseConfig = {
  kernelName: Reverse,
  backendName: "wasm",
  kernelFunc: reverse,
  setupFunc: setup29
};
/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
let wasmRotate;
function setup30(backend2) {
  wasmRotate = backend2.wasm.cwrap(RotateWithOffset, null, [
    "number",
    "number",
    "number",
    "number",
    "number",
    "number",
    "number",
    "number",
    "array",
    "number",
    "number"
  ]);
}
function rotateWithOffset(args) {
  const {inputs, backend: backend2, attrs} = args;
  const {image: image2} = inputs;
  const {radians, fillValue, center} = attrs;
  const out = backend2.makeOutput(image2.shape, image2.dtype);
  const imageId = backend2.dataIdMap.get(image2.dataId).id;
  const outId = backend2.dataIdMap.get(out.dataId).id;
  const [batch, imageHeight, imageWidth, numChannels] = image2.shape;
  const [centerX, centerY] = backend_util_exports.getImageCenter(center, imageHeight, imageWidth);
  const fillIsBlack = fillValue === 0;
  const fullOpacityValue = 255;
  const fillValues = typeof fillValue === "number" ? [fillValue, fillValue, fillValue, fillIsBlack ? 0 : fullOpacityValue] : [...fillValue, fullOpacityValue];
  const fillBytes = new Uint8Array(new Int32Array(fillValues).buffer);
  wasmRotate(imageId, batch, imageHeight, imageWidth, numChannels, radians, centerX, centerY, fillBytes, fillValues.length, outId);
  return out;
}
const rotateWithOffsetConfig = {
  kernelName: RotateWithOffset,
  backendName: "wasm",
  kernelFunc: rotateWithOffset,
  setupFunc: setup30
};
/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const rsqrtConfig = createUnaryKernelConfig(Rsqrt);
/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
let wasmScatterNd;
function setup31(backend2) {
  wasmScatterNd = backend2.wasm.cwrap(ScatterNd, null, [
    "number",
    "number",
    "number",
    "number",
    "number",
    "number",
    "array",
    "number",
    "number"
  ]);
}
function scatterNd(args) {
  const {backend: backend2, inputs, attrs} = args;
  const {indices, updates} = inputs;
  const {shape} = attrs;
  const out = backend2.makeOutput(shape, updates.dtype);
  if (util_exports.sizeFromShape(shape) === 0) {
    return out;
  }
  const {sliceRank, numUpdates, sliceSize, strides, outputSize} = scatter_nd_util_exports.calculateShapes(updates, indices, shape);
  const indicesData = backend2.dataIdMap.get(indices.dataId);
  const indicesId = indicesData.id;
  const updatesData = backend2.dataIdMap.get(updates.dataId);
  const updatesId = updatesData.id;
  const stridesBytes = new Uint8Array(new Int32Array(strides).buffer);
  const outId = backend2.dataIdMap.get(out.dataId).id;
  wasmScatterNd(indicesId, updatesId, CppDType[updates.dtype], sliceRank, numUpdates, sliceSize, stridesBytes, outputSize, outId);
  return out;
}
const scatterNdConfig = {
  kernelName: ScatterNd,
  backendName: "wasm",
  setupFunc: setup31,
  kernelFunc: scatterNd
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
let wasmSelect;
function setup32(backend2) {
  wasmSelect = backend2.wasm.cwrap(SelectV2, null, [
    "number",
    "number",
    "number",
    "number",
    "number"
  ]);
}
function select(args) {
  const {inputs, backend: backend2} = args;
  const {condition, t, e} = inputs;
  const conditionId = backend2.dataIdMap.get(condition.dataId).id;
  const tId = backend2.dataIdMap.get(t.dataId).id;
  const eId = backend2.dataIdMap.get(e.dataId).id;
  const out = backend2.makeOutput(t.shape, t.dtype);
  const outId = backend2.dataIdMap.get(out.dataId).id;
  const cRank = condition.shape.length;
  const tRank = t.shape.length;
  const offset = cRank === 0 || cRank > 1 || tRank === 1 ? 1 : util_exports.sizeFromShape(t.shape.slice(1));
  wasmSelect(conditionId, tId, eId, offset, outId);
  return out;
}
const selectV2Config = {
  kernelName: SelectV2,
  backendName: "wasm",
  kernelFunc: select,
  setupFunc: setup32
};
/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
let wasmFunc6;
function setup33(backend2) {
  wasmFunc6 = backend2.wasm.cwrap(Sigmoid, null, ["number", "number"]);
}
function sigmoid(args) {
  const {backend: backend2, inputs: {x}} = args;
  const xId = backend2.dataIdMap.get(x.dataId).id;
  const out = backend2.makeOutput(x.shape, x.dtype);
  const outId = backend2.dataIdMap.get(out.dataId).id;
  if (util_exports.sizeFromShape(out.shape) === 0) {
    return out;
  }
  wasmFunc6(xId, outId);
  return out;
}
const sigmoidConfig = {
  kernelName: "Sigmoid",
  backendName: "wasm",
  setupFunc: setup33,
  kernelFunc: sigmoid
};
/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const sinConfig = createUnaryKernelConfig(Sin);
/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function slice(args) {
  const {inputs: {x}, attrs: {begin, size}, backend: backend2} = args;
  const [begin_, size_] = slice_util_exports.parseSliceParams(x, begin, size);
  const isContinous = slice_util_exports.isSliceContinous(x.shape, begin_, size_);
  const xVals = backend2.typedArrayFromHeap(x);
  const out = backend2.makeOutput(size_, x.dtype);
  const outVals = backend2.typedArrayFromHeap(out);
  const xStrides = util_exports.computeStrides(x.shape);
  if (isContinous) {
    const flatOffset = slice_util_exports.computeFlatOffset(begin_, xStrides);
    outVals.set(xVals.subarray(flatOffset, flatOffset + util_exports.sizeFromShape(size_)));
    return out;
  }
  const rank = x.shape.length;
  if (rank === 2) {
    slice2d(xVals, xStrides[0], outVals, begin_, size_);
  } else if (rank === 3) {
    slice3d(xVals, xStrides[0], xStrides[1], outVals, begin_, size_);
  } else if (rank === 4) {
    slice4d(xVals, xStrides[0], xStrides[1], xStrides[2], outVals, begin_, size_);
  } else {
    genericSliceSlow(xVals, x, outVals, begin_, size_);
  }
  return out;
}
function slice2d(xVals, xStride, outVals, begin, size) {
  let outOffset = 0;
  const beginI = begin[0];
  const beginJ = begin[1];
  const endI = beginI + size[0];
  for (let i = beginI; i < endI; i++) {
    const xOffset = i * xStride + beginJ;
    outVals.set(xVals.subarray(xOffset, xOffset + size[1]), outOffset);
    outOffset += size[1];
  }
}
function slice3d(xVals, xStride1, xStride2, outVals, begin, size) {
  let outOffset = 0;
  const beginI = begin[0];
  const beginJ = begin[1];
  const beginK = begin[2];
  const endI = beginI + size[0];
  const endJ = beginJ + size[1];
  for (let i = beginI; i < endI; i++) {
    for (let j = beginJ; j < endJ; j++) {
      const xOffset = i * xStride1 + j * xStride2 + beginK;
      outVals.set(xVals.subarray(xOffset, xOffset + size[2]), outOffset);
      outOffset += size[2];
    }
  }
}
function slice4d(xVals, xStride1, xStride2, xStride3, outVals, begin, size) {
  let outOffset = 0;
  const beginI = begin[0];
  const beginJ = begin[1];
  const beginK = begin[2];
  const endI = beginI + size[0];
  const endJ = beginJ + size[1];
  const endK = beginK + size[2];
  const beginL = begin[3];
  for (let i = beginI; i < endI; i++) {
    for (let j = beginJ; j < endJ; j++) {
      for (let k = beginK; k < endK; k++) {
        const xOffset = i * xStride1 + j * xStride2 + k * xStride3 + beginL;
        outVals.set(xVals.subarray(xOffset, xOffset + size[3]), outOffset);
        outOffset += size[3];
      }
    }
  }
}
function genericSliceSlow(xVals, xInfo, outVals, begin, size) {
  const outBuf = buffer(size, xInfo.dtype, outVals);
  const xBuf = buffer(xInfo.shape, xInfo.dtype, xVals);
  for (let i = 0; i < outBuf.size; ++i) {
    const loc = outBuf.indexToLoc(i);
    const xLoc = loc.map((idx, j) => idx + begin[j]);
    outVals[i] = xBuf.get(...xLoc);
  }
}
const sliceConfig = {
  kernelName: Slice,
  backendName: "wasm",
  kernelFunc: slice
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
let wasmFunc7;
function setup34(backend2) {
  wasmFunc7 = backend2.wasm.cwrap(Softmax, null, [
    "number",
    "number",
    "number",
    "number"
  ]);
}
function softmax(args) {
  const {backend: backend2, inputs: {logits}, attrs: {dim}} = args;
  const xId = backend2.dataIdMap.get(logits.dataId).id;
  const out = backend2.makeOutput(logits.shape, logits.dtype);
  const outId = backend2.dataIdMap.get(out.dataId).id;
  const channels = logits.shape[dim];
  const batch = util_exports.sizeFromShape(logits.shape) / channels;
  if (util_exports.sizeFromShape(out.shape) === 0) {
    return out;
  }
  wasmFunc7(xId, outId, channels, batch);
  return out;
}
const softmaxConfig = {
  kernelName: Softmax,
  backendName: "wasm",
  setupFunc: setup34,
  kernelFunc: softmax
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function split(args) {
  const {inputs, attrs, backend: backend2} = args;
  const {x} = inputs;
  const {numOrSizeSplits, axis} = attrs;
  const $axis = util_exports.parseAxisParam(axis, x.shape)[0];
  const splitSizes = backend_util_exports.prepareSplitSize(x, numOrSizeSplits, axis);
  const begin = new Array(x.shape.length).fill(0);
  const size = x.shape.slice();
  return splitSizes.map((s) => {
    const xSliceSize = [...size];
    xSliceSize[$axis] = s;
    const xSlice = slice({inputs: {x}, attrs: {begin, size: xSliceSize}, backend: backend2});
    begin[$axis] += s;
    return xSlice;
  });
}
const splitVConfig = {
  kernelName: SplitV,
  backendName: "wasm",
  kernelFunc: split
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const sqrtConfig = createUnaryKernelConfig(Sqrt);
/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const squareConfig = createUnaryKernelConfig(Square);
/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const supportsFullBroadcast15 = true;
const squaredDifferenceConfig = createBinaryKernelConfig(SquaredDifference, supportsFullBroadcast15);
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
let wasmStridedSlice;
function setup35(backend2) {
  wasmStridedSlice = backend2.wasm.cwrap(StridedSlice, null, [
    "number",
    "array",
    "number",
    "array",
    "array",
    "array",
    "array",
    "array",
    "number",
    "number"
  ]);
}
function stridedSlice(args) {
  const {backend: backend2, inputs, attrs} = args;
  const {x} = inputs;
  let {begin, end, strides} = attrs;
  if (strides == null) {
    strides = new Array(begin.length);
  }
  const {beginMask, endMask, ellipsisMask, newAxisMask, shrinkAxisMask} = attrs;
  const ellipsisAxes = backend_util_exports.slice_util.maskToAxes(ellipsisMask);
  if (ellipsisAxes.length > 1) {
    throw new Error("Multiple ellipses in slice is not allowed.");
  }
  if (ellipsisMask !== 0 && newAxisMask !== 0) {
    throw new Error("Using both ellipsisMask and newAxisMask is not yet supported.");
  }
  if (ellipsisMask !== 0 && shrinkAxisMask !== 0) {
    throw new Error("Using both ellipsisMask and shrinkAxisMask is not yet supported.");
  }
  const numInterpolatedAxes = x.shape.length - begin.length;
  const expandAxes = backend_util_exports.slice_util.maskToAxes(newAxisMask);
  const newShape = x.shape.slice();
  expandAxes.forEach((axis) => {
    begin[axis] = 0;
    end[axis] = 1;
    newShape.splice(axis, 0, 1);
  });
  const xReshaped = reshape4({inputs: {x}, attrs: {shape: newShape}, backend: backend2});
  const {begin: normalizedBegin, end: normalizedEnd, strides: normalizedStrides} = backend_util_exports.slice_util.getNormalizedAxes(xReshaped.shape, ellipsisAxes, numInterpolatedAxes, begin, end, strides, beginMask, endMask, ellipsisMask);
  begin = normalizedBegin;
  end = normalizedEnd;
  strides = normalizedStrides;
  const shrinkAxes = backend_util_exports.slice_util.maskToAxes(shrinkAxisMask);
  shrinkAxes.forEach((axis) => {
    end[axis] = begin[axis] + 1;
    strides[axis] = 1;
  });
  const size = backend_util_exports.slice_util.computeOutShape(begin, end, strides);
  const outShape = size.filter((_, axis) => shrinkAxes.indexOf(axis) === -1);
  const nonStrided = strides.every((v) => v === 1);
  if (nonStrided) {
    const xSliced = slice({inputs: {x}, attrs: {begin, size}, backend: backend2});
    return reshape4({inputs: {x: xSliced}, attrs: {shape: outShape}, backend: backend2});
  }
  const out = backend2.makeOutput(outShape, "float32");
  if (!outShape.some((axis) => axis === 0)) {
    const xId = backend2.dataIdMap.get(xReshaped.dataId).id;
    const xStridesBytes = new Uint8Array(new Int32Array(util_exports.computeStrides(xReshaped.shape)).buffer);
    const beginBytes = new Uint8Array(new Int32Array(begin).buffer);
    const endBytes = new Uint8Array(new Int32Array(end).buffer);
    const stridesBytes = new Uint8Array(new Int32Array(strides).buffer);
    const outputShapeBytes = new Uint8Array(new Int32Array(outShape).buffer);
    const outStridesBytes = new Uint8Array(new Int32Array(util_exports.computeStrides(outShape)).buffer);
    const outId = backend2.dataIdMap.get(out.dataId).id;
    wasmStridedSlice(xId, xStridesBytes, xReshaped.shape.length, beginBytes, endBytes, stridesBytes, outputShapeBytes, outStridesBytes, outShape.length, outId);
  }
  return reshape4({inputs: {x: out}, attrs: {shape: outShape}, backend: backend2});
}
const stridedSliceConfig = {
  kernelName: StridedSlice,
  backendName: "wasm",
  setupFunc: setup35,
  kernelFunc: stridedSlice
};
/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const supportsFullBroadcast16 = true;
const subConfig = createBinaryKernelConfig(Sub, supportsFullBroadcast16);
/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
let wasmSum;
function setup36(backend2) {
  wasmSum = backend2.wasm.cwrap(Sum, null, ["number, number, number"]);
}
function sum4(args) {
  const {backend: backend2, inputs, attrs} = args;
  const {axis, keepDims} = attrs;
  const {x} = inputs;
  const xId = backend2.dataIdMap.get(x.dataId).id;
  let inputId = xId;
  let input = x;
  const {transposed, axes, originalAxes, inputWasTransposed} = permuteAxesAndTranspose(x, axis, backend2);
  let reductionAxes = axes;
  if (inputWasTransposed) {
    const transposedId = backend2.dataIdMap.get(transposed.dataId).id;
    if (transposedId !== xId) {
      input = transposed;
      inputId = transposedId;
      reductionAxes = backend_util_exports.getInnerMostAxes(reductionAxes.length, input.shape.length);
    }
  }
  backend_util_exports.assertAxesAreInnerMostDims("sum", reductionAxes, input.shape.length);
  const [outShape, reduceShape] = backend_util_exports.computeOutAndReduceShapes(input.shape, reductionAxes);
  const reduceSize = util_exports.sizeFromShape(reduceShape);
  const out = backend2.makeOutput(outShape, input.dtype);
  if (util_exports.sizeFromShape(input.shape) !== 0) {
    const outId = backend2.dataIdMap.get(out.dataId).id;
    wasmSum(inputId, reduceSize, outId);
  }
  if (inputWasTransposed) {
    backend2.disposeData(transposed.dataId);
  }
  if (keepDims) {
    const newShape = backend_util_exports.expandShapeToKeepDim(out.shape, originalAxes);
    out.shape = newShape;
  }
  return out;
}
const sumConfig = {
  kernelName: Sum,
  backendName: "wasm",
  setupFunc: setup36,
  kernelFunc: sum4
};
/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const tanhConfig = createUnaryKernelConfig(Tanh);
/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
let wasmTile;
function setup37(backend2) {
  wasmTile = backend2.wasm.cwrap(Tile, null, [
    "number",
    "array",
    "number",
    "array",
    "number",
    "number"
  ]);
}
function tile(args) {
  const {inputs, backend: backend2, attrs} = args;
  const {x} = inputs;
  const xId = backend2.dataIdMap.get(x.dataId).id;
  const {reps} = attrs;
  const newShape = new Array(x.shape.length);
  for (let i = 0; i < newShape.length; i++) {
    newShape[i] = x.shape[i] * reps[i];
  }
  const xShapeBytes = new Uint8Array(new Int32Array(x.shape).buffer);
  const newShapeBytes = new Uint8Array(new Int32Array(newShape).buffer);
  const out = backend2.makeOutput(newShape, x.dtype);
  const outId = backend2.dataIdMap.get(out.dataId).id;
  wasmTile(xId, xShapeBytes, x.shape.length, newShapeBytes, newShape.length, CppDType[out.dtype], outId);
  return out;
}
const tileConfig = {
  kernelName: Tile,
  backendName: "wasm",
  setupFunc: setup37,
  kernelFunc: tile
};
/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function unpack(args) {
  const {inputs, backend: backend2, attrs} = args;
  const {value} = inputs;
  const {axis} = attrs;
  const numOutputs = value.shape[axis];
  const rank = value.shape.length;
  const outShape = new Array(rank - 1);
  let outIndex = 0;
  for (let i = 0; i < rank; i++) {
    if (i !== axis) {
      outShape[outIndex++] = value.shape[i];
    }
  }
  const outs = new Array(numOutputs);
  const begin = new Array(rank).fill(0);
  const size = value.shape.slice();
  size[axis] = 1;
  for (let i = 0; i < outs.length; i++) {
    begin[axis] = i;
    outs[i] = slice({inputs: {x: value}, attrs: {begin, size}, backend: backend2});
  }
  return outs.map(({dataId, dtype}) => ({dataId, dtype, shape: outShape}));
}
const unpackConfig = {
  kernelName: Unpack,
  backendName: "wasm",
  kernelFunc: unpack
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function zerosLike(args) {
  const {inputs: {x}, backend: backend2} = args;
  const out = backend2.makeOutput(x.shape, x.dtype);
  const outVals = backend2.typedArrayFromHeap(out);
  outVals.fill(0);
  return out;
}
const zerosLikeConfig = {
  kernelName: ZerosLike,
  backendName: "wasm",
  kernelFunc: zerosLike
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const kernelConfigs = [
  absConfig,
  addConfig,
  addNConfig,
  argMaxConfig,
  avgPoolConfig,
  batchMatMulConfig,
  castConfig,
  clipByValueConfig,
  concatConfig,
  conv2DConfig,
  conv2DBackpropInputConfig,
  cosConfig,
  cropAndResizeConfig,
  cumsumConfig,
  depthToSpaceConfig,
  depthwiseConv2dNativeConfig,
  divConfig,
  equalConfig,
  expConfig,
  fillConfig,
  flipLeftRightConfig,
  floorDivConfig,
  fusedMatMulConfig,
  fusedBatchNormConfig,
  fusedConv2DConfig,
  fusedDepthwiseConv2DConfig,
  gatherNdConfig,
  gatherV2Config,
  greaterConfig,
  greaterEqualConfig,
  identityConfig,
  lessConfig,
  lessEqualConfig,
  logConfig,
  logicalAndConfig,
  maxConfig,
  maximumConfig,
  maxPoolConfig,
  minConfig,
  minimumConfig,
  multiplyConfig,
  negateConfig,
  nonMaxSuppressionV3Config,
  nonMaxSuppressionV4Config,
  nonMaxSuppressionV5Config,
  notEqualConfig,
  oneHotConfig,
  onesLikeConfig,
  padV2Config,
  powConfig,
  preluConfig,
  reluConfig,
  relu6Config,
  reshapeConfig,
  resizeBilinearConfig,
  reverseConfig,
  rotateWithOffsetConfig,
  rsqrtConfig,
  scatterNdConfig,
  selectV2Config,
  sigmoidConfig,
  sinConfig,
  sliceConfig,
  softmaxConfig,
  splitVConfig,
  sqrtConfig,
  squareConfig,
  squaredDifferenceConfig,
  stridedSliceConfig,
  subConfig,
  sumConfig,
  tanhConfig,
  tileConfig,
  transposeConfig,
  unpackConfig,
  zerosLikeConfig
];
for (const kernelConfig of kernelConfigs) {
  registerKernel(kernelConfig);
}
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const ENV2 = env();
ENV2.registerFlag("WASM_HAS_SIMD_SUPPORT", async () => WebAssembly.validate(new Uint8Array([
  0,
  97,
  115,
  109,
  1,
  0,
  0,
  0,
  1,
  4,
  1,
  96,
  0,
  0,
  3,
  2,
  1,
  0,
  10,
  9,
  1,
  7,
  0,
  65,
  0,
  253,
  15,
  26,
  11
])));
ENV2.registerFlag("WASM_HAS_MULTITHREAD_SUPPORT", async () => {
  if (ENV2.get("IS_NODE")) {
    return false;
  }
  try {
    new MessageChannel().port1.postMessage(new SharedArrayBuffer(1));
    return WebAssembly.validate(new Uint8Array([
      0,
      97,
      115,
      109,
      1,
      0,
      0,
      0,
      1,
      4,
      1,
      96,
      0,
      0,
      3,
      2,
      1,
      0,
      5,
      4,
      1,
      3,
      1,
      1,
      10,
      11,
      1,
      9,
      0,
      65,
      0,
      254,
      16,
      2,
      0,
      26,
      11
    ]));
  } catch (e) {
    return false;
  }
});
const tfjs_backend_wasm_threaded_simd = __toModule(require_tfjs_backend_wasm_threaded_simd());
const wasmWorkerContents = 'var threadInfoStruct=0;var selfThreadId=0;var parentThreadId=0;var Module={};function threadPrintErr(){var text=Array.prototype.slice.call(arguments).join(" ");console.error(text)}function threadAlert(){var text=Array.prototype.slice.call(arguments).join(" ");postMessage({cmd:"alert",text:text,threadId:selfThreadId})}var err=threadPrintErr;this.alert=threadAlert;Module["instantiateWasm"]=function(info,receiveInstance){var instance=new WebAssembly.Instance(Module["wasmModule"],info);Module["wasmModule"]=null;receiveInstance(instance);return instance.exports};this.onmessage=function(e){try{if(e.data.cmd==="load"){Module["DYNAMIC_BASE"]=e.data.DYNAMIC_BASE;Module["DYNAMICTOP_PTR"]=e.data.DYNAMICTOP_PTR;Module["wasmModule"]=e.data.wasmModule;Module["wasmMemory"]=e.data.wasmMemory;Module["buffer"]=Module["wasmMemory"].buffer;Module["ENVIRONMENT_IS_PTHREAD"]=true;if(typeof e.data.urlOrBlob==="string"){importScripts(e.data.urlOrBlob)}else{var objectUrl=URL.createObjectURL(e.data.urlOrBlob);importScripts(objectUrl);URL.revokeObjectURL(objectUrl)}Module=WasmBackendModuleThreadedSimd(Module);postMessage({"cmd":"loaded"})}else if(e.data.cmd==="objectTransfer"){Module["PThread"].receiveObjectTransfer(e.data)}else if(e.data.cmd==="run"){Module["__performance_now_clock_drift"]=performance.now()-e.data.time;threadInfoStruct=e.data.threadInfoStruct;Module["__register_pthread_ptr"](threadInfoStruct,0,0);selfThreadId=e.data.selfThreadId;parentThreadId=e.data.parentThreadId;var max=e.data.stackBase;var top=e.data.stackBase+e.data.stackSize;Module["establishStackSpace"](top,max);Module["_emscripten_tls_init"]();Module["PThread"].receiveObjectTransfer(e.data);Module["PThread"].setThreadStatus(Module["_pthread_self"](),1);try{var result=Module["dynCall_ii"](e.data.start_routine,e.data.arg);if(!Module["getNoExitRuntime"]())Module["PThread"].threadExit(result)}catch(ex){if(ex==="Canceled!"){Module["PThread"].threadCancel()}else if(ex!="unwind"){Atomics.store(Module["HEAPU32"],threadInfoStruct+4>>2,ex instanceof Module["ExitStatus"]?ex.status:-2);Atomics.store(Module["HEAPU32"],threadInfoStruct+0>>2,1);Module["_emscripten_futex_wake"](threadInfoStruct+0,2147483647);if(!(ex instanceof Module["ExitStatus"]))throw ex}}}else if(e.data.cmd==="cancel"){if(threadInfoStruct){Module["PThread"].threadCancel()}}else if(e.data.target==="setimmediate"){}else if(e.data.cmd==="processThreadQueue"){if(threadInfoStruct){Module["_emscripten_current_thread_process_queued_calls"]()}}else{err("worker.js received unknown command "+e.data.cmd);err(e.data)}}catch(ex){err("worker.js onmessage() captured an uncaught exception: "+ex);if(ex.stack)err(ex.stack);throw ex}};if(typeof process==="object"&&typeof process.versions==="object"&&typeof process.versions.node==="string"){self={location:{href:__filename}};var onmessage=this.onmessage;var nodeWorkerThreads=require("worker_threads");Worker=nodeWorkerThreads.Worker;var parentPort=nodeWorkerThreads.parentPort;parentPort.on("message",function(data){onmessage({data:data})});var nodeFS=require("fs");var nodeRead=function(filename){return nodeFS.readFileSync(filename,"utf8")};function globalEval(x){global.require=require;global.Module=Module;eval.call(null,x)}importScripts=function(f){globalEval(nodeRead(f))};postMessage=function(msg){parentPort.postMessage(msg)};if(typeof performance==="undefined"){performance={now:function(){return Date.now()}}}}';
const tfjs_backend_wasm = __toModule(require_tfjs_backend_wasm());
/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const WASM_PRIORITY = 2;
class BackendWasm extends KernelBackend {
  constructor(wasm) {
    super();
    this.wasm = wasm;
    this.dataIdNextNumber = 1;
    this.wasm.tfjs.init();
    this.dataIdMap = new DataStorage(this, engine9());
  }
  write(values, shape, dtype) {
    const dataId = {};
    this.move(dataId, values, shape, dtype);
    return dataId;
  }
  numDataIds() {
    return this.dataIdMap.numDataIds();
  }
  async time(f) {
    const start = util_exports.now();
    f();
    const kernelMs = util_exports.now() - start;
    return {kernelMs};
  }
  move(dataId, values, shape, dtype) {
    const id = this.dataIdNextNumber++;
    if (dtype === "string") {
      const stringBytes = values;
      this.dataIdMap.set(dataId, {id, stringBytes, shape, dtype, memoryOffset: null});
      return;
    }
    const size = util_exports.sizeFromShape(shape);
    const numBytes = size * util_exports.bytesPerElement(dtype);
    const memoryOffset = this.wasm._malloc(numBytes);
    this.dataIdMap.set(dataId, {id, memoryOffset, shape, dtype});
    this.wasm.tfjs.registerTensor(id, size, memoryOffset);
    if (values != null) {
      this.wasm.HEAPU8.set(new Uint8Array(values.buffer, values.byteOffset, numBytes), memoryOffset);
    }
  }
  async read(dataId) {
    return this.readSync(dataId);
  }
  readSync(dataId) {
    const {memoryOffset, dtype, shape, stringBytes} = this.dataIdMap.get(dataId);
    if (dtype === "string") {
      return stringBytes;
    }
    const bytes = this.wasm.HEAPU8.slice(memoryOffset, memoryOffset + util_exports.sizeFromShape(shape) * util_exports.bytesPerElement(dtype));
    return typedArrayFromBuffer(bytes.buffer, dtype);
  }
  disposeData(dataId) {
    const data2 = this.dataIdMap.get(dataId);
    this.wasm._free(data2.memoryOffset);
    this.wasm.tfjs.disposeData(data2.id);
    this.dataIdMap.delete(dataId);
  }
  floatPrecision() {
    return 32;
  }
  getMemoryOffset(dataId) {
    return this.dataIdMap.get(dataId).memoryOffset;
  }
  dispose() {
    this.wasm.tfjs.dispose();
    this.wasm = null;
  }
  memory() {
    return {unreliable: false};
  }
  makeOutput(shape, dtype, memoryOffset) {
    let dataId;
    if (memoryOffset == null) {
      dataId = this.write(null, shape, dtype);
    } else {
      dataId = {};
      const id = this.dataIdNextNumber++;
      this.dataIdMap.set(dataId, {id, memoryOffset, shape, dtype});
      const size = util_exports.sizeFromShape(shape);
      this.wasm.tfjs.registerTensor(id, size, memoryOffset);
    }
    return {dataId, shape, dtype};
  }
  typedArrayFromHeap({shape, dtype, dataId}) {
    const buffer2 = this.wasm.HEAPU8.buffer;
    const {memoryOffset} = this.dataIdMap.get(dataId);
    const size = util_exports.sizeFromShape(shape);
    switch (dtype) {
      case "float32":
        return new Float32Array(buffer2, memoryOffset, size);
      case "int32":
        return new Int32Array(buffer2, memoryOffset, size);
      case "bool":
        return new Uint8Array(buffer2, memoryOffset, size);
      default:
        throw new Error(`Unknown dtype ${dtype}`);
    }
  }
}
registerBackend("wasm", async () => {
  const {wasm} = await init();
  return new BackendWasm(wasm);
}, WASM_PRIORITY);
function createInstantiateWasmFunc(path) {
  return (imports, callback) => {
    util_exports.fetch(path, {credentials: "same-origin"}).then((response) => {
      if (!response["ok"]) {
        imports.env.a(`failed to load wasm binary file at '${path}'`);
      }
      response.arrayBuffer().then((binary) => {
        WebAssembly.instantiate(binary, imports).then((output) => {
          callback(output.instance);
        });
      });
    });
    return {};
  };
}
function getPathToWasmBinary(simdSupported, threadsSupported, wasmModuleFolder) {
  if (wasmPath != null) {
    return wasmPath;
  }
  let path = "tfjs-backend-wasm.wasm";
  if (simdSupported && threadsSupported) {
    path = "tfjs-backend-wasm-threaded-simd.wasm";
  } else if (simdSupported) {
    path = "tfjs-backend-wasm-simd.wasm";
  }
  if (wasmFileMap != null) {
    if (wasmFileMap[path] != null) {
      return wasmFileMap[path];
    }
  }
  return wasmModuleFolder + path;
}
async function init() {
  const [simdSupported, threadsSupported] = await Promise.all([
    env().getAsync("WASM_HAS_SIMD_SUPPORT"),
    env().getAsync("WASM_HAS_MULTITHREAD_SUPPORT")
  ]);
  return new Promise((resolve, reject) => {
    const factoryConfig = {};
    factoryConfig.locateFile = (path, prefix) => {
      if (path.endsWith(".worker.js")) {
        const response = wasmWorkerContents;
        const blob = new Blob([response], {type: "application/javascript"});
        return URL.createObjectURL(blob);
      }
      if (path.endsWith(".wasm")) {
        return getPathToWasmBinary(simdSupported, threadsSupported, wasmPathPrefix != null ? wasmPathPrefix : prefix);
      }
      return prefix + path;
    };
    if (customFetch) {
      factoryConfig.instantiateWasm = createInstantiateWasmFunc(getPathToWasmBinary(simdSupported, threadsSupported, wasmPathPrefix != null ? wasmPathPrefix : ""));
    }
    let wasm;
    if (threadsSupported && simdSupported && wasmPath == null) {
      wasm = tfjs_backend_wasm_threaded_simd.default(factoryConfig);
      wasm.mainScriptUrlOrBlob = new Blob([`var _scriptDir = undefined; var WasmBackendModuleThreadedSimd = ` + tfjs_backend_wasm_threaded_simd.default.toString()], {type: "text/javascript"});
    } else {
      wasm = tfjs_backend_wasm.default(factoryConfig);
    }
    const voidReturnType = null;
    wasm.tfjs = {
      init: wasm.cwrap("init", null, []),
      registerTensor: wasm.cwrap("register_tensor", null, [
        "number",
        "number",
        "number"
      ]),
      disposeData: wasm.cwrap("dispose_data", voidReturnType, ["number"]),
      dispose: wasm.cwrap("dispose", voidReturnType, [])
    };
    let initialized = false;
    wasm.onRuntimeInitialized = () => {
      initialized = true;
      initAborted = false;
      resolve({wasm});
    };
    wasm.onAbort = () => {
      if (initialized) {
        return;
      }
      if (initAborted) {
        return;
      }
      initAborted = true;
      const rejectMsg = "Make sure the server can serve the `.wasm` file relative to the bundled js file. For more details see https://github.com/tensorflow/tfjs/blob/master/tfjs-backend-wasm/README.md#using-bundlers";
      reject({message: rejectMsg});
    };
  });
}
function typedArrayFromBuffer(buffer2, dtype) {
  switch (dtype) {
    case "float32":
      return new Float32Array(buffer2);
    case "int32":
      return new Int32Array(buffer2);
    case "bool":
      return new Uint8Array(buffer2);
    default:
      throw new Error(`Unknown dtype ${dtype}`);
  }
}
const wasmBinaryNames = [
  "tfjs-backend-wasm.wasm",
  "tfjs-backend-wasm-simd.wasm",
  "tfjs-backend-wasm-threaded-simd.wasm"
];
let wasmPath = null;
let wasmPathPrefix = null;
let wasmFileMap = {};
let initAborted = false;
let customFetch = false;
function setWasmPaths(prefixOrFileMap, usePlatformFetch = false) {
  if (initAborted) {
    throw new Error("The WASM backend was already initialized. Make sure you call `setWasmPaths()` before you call `tf.setBackend()` or `tf.ready()`");
  }
  if (typeof prefixOrFileMap === "string") {
    wasmPathPrefix = prefixOrFileMap;
  } else {
    wasmFileMap = prefixOrFileMap;
    const missingPaths = wasmBinaryNames.filter((name) => wasmFileMap[name] == null);
    if (missingPaths.length > 0) {
      throw new Error(`There were no entries found for the following binaries: ${missingPaths.join(",")}. Please either call setWasmPaths with a map providing a path for each binary, or with a string indicating the directory where all the binaries can be found.`);
    }
  }
  customFetch = usePlatformFetch;
}
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const loadGraphModel = tf.loadGraphModel;
const facemesh = __toModule(require_facemesh());
const age = __toModule(require_age());
const gender = __toModule(require_gender());
const emotion = __toModule(require_emotion());
const embedding = __toModule(require_embedding());
const posenet = __toModule(require_posenet());
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function getBoxSize(box) {
  return [
    Math.abs(box.endPoint[0] - box.startPoint[0]),
    Math.abs(box.endPoint[1] - box.startPoint[1])
  ];
}
function getBoxCenter(box) {
  return [
    box.startPoint[0] + (box.endPoint[0] - box.startPoint[0]) / 2,
    box.startPoint[1] + (box.endPoint[1] - box.startPoint[1]) / 2
  ];
}
function cutBoxFromImageAndResize(box, image2, cropSize) {
  const h = image2.shape[1];
  const w = image2.shape[2];
  const boxes = [[
    box.startPoint[1] / h,
    box.startPoint[0] / w,
    box.endPoint[1] / h,
    box.endPoint[0] / w
  ]];
  return tf.image.cropAndResize(image2, boxes, [0], cropSize);
}
function scaleBoxCoordinates(box, factor) {
  const startPoint = [box.startPoint[0] * factor[0], box.startPoint[1] * factor[1]];
  const endPoint = [box.endPoint[0] * factor[0], box.endPoint[1] * factor[1]];
  const palmLandmarks = box.palmLandmarks.map((coord) => {
    const scaledCoord = [coord[0] * factor[0], coord[1] * factor[1]];
    return scaledCoord;
  });
  return {startPoint, endPoint, palmLandmarks, confidence: box.confidence};
}
function enlargeBox(box, factor = 1.5) {
  const center = getBoxCenter(box);
  const size = getBoxSize(box);
  const newHalfSize = [factor * size[0] / 2, factor * size[1] / 2];
  const startPoint = [center[0] - newHalfSize[0], center[1] - newHalfSize[1]];
  const endPoint = [center[0] + newHalfSize[0], center[1] + newHalfSize[1]];
  return {startPoint, endPoint, palmLandmarks: box.palmLandmarks};
}
function squarifyBox(box) {
  const centers = getBoxCenter(box);
  const size = getBoxSize(box);
  const maxEdge = Math.max(...size);
  const halfSize = maxEdge / 2;
  const startPoint = [centers[0] - halfSize, centers[1] - halfSize];
  const endPoint = [centers[0] + halfSize, centers[1] + halfSize];
  return {startPoint, endPoint, palmLandmarks: box.palmLandmarks};
}
function shiftBox(box, shiftFactor) {
  const boxSize = [
    box.endPoint[0] - box.startPoint[0],
    box.endPoint[1] - box.startPoint[1]
  ];
  const shiftVector = [boxSize[0] * shiftFactor[0], boxSize[1] * shiftFactor[1]];
  const startPoint = [box.startPoint[0] + shiftVector[0], box.startPoint[1] + shiftVector[1]];
  const endPoint = [box.endPoint[0] + shiftVector[0], box.endPoint[1] + shiftVector[1]];
  return {startPoint, endPoint, palmLandmarks: box.palmLandmarks};
}
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function normalizeRadians(angle) {
  return angle - 2 * Math.PI * Math.floor((angle + Math.PI) / (2 * Math.PI));
}
function computeRotation(point1, point2) {
  const radians = Math.PI / 2 - Math.atan2(-(point2[1] - point1[1]), point2[0] - point1[0]);
  return normalizeRadians(radians);
}
const buildTranslationMatrix = (x, y) => [[1, 0, x], [0, 1, y], [0, 0, 1]];
function dot(v1, v2) {
  let product = 0;
  for (let i = 0; i < v1.length; i++) {
    product += v1[i] * v2[i];
  }
  return product;
}
function getColumnFrom2DArr(arr, columnIndex) {
  const column = [];
  for (let i = 0; i < arr.length; i++) {
    column.push(arr[i][columnIndex]);
  }
  return column;
}
function multiplyTransformMatrices(mat1, mat2) {
  const product = [];
  const size = mat1.length;
  for (let row = 0; row < size; row++) {
    product.push([]);
    for (let col = 0; col < size; col++) {
      product[row].push(dot(mat1[row], getColumnFrom2DArr(mat2, col)));
    }
  }
  return product;
}
function buildRotationMatrix(rotation, center) {
  const cosA = Math.cos(rotation);
  const sinA = Math.sin(rotation);
  const rotationMatrix = [[cosA, -sinA, 0], [sinA, cosA, 0], [0, 0, 1]];
  const translationMatrix = buildTranslationMatrix(center[0], center[1]);
  const translationTimesRotation = multiplyTransformMatrices(translationMatrix, rotationMatrix);
  const negativeTranslationMatrix = buildTranslationMatrix(-center[0], -center[1]);
  return multiplyTransformMatrices(translationTimesRotation, negativeTranslationMatrix);
}
function invertTransformMatrix(matrix) {
  const rotationComponent = [[matrix[0][0], matrix[1][0]], [matrix[0][1], matrix[1][1]]];
  const translationComponent = [matrix[0][2], matrix[1][2]];
  const invertedTranslation = [
    -dot(rotationComponent[0], translationComponent),
    -dot(rotationComponent[1], translationComponent)
  ];
  return [
    rotationComponent[0].concat(invertedTranslation[0]),
    rotationComponent[1].concat(invertedTranslation[1]),
    [0, 0, 1]
  ];
}
function rotatePoint(homogeneousCoordinate, rotationMatrix) {
  return [
    dot(homogeneousCoordinate, rotationMatrix[0]),
    dot(homogeneousCoordinate, rotationMatrix[1])
  ];
}
const handpose = __toModule(require_handpose());
const gesture = __toModule(require_gesture());
const image = __toModule(require_image());
const profile = __toModule(require_profile());
var config_default = {
  backend: "webgl",
  wasmPath: "../assets/",
  console: true,
  async: true,
  profile: false,
  deallocate: false,
  scoped: false,
  videoOptimized: true,
  filter: {
    enabled: true,
    width: 0,
    height: 0,
    return: true,
    brightness: 0,
    contrast: 0,
    sharpness: 0,
    blur: 0,
    saturation: 0,
    hue: 0,
    negative: false,
    sepia: false,
    vintage: false,
    kodachrome: false,
    technicolor: false,
    polaroid: false,
    pixelate: 0
  },
  gesture: {
    enabled: true
  },
  face: {
    enabled: true,
    detector: {
      modelPath: "../models/blazeface-back.json",
      inputSize: 256,
      rotation: false,
      maxFaces: 10,
      skipFrames: 15,
      minConfidence: 0.5,
      iouThreshold: 0.2,
      scoreThreshold: 0.5
    },
    mesh: {
      enabled: true,
      modelPath: "../models/facemesh.json",
      inputSize: 192
    },
    iris: {
      enabled: true,
      modelPath: "../models/iris.json",
      inputSize: 64
    },
    age: {
      enabled: true,
      modelPath: "../models/age-ssrnet-imdb.json",
      inputSize: 64,
      skipFrames: 15
    },
    gender: {
      enabled: true,
      minConfidence: 0.1,
      modelPath: "../models/gender-ssrnet-imdb.json",
      inputSize: 64,
      skipFrames: 15
    },
    emotion: {
      enabled: true,
      inputSize: 64,
      minConfidence: 0.2,
      skipFrames: 15,
      modelPath: "../models/emotion-large.json"
    },
    embedding: {
      enabled: false,
      inputSize: 112,
      modelPath: "../models/mobilefacenet.json"
    }
  },
  body: {
    enabled: true,
    modelPath: "../models/posenet.json",
    inputSize: 257,
    maxDetections: 10,
    scoreThreshold: 0.8,
    nmsRadius: 20
  },
  hand: {
    enabled: true,
    inputSize: 256,
    skipFrames: 15,
    minConfidence: 0.5,
    iouThreshold: 0.1,
    scoreThreshold: 0.8,
    maxHands: 1,
    landmarks: true,
    detector: {
      modelPath: "../models/handdetect.json"
    },
    skeleton: {
      modelPath: "../models/handskeleton.json"
    }
  }
};
var version3 = "0.9.2";
const now2 = () => {
  if (typeof performance !== "undefined")
    return performance.now();
  return parseInt(Number(process.hrtime.bigint()) / 1e3 / 1e3);
};
function mergeDeep(...objects) {
  const isObject = (obj) => obj && typeof obj === "object";
  return objects.reduce((prev, obj) => {
    Object.keys(obj || {}).forEach((key) => {
      const pVal = prev[key];
      const oVal = obj[key];
      if (Array.isArray(pVal) && Array.isArray(oVal)) {
        prev[key] = pVal.concat(...oVal);
      } else if (isObject(pVal) && isObject(oVal)) {
        prev[key] = mergeDeep(pVal, oVal);
      } else {
        prev[key] = oVal;
      }
    });
    return prev;
  }, {});
}
class Human {
  constructor(userConfig2 = {}) {
    this.tf = tf;
    this.version = version3;
    this.config = mergeDeep(config_default, userConfig2);
    this.fx = null;
    this.state = "idle";
    this.numTensors = 0;
    this.analyzeMemoryLeaks = false;
    this.checkSanity = false;
    this.firstRun = true;
    this.perf = {};
    this.models = {
      facemesh: null,
      posenet: null,
      handpose: null,
      iris: null,
      age: null,
      gender: null,
      emotion: null
    };
    this.facemesh = facemesh;
    this.age = age;
    this.gender = gender;
    this.emotion = emotion;
    this.body = posenet;
    this.hand = handpose;
  }
  log(...msg) {
    if (msg && this.config.console)
      console.log("Human:", ...msg);
  }
  profile() {
    if (this.config.profile)
      return profile.data;
    return {};
  }
  analyze(...msg) {
    if (!this.analyzeMemoryLeaks)
      return;
    const current = tf.engine().state.numTensors;
    const previous = this.numTensors;
    this.numTensors = current;
    const leaked = current - previous;
    if (leaked !== 0)
      this.log(...msg, leaked);
  }
  sanity(input) {
    if (!this.checkSanity)
      return null;
    if (!input)
      return "input is not defined";
    if (tf.ENV.flags.IS_NODE && !(input instanceof tf.Tensor)) {
      return "input must be a tensor";
    }
    try {
      tf.getBackend();
    } catch (e) {
      return "backend not loaded";
    }
    return null;
  }
  simmilarity(embedding1, embedding2) {
    if (this.config.face.embedding.enabled)
      return embedding.simmilarity(embedding1, embedding2);
    return 0;
  }
  async load(userConfig2) {
    this.state = "load";
    const timeStamp = now2();
    if (userConfig2)
      this.config = mergeDeep(this.config, userConfig2);
    if (this.firstRun) {
      this.checkBackend(true);
      this.log(`version: ${this.version} TensorFlow/JS version: ${tf.version_core}`);
      this.log("configuration:", this.config);
      this.log("flags:", tf.ENV.flags);
      this.firstRun = false;
    }
    if (this.config.async) {
      [
        this.models.facemesh,
        this.models.age,
        this.models.gender,
        this.models.emotion,
        this.models.embedding,
        this.models.posenet,
        this.models.handpose
      ] = await Promise.all([
        this.models.facemesh || (this.config.face.enabled ? facemesh.load(this.config.face) : null),
        this.models.age || (this.config.face.enabled && this.config.face.age.enabled ? age.load(this.config) : null),
        this.models.gender || (this.config.face.enabled && this.config.face.gender.enabled ? gender.load(this.config) : null),
        this.models.emotion || (this.config.face.enabled && this.config.face.emotion.enabled ? emotion.load(this.config) : null),
        this.models.embedding || (this.config.face.enabled && this.config.face.embedding.enabled ? embedding.load(this.config) : null),
        this.models.posenet || (this.config.body.enabled ? posenet.load(this.config) : null),
        this.models.handpose || (this.config.hand.enabled ? handpose.load(this.config.hand) : null)
      ]);
    } else {
      if (this.config.face.enabled && !this.models.facemesh)
        this.models.facemesh = await facemesh.load(this.config.face);
      if (this.config.face.enabled && this.config.face.age.enabled && !this.models.age)
        this.models.age = await age.load(this.config);
      if (this.config.face.enabled && this.config.face.gender.enabled && !this.models.gender)
        this.models.gender = await gender.load(this.config);
      if (this.config.face.enabled && this.config.face.emotion.enabled && !this.models.emotion)
        this.models.emotion = await emotion.load(this.config);
      if (this.config.face.enabled && this.config.face.embedding.enabled && !this.models.embedding)
        this.models.embedding = await embedding.load(this.config);
      if (this.config.body.enabled && !this.models.posenet)
        this.models.posenet = await posenet.load(this.config);
      if (this.config.hand.enabled && !this.models.handpose)
        this.models.handpose = await handpose.load(this.config.hand);
    }
    const current = Math.trunc(now2() - timeStamp);
    if (current > (this.perf.load || 0))
      this.perf.load = current;
  }
  async checkBackend(force) {
    const timeStamp = now2();
    if (this.config.backend && this.config.backend !== "" && force || tf.getBackend() !== this.config.backend) {
      this.state = "backend";
      this.log("setting backend:", this.config.backend);
      if (this.config.backend === "wasm") {
        this.log("settings wasm path:", this.config.wasmPath);
        setWasmPaths(this.config.wasmPath);
        const simd = await tf.env().getAsync("WASM_HAS_SIMD_SUPPORT");
        if (!simd)
          this.log("warning: wasm simd support is not enabled");
      }
      await tf.setBackend(this.config.backend);
      tf.enableProdMode();
      if (this.config.backend === "webgl") {
        if (this.config.deallocate) {
          this.log("changing webgl: WEBGL_DELETE_TEXTURE_THRESHOLD:", this.config.deallocate);
          tf.ENV.set("WEBGL_DELETE_TEXTURE_THRESHOLD", this.config.deallocate ? 0 : -1);
        }
        tf.ENV.set("WEBGL_PACK_DEPTHWISECONV", true);
      }
      await tf.ready();
    }
    const current = Math.trunc(now2() - timeStamp);
    if (current > (this.perf.backend || 0))
      this.perf.backend = current;
  }
  async detectFace(input) {
    let timeStamp;
    let ageRes;
    let genderRes;
    let emotionRes;
    let embeddingRes;
    const faceRes = [];
    this.state = "run:face";
    timeStamp = now2();
    const faces = await this.models.facemesh.estimateFaces(input, this.config.face);
    this.perf.face = Math.trunc(now2() - timeStamp);
    for (const face2 of faces) {
      this.analyze("Get Face");
      if (!face2.image || face2.image.isDisposedInternal) {
        this.log("Face object is disposed:", face2.image);
        continue;
      }
      this.analyze("Start Age:");
      if (this.config.async) {
        ageRes = this.config.face.age.enabled ? age.predict(face2.image, this.config) : {};
      } else {
        this.state = "run:age";
        timeStamp = now2();
        ageRes = this.config.face.age.enabled ? await age.predict(face2.image, this.config) : {};
        this.perf.age = Math.trunc(now2() - timeStamp);
      }
      this.analyze("Start Gender:");
      if (this.config.async) {
        genderRes = this.config.face.gender.enabled ? gender.predict(face2.image, this.config) : {};
      } else {
        this.state = "run:gender";
        timeStamp = now2();
        genderRes = this.config.face.gender.enabled ? await gender.predict(face2.image, this.config) : {};
        this.perf.gender = Math.trunc(now2() - timeStamp);
      }
      this.analyze("Start Emotion:");
      if (this.config.async) {
        emotionRes = this.config.face.emotion.enabled ? emotion.predict(face2.image, this.config) : {};
      } else {
        this.state = "run:emotion";
        timeStamp = now2();
        emotionRes = this.config.face.emotion.enabled ? await emotion.predict(face2.image, this.config) : {};
        this.perf.emotion = Math.trunc(now2() - timeStamp);
      }
      this.analyze("End Emotion:");
      this.analyze("Start Embedding:");
      if (this.config.async) {
        embeddingRes = this.config.face.embedding.enabled ? embedding.predict(face2.image, this.config) : {};
      } else {
        this.state = "run:embedding";
        timeStamp = now2();
        embeddingRes = this.config.face.embedding.enabled ? await embedding.predict(face2.image, this.config) : {};
        this.perf.embedding = Math.trunc(now2() - timeStamp);
      }
      this.analyze("End Emotion:");
      if (this.config.async) {
        [ageRes, genderRes, emotionRes, embeddingRes] = await Promise.all([ageRes, genderRes, emotionRes, embeddingRes]);
      }
      this.analyze("Finish Face:");
      face2.image.dispose();
      const irisSize = face2.annotations.leftEyeIris && face2.annotations.rightEyeIris ? 11.7 * Math.max(Math.abs(face2.annotations.leftEyeIris[3][0] - face2.annotations.leftEyeIris[1][0]), Math.abs(face2.annotations.rightEyeIris[4][1] - face2.annotations.rightEyeIris[2][1])) : 0;
      faceRes.push({
        confidence: face2.confidence,
        box: face2.box,
        mesh: face2.mesh,
        annotations: face2.annotations,
        age: ageRes.age,
        gender: genderRes.gender,
        genderConfidence: genderRes.confidence,
        emotion: emotionRes,
        embedding: embeddingRes,
        iris: irisSize !== 0 ? Math.trunc(irisSize) / 100 : 0
      });
      this.analyze("End Face");
    }
    this.analyze("End FaceMesh:");
    if (this.config.async) {
      if (this.perf.face)
        delete this.perf.face;
      if (this.perf.age)
        delete this.perf.age;
      if (this.perf.gender)
        delete this.perf.gender;
      if (this.perf.emotion)
        delete this.perf.emotion;
    }
    return faceRes;
  }
  async image(input, userConfig2 = {}) {
    this.state = "image";
    this.config = mergeDeep(this.config, userConfig2);
    const process3 = image.process(input, this.config);
    process3.tensor.dispose();
    return process3.canvas;
  }
  async detect(input, userConfig2 = {}) {
    return new Promise(async (resolve) => {
      this.state = "config";
      let timeStamp;
      this.config = mergeDeep(this.config, userConfig2);
      this.state = "check";
      const error = this.sanity(input);
      if (error) {
        this.log(error, input);
        resolve({error});
      }
      let poseRes;
      let handRes;
      let faceRes;
      const timeStart = now2();
      await this.checkBackend();
      await this.load();
      if (this.config.scoped)
        tf.engine().startScope();
      this.analyze("Start Scope:");
      timeStamp = now2();
      const process3 = image.process(input, this.config);
      this.perf.image = Math.trunc(now2() - timeStamp);
      this.analyze("Get Image:");
      if (this.config.async) {
        faceRes = this.config.face.enabled ? this.detectFace(process3.tensor) : [];
        if (this.perf.face)
          delete this.perf.face;
      } else {
        this.state = "run:face";
        timeStamp = now2();
        faceRes = this.config.face.enabled ? await this.detectFace(process3.tensor) : [];
        this.perf.face = Math.trunc(now2() - timeStamp);
      }
      this.analyze("Start Body:");
      if (this.config.async) {
        poseRes = this.config.body.enabled ? this.models.posenet.estimatePoses(process3.tensor, this.config) : [];
        if (this.perf.body)
          delete this.perf.body;
      } else {
        this.state = "run:body";
        timeStamp = now2();
        poseRes = this.config.body.enabled ? await this.models.posenet.estimatePoses(process3.tensor, this.config) : [];
        this.perf.body = Math.trunc(now2() - timeStamp);
      }
      this.analyze("End Body:");
      this.analyze("Start Hand:");
      if (this.config.async) {
        handRes = this.config.hand.enabled ? this.models.handpose.estimateHands(process3.tensor, this.config.hand) : [];
        if (this.perf.hand)
          delete this.perf.hand;
      } else {
        this.state = "run:hand";
        timeStamp = now2();
        handRes = this.config.hand.enabled ? await this.models.handpose.estimateHands(process3.tensor, this.config.hand) : [];
        this.perf.hand = Math.trunc(now2() - timeStamp);
      }
      if (this.config.async) {
        [faceRes, poseRes, handRes] = await Promise.all([faceRes, poseRes, handRes]);
      }
      process3.tensor.dispose();
      if (this.config.scoped)
        tf.engine().endScope();
      this.analyze("End Scope:");
      let gestureRes = [];
      if (this.config.gesture.enabled) {
        timeStamp = now2();
        gestureRes = {face: gesture.face(faceRes), body: gesture.body(poseRes), hand: gesture.hand(handRes)};
        if (!this.config.async)
          this.perf.gesture = Math.trunc(now2() - timeStamp);
        else if (this.perf.gesture)
          delete this.perf.gesture;
      }
      this.perf.total = Math.trunc(now2() - timeStart);
      this.state = "idle";
      resolve({face: faceRes, body: poseRes, hand: handRes, gesture: gestureRes, performance: this.perf, canvas: process3.canvas});
    });
  }
  async warmup(userConfig2, sample2) {
    if (!sample2)
      sample2 = new ImageData(255, 255);
    const warmup = await this.detect(sample2, userConfig2);
    this.log("warmed up");
    return warmup;
  }
}

// demo/draw.js
async function drawGesture(result, canvas, ui2) {
  if (!result)
    return;
  const ctx = canvas.getContext("2d");
  ctx.font = ui2.baseFont;
  ctx.fillStyle = ui2.baseLabel;
  let i = 1;
  for (const [key, val] of Object.entries(result)) {
    if (val.length > 0) {
      const label = `${key}: ${val.join(", ")}`;
      ctx.fillText(label, 6, i * (ui2.baseLineHeight + 24));
      i += 1;
    }
  }
}
async function drawFace(result, canvas, ui2, triangulation) {
  if (!result)
    return;
  const ctx = canvas.getContext("2d");
  for (const face of result) {
    ctx.font = ui2.baseFont;
    ctx.strokeStyle = ui2.baseColor;
    ctx.fillStyle = ui2.baseColor;
    ctx.lineWidth = ui2.baseLineWidth;
    ctx.beginPath();
    if (ui2.drawBoxes) {
      ctx.rect(face.box[0], face.box[1], face.box[2], face.box[3]);
    }
    const labels = [];
    if (face.genderConfidence)
      labels.push(`${Math.trunc(100 * face.genderConfidence)}% ${face.gender || ""}`);
    if (face.age)
      labels.push(`age: ${face.age || ""}`);
    if (face.iris)
      labels.push(`iris: ${face.iris}`);
    if (face.emotion && face.emotion.length > 0) {
      const emotion2 = face.emotion.map((a) => `${Math.trunc(100 * a.score)}% ${a.emotion}`);
      labels.push(emotion2.join(" "));
    }
    ctx.fillStyle = ui2.baseLabel;
    for (const i in labels)
      ctx.fillText(labels[i], face.box[0] + 8, face.box[1] + 24 + (i + 1) * ui2.baseLineHeight);
    ctx.stroke();
    ctx.lineWidth = 1;
    if (face.mesh) {
      if (ui2.drawPoints) {
        for (const point of face.mesh) {
          ctx.fillStyle = ui2.useDepth ? `rgba(${127.5 + 2 * point[2]}, ${127.5 - 2 * point[2]}, 255, 0.5)` : ui2.baseColor;
          ctx.beginPath();
          ctx.arc(point[0], point[1], 2, 0, 2 * Math.PI);
          ctx.fill();
        }
      }
      if (ui2.drawPolygons) {
        for (let i = 0; i < triangulation.length / 3; i++) {
          const points = [
            triangulation[i * 3 + 0],
            triangulation[i * 3 + 1],
            triangulation[i * 3 + 2]
          ].map((index) => face.mesh[index]);
          const path = new Path2D();
          path.moveTo(points[0][0], points[0][1]);
          for (const point of points) {
            path.lineTo(point[0], point[1]);
          }
          path.closePath();
          ctx.strokeStyle = ui2.useDepth ? `rgba(${127.5 + 2 * points[0][2]}, ${127.5 - 2 * points[0][2]}, 255, 0.3)` : ui2.baseColor;
          ctx.stroke(path);
          if (ui2.fillPolygons) {
            ctx.fillStyle = ui2.useDepth ? `rgba(${127.5 + 2 * points[0][2]}, ${127.5 - 2 * points[0][2]}, 255, 0.3)` : ui2.baseColor;
            ctx.fill(path);
          }
        }
        if (face.annotations && face.annotations.leftEyeIris) {
          ctx.strokeStyle = ui2.useDepth ? "rgba(255, 200, 255, 0.3)" : ui2.baseColor;
          ctx.beginPath();
          const sizeX = Math.abs(face.annotations.leftEyeIris[3][0] - face.annotations.leftEyeIris[1][0]) / 2;
          const sizeY = Math.abs(face.annotations.leftEyeIris[4][1] - face.annotations.leftEyeIris[2][1]) / 2;
          ctx.ellipse(face.annotations.leftEyeIris[0][0], face.annotations.leftEyeIris[0][1], sizeX, sizeY, 0, 0, 2 * Math.PI);
          ctx.stroke();
          if (ui2.fillPolygons) {
            ctx.fillStyle = ui2.useDepth ? "rgba(255, 255, 200, 0.3)" : ui2.baseColor;
            ctx.fill();
          }
        }
        if (face.annotations && face.annotations.rightEyeIris) {
          ctx.strokeStyle = ui2.useDepth ? "rgba(255, 200, 255, 0.3)" : ui2.baseColor;
          ctx.beginPath();
          const sizeX = Math.abs(face.annotations.rightEyeIris[3][0] - face.annotations.rightEyeIris[1][0]) / 2;
          const sizeY = Math.abs(face.annotations.rightEyeIris[4][1] - face.annotations.rightEyeIris[2][1]) / 2;
          ctx.ellipse(face.annotations.rightEyeIris[0][0], face.annotations.rightEyeIris[0][1], sizeX, sizeY, 0, 0, 2 * Math.PI);
          ctx.stroke();
          if (ui2.fillPolygons) {
            ctx.fillStyle = ui2.useDepth ? "rgba(255, 255, 200, 0.3)" : ui2.baseColor;
            ctx.fill();
          }
        }
      }
    }
  }
}
const lastDrawnPose = [];
async function drawBody(result, canvas, ui2) {
  if (!result)
    return;
  const ctx = canvas.getContext("2d");
  ctx.lineJoin = "round";
  for (const i in result) {
    if (!lastDrawnPose[i] && ui2.buffered)
      lastDrawnPose[i] = {...result[i]};
    ctx.fillStyle = ui2.baseColor;
    ctx.strokeStyle = ui2.baseColor;
    ctx.font = ui2.baseFont;
    ctx.lineWidth = ui2.baseLineWidth;
    if (ui2.drawPoints) {
      for (const pt in result[i].keypoints) {
        ctx.beginPath();
        if (ui2.buffered) {
          lastDrawnPose[i].keypoints[pt].position.x = (lastDrawnPose[i].keypoints[pt].position.x + result[i].keypoints[pt].position.x) / 2;
          lastDrawnPose[i].keypoints[pt].position.y = (lastDrawnPose[i].keypoints[pt].position.y + result[i].keypoints[pt].position.y) / 2;
          ctx.arc(lastDrawnPose[i].keypoints[pt].position.x, lastDrawnPose[i].keypoints[pt].position.y, 2, 0, 2 * Math.PI);
        } else {
          ctx.arc(result[i].keypoints[pt].position.x, result[i].keypoints[pt].position.y, 2, 0, 2 * Math.PI);
        }
        ctx.fill();
      }
    }
    if (ui2.drawPolygons) {
      const path = new Path2D();
      let part;
      part = result[i].keypoints.find((a) => a.part === "leftShoulder");
      path.moveTo(part.position.x, part.position.y);
      part = result[i].keypoints.find((a) => a.part === "rightShoulder");
      path.lineTo(part.position.x, part.position.y);
      part = result[i].keypoints.find((a) => a.part === "rightHip");
      path.lineTo(part.position.x, part.position.y);
      part = result[i].keypoints.find((a) => a.part === "leftHip");
      path.lineTo(part.position.x, part.position.y);
      part = result[i].keypoints.find((a) => a.part === "leftShoulder");
      path.lineTo(part.position.x, part.position.y);
      part = result[i].keypoints.find((a) => a.part === "leftHip");
      path.moveTo(part.position.x, part.position.y);
      part = result[i].keypoints.find((a) => a.part === "leftKnee");
      path.lineTo(part.position.x, part.position.y);
      part = result[i].keypoints.find((a) => a.part === "leftAnkle");
      path.lineTo(part.position.x, part.position.y);
      part = result[i].keypoints.find((a) => a.part === "rightHip");
      path.moveTo(part.position.x, part.position.y);
      part = result[i].keypoints.find((a) => a.part === "rightKnee");
      path.lineTo(part.position.x, part.position.y);
      part = result[i].keypoints.find((a) => a.part === "rightAnkle");
      path.lineTo(part.position.x, part.position.y);
      part = result[i].keypoints.find((a) => a.part === "rightShoulder");
      path.moveTo(part.position.x, part.position.y);
      part = result[i].keypoints.find((a) => a.part === "leftShoulder");
      path.lineTo(part.position.x, part.position.y);
      part = result[i].keypoints.find((a) => a.part === "leftElbow");
      path.lineTo(part.position.x, part.position.y);
      part = result[i].keypoints.find((a) => a.part === "leftWrist");
      path.lineTo(part.position.x, part.position.y);
      part = result[i].keypoints.find((a) => a.part === "leftShoulder");
      path.moveTo(part.position.x, part.position.y);
      part = result[i].keypoints.find((a) => a.part === "rightShoulder");
      path.lineTo(part.position.x, part.position.y);
      part = result[i].keypoints.find((a) => a.part === "rightElbow");
      path.lineTo(part.position.x, part.position.y);
      part = result[i].keypoints.find((a) => a.part === "rightWrist");
      path.lineTo(part.position.x, part.position.y);
      ctx.stroke(path);
    }
  }
}
async function drawHand(result, canvas, ui2) {
  if (!result)
    return;
  const ctx = canvas.getContext("2d");
  ctx.lineJoin = "round";
  for (const hand of result) {
    ctx.font = ui2.baseFont;
    ctx.lineWidth = ui2.baseLineWidth;
    if (ui2.drawBoxes) {
      ctx.lineWidth = ui2.baseLineWidth;
      ctx.beginPath();
      ctx.strokeStyle = ui2.baseColor;
      ctx.fillStyle = ui2.baseColor;
      ctx.rect(hand.box[0], hand.box[1], hand.box[2], hand.box[3]);
      ctx.fillStyle = ui2.baseLabel;
      ctx.fillText("hand", hand.box[0] + 2, hand.box[1] + 22, hand.box[2]);
      ctx.stroke();
    }
    if (ui2.drawPoints) {
      if (hand.landmarks && hand.landmarks.length > 0) {
        for (const point of hand.landmarks) {
          ctx.fillStyle = ui2.useDepth ? `rgba(${127.5 + 2 * point[2]}, ${127.5 - 2 * point[2]}, 255, 0.5)` : ui2.baseColor;
          ctx.beginPath();
          ctx.arc(point[0], point[1], 2, 0, 2 * Math.PI);
          ctx.fill();
        }
      }
    }
    if (ui2.drawPolygons) {
      const addPart = (part) => {
        if (!part)
          return;
        for (let i = 0; i < part.length; i++) {
          ctx.lineWidth = ui2.baseLineWidth;
          ctx.beginPath();
          ctx.strokeStyle = ui2.useDepth ? `rgba(${127.5 + 2 * part[i][2]}, ${127.5 - 2 * part[i][2]}, 255, 0.5)` : ui2.baseColor;
          ctx.moveTo(part[i > 0 ? i - 1 : 0][0], part[i > 0 ? i - 1 : 0][1]);
          ctx.lineTo(part[i][0], part[i][1]);
          ctx.stroke();
        }
      };
      addPart(hand.annotations.indexFinger);
      addPart(hand.annotations.middleFinger);
      addPart(hand.annotations.ringFinger);
      addPart(hand.annotations.pinky);
      addPart(hand.annotations.thumb);
    }
  }
}
const draw = {
  face: drawFace,
  body: drawBody,
  hand: drawHand,
  gesture: drawGesture
};
var draw_default = draw;

// demo/menu.js
let instance = 0;
let CSScreated = false;
let theme = {
  background: "darkslategray",
  hover: "lightgray",
  itemBackground: "black",
  itemColor: "white",
  buttonBackground: "lightblue",
  buttonHover: "lightgreen",
  checkboxOn: "lightgreen",
  checkboxOff: "lightcoral",
  rangeBackground: "lightblue",
  rangeLabel: "white",
  chartColor: "lightblue"
};
function createCSS() {
  if (CSScreated)
    return;
  const css = `
  :root { --rounded: 0.2rem; }
  .menu { position: absolute; top: 0rem; right: 0; width: fit-content; padding: 0 0.8rem 0 0.8rem; line-height: 1.8rem; z-index: 10; max-height: calc(100% - 4rem);
          box-shadow: 0 0 8px dimgrey; background: ${theme.background}; border-radius: var(--rounded); border-color: black; border-style: solid; border-width: thin; }

  .menu:hover { box-shadow: 0 0 8px ${theme.hover}; }
  .menu-container { display: block; max-height: 100vh; }
  .menu-container-fadeout { max-height: 0; overflow: hidden; transition: max-height, 0.5s ease; }
  .menu-container-fadein { max-height: 100vh; overflow: hidden; transition: max-height, 0.5s ease; }
  .menu-item { display: flex; white-space: nowrap; padding: 0.2rem; width: max-content; cursor: default; }
  .menu-title { text-align: right; cursor: pointer; }
  .menu-hr { margin: 0.2rem; border: 1px solid rgba(0, 0, 0, 0.5) }
  .menu-label { padding: 0; font-weight: 800; }

  .menu-list { margin-right: 0.8rem; }
  select:focus { outline: none; }
  .menu-list-item { background: ${theme.itemBackground}; color: ${theme.itemColor}; border: none; padding: 0.2rem; font-family: inherit;
    font-variant: inherit; border-radius: var(--rounded); font-weight: 800; }

  .menu-chart-title { padding: 0; font-size: 0.8rem; font-weight: 800; align-items: center}
  .menu-chart-canvas { background: transparent; margin: 0.2rem 0 0.2rem 0.6rem; }
  
  .menu-button { border: 0; background: ${theme.buttonBackground}; width: 100%; padding: 8px; margin: 8px 0 8px 0; cursor: pointer; box-shadow: 4px 4px 4px 0 dimgrey;
    border-radius: var(--rounded); justify-content: center; font-family: inherit; font-variant: inherit; font-size: 1rem; font-weight: 800; }
  .menu-button:hover { background: ${theme.buttonHover}; box-shadow: 4px 4px 4px 0 black; }
  .menu-button:focus { outline: none; }

  .menu-checkbox { width: 2.8rem; height: 1rem; background: ${theme.itemBackground}; margin: 0.5rem 0.8rem 0 0; position: relative; border-radius: var(--rounded); }
  .menu-checkbox:after { content: 'OFF'; color: ${theme.checkboxOff}; position: absolute; right: 0.2rem; top: -0.4rem; font-weight: 800; font-size: 0.5rem; }
  .menu-checkbox:before { content: 'ON'; color: ${theme.checkboxOn}; position: absolute; left: 0.3rem; top: -0.4rem; font-weight: 800; font-size: 0.5rem; }
  .menu-checkbox-label { width: 1.3rem; height: 0.8rem; cursor: pointer; position: absolute; top: 0.1rem; left: 0.1rem; z-index: 1; background: ${theme.checkboxOff};
    border-radius: var(--rounded); transition: left 0.6s ease; }

  input[type=checkbox] { visibility: hidden; }
  input[type=checkbox]:checked + label { left: 1.4rem; background: ${theme.checkboxOn}; }

  .menu-range { margin: 0 0.8rem 0 0; width: 5rem; background: transparent; color: ${theme.rangeBackground}; }
  .menu-range:before { color: ${theme.rangeLabel}; margin: 0 0.4rem 0 0; font-weight: 800; font-size: 0.6rem; position: relative; top: 0.3rem; content: attr(value); }

  input[type=range] { -webkit-appearance: none; }
  input[type=range]::-webkit-slider-runnable-track { width: 100%; height: 1rem; cursor: pointer; background: ${theme.itemBackground}; border-radius: var(--rounded); border: 1px; }
  input[type=range]::-moz-range-track { width: 100%; height: 1rem; cursor: pointer; background: ${theme.itemBackground}; border-radius: var(--rounded); border: 1px; }
  input[type=range]::-webkit-slider-thumb { border: 1px solid #000000; margin-top: 0.05rem; height: 0.9rem; width: 1.5rem; border-radius: var(--rounded); background: ${theme.rangeBackground}; cursor: pointer; -webkit-appearance: none; }
  input[type=range]::-moz-range-thumb { border: 1px solid #000000; margin-top: 0.05rem; height: 0.9rem; width: 1.5rem; border-radius: var(--rounded); background: ${theme.rangeBackground}; cursor: pointer; -webkit-appearance: none; }

  .svg-background { fill:darkslategrey; cursor:pointer; opacity: 0.6; }
  .svg-foreground { fill:white; cursor:pointer; opacity: 0.8; }
  `;
  const el = document.createElement("style");
  el.innerHTML = css;
  document.getElementsByTagName("head")[0].appendChild(el);
  CSScreated = true;
}
class Menu {
  constructor(parent, title, position, userTheme) {
    if (userTheme)
      theme = {...theme, ...userTheme};
    createCSS();
    this.createMenu(parent, title, position);
    this.id = 0;
    this.instance = instance;
    instance++;
    this._maxFPS = 0;
    this.hidden = 0;
  }
  createMenu(parent, title = "", position = {top: null, left: null, bottom: null, right: null}) {
    this.menu = document.createElement("div");
    this.menu.id = `menu-${instance}`;
    this.menu.className = "menu";
    if (position) {
      if (position.top)
        this.menu.style.top = position.top;
      if (position.bottom)
        this.menu.style.bottom = position.bottom;
      if (position.left)
        this.menu.style.left = position.left;
      if (position.right)
        this.menu.style.right = position.right;
    }
    this.container = document.createElement("div");
    this.container.id = `menu-container-${instance}`;
    this.container.className = "menu-container menu-container-fadein";
    const elTitle = document.createElement("div");
    elTitle.className = "menu-title";
    elTitle.id = `menu-title-${instance}`;
    const svg = `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 448 512" style="width: 2rem; height: 2rem; vertical-align: top;">
        <path d="M400 32H48A48 48 0 0 0 0 80v352a48 48 0 0 0 48 48h352a48 48 0 0 0 48-48V80a48 48 0 0 0-48-48zm-51.37 182.31L232.06 348.16a10.38 10.38 0 0 1-16.12 0L99.37 214.31C92.17 206 97.28 192 107.43 192h233.14c10.15 0 15.26 14 8.06 22.31z" class="svg-background"/>
        <path d="M348.63 214.31L232.06 348.16a10.38 10.38 0 0 1-16.12 0L99.37 214.31C92.17 206 97.28 192 107.43 192h233.14c10.15 0 15.26 14 8.06 22.31z" class="svg-foreground"/>
      </svg>`;
    elTitle.innerHTML = `${title}${svg}`;
    this.menu.appendChild(elTitle);
    elTitle.addEventListener("click", () => {
      this.container.classList.toggle("menu-container-fadeout");
      this.container.classList.toggle("menu-container-fadein");
      this.menu.style.borderStyle = this.container.classList.contains("menu-container-fadeout") ? "none" : "solid";
    });
    this.menu.appendChild(this.container);
    if (typeof parent === "object")
      parent.appendChild(this.menu);
    else
      document.getElementById(parent).appendChild(this.menu);
  }
  get newID() {
    this.id++;
    return `menu-${this.instance}-${this.id}`;
  }
  get ID() {
    return `menu-${this.instance}-${this.id}`;
  }
  get width() {
    return this.menu.offsetWidth;
  }
  get height() {
    return this.menu.offsetHeight;
  }
  hide() {
    if (this.container.classList.contains("menu-container-fadein")) {
      this.container.classList.toggle("menu-container-fadeout");
      this.container.classList.toggle("menu-container-fadein");
    }
  }
  visible() {
    return this.container.classList.contains("menu-container-fadein");
  }
  toggle(evt) {
    this.container.classList.toggle("menu-container-fadeout");
    this.container.classList.toggle("menu-container-fadein");
    if (this.container.classList.contains("menu-container-fadein") && evt) {
      const x = evt.x || (evt.touches && evt.touches[0] ? evt.touches[0].pageX : null);
      const y = evt.y || (evt.touches && evt.touches[0] ? evt.touches[0].pageY : null);
      if (x)
        this.menu.style.left = `${x - 105}px`;
      if (y)
        this.menu.style.top = "5.5rem";
      if (this.menu.offsetLeft < 0)
        this.menu.style.left = 0;
      if (this.menu.offsetLeft + this.menu.offsetWidth > window.innerWidth) {
        this.menu.style.left = null;
        this.menu.style.right = 0;
      }
      this.menu.style.borderStyle = "solid";
    } else {
      this.menu.style.borderStyle = "none";
    }
  }
  addTitle(title) {
    const el = document.createElement("div");
    el.className = "menu-title";
    el.id = this.newID;
    el.innerHTML = title;
    this.menu.appendChild(el);
    el.addEventListener("click", () => {
      this.hidden = !this.hidden;
      const all = document.getElementsByClassName("menu");
      for (const item of all) {
        item.style.display = this.hidden ? "none" : "block";
      }
    });
    return el;
  }
  addLabel(title) {
    const el = document.createElement("div");
    el.className = "menu-item menu-label";
    el.id = this.newID;
    el.innerHTML = title;
    this.container.appendChild(el);
    return el;
  }
  addBool(title, object, variable, callback) {
    const el = document.createElement("div");
    el.className = "menu-item";
    el.innerHTML = `<div class="menu-checkbox"><input class="menu-checkbox" type="checkbox" id="${this.newID}" ${object[variable] ? "checked" : ""}/><label class="menu-checkbox-label" for="${this.ID}"></label></div>${title}`;
    this.container.appendChild(el);
    el.addEventListener("change", (evt) => {
      object[variable] = evt.target.checked;
      if (callback)
        callback(evt.target.checked);
    });
    return el;
  }
  async addList(title, items, selected, callback) {
    const el = document.createElement("div");
    el.className = "menu-item";
    let options = "";
    for (const item of items) {
      const def = item === selected ? "selected" : "";
      options += `<option value="${item}" ${def}>${item}</option>`;
    }
    el.innerHTML = `<div class="menu-list"><select name="${this.ID}" class="menu-list-item">${options}</select><label for="${this.ID}"></label></div>${title}`;
    el.style.fontFamily = document.body.style.fontFamily;
    el.style.fontSize = document.body.style.fontSize;
    el.style.fontVariant = document.body.style.fontVariant;
    this.container.appendChild(el);
    el.addEventListener("change", (evt) => {
      if (callback)
        callback(items[evt.target.selectedIndex]);
    });
    return el;
  }
  addRange(title, object, variable, min2, max2, step2, callback) {
    const el = document.createElement("div");
    el.className = "menu-item";
    el.innerHTML = `<input class="menu-range" type="range" id="${this.newID}" min="${min2}" max="${max2}" step="${step2}" value="${object[variable]}">${title}`;
    this.container.appendChild(el);
    el.addEventListener("change", (evt) => {
      object[variable] = parseInt(evt.target.value) === parseFloat(evt.target.value) ? parseInt(evt.target.value) : parseFloat(evt.target.value);
      evt.target.setAttribute("value", evt.target.value);
      if (callback)
        callback(evt.target.value);
    });
    el.input = el.children[0];
    return el;
  }
  addHTML(html) {
    const el = document.createElement("div");
    el.className = "menu-item";
    el.id = this.newID;
    if (html)
      el.innerHTML = html;
    this.container.appendChild(el);
    return el;
  }
  addButton(titleOn, titleOff, callback) {
    const el = document.createElement("button");
    el.className = "menu-item menu-button";
    el.style.fontFamily = document.body.style.fontFamily;
    el.style.fontSize = document.body.style.fontSize;
    el.style.fontVariant = document.body.style.fontVariant;
    el.type = "button";
    el.id = this.newID;
    el.innerText = titleOn;
    this.container.appendChild(el);
    el.addEventListener("click", () => {
      if (el.innerText === titleOn)
        el.innerText = titleOff;
      else
        el.innerText = titleOn;
      if (callback)
        callback(el.innerText !== titleOn);
    });
    return el;
  }
  addValue(title, val, suffix = "") {
    const el = document.createElement("div");
    el.className = "menu-item";
    el.id = `menu-val-${title}`;
    el.innerText = `${title}: ${val}${suffix}`;
    this.container.appendChild(el);
    return el;
  }
  updateValue(title, val, suffix = "") {
    const el = document.getElementById(`menu-val-${title}`);
    if (el)
      el.innerText = `${title}: ${val}${suffix}`;
    else
      this.addValue(title, val);
  }
  addChart(title, id, width = 200, height = 40, color) {
    if (color)
      theme.chartColor = color;
    const el = document.createElement("div");
    el.className = "menu-item menu-chart-title";
    el.id = this.newID;
    el.innerHTML = `<font color=${theme.chartColor}>${title}</font><canvas id="menu-canvas-${id}" class="menu-chart-canvas" width="${width}px" height="${height}px"></canvas>`;
    this.container.appendChild(el);
    return el;
  }
  async updateChart(id, values) {
    if (!values || values.length === 0)
      return;
    const canvas = document.getElementById(`menu-canvas-${id}`);
    if (!canvas)
      return;
    const ctx = canvas.getContext("2d");
    ctx.fillStyle = theme.background;
    ctx.fillRect(0, 0, canvas.width, canvas.height);
    const width = canvas.width / values.length;
    const max2 = 1 + Math.max(...values);
    const height = canvas.height / max2;
    for (const i in values) {
      const gradient = ctx.createLinearGradient(0, (max2 - values[i]) * height, 0, 0);
      gradient.addColorStop(0.1, theme.chartColor);
      gradient.addColorStop(0.4, theme.background);
      ctx.fillStyle = gradient;
      ctx.fillRect(i * width, 0, width - 4, canvas.height);
      ctx.fillStyle = theme.background;
      ctx.font = `${width / 1.5}px "Segoe UI"`;
      ctx.fillText(Math.round(values[i]), i * width + 1, canvas.height - 1, width - 1);
    }
  }
}
var menu_default = Menu;

// assets/gl-bench.js
const UISVG = `
  <div class="gl-box">
    <svg viewBox="0 0 55 60">
      <text x="27" y="56" class="gl-fps">00 FPS</text>
      <text x="28" y="8" class="gl-mem"></text>
      <rect x="0" y="14" rx="4" ry="4" width="55" height="32"></rect>
      <polyline class="gl-chart"></polyline>
    </svg>
    <svg viewBox="0 0 14 60" class="gl-cpu-svg">
      <line x1="7" y1="38" x2="7" y2="11" class="opacity"/>
      <line x1="7" y1="38" x2="7" y2="11" class="gl-cpu" stroke-dasharray="0 27"/>
      <path d="M5.35 43c-.464 0-.812.377-.812.812v1.16c-.783.1972-1.421.812-1.595 1.624h-1.16c-.435 0-.812.348-.812.812s.348.812.812.812h1.102v1.653H1.812c-.464 0-.812.377-.812.812 0 .464.377.812.812.812h1.131c.1943.783.812 1.392 1.595 1.595v1.131c0 .464.377.812.812.812.464 0 .812-.377.812-.812V53.15h1.653v1.073c0 .464.377.812.812.812.464 0 .812-.377.812-.812v-1.131c.783-.1943 1.392-.812 1.595-1.595h1.131c.464 0 .812-.377.812-.812 0-.464-.377-.812-.812-.812h-1.073V48.22h1.102c.435 0 .812-.348.812-.812s-.348-.812-.812-.812h-1.16c-.1885-.783-.812-1.421-1.595-1.624v-1.131c0-.464-.377-.812-.812-.812-.464 0-.812.377-.812.812v1.073H6.162v-1.073c0-.464-.377-.812-.812-.812zm.58 3.48h2.088c.754 0 1.363.609 1.363 1.363v2.088c0 .754-.609 1.363-1.363 1.363H5.93c-.754 0-1.363-.609-1.363-1.363v-2.088c0-.754.609-1.363 1.363-1.363z"/>
    </svg>
    <svg viewBox="0 0 14 60" class="gl-gpu-svg">
      <line x1="7" y1="38" x2="7" y2="11" class="opacity"/>
      <line x1="7" y1="38" x2="7" y2="11" class="gl-gpu" stroke-dasharray="0 27"/>
      <path d="M1.94775 43.3772a.736.736 0 10-.00416 1.472c.58535.00231.56465.1288.6348.3197.07015.18975.04933.43585.04933.43585l-.00653.05405v8.671a.736.736 0 101.472 0v-1.4145c.253.09522.52785.1495.81765.1495h5.267c1.2535 0 2.254-.9752 2.254-2.185v-3.105c0-1.2075-1.00625-2.185-2.254-2.185h-5.267c-.28865 0-.5635.05405-.8165.1495.01806-.16445.04209-.598-.1357-1.0787-.22425-.6072-.9499-1.2765-2.0125-1.2765zm2.9095 3.6455c.42435 0 .7659.36225.7659.8119v2.9785c0 .44965-.34155.8119-.7659.8119s-.7659-.36225-.7659-.8119v-2.9785c0-.44965.34155-.8119.7659-.8119zm4.117 0a2.3 2.3 0 012.3 2.3 2.3 2.3 0 01-2.3 2.3 2.3 2.3 0 01-2.3-2.3 2.3 2.3 0 012.3-2.3z"/>
    </svg>
  </div>
  `;
const UICSS = `
  #gl-bench { position: absolute; right:0; bottom:0; z-index:1000; -webkit-user-select: none; -moz-user-select: none; user-select: none; }
  #gl-bench div { position: relative; display: block; margin: 4px; padding: 0 7px 0 10px; background: darkslategray; border-radius: 0.2rem; cursor: pointer; opacity: 0.9; }
  #gl-bench svg { height: 60px; margin: 0 -1px; }
  #gl-bench text { font-size: 12px; font-family: Helvetica,Arial,sans-serif; font-weight: 700; dominant-baseline: middle; text-anchor: middle; }
  #gl-bench .gl-mem { font-size: 9px; fill: white; }
  #gl-bench .gl-fps { font-size: 10px; fill: white; }
  #gl-bench line { stroke-width: 5; stroke: white; stroke-linecap: round; }
  #gl-bench polyline { fill: none; stroke: white; stroke-linecap: round; stroke-linejoin: round; stroke-width: 3.5; }
  #gl-bench rect { fill: black; }
  #gl-bench .opacity { stroke: black; }
  `;
class GLBench {
  constructor(gl, settings = {}) {
    this.css = UICSS;
    this.svg = UISVG;
    this.paramLogger = () => {
    };
    this.chartLogger = () => {
    };
    this.chartLen = 20;
    this.chartHz = 20;
    this.names = [];
    this.cpuAccums = [];
    this.gpuAccums = [];
    this.activeAccums = [];
    this.chart = new Array(this.chartLen);
    this.now = () => performance && performance.now ? performance.now() : Date.now();
    this.updateUI = () => {
      [].forEach.call(this.nodes["gl-gpu-svg"], (node) => {
        node.style.display = this.trackGPU ? "inline" : "none";
      });
    };
    Object.assign(this, settings);
    this.detected = 0;
    this.finished = [];
    this.isFramebuffer = 0;
    this.frameId = 0;
    let rafId, n = 0, t0;
    let loop = (t) => {
      if (++n < 20) {
        rafId = requestAnimationFrame(loop);
      } else {
        this.detected = Math.ceil(1e3 * n / (t - t0) / 70);
        cancelAnimationFrame(rafId);
      }
      if (!t0)
        t0 = t;
    };
    requestAnimationFrame(loop);
    if (gl) {
      const glFinish = async (t, activeAccums) => Promise.resolve(setTimeout(() => {
        gl.getError();
        const dt = this.now() - t;
        activeAccums.forEach((active, i) => {
          if (active)
            this.gpuAccums[i] += dt;
        });
      }, 0));
      const addProfiler = (fn, self2, target) => function() {
        const t = self2.now();
        fn.apply(target, arguments);
        if (self2.trackGPU)
          self2.finished.push(glFinish(t, self2.activeAccums.slice(0)));
      };
      [
        "drawArrays",
        "drawElements",
        "drawArraysInstanced",
        "drawBuffers",
        "drawElementsInstanced",
        "drawRangeElements"
      ].forEach((fn) => {
        if (gl[fn])
          gl[fn] = addProfiler(gl[fn], this, gl);
      });
      gl.getExtension = ((fn, self2) => function() {
        let ext = fn.apply(gl, arguments);
        if (ext) {
          ["drawElementsInstancedANGLE", "drawBuffersWEBGL"].forEach((fn2) => {
            if (ext[fn2])
              ext[fn2] = addProfiler(ext[fn2], self2, ext);
          });
        }
        return ext;
      })(gl.getExtension, this);
    }
    if (!this.withoutUI) {
      if (!this.dom)
        this.dom = document.body;
      let elm = document.createElement("div");
      elm.id = "gl-bench";
      this.dom.appendChild(elm);
      this.dom.insertAdjacentHTML("afterbegin", '<style id="gl-bench-style">' + this.css + "</style>");
      this.dom = elm;
      this.dom.addEventListener("click", () => {
        this.trackGPU = !this.trackGPU;
        this.updateUI();
      });
      this.paramLogger = ((logger, dom, names) => {
        const classes = ["gl-cpu", "gl-gpu", "gl-mem", "gl-fps", "gl-gpu-svg", "gl-chart"];
        const nodes = Object.assign({}, classes);
        classes.forEach((c) => nodes[c] = dom.getElementsByClassName(c));
        this.nodes = nodes;
        return (i, cpu, gpu, mem, fps, totalTime, frameId) => {
          nodes["gl-cpu"][i].style.strokeDasharray = (cpu * 0.27).toFixed(0) + " 100";
          nodes["gl-gpu"][i].style.strokeDasharray = (gpu * 0.27).toFixed(0) + " 100";
          nodes["gl-mem"][i].innerHTML = names[i] ? names[i] : mem ? "mem: " + mem.toFixed(0) + "mb" : "";
          nodes["gl-fps"][i].innerHTML = fps.toFixed(0) + " FPS";
          logger(names[i], cpu, gpu, mem, fps, totalTime, frameId);
        };
      })(this.paramLogger, this.dom, this.names);
      this.chartLogger = ((logger, dom) => {
        let nodes = {"gl-chart": dom.getElementsByClassName("gl-chart")};
        return (i, chart, circularId) => {
          let points = "";
          let len = chart.length;
          for (let i2 = 0; i2 < len; i2++) {
            let id = (circularId + i2 + 1) % len;
            if (chart[id] != void 0) {
              points = points + " " + (55 * i2 / (len - 1)).toFixed(1) + "," + (45 - chart[id] * 22 / 60 / this.detected).toFixed(1);
            }
          }
          nodes["gl-chart"][i].setAttribute("points", points);
          logger(this.names[i], chart, circularId);
        };
      })(this.chartLogger, this.dom);
    }
  }
  addUI(name) {
    if (this.names.indexOf(name) == -1) {
      this.names.push(name);
      if (this.dom) {
        this.dom.insertAdjacentHTML("beforeend", this.svg);
        this.updateUI();
      }
      this.cpuAccums.push(0);
      this.gpuAccums.push(0);
      this.activeAccums.push(false);
    }
  }
  nextFrame(now3) {
    this.frameId++;
    const t = now3 ? now3 : this.now();
    if (this.frameId <= 1) {
      this.paramFrame = this.frameId;
      this.paramTime = t;
    } else {
      let duration = t - this.paramTime;
      if (duration >= 1e3) {
        const frameCount = this.frameId - this.paramFrame;
        const fps = frameCount / duration * 1e3;
        for (let i = 0; i < this.names.length; i++) {
          const cpu = this.cpuAccums[i] / duration * 100, gpu = this.gpuAccums[i] / duration * 100, mem = performance && performance.memory ? performance.memory.usedJSHeapSize / (1 << 20) : 0;
          this.paramLogger(i, cpu, gpu, mem, fps, duration, frameCount);
          this.cpuAccums[i] = 0;
          Promise.all(this.finished).then(() => {
            this.gpuAccums[i] = 0;
            this.finished = [];
          });
        }
        this.paramFrame = this.frameId;
        this.paramTime = t;
      }
    }
    if (!this.detected || !this.chartFrame) {
      this.chartFrame = this.frameId;
      this.chartTime = t;
      this.circularId = 0;
    } else {
      let timespan = t - this.chartTime;
      let hz = this.chartHz * timespan / 1e3;
      while (--hz > 0 && this.detected) {
        const frameCount = this.frameId - this.chartFrame;
        const fps = frameCount / timespan * 1e3;
        this.chart[this.circularId % this.chartLen] = fps;
        for (let i = 0; i < this.names.length; i++) {
          this.chartLogger(i, this.chart, this.circularId);
        }
        this.circularId++;
        this.chartFrame = this.frameId;
        this.chartTime = t;
      }
    }
  }
  begin(name) {
    this.updateAccums(name);
  }
  end(name) {
    this.updateAccums(name);
  }
  updateAccums(name) {
    let nameId = this.names.indexOf(name);
    if (nameId == -1) {
      nameId = this.names.length;
      this.addUI(name);
    }
    const t = this.now();
    const dt = t - this.t0;
    for (let i = 0; i < nameId + 1; i++) {
      if (this.activeAccums[i]) {
        this.cpuAccums[i] += dt;
      }
    }
    this.activeAccums[nameId] = !this.activeAccums[nameId];
    this.t0 = t;
  }
}
var gl_bench_default = GLBench;

// demo/browser.js
const userConfig = {};
const human = new Human(userConfig);
const ui = {
  baseColor: "rgba(173, 216, 230, 0.3)",
  baseBackground: "rgba(50, 50, 50, 1)",
  baseLabel: "rgba(173, 216, 230, 0.9)",
  baseFontProto: 'small-caps {size} "Segoe UI"',
  baseLineWidth: 12,
  baseLineHeightProto: 2,
  crop: true,
  columns: 2,
  busy: false,
  facing: true,
  useWorker: false,
  worker: "demo/worker.js",
  samples: ["../assets/sample6.jpg", "../assets/sample1.jpg", "../assets/sample4.jpg", "../assets/sample5.jpg", "../assets/sample3.jpg", "../assets/sample2.jpg"],
  compare: "../assets/sample-me.jpg",
  drawBoxes: true,
  drawPoints: false,
  drawPolygons: true,
  fillPolygons: false,
  useDepth: true,
  console: true,
  maxFPSframes: 10,
  modelsPreload: true,
  modelsWarmup: true,
  menuWidth: 0,
  menuHeight: 0,
  camera: {},
  fps: [],
  buffered: false,
  bufferedFPSTarget: 24,
  drawThread: null,
  detectThread: null,
  framesDraw: 0,
  framesDetect: 0,
  bench: false
};
let menu2;
let menuFX;
let worker;
let bench;
let sample;
let lastDetectedResult = {};
function str(...msg) {
  if (!Array.isArray(msg))
    return msg;
  let line = "";
  for (const entry of msg) {
    if (typeof entry === "object")
      line += JSON.stringify(entry).replace(/{|}|"|\[|\]/g, "").replace(/,/g, ", ");
    else
      line += entry;
  }
  return line;
}
const log2 = (...msg) => {
  if (ui.console)
    console.log(...msg);
};
const status = (msg) => {
  document.getElementById("status").innerText = msg;
};
async function calcSimmilariry(faces) {
  var _a;
  if (!faces || !faces[0] || ((_a = faces[0].embedding) == null ? void 0 : _a.length) !== 192)
    return;
  const current = faces[0].embedding;
  const original = sample && sample.face && sample.face[0] && sample.face[0].embedding ? sample.face[0].embedding : null;
  if (original && original.length === 192) {
    const simmilarity = human.simmilarity(current, original);
    document.getElementById("simmilarity").innerText = `simmilarity: ${Math.trunc(1e3 * simmilarity) / 10}%`;
  }
}
async function drawResults(input) {
  const result = lastDetectedResult;
  const canvas = document.getElementById("canvas");
  if (result.performance && result.performance.total)
    ui.fps.push(1e3 / result.performance.total);
  if (ui.fps.length > ui.maxFPSframes)
    ui.fps.shift();
  await menu2.updateChart("FPS", ui.fps);
  if (ui.buffered || !result.canvas)
    result.canvas = await human.image(input, userConfig);
  const ctx = canvas.getContext("2d");
  ctx.fillStyle = ui.baseBackground;
  ctx.fillRect(0, 0, canvas.width, canvas.height);
  if (result.canvas) {
    if (result.canvas.width !== canvas.width)
      canvas.width = result.canvas.width;
    if (result.canvas.height !== canvas.height)
      canvas.height = result.canvas.height;
    ctx.drawImage(result.canvas, 0, 0, result.canvas.width, result.canvas.height, 0, 0, result.canvas.width, result.canvas.height);
  } else {
    ctx.drawImage(input, 0, 0, input.width, input.height, 0, 0, canvas.width, canvas.height);
  }
  await draw_default.face(result.face, canvas, ui, human.facemesh.triangulation);
  await draw_default.body(result.body, canvas, ui);
  await draw_default.hand(result.hand, canvas, ui);
  await draw_default.gesture(result.gesture, canvas, ui);
  await calcSimmilariry(result.face);
  const engine = human.tf.engine();
  const gpu = engine.backendInstance ? `gpu: ${(engine.backendInstance.numBytesInGPU ? engine.backendInstance.numBytesInGPU : 0).toLocaleString()} bytes` : "";
  const memory = `system: ${engine.state.numBytes.toLocaleString()} bytes ${gpu} | tensors: ${engine.state.numTensors.toLocaleString()}`;
  const processing = result.canvas ? `processing: ${result.canvas.width} x ${result.canvas.height}` : "";
  const avg = Math.trunc(10 * ui.fps.reduce((a, b) => a + b, 0) / ui.fps.length) / 10;
  const warning = ui.fps.length > 5 && avg < 5 ? '<font color="lightcoral">warning: your performance is low: try switching to higher performance backend, lowering resolution or disabling some models</font>' : "";
  document.getElementById("log").innerHTML = `
    video: ${ui.camera.name} | facing: ${ui.camera.facing} | resolution: ${ui.camera.width} x ${ui.camera.height} ${processing}<br>
    backend: ${human.tf.getBackend()} | ${memory}<br>
    performance: ${str(result.performance)} FPS:${avg}<br>
    ${warning}
  `;
  ui.framesDraw++;
  ui.lastFrame = performance.now();
  if (ui.buffered && !ui.drawThread)
    ui.drawThread = setInterval(() => drawResults(input, canvas), 1e3 / ui.bufferedFPSTarget);
  if (!ui.buffered && ui.drawThread) {
    clearTimeout(ui.drawThread);
    ui.drawThread = null;
  }
}
async function setupCamera() {
  var _a;
  if (ui.busy)
    return null;
  ui.busy = true;
  const video = document.getElementById("video");
  const canvas = document.getElementById("canvas");
  const output = document.getElementById("log");
  const live = video.srcObject ? video.srcObject.getVideoTracks()[0].readyState === "live" && video.readyState > 2 && !video.paused : false;
  console.log("camera live", live);
  let msg = "";
  status("setting up camera");
  if (!navigator.mediaDevices) {
    msg = "camera access not supported";
    output.innerText += `
${msg}`;
    log2(msg);
    status(msg);
    return null;
  }
  let stream;
  const constraints = {
    audio: false,
    video: {
      facingMode: ui.facing ? "user" : "environment",
      resizeMode: ui.crop ? "crop-and-scale" : "none",
      width: {ideal: window.innerWidth},
      height: {ideal: window.innerHeight}
    }
  };
  try {
    stream = await navigator.mediaDevices.getUserMedia(constraints);
  } catch (err) {
    if (err.name === "PermissionDeniedError")
      msg = "camera permission denied";
    else if (err.name === "SourceUnavailableError")
      msg = "camera not available";
    else
      msg = "camera error";
    output.innerText += `
${msg}`;
    status(msg);
    log2(err);
  }
  if (stream)
    video.srcObject = stream;
  else
    return null;
  const track = stream.getVideoTracks()[0];
  const settings = track.getSettings();
  ui.camera = {name: (_a = track.label) == null ? void 0 : _a.toLowerCase(), width: settings.width, height: settings.height, facing: settings.facingMode === "user" ? "front" : "back"};
  return new Promise((resolve) => {
    video.onloadeddata = async () => {
      video.width = video.videoWidth;
      video.height = video.videoHeight;
      canvas.width = video.width;
      canvas.height = video.height;
      canvas.style.width = canvas.width > canvas.height ? "100vw" : "";
      canvas.style.height = canvas.width > canvas.height ? "" : "100vh";
      ui.menuWidth.input.setAttribute("value", video.width);
      ui.menuHeight.input.setAttribute("value", video.height);
      const size = 14 + 6 * canvas.width / window.innerWidth;
      ui.baseFont = ui.baseFontProto.replace(/{size}/, `${size}px`);
      console.log("camera continue", live);
      if (live)
        video.play();
      if (live && !ui.detectThread)
        runHumanDetect(video, canvas);
      ui.busy = false;
      status("");
      resolve(video);
    };
  });
}
function webWorker(input, image2, canvas, timestamp) {
  if (!worker) {
    log2("creating worker thread");
    worker = new Worker(ui.worker, {type: "module"});
    worker.addEventListener("message", (msg) => {
      if (ui.bench)
        bench.end();
      if (ui.bench)
        bench.nextFrame(timestamp);
      lastDetectedResult = msg.data.result;
      ui.framesDetect++;
      if (!ui.drawThread)
        drawResults(input);
      ui.detectThread = requestAnimationFrame((now3) => runHumanDetect(input, canvas, now3));
    });
  }
  if (ui.bench)
    bench.begin();
  worker.postMessage({image: image2.data.buffer, width: canvas.width, height: canvas.height}, [image2.data.buffer]);
}
function runHumanDetect(input, canvas, timestamp) {
  var _a;
  const live = input.srcObject && input.srcObject.getVideoTracks()[0].readyState === "live" && input.readyState > 2 && !input.paused;
  if (!live && input.srcObject) {
    if (ui.drawThread)
      clearTimeout(ui.drawThread);
    if (ui.detectThread)
      cancelAnimationFrame(ui.detectThread);
    ui.drawThread = null;
    ui.detectThread = null;
    if (input.paused)
      log2("camera paused");
    else if (input.srcObject.getVideoTracks()[0].readyState === "live" && input.readyState <= 2)
      setTimeout(() => runHumanDetect(input, canvas), 500);
    else
      log2(`camera not ready: track state: ${(_a = input.srcObject) == null ? void 0 : _a.getVideoTracks()[0].readyState} stream state: ${input.readyState}`);
    clearTimeout(ui.drawThread);
    ui.drawThread = null;
    log2("frame statistics: drawn:", ui.framesDraw, "detected:", ui.framesDetect);
    return;
  }
  status("");
  if (ui.useWorker) {
    const offscreen = new OffscreenCanvas(canvas.width, canvas.height);
    const ctx = offscreen.getContext("2d");
    ctx.drawImage(input, 0, 0, input.width, input.height, 0, 0, canvas.width, canvas.height);
    const data = ctx.getImageData(0, 0, canvas.width, canvas.height);
    webWorker(input, data, canvas, userConfig, timestamp);
  } else {
    if (ui.bench)
      bench.begin();
    human.detect(input, userConfig).then((result) => {
      if (ui.bench)
        bench.end();
      if (ui.bench)
        bench.nextFrame(timestamp);
      if (result.error)
        log2(result.error);
      else {
        lastDetectedResult = result;
        if (!ui.drawThread)
          drawResults(input);
        ui.framesDetect++;
        ui.detectThread = requestAnimationFrame((now3) => runHumanDetect(input, canvas, now3));
      }
    });
  }
}
async function processImage(input) {
  return new Promise((resolve) => {
    const image2 = new Image();
    image2.onload = async () => {
      log2("Processing image:", image2.src);
      const canvas = document.getElementById("canvas");
      image2.width = image2.naturalWidth;
      image2.height = image2.naturalHeight;
      canvas.width = human.config.filter.width && human.config.filter.width > 0 ? human.config.filter.width : image2.naturalWidth;
      canvas.height = human.config.filter.height && human.config.filter.height > 0 ? human.config.filter.height : image2.naturalHeight;
      const result = await human.detect(image2, userConfig);
      lastDetectedResult = result;
      await drawResults(image2);
      const thumb = document.createElement("canvas");
      thumb.className = "thumbnail";
      thumb.width = window.innerWidth / (ui.columns + 0.1);
      thumb.height = canvas.height / (window.innerWidth / thumb.width);
      const ctx = thumb.getContext("2d");
      ctx.drawImage(canvas, 0, 0, canvas.width, canvas.height, 0, 0, thumb.width, thumb.height);
      document.getElementById("samples-container").appendChild(thumb);
      image2.src = "";
      resolve(true);
    };
    image2.src = input;
  });
}
async function detectVideo() {
  human.config.videoOptimized = true;
  document.getElementById("samples-container").style.display = "none";
  document.getElementById("canvas").style.display = "block";
  const video = document.getElementById("video");
  const canvas = document.getElementById("canvas");
  ui.baseLineHeight = ui.baseLineHeightProto;
  if (video.srcObject !== null && !video.paused) {
    document.getElementById("play").style.display = "block";
    status("paused");
    video.pause();
  } else {
    await setupCamera();
    document.getElementById("play").style.display = "none";
    status("");
    video.play();
  }
  if (!ui.detectThread)
    runHumanDetect(video, canvas);
}
async function detectSampleImages() {
  document.getElementById("play").style.display = "none";
  human.config.videoOptimized = false;
  const size = 12 + Math.trunc(12 * ui.columns * window.innerWidth / document.body.clientWidth);
  ui.baseFont = ui.baseFontProto.replace(/{size}/, `${size}px`);
  ui.baseLineHeight = ui.baseLineHeightProto * ui.columns;
  document.getElementById("canvas").style.display = "none";
  document.getElementById("samples-container").style.display = "block";
  log2("Running detection of sample images");
  status("processing images");
  document.getElementById("samples-container").innerHTML = "";
  for (const image2 of ui.samples)
    await processImage(image2);
  status("");
}
function setupMenu() {
  document.getElementById("compare-container").style.display = human.config.face.embedding.enabled ? "block" : "none";
  menu2 = new menu_default(document.body, "", {top: "1rem", right: "1rem"});
  const btn = menu2.addButton("start video", "pause video", () => detectVideo());
  menu2.addButton("process images", "process images", () => detectSampleImages());
  document.getElementById("play").addEventListener("click", () => btn.click());
  menu2.addHTML('<hr style="min-width: 200px; border-style: inset; border-color: dimgray">');
  menu2.addList("backend", ["cpu", "webgl", "wasm"], human.config.backend, (val) => human.config.backend = val);
  menu2.addBool("async operations", human.config, "async", (val) => human.config.async = val);
  menu2.addBool("enable profiler", human.config, "profile", (val) => human.config.profile = val);
  menu2.addBool("memory shield", human.config, "deallocate", (val) => human.config.deallocate = val);
  menu2.addBool("use web worker", ui, "useWorker");
  menu2.addHTML('<hr style="min-width: 200px; border-style: inset; border-color: dimgray">');
  menu2.addLabel("enabled models");
  menu2.addBool("face detect", human.config.face, "enabled");
  menu2.addBool("face mesh", human.config.face.mesh, "enabled");
  menu2.addBool("face iris", human.config.face.iris, "enabled");
  menu2.addBool("face age", human.config.face.age, "enabled");
  menu2.addBool("face gender", human.config.face.gender, "enabled");
  menu2.addBool("face emotion", human.config.face.emotion, "enabled");
  menu2.addBool("body pose", human.config.body, "enabled");
  menu2.addBool("hand pose", human.config.hand, "enabled");
  menu2.addBool("gesture analysis", human.config.gesture, "enabled");
  menu2.addHTML('<hr style="min-width: 200px; border-style: inset; border-color: dimgray">');
  menu2.addLabel("model parameters");
  menu2.addRange("max objects", human.config.face.detector, "maxFaces", 1, 50, 1, (val) => {
    human.config.face.detector.maxFaces = parseInt(val);
    human.config.body.maxDetections = parseInt(val);
    human.config.hand.maxHands = parseInt(val);
  });
  menu2.addRange("skip frames", human.config.face.detector, "skipFrames", 0, 50, 1, (val) => {
    human.config.face.detector.skipFrames = parseInt(val);
    human.config.face.emotion.skipFrames = parseInt(val);
    human.config.face.age.skipFrames = parseInt(val);
    human.config.hand.skipFrames = parseInt(val);
  });
  menu2.addRange("min confidence", human.config.face.detector, "minConfidence", 0, 1, 0.05, (val) => {
    human.config.face.detector.minConfidence = parseFloat(val);
    human.config.face.gender.minConfidence = parseFloat(val);
    human.config.face.emotion.minConfidence = parseFloat(val);
    human.config.hand.minConfidence = parseFloat(val);
  });
  menu2.addRange("score threshold", human.config.face.detector, "scoreThreshold", 0.1, 1, 0.05, (val) => {
    human.config.face.detector.scoreThreshold = parseFloat(val);
    human.config.hand.scoreThreshold = parseFloat(val);
    human.config.body.scoreThreshold = parseFloat(val);
  });
  menu2.addRange("overlap", human.config.face.detector, "iouThreshold", 0.1, 1, 0.05, (val) => {
    human.config.face.detector.iouThreshold = parseFloat(val);
    human.config.hand.iouThreshold = parseFloat(val);
  });
  menu2.addHTML('<hr style="min-width: 200px; border-style: inset; border-color: dimgray">');
  menu2.addChart("FPS", "FPS");
  menuFX = new menu_default(document.body, "", {top: "1rem", right: "18rem"});
  menuFX.addLabel("ui options");
  menuFX.addBool("buffered output", ui, "buffered", (val) => ui.buffered = val);
  menuFX.addBool("crop & scale", ui, "crop", () => setupCamera());
  menuFX.addBool("camera front/back", ui, "facing", () => setupCamera());
  menuFX.addBool("use 3D depth", ui, "useDepth");
  menuFX.addBool("draw boxes", ui, "drawBoxes");
  menuFX.addBool("draw polygons", ui, "drawPolygons");
  menuFX.addBool("Fill Polygons", ui, "fillPolygons");
  menuFX.addBool("draw points", ui, "drawPoints");
  menuFX.addHTML('<hr style="min-width: 200px; border-style: inset; border-color: dimgray">');
  menuFX.addLabel("image processing");
  menuFX.addBool("enabled", human.config.filter, "enabled");
  ui.menuWidth = menuFX.addRange("image width", human.config.filter, "width", 0, 3840, 10, (val) => human.config.filter.width = parseInt(val));
  ui.menuHeight = menuFX.addRange("image height", human.config.filter, "height", 0, 2160, 10, (val) => human.config.filter.height = parseInt(val));
  menuFX.addRange("brightness", human.config.filter, "brightness", -1, 1, 0.05, (val) => human.config.filter.brightness = parseFloat(val));
  menuFX.addRange("contrast", human.config.filter, "contrast", -1, 1, 0.05, (val) => human.config.filter.contrast = parseFloat(val));
  menuFX.addRange("sharpness", human.config.filter, "sharpness", 0, 1, 0.05, (val) => human.config.filter.sharpness = parseFloat(val));
  menuFX.addRange("blur", human.config.filter, "blur", 0, 20, 1, (val) => human.config.filter.blur = parseInt(val));
  menuFX.addRange("saturation", human.config.filter, "saturation", -1, 1, 0.05, (val) => human.config.filter.saturation = parseFloat(val));
  menuFX.addRange("hue", human.config.filter, "hue", 0, 360, 5, (val) => human.config.filter.hue = parseInt(val));
  menuFX.addRange("pixelate", human.config.filter, "pixelate", 0, 32, 1, (val) => human.config.filter.pixelate = parseInt(val));
  menuFX.addBool("negative", human.config.filter, "negative");
  menuFX.addBool("sepia", human.config.filter, "sepia");
  menuFX.addBool("vintage", human.config.filter, "vintage");
  menuFX.addBool("kodachrome", human.config.filter, "kodachrome");
  menuFX.addBool("technicolor", human.config.filter, "technicolor");
  menuFX.addBool("polaroid", human.config.filter, "polaroid");
}
async function setupMonitor() {
  let gl = human.tf.engine().backend.gpgpu;
  if (!gl)
    gl = document.getElementById("bench-canvas").getContext("webgl2");
  if (!bench) {
    bench = new gl_bench_default(gl, {
      trackGPU: true,
      chartHz: 20,
      chartLen: 50
    });
  }
}
async function main() {
  log2("Human: demo starting ...");
  setupMenu();
  setupMonitor();
  document.getElementById("log").innerText = `Human: version ${human.version} TensorFlow/JS: version ${human.tf.version_core}`;
  if (ui.modelsPreload) {
    status("loading");
    await human.load(userConfig);
  }
  if (ui.modelsWarmup) {
    status("initializing");
    sample = await human.warmup(userConfig, document.getElementById("sample-image"));
  }
  status("human: ready");
  document.getElementById("loader").style.display = "none";
  document.getElementById("play").style.display = "block";
}
window.onload = main;
window.onresize = setupCamera;
//# sourceMappingURL=demo-browser-index.js.map
